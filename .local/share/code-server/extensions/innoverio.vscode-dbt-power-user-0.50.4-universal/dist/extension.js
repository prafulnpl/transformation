/*! For license information please see extension.js.LICENSE.txt */
(() => {
 var __webpack_modules__ = {
  5412: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.BaseManager = void 0;
   const signaling_1 = __webpack_require__(57082), serverconnection_1 = __webpack_require__(1089);
   exports.BaseManager = class {
    constructor(options) {
     var _a;
     this._isDisposed = !1, this._disposed = new signaling_1.Signal(this), this.serverSettings = null !== (_a = options.serverSettings) && void 0 !== _a ? _a : serverconnection_1.ServerConnection.makeSettings();
    }
    get disposed() {
     return this._disposed;
    }
    get isDisposed() {
     return this._isDisposed;
    }
    dispose() {
     this.isDisposed || (this._disposed.emit(void 0), signaling_1.Signal.clearData(this));
    }
   };
  },
  44816: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.BuildManager = void 0;
   const coreutils_1 = __webpack_require__(16015), serverconnection_1 = __webpack_require__(1089);
   exports.BuildManager = class {
    constructor(options = {}) {
     var _a;
     this._url = "", this.serverSettings = null !== (_a = options.serverSettings) && void 0 !== _a ? _a : serverconnection_1.ServerConnection.makeSettings();
     const {baseUrl, appUrl} = this.serverSettings;
     this._url = coreutils_1.URLExt.join(baseUrl, appUrl, "api/build");
    }
    get isAvailable() {
     return "true" === coreutils_1.PageConfig.getOption("buildAvailable").toLowerCase();
    }
    get shouldCheck() {
     return "true" === coreutils_1.PageConfig.getOption("buildCheck").toLowerCase();
    }
    getStatus() {
     const {_url, serverSettings} = this;
     return serverconnection_1.ServerConnection.makeRequest(_url, {}, serverSettings).then((response => {
      if (200 !== response.status) throw new serverconnection_1.ServerConnection.ResponseError(response);
      return response.json();
     })).then((data => {
      if ("string" != typeof data.status) throw new Error("Invalid data");
      if ("string" != typeof data.message) throw new Error("Invalid data");
      return data;
     }));
    }
    build() {
     const {_url, serverSettings} = this;
     return serverconnection_1.ServerConnection.makeRequest(_url, {
      method: "POST"
     }, serverSettings).then((response => {
      if (400 === response.status) throw new serverconnection_1.ServerConnection.ResponseError(response, "Build aborted");
      if (200 !== response.status) {
       const message = `Build failed with ${response.status}.\n\n        If you are experiencing the build failure after installing an extension (or trying to include previously installed extension after updating JupyterLab) please check the extension repository for new installation instructions as many extensions migrated to the prebuilt extensions system which no longer requires rebuilding JupyterLab (but uses a different installation procedure, typically involving a package manager such as 'pip' or 'conda').\n\n        If you specifically intended to install a source extension, please run 'jupyter lab build' on the server for full output.`;
       throw new serverconnection_1.ServerConnection.ResponseError(response, message);
      }
     }));
    }
    cancel() {
     const {_url, serverSettings} = this;
     return serverconnection_1.ServerConnection.makeRequest(_url, {
      method: "DELETE"
     }, serverSettings).then((response => {
      if (204 !== response.status) throw new serverconnection_1.ServerConnection.ResponseError(response);
     }));
    }
   };
  },
  39851: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.ConfigWithDefaults = exports.ConfigSection = void 0;
   const coreutils_1 = __webpack_require__(16015), __1 = __webpack_require__(50608);
   !function(ConfigSection) {
    ConfigSection.create = function(options) {
     const section = new DefaultConfigSection(options);
     return section.load().then((() => section));
    };
   }(exports.ConfigSection || (exports.ConfigSection = {}));
   class DefaultConfigSection {
    constructor(options) {
     var _a;
     this._url = "unknown";
     const settings = this.serverSettings = null !== (_a = options.serverSettings) && void 0 !== _a ? _a : __1.ServerConnection.makeSettings();
     this._url = coreutils_1.URLExt.join(settings.baseUrl, "api/config", encodeURIComponent(options.name));
    }
    get data() {
     return this._data;
    }
    async load() {
     const response = await __1.ServerConnection.makeRequest(this._url, {}, this.serverSettings);
     if (200 !== response.status) {
      throw await __1.ServerConnection.ResponseError.create(response);
     }
     this._data = await response.json();
    }
    async update(newdata) {
     this._data = Object.assign(Object.assign({}, this._data), newdata);
     const init = {
      method: "PATCH",
      body: JSON.stringify(newdata)
     }, response = await __1.ServerConnection.makeRequest(this._url, init, this.serverSettings);
     if (200 !== response.status) {
      throw await __1.ServerConnection.ResponseError.create(response);
     }
     return this._data = await response.json(), this._data;
    }
   }
   exports.ConfigWithDefaults = class {
    constructor(options) {
     var _a, _b;
     this._className = "", this._section = options.section, this._defaults = null !== (_a = options.defaults) && void 0 !== _a ? _a : {}, 
     this._className = null !== (_b = options.className) && void 0 !== _b ? _b : "";
    }
    get(key) {
     const data = this._classData();
     return key in data ? data[key] : this._defaults[key];
    }
    set(key, value) {
     const d = {};
     if (d[key] = value, this._className) {
      const d2 = {};
      return d2[this._className] = d, this._section.update(d2);
     }
     return this._section.update(d);
    }
    _classData() {
     const data = this._section.data;
     return this._className && this._className in data ? data[this._className] : data;
    }
   };
  },
  97375: function(__unused_webpack_module, exports, __webpack_require__) {
   "use strict";
   var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    void 0 === k2 && (k2 = k), Object.defineProperty(o, k2, {
     enumerable: !0,
     get: function() {
      return m[k];
     }
    });
   } : function(o, m, k, k2) {
    void 0 === k2 && (k2 = k), o[k2] = m[k];
   }), __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
     enumerable: !0,
     value: v
    });
   } : function(o, v) {
    o.default = v;
   }), __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (null != mod) for (var k in mod) "default" !== k && Object.prototype.hasOwnProperty.call(mod, k) && __createBinding(result, mod, k);
    return __setModuleDefault(result, mod), result;
   };
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.Drive = exports.ContentsManager = exports.Contents = void 0;
   const coreutils_1 = __webpack_require__(16015), algorithm_1 = __webpack_require__(56588), signaling_1 = __webpack_require__(57082), __1 = __webpack_require__(50608), validate = __importStar(__webpack_require__(77821));
   var Private;
   !function(Contents) {
    Contents.validateContentsModel = function(contents) {
     validate.validateContentsModel(contents);
    }, Contents.validateCheckpointModel = function(checkpoint) {
     validate.validateCheckpointModel(checkpoint);
    };
   }(exports.Contents || (exports.Contents = {}));
   exports.ContentsManager = class {
    constructor(options = {}) {
     var _a, _b;
     this._isDisposed = !1, this._additionalDrives = new Map, this._fileChanged = new signaling_1.Signal(this);
     const serverSettings = this.serverSettings = null !== (_a = options.serverSettings) && void 0 !== _a ? _a : __1.ServerConnection.makeSettings();
     this._defaultDrive = null !== (_b = options.defaultDrive) && void 0 !== _b ? _b : new Drive({
      serverSettings
     }), this._defaultDrive.fileChanged.connect(this._onFileChanged, this);
    }
    get fileChanged() {
     return this._fileChanged;
    }
    get isDisposed() {
     return this._isDisposed;
    }
    dispose() {
     this.isDisposed || (this._isDisposed = !0, signaling_1.Signal.clearData(this));
    }
    addDrive(drive) {
     this._additionalDrives.set(drive.name, drive), drive.fileChanged.connect(this._onFileChanged, this);
    }
    getModelDBFactory(path) {
     var _a;
     const [drive] = this._driveForPath(path);
     return null !== (_a = null == drive ? void 0 : drive.modelDBFactory) && void 0 !== _a ? _a : null;
    }
    localPath(path) {
     const parts = path.split("/"), firstParts = parts[0].split(":");
     return 1 !== firstParts.length && this._additionalDrives.has(firstParts[0]) ? coreutils_1.PathExt.join(firstParts.slice(1).join(":"), ...parts.slice(1)) : coreutils_1.PathExt.removeSlash(path);
    }
    normalize(path) {
     const parts = path.split(":");
     return 1 === parts.length ? coreutils_1.PathExt.normalize(path) : `${parts[0]}:${coreutils_1.PathExt.normalize(parts.slice(1).join(":"))}`;
    }
    resolvePath(root, path) {
     const driveName = this.driveName(root), localPath = this.localPath(root), resolved = coreutils_1.PathExt.resolve("/", localPath, path);
     return driveName ? `${driveName}:${resolved}` : resolved;
    }
    driveName(path) {
     const firstParts = path.split("/")[0].split(":");
     return 1 === firstParts.length ? "" : this._additionalDrives.has(firstParts[0]) ? firstParts[0] : "";
    }
    get(path, options) {
     const [drive, localPath] = this._driveForPath(path);
     return drive.get(localPath, options).then((contentsModel => {
      const listing = [];
      return "directory" === contentsModel.type && contentsModel.content ? (algorithm_1.each(contentsModel.content, (item => {
       listing.push(Object.assign(Object.assign({}, item), {
        path: this._toGlobalPath(drive, item.path)
       }));
      })), Object.assign(Object.assign({}, contentsModel), {
       path: this._toGlobalPath(drive, localPath),
       content: listing,
       serverPath: contentsModel.path
      })) : Object.assign(Object.assign({}, contentsModel), {
       path: this._toGlobalPath(drive, localPath),
       serverPath: contentsModel.path
      });
     }));
    }
    getDownloadUrl(path) {
     const [drive, localPath] = this._driveForPath(path);
     return drive.getDownloadUrl(localPath);
    }
    newUntitled(options = {}) {
     if (options.path) {
      const globalPath = this.normalize(options.path), [drive, localPath] = this._driveForPath(globalPath);
      return drive.newUntitled(Object.assign(Object.assign({}, options), {
       path: localPath
      })).then((contentsModel => Object.assign(Object.assign({}, contentsModel), {
       path: coreutils_1.PathExt.join(globalPath, contentsModel.name),
       serverPath: contentsModel.path
      })));
     }
     return this._defaultDrive.newUntitled(options);
    }
    delete(path) {
     const [drive, localPath] = this._driveForPath(path);
     return drive.delete(localPath);
    }
    rename(path, newPath) {
     const [drive1, path1] = this._driveForPath(path), [drive2, path2] = this._driveForPath(newPath);
     if (drive1 !== drive2) throw Error("ContentsManager: renaming files must occur within a Drive");
     return drive1.rename(path1, path2).then((contentsModel => Object.assign(Object.assign({}, contentsModel), {
      path: this._toGlobalPath(drive1, path2),
      serverPath: contentsModel.path
     })));
    }
    save(path, options = {}) {
     const globalPath = this.normalize(path), [drive, localPath] = this._driveForPath(path);
     return drive.save(localPath, Object.assign(Object.assign({}, options), {
      path: localPath
     })).then((contentsModel => Object.assign(Object.assign({}, contentsModel), {
      path: globalPath,
      serverPath: contentsModel.path
     })));
    }
    copy(fromFile, toDir) {
     const [drive1, path1] = this._driveForPath(fromFile), [drive2, path2] = this._driveForPath(toDir);
     if (drive1 === drive2) return drive1.copy(path1, path2).then((contentsModel => Object.assign(Object.assign({}, contentsModel), {
      path: this._toGlobalPath(drive1, contentsModel.path),
      serverPath: contentsModel.path
     })));
     throw Error("Copying files between drives is not currently implemented");
    }
    createCheckpoint(path) {
     const [drive, localPath] = this._driveForPath(path);
     return drive.createCheckpoint(localPath);
    }
    listCheckpoints(path) {
     const [drive, localPath] = this._driveForPath(path);
     return drive.listCheckpoints(localPath);
    }
    restoreCheckpoint(path, checkpointID) {
     const [drive, localPath] = this._driveForPath(path);
     return drive.restoreCheckpoint(localPath, checkpointID);
    }
    deleteCheckpoint(path, checkpointID) {
     const [drive, localPath] = this._driveForPath(path);
     return drive.deleteCheckpoint(localPath, checkpointID);
    }
    _toGlobalPath(drive, localPath) {
     return drive === this._defaultDrive ? coreutils_1.PathExt.removeSlash(localPath) : `${drive.name}:${coreutils_1.PathExt.removeSlash(localPath)}`;
    }
    _driveForPath(path) {
     const driveName = this.driveName(path), localPath = this.localPath(path);
     return driveName ? [ this._additionalDrives.get(driveName), localPath ] : [ this._defaultDrive, localPath ];
    }
    _onFileChanged(sender, args) {
     var _a, _b;
     if (sender === this._defaultDrive) this._fileChanged.emit(args); else {
      let newValue = null, oldValue = null;
      (null === (_a = args.newValue) || void 0 === _a ? void 0 : _a.path) && (newValue = Object.assign(Object.assign({}, args.newValue), {
       path: this._toGlobalPath(sender, args.newValue.path)
      })), (null === (_b = args.oldValue) || void 0 === _b ? void 0 : _b.path) && (oldValue = Object.assign(Object.assign({}, args.oldValue), {
       path: this._toGlobalPath(sender, args.oldValue.path)
      })), this._fileChanged.emit({
       type: args.type,
       newValue,
       oldValue
      });
     }
    }
   };
   class Drive {
    constructor(options = {}) {
     var _a, _b, _c;
     this._isDisposed = !1, this._fileChanged = new signaling_1.Signal(this), this.name = null !== (_a = options.name) && void 0 !== _a ? _a : "Default", 
     this._apiEndpoint = null !== (_b = options.apiEndpoint) && void 0 !== _b ? _b : "api/contents", 
     this.serverSettings = null !== (_c = options.serverSettings) && void 0 !== _c ? _c : __1.ServerConnection.makeSettings();
    }
    get fileChanged() {
     return this._fileChanged;
    }
    get isDisposed() {
     return this._isDisposed;
    }
    dispose() {
     this.isDisposed || (this._isDisposed = !0, signaling_1.Signal.clearData(this));
    }
    async get(localPath, options) {
     let url = this._getUrl(localPath);
     if (options) {
      "notebook" === options.type && delete options.format;
      const content = options.content ? "1" : "0", params = Object.assign(Object.assign({}, options), {
       content
      });
      url += coreutils_1.URLExt.objectToQueryString(params);
     }
     const settings = this.serverSettings, response = await __1.ServerConnection.makeRequest(url, {}, settings);
     if (200 !== response.status) {
      throw await __1.ServerConnection.ResponseError.create(response);
     }
     const data = await response.json();
     return validate.validateContentsModel(data), data;
    }
    getDownloadUrl(localPath) {
     const baseUrl = this.serverSettings.baseUrl;
     let url = coreutils_1.URLExt.join(baseUrl, "files", coreutils_1.URLExt.encodeParts(localPath));
     const xsrfTokenMatch = document.cookie.match("\\b_xsrf=([^;]*)\\b");
     if (xsrfTokenMatch) {
      const fullUrl = new URL(url);
      fullUrl.searchParams.append("_xsrf", xsrfTokenMatch[1]), url = fullUrl.toString();
     }
     return Promise.resolve(url);
    }
    async newUntitled(options = {}) {
     var _a;
     let body = "{}";
     options && (options.ext && (options.ext = Private.normalizeExtension(options.ext)), 
     body = JSON.stringify(options));
     const settings = this.serverSettings, url = this._getUrl(null !== (_a = options.path) && void 0 !== _a ? _a : ""), init = {
      method: "POST",
      body
     }, response = await __1.ServerConnection.makeRequest(url, init, settings);
     if (201 !== response.status) {
      throw await __1.ServerConnection.ResponseError.create(response);
     }
     const data = await response.json();
     return validate.validateContentsModel(data), this._fileChanged.emit({
      type: "new",
      oldValue: null,
      newValue: data
     }), data;
    }
    async delete(localPath) {
     const url = this._getUrl(localPath), settings = this.serverSettings, response = await __1.ServerConnection.makeRequest(url, {
      method: "DELETE"
     }, settings);
     if (204 !== response.status) {
      throw await __1.ServerConnection.ResponseError.create(response);
     }
     this._fileChanged.emit({
      type: "delete",
      oldValue: {
       path: localPath
      },
      newValue: null
     });
    }
    async rename(oldLocalPath, newLocalPath) {
     const settings = this.serverSettings, url = this._getUrl(oldLocalPath), init = {
      method: "PATCH",
      body: JSON.stringify({
       path: newLocalPath
      })
     }, response = await __1.ServerConnection.makeRequest(url, init, settings);
     if (200 !== response.status) {
      throw await __1.ServerConnection.ResponseError.create(response);
     }
     const data = await response.json();
     return validate.validateContentsModel(data), this._fileChanged.emit({
      type: "rename",
      oldValue: {
       path: oldLocalPath
      },
      newValue: data
     }), data;
    }
    async save(localPath, options = {}) {
     const settings = this.serverSettings, url = this._getUrl(localPath), init = {
      method: "PUT",
      body: JSON.stringify(options)
     }, response = await __1.ServerConnection.makeRequest(url, init, settings);
     if (200 !== response.status && 201 !== response.status) {
      throw await __1.ServerConnection.ResponseError.create(response);
     }
     const data = await response.json();
     return validate.validateContentsModel(data), this._fileChanged.emit({
      type: "save",
      oldValue: null,
      newValue: data
     }), data;
    }
    async copy(fromFile, toDir) {
     const settings = this.serverSettings, url = this._getUrl(toDir), init = {
      method: "POST",
      body: JSON.stringify({
       copy_from: fromFile
      })
     }, response = await __1.ServerConnection.makeRequest(url, init, settings);
     if (201 !== response.status) {
      throw await __1.ServerConnection.ResponseError.create(response);
     }
     const data = await response.json();
     return validate.validateContentsModel(data), this._fileChanged.emit({
      type: "new",
      oldValue: null,
      newValue: data
     }), data;
    }
    async createCheckpoint(localPath) {
     const url = this._getUrl(localPath, "checkpoints"), response = await __1.ServerConnection.makeRequest(url, {
      method: "POST"
     }, this.serverSettings);
     if (201 !== response.status) {
      throw await __1.ServerConnection.ResponseError.create(response);
     }
     const data = await response.json();
     return validate.validateCheckpointModel(data), data;
    }
    async listCheckpoints(localPath) {
     const url = this._getUrl(localPath, "checkpoints"), response = await __1.ServerConnection.makeRequest(url, {}, this.serverSettings);
     if (200 !== response.status) {
      throw await __1.ServerConnection.ResponseError.create(response);
     }
     const data = await response.json();
     if (!Array.isArray(data)) throw new Error("Invalid Checkpoint list");
     for (let i = 0; i < data.length; i++) validate.validateCheckpointModel(data[i]);
     return data;
    }
    async restoreCheckpoint(localPath, checkpointID) {
     const url = this._getUrl(localPath, "checkpoints", checkpointID), response = await __1.ServerConnection.makeRequest(url, {
      method: "POST"
     }, this.serverSettings);
     if (204 !== response.status) {
      throw await __1.ServerConnection.ResponseError.create(response);
     }
    }
    async deleteCheckpoint(localPath, checkpointID) {
     const url = this._getUrl(localPath, "checkpoints", checkpointID), response = await __1.ServerConnection.makeRequest(url, {
      method: "DELETE"
     }, this.serverSettings);
     if (204 !== response.status) {
      throw await __1.ServerConnection.ResponseError.create(response);
     }
    }
    _getUrl(...args) {
     const parts = args.map((path => coreutils_1.URLExt.encodeParts(path))), baseUrl = this.serverSettings.baseUrl;
     return coreutils_1.URLExt.join(baseUrl, this._apiEndpoint, ...parts);
    }
   }
   exports.Drive = Drive, function(Private) {
    Private.normalizeExtension = function(extension) {
     return extension.length > 0 && 0 !== extension.indexOf(".") && (extension = `.${extension}`), 
     extension;
    };
   }(Private || (Private = {}));
  },
  77821: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.validateCheckpointModel = exports.validateContentsModel = void 0;
   const validate_1 = __webpack_require__(1480);
   exports.validateContentsModel = function(model) {
    validate_1.validateProperty(model, "name", "string"), validate_1.validateProperty(model, "path", "string"), 
    validate_1.validateProperty(model, "type", "string"), validate_1.validateProperty(model, "created", "string"), 
    validate_1.validateProperty(model, "last_modified", "string"), validate_1.validateProperty(model, "mimetype", "object"), 
    validate_1.validateProperty(model, "content", "object"), validate_1.validateProperty(model, "format", "object");
   }, exports.validateCheckpointModel = function(model) {
    validate_1.validateProperty(model, "id", "string"), validate_1.validateProperty(model, "last_modified", "string");
   };
  },
  1091: function(__unused_webpack_module, exports, __webpack_require__) {
   "use strict";
   var __await = this && this.__await || function(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
   }, __asyncGenerator = this && this.__asyncGenerator || function(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var i, g = generator.apply(thisArg, _arguments || []), q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
     return this;
    }, i;
    function verb(n) {
     g[n] && (i[n] = function(v) {
      return new Promise((function(a, b) {
       q.push([ n, v, a, b ]) > 1 || resume(n, v);
      }));
     });
    }
    function resume(n, v) {
     try {
      (r = g[n](v)).value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
     } catch (e) {
      settle(q[0][3], e);
     }
     var r;
    }
    function fulfill(value) {
     resume("next", value);
    }
    function reject(value) {
     resume("throw", value);
    }
    function settle(f, v) {
     f(v), q.shift(), q.length && resume(q[0][0], q[0][1]);
    }
   };
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.EventManager = void 0;
   const coreutils_1 = __webpack_require__(16015), coreutils_2 = __webpack_require__(64954), polling_1 = __webpack_require__(93498), signaling_1 = __webpack_require__(57082), serverconnection_1 = __webpack_require__(1089);
   var Private;
   exports.EventManager = class {
    constructor(options = {}) {
     var _a;
     this._isDisabled = 2 > coreutils_1.PageConfig.getNotebookVersion()[0], this._isDisposed = !1, 
     this._socket = null, this.serverSettings = null !== (_a = options.serverSettings) && void 0 !== _a ? _a : serverconnection_1.ServerConnection.makeSettings(), 
     this._poll = new polling_1.Poll({
      factory: () => this._subscribe()
     }), this._stream = new Private.Stream(this), this._isDisabled ? this._stream.stop() : this._poll.start();
    }
    get isDisposed() {
     return this._isDisposed;
    }
    get stream() {
     return this._stream;
    }
    dispose() {
     if (this.isDisposed) return;
     this._isDisposed = !0, this._poll.dispose();
     const socket = this._socket;
     socket && (this._socket = null, socket.onopen = () => {}, socket.onerror = () => {}, 
     socket.onmessage = () => {}, socket.onclose = () => {}, socket.close()), signaling_1.Signal.clearData(this), 
     this._stream.stop();
    }
    async emit(event) {
     const {serverSettings} = this, {baseUrl, token} = serverSettings, {makeRequest, ResponseError} = serverconnection_1.ServerConnection, url = coreutils_1.URLExt.join(baseUrl, "api/events") + (token ? `?token=${token}` : ""), init = {
      body: JSON.stringify(event),
      method: "POST"
     }, response = await makeRequest(url, init, serverSettings);
     if (204 !== response.status) throw new ResponseError(response);
    }
    _subscribe() {
     return new Promise(((_, reject) => {
      if (this.isDisposed || this._isDisabled) return;
      const {token, WebSocket, wsUrl} = this.serverSettings, url = coreutils_1.URLExt.join(wsUrl, "api/events", "subscribe") + (token ? `?token=${encodeURIComponent(token)}` : ""), socket = this._socket = new WebSocket(url), stream = this._stream;
      socket.onclose = () => reject(new Error("EventManager socket closed")), socket.onmessage = msg => msg.data && stream.emit(JSON.parse(msg.data));
     }));
    }
   }, function(Private) {
    class Stream extends signaling_1.Signal {
     constructor() {
      super(...arguments), this._pending = new coreutils_2.PromiseDelegate;
     }
     [Symbol.asyncIterator]() {
      return __asyncGenerator(this, arguments, (function*() {
       let pending = this._pending;
       for (;;) try {
        const {args, next} = yield __await(pending.promise);
        pending = next, yield yield __await(args);
       } catch (_) {
        return yield __await(void 0);
       }
      }));
     }
     emit(args) {
      const pending = this._pending;
      this._pending = new coreutils_2.PromiseDelegate, pending.resolve({
       args,
       next: this._pending
      }), super.emit(args);
     }
     stop() {
      this._pending.promise.catch((() => {})), this._pending.reject("stop");
     }
    }
    Private.Stream = Stream;
   }(Private || (Private = {}));
  },
  50608: function(__unused_webpack_module, exports, __webpack_require__) {
   "use strict";
   var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    void 0 === k2 && (k2 = k), Object.defineProperty(o, k2, {
     enumerable: !0,
     get: function() {
      return m[k];
     }
    });
   } : function(o, m, k, k2) {
    void 0 === k2 && (k2 = k), o[k2] = m[k];
   }), __exportStar = this && this.__exportStar || function(m, exports) {
    for (var p in m) "default" === p || Object.prototype.hasOwnProperty.call(exports, p) || __createBinding(exports, m, p);
   };
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), __exportStar(__webpack_require__(5412), exports), __exportStar(__webpack_require__(39851), exports), 
   __exportStar(__webpack_require__(97375), exports), __exportStar(__webpack_require__(1091), exports), 
   __exportStar(__webpack_require__(14272), exports), __exportStar(__webpack_require__(76807), exports), 
   __exportStar(__webpack_require__(90139), exports), __exportStar(__webpack_require__(1089), exports), 
   __exportStar(__webpack_require__(86923), exports), __exportStar(__webpack_require__(95399), exports), 
   __exportStar(__webpack_require__(67569), exports), __exportStar(__webpack_require__(18430), exports), 
   __exportStar(__webpack_require__(90362), exports), __exportStar(__webpack_require__(93892), exports);
  },
  52570: function(__unused_webpack_module, exports, __webpack_require__) {
   "use strict";
   var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    void 0 === k2 && (k2 = k), Object.defineProperty(o, k2, {
     enumerable: !0,
     get: function() {
      return m[k];
     }
    });
   } : function(o, m, k, k2) {
    void 0 === k2 && (k2 = k), o[k2] = m[k];
   }), __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
     enumerable: !0,
     value: v
    });
   } : function(o, v) {
    o.default = v;
   }), __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (null != mod) for (var k in mod) "default" !== k && Object.prototype.hasOwnProperty.call(mod, k) && __createBinding(result, mod, k);
    return __setModuleDefault(result, mod), result;
   };
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.CommHandler = void 0;
   const disposable_1 = __webpack_require__(83070), KernelMessage = __importStar(__webpack_require__(59798));
   class CommHandler extends disposable_1.DisposableDelegate {
    constructor(target, id, kernel, disposeCb) {
     super(disposeCb), this._target = "", this._id = "", this._id = id, this._target = target, 
     this._kernel = kernel;
    }
    get commId() {
     return this._id;
    }
    get targetName() {
     return this._target;
    }
    get onClose() {
     return this._onClose;
    }
    set onClose(cb) {
     this._onClose = cb;
    }
    get onMsg() {
     return this._onMsg;
    }
    set onMsg(cb) {
     this._onMsg = cb;
    }
    open(data, metadata, buffers = []) {
     if (this.isDisposed || this._kernel.isDisposed) throw new Error("Cannot open");
     const msg = KernelMessage.createMessage({
      msgType: "comm_open",
      channel: "shell",
      username: this._kernel.username,
      session: this._kernel.clientId,
      content: {
       comm_id: this._id,
       target_name: this._target,
       data: null != data ? data : {}
      },
      metadata,
      buffers
     });
     return this._kernel.sendShellMessage(msg, !1, !0);
    }
    send(data, metadata, buffers = [], disposeOnDone = !0) {
     if (this.isDisposed || this._kernel.isDisposed) throw new Error("Cannot send");
     const msg = KernelMessage.createMessage({
      msgType: "comm_msg",
      channel: "shell",
      username: this._kernel.username,
      session: this._kernel.clientId,
      content: {
       comm_id: this._id,
       data
      },
      metadata,
      buffers
     });
     return this._kernel.sendShellMessage(msg, !1, disposeOnDone);
    }
    close(data, metadata, buffers = []) {
     if (this.isDisposed || this._kernel.isDisposed) throw new Error("Cannot close");
     const msg = KernelMessage.createMessage({
      msgType: "comm_close",
      channel: "shell",
      username: this._kernel.username,
      session: this._kernel.clientId,
      content: {
       comm_id: this._id,
       data: null != data ? data : {}
      },
      metadata,
      buffers
     }), future = this._kernel.sendShellMessage(msg, !1, !0), onClose = this._onClose;
     if (onClose) {
      onClose(KernelMessage.createMessage({
       msgType: "comm_close",
       channel: "iopub",
       username: this._kernel.username,
       session: this._kernel.clientId,
       content: {
        comm_id: this._id,
        data: null != data ? data : {}
       },
       metadata,
       buffers
      }));
     }
     return this.dispose(), future;
    }
   }
   exports.CommHandler = CommHandler;
  },
  45089: function(__unused_webpack_module, exports, __webpack_require__) {
   "use strict";
   var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    void 0 === k2 && (k2 = k), Object.defineProperty(o, k2, {
     enumerable: !0,
     get: function() {
      return m[k];
     }
    });
   } : function(o, m, k, k2) {
    void 0 === k2 && (k2 = k), o[k2] = m[k];
   }), __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
     enumerable: !0,
     value: v
    });
   } : function(o, v) {
    o.default = v;
   }), __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (null != mod) for (var k in mod) "default" !== k && Object.prototype.hasOwnProperty.call(mod, k) && __createBinding(result, mod, k);
    return __setModuleDefault(result, mod), result;
   };
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.KernelConnection = void 0;
   const coreutils_1 = __webpack_require__(16015), coreutils_2 = __webpack_require__(64954), signaling_1 = __webpack_require__(57082), __1 = __webpack_require__(50608), comm_1 = __webpack_require__(52570), KernelMessage = __importStar(__webpack_require__(59798)), future_1 = __webpack_require__(46073), serialize = __importStar(__webpack_require__(93962)), validate = __importStar(__webpack_require__(38872)), kernelspec_1 = __webpack_require__(76807), restapi = __importStar(__webpack_require__(38662));
   class KernelConnection {
    constructor(options) {
     var _a, _b, _c, _d;
     this._createSocket = () => {
      this._errorIfDisposed(), this._clearSocket(), this._updateConnectionStatus("connecting");
      const settings = this.serverSettings, partialUrl = coreutils_1.URLExt.join(settings.wsUrl, restapi.KERNEL_SERVICE_URL, encodeURIComponent(this._id)), display = partialUrl.replace(/^((?:\w+:)?\/\/)(?:[^@\/]+@)/, "$1");
      console.debug(`Starting WebSocket: ${display}`);
      let url = coreutils_1.URLExt.join(partialUrl, "channels?session_id=" + encodeURIComponent(this._clientId));
      const token = settings.token;
      settings.appendToken && "" !== token && (url += `&token=${encodeURIComponent(token)}`), 
      this._ws = new settings.WebSocket(url), this._ws.binaryType = "arraybuffer";
      let alreadyCalledOnclose = !1;
      const getKernelModel = async evt => {
       var _a, _b;
       if (!this._isDisposed) {
        this._reason = "", this._model = void 0;
        try {
         const model = await restapi.getKernelModel(this._id, settings);
         this._model = model, "dead" === (null == model ? void 0 : model.execution_state) ? this._updateStatus("dead") : this._onWSClose(evt);
        } catch (err) {
         if (err instanceof __1.ServerConnection.NetworkError || 503 === (null === (_a = err.response) || void 0 === _a ? void 0 : _a.status) || 424 === (null === (_b = err.response) || void 0 === _b ? void 0 : _b.status)) {
          const timeout = 1e3 * Private.getRandomIntInclusive(10, 30);
          setTimeout(getKernelModel, timeout, evt);
         } else this._reason = "Kernel died unexpectedly", this._updateStatus("dead");
        }
       }
      }, earlyClose = async evt => {
       alreadyCalledOnclose || (alreadyCalledOnclose = !0, await getKernelModel(evt));
      };
      this._ws.onmessage = this._onWSMessage, this._ws.onopen = this._onWSOpen, this._ws.onclose = earlyClose, 
      this._ws.onerror = earlyClose;
     }, this._onWSOpen = evt => {
      this._ws.onclose = this._onWSClose, this._ws.onerror = this._onWSClose, this._updateConnectionStatus("connected");
     }, this._onWSMessage = evt => {
      let msg;
      try {
       msg = serialize.deserialize(evt.data), validate.validateMessage(msg);
      } catch (error) {
       throw error.message = `Kernel message validation error: ${error.message}`, error;
      }
      this._kernelSession = msg.header.session, this._msgChain = this._msgChain.then((() => this._handleMessage(msg))).catch((error => {
       error.message.startsWith("Canceled future for ") && console.error(error);
      })), this._anyMessage.emit({
       msg,
       direction: "recv"
      });
     }, this._onWSClose = evt => {
      this.isDisposed || this._reconnect();
     }, this._id = "", this._name = "", this._status = "unknown", this._connectionStatus = "connecting", 
     this._kernelSession = "", this._isDisposed = !1, this._ws = null, this._username = "", 
     this._reconnectLimit = 7, this._reconnectAttempt = 0, this._reconnectTimeout = null, 
     this._futures = new Map, this._comms = new Map, this._targetRegistry = Object.create(null), 
     this._info = new coreutils_2.PromiseDelegate, this._pendingMessages = [], this._statusChanged = new signaling_1.Signal(this), 
     this._connectionStatusChanged = new signaling_1.Signal(this), this._disposed = new signaling_1.Signal(this), 
     this._iopubMessage = new signaling_1.Signal(this), this._anyMessage = new signaling_1.Signal(this), 
     this._pendingInput = new signaling_1.Signal(this), this._unhandledMessage = new signaling_1.Signal(this), 
     this._displayIdToParentIds = new Map, this._msgIdToDisplayIds = new Map, this._msgChain = Promise.resolve(), 
     this._hasPendingInput = !1, this._reason = "", this._noOp = () => {}, this._name = options.model.name, 
     this._id = options.model.id, this.serverSettings = null !== (_a = options.serverSettings) && void 0 !== _a ? _a : __1.ServerConnection.makeSettings(), 
     this._clientId = null !== (_b = options.clientId) && void 0 !== _b ? _b : coreutils_2.UUID.uuid4(), 
     this._username = null !== (_c = options.username) && void 0 !== _c ? _c : "", this.handleComms = null === (_d = options.handleComms) || void 0 === _d || _d, 
     this._createSocket();
    }
    get disposed() {
     return this._disposed;
    }
    get statusChanged() {
     return this._statusChanged;
    }
    get connectionStatusChanged() {
     return this._connectionStatusChanged;
    }
    get iopubMessage() {
     return this._iopubMessage;
    }
    get unhandledMessage() {
     return this._unhandledMessage;
    }
    get model() {
     return this._model || {
      id: this.id,
      name: this.name,
      reason: this._reason
     };
    }
    get anyMessage() {
     return this._anyMessage;
    }
    get pendingInput() {
     return this._pendingInput;
    }
    get id() {
     return this._id;
    }
    get name() {
     return this._name;
    }
    get username() {
     return this._username;
    }
    get clientId() {
     return this._clientId;
    }
    get status() {
     return this._status;
    }
    get connectionStatus() {
     return this._connectionStatus;
    }
    get isDisposed() {
     return this._isDisposed;
    }
    get info() {
     return this._info.promise;
    }
    get spec() {
     return this._specPromise || (this._specPromise = kernelspec_1.KernelSpecAPI.getSpecs(this.serverSettings).then((specs => specs.kernelspecs[this._name]))), 
     this._specPromise;
    }
    clone(options = {}) {
     return new KernelConnection(Object.assign({
      model: this.model,
      username: this.username,
      serverSettings: this.serverSettings,
      handleComms: !1
     }, options));
    }
    dispose() {
     this.isDisposed || (this._isDisposed = !0, this._disposed.emit(), this._updateConnectionStatus("disconnected"), 
     this._clearKernelState(), this._pendingMessages = [], this._clearSocket(), signaling_1.Signal.clearData(this));
    }
    sendShellMessage(msg, expectReply = !1, disposeOnDone = !0) {
     return this._sendKernelShellControl(future_1.KernelShellFutureHandler, msg, expectReply, disposeOnDone);
    }
    sendControlMessage(msg, expectReply = !1, disposeOnDone = !0) {
     return this._sendKernelShellControl(future_1.KernelControlFutureHandler, msg, expectReply, disposeOnDone);
    }
    _sendKernelShellControl(ctor, msg, expectReply = !1, disposeOnDone = !0) {
     this._sendMessage(msg), this._anyMessage.emit({
      msg,
      direction: "send"
     });
     const future = new ctor((() => {
      const msgId = msg.header.msg_id;
      this._futures.delete(msgId);
      const displayIds = this._msgIdToDisplayIds.get(msgId);
      displayIds && (displayIds.forEach((displayId => {
       const msgIds = this._displayIdToParentIds.get(displayId);
       if (msgIds) {
        const idx = msgIds.indexOf(msgId);
        if (-1 === idx) return;
        1 === msgIds.length ? this._displayIdToParentIds.delete(displayId) : (msgIds.splice(idx, 1), 
        this._displayIdToParentIds.set(displayId, msgIds));
       }
      })), this._msgIdToDisplayIds.delete(msgId));
     }), msg, expectReply, disposeOnDone, this);
     return this._futures.set(msg.header.msg_id, future), future;
    }
    _sendMessage(msg, queue = !0) {
     if ("dead" === this.status) throw new Error("Kernel is dead");
     if (("" === this._kernelSession || "_RESTARTING_" === this._kernelSession) && KernelMessage.isInfoRequestMsg(msg)) {
      if ("connected" === this.connectionStatus) return void this._ws.send(serialize.serialize(msg));
      throw new Error("Could not send message: status is not connected");
     }
     if (queue && this._pendingMessages.length > 0) this._pendingMessages.push(msg); else if ("connected" === this.connectionStatus && "_RESTARTING_" !== this._kernelSession) this._ws.send(serialize.serialize(msg)); else {
      if (!queue) throw new Error("Could not send message");
      this._pendingMessages.push(msg);
     }
    }
    async interrupt() {
     if (this.hasPendingInput = !1, "dead" === this.status) throw new Error("Kernel is dead");
     return restapi.interruptKernel(this.id, this.serverSettings);
    }
    async restart() {
     if ("dead" === this.status) throw new Error("Kernel is dead");
     this._updateStatus("restarting"), this._clearKernelState(), this._kernelSession = "_RESTARTING_", 
     await restapi.restartKernel(this.id, this.serverSettings), await this.reconnect(), 
     this.hasPendingInput = !1;
    }
    reconnect() {
     this._errorIfDisposed();
     const result = new coreutils_2.PromiseDelegate, fulfill = (sender, status) => {
      "connected" === status ? (result.resolve(), this.connectionStatusChanged.disconnect(fulfill, this)) : "disconnected" === status && (result.reject(new Error("Kernel connection disconnected")), 
      this.connectionStatusChanged.disconnect(fulfill, this));
     };
     return this.connectionStatusChanged.connect(fulfill, this), this._reconnectAttempt = 0, 
     this._reconnect(), result.promise;
    }
    async shutdown() {
     "dead" !== this.status && await restapi.shutdownKernel(this.id, this.serverSettings), 
     this.handleShutdown();
    }
    handleShutdown() {
     this._updateStatus("dead"), this.dispose();
    }
    async requestKernelInfo() {
     const msg = KernelMessage.createMessage({
      msgType: "kernel_info_request",
      channel: "shell",
      username: this._username,
      session: this._clientId,
      content: {}
     });
     let reply;
     try {
      reply = await Private.handleShellMessage(this, msg);
     } catch (e) {
      if (this.isDisposed) return;
      throw e;
     }
     if (this._errorIfDisposed(), reply) return void 0 === reply.content.status && (reply.content.status = "ok"), 
     "ok" !== reply.content.status ? (this._info.reject("Kernel info reply errored"), 
     reply) : (this._info.resolve(reply.content), this._kernelSession = reply.header.session, 
     reply);
    }
    requestComplete(content) {
     const msg = KernelMessage.createMessage({
      msgType: "complete_request",
      channel: "shell",
      username: this._username,
      session: this._clientId,
      content
     });
     return Private.handleShellMessage(this, msg);
    }
    requestInspect(content) {
     const msg = KernelMessage.createMessage({
      msgType: "inspect_request",
      channel: "shell",
      username: this._username,
      session: this._clientId,
      content
     });
     return Private.handleShellMessage(this, msg);
    }
    requestHistory(content) {
     const msg = KernelMessage.createMessage({
      msgType: "history_request",
      channel: "shell",
      username: this._username,
      session: this._clientId,
      content
     });
     return Private.handleShellMessage(this, msg);
    }
    requestExecute(content, disposeOnDone = !0, metadata) {
     const msg = KernelMessage.createMessage({
      msgType: "execute_request",
      channel: "shell",
      username: this._username,
      session: this._clientId,
      content: Object.assign(Object.assign({}, {
       silent: !1,
       store_history: !0,
       user_expressions: {},
       allow_stdin: !0,
       stop_on_error: !1
      }), content),
      metadata
     });
     return this.sendShellMessage(msg, !0, disposeOnDone);
    }
    requestDebug(content, disposeOnDone = !0) {
     const msg = KernelMessage.createMessage({
      msgType: "debug_request",
      channel: "control",
      username: this._username,
      session: this._clientId,
      content
     });
     return this.sendControlMessage(msg, !0, disposeOnDone);
    }
    requestIsComplete(content) {
     const msg = KernelMessage.createMessage({
      msgType: "is_complete_request",
      channel: "shell",
      username: this._username,
      session: this._clientId,
      content
     });
     return Private.handleShellMessage(this, msg);
    }
    requestCommInfo(content) {
     const msg = KernelMessage.createMessage({
      msgType: "comm_info_request",
      channel: "shell",
      username: this._username,
      session: this._clientId,
      content
     });
     return Private.handleShellMessage(this, msg);
    }
    sendInputReply(content, parent_header) {
     const msg = KernelMessage.createMessage({
      msgType: "input_reply",
      channel: "stdin",
      username: this._username,
      session: this._clientId,
      content
     });
     parent_header && (msg.parent_header = parent_header), this._sendMessage(msg), this._anyMessage.emit({
      msg,
      direction: "send"
     }), this.hasPendingInput = !1;
    }
    createComm(targetName, commId = coreutils_2.UUID.uuid4()) {
     if (!this.handleComms) throw new Error("Comms are disabled on this kernel connection");
     if (this._comms.has(commId)) throw new Error("Comm is already created");
     const comm = new comm_1.CommHandler(targetName, commId, this, (() => {
      this._unregisterComm(commId);
     }));
     return this._comms.set(commId, comm), comm;
    }
    hasComm(commId) {
     return this._comms.has(commId);
    }
    registerCommTarget(targetName, callback) {
     this.handleComms && (this._targetRegistry[targetName] = callback);
    }
    removeCommTarget(targetName, callback) {
     this.handleComms && (this.isDisposed || this._targetRegistry[targetName] !== callback || delete this._targetRegistry[targetName]);
    }
    registerMessageHook(msgId, hook) {
     var _a;
     const future = null === (_a = this._futures) || void 0 === _a ? void 0 : _a.get(msgId);
     future && future.registerMessageHook(hook);
    }
    removeMessageHook(msgId, hook) {
     var _a;
     const future = null === (_a = this._futures) || void 0 === _a ? void 0 : _a.get(msgId);
     future && future.removeMessageHook(hook);
    }
    removeInputGuard() {
     this.hasPendingInput = !1;
    }
    async _handleDisplayId(displayId, msg) {
     var _a, _b;
     const msgId = msg.parent_header.msg_id;
     let parentIds = this._displayIdToParentIds.get(displayId);
     if (parentIds) {
      const updateMsg = {
       header: coreutils_2.JSONExt.deepCopy(msg.header),
       parent_header: coreutils_2.JSONExt.deepCopy(msg.parent_header),
       metadata: coreutils_2.JSONExt.deepCopy(msg.metadata),
       content: coreutils_2.JSONExt.deepCopy(msg.content),
       channel: msg.channel,
       buffers: msg.buffers ? msg.buffers.slice() : []
      };
      updateMsg.header.msg_type = "update_display_data", await Promise.all(parentIds.map((async parentId => {
       const future = this._futures && this._futures.get(parentId);
       future && await future.handleMsg(updateMsg);
      })));
     }
     if ("update_display_data" === msg.header.msg_type) return !0;
     parentIds = null !== (_a = this._displayIdToParentIds.get(displayId)) && void 0 !== _a ? _a : [], 
     -1 === parentIds.indexOf(msgId) && parentIds.push(msgId), this._displayIdToParentIds.set(displayId, parentIds);
     const displayIds = null !== (_b = this._msgIdToDisplayIds.get(msgId)) && void 0 !== _b ? _b : [];
     return -1 === displayIds.indexOf(msgId) && displayIds.push(msgId), this._msgIdToDisplayIds.set(msgId, displayIds), 
     !1;
    }
    _clearSocket() {
     null !== this._ws && (this._ws.onopen = this._noOp, this._ws.onclose = this._noOp, 
     this._ws.onerror = this._noOp, this._ws.onmessage = this._noOp, this._ws.close(), 
     this._ws = null);
    }
    _updateStatus(status) {
     this._status !== status && "dead" !== this._status && (this._status = status, Private.logKernelStatus(this), 
     this._statusChanged.emit(status), "dead" === status && this.dispose());
    }
    _sendPending() {
     for (;"connected" === this.connectionStatus && "_RESTARTING_" !== this._kernelSession && this._pendingMessages.length > 0; ) this._sendMessage(this._pendingMessages[0], !1), 
     this._pendingMessages.shift();
    }
    _clearKernelState() {
     this._kernelSession = "", this._pendingMessages = [], this._futures.forEach((future => {
      future.dispose();
     })), this._comms.forEach((comm => {
      comm.dispose();
     })), this._msgChain = Promise.resolve(), this._futures = new Map, this._comms = new Map, 
     this._displayIdToParentIds.clear(), this._msgIdToDisplayIds.clear();
    }
    _assertCurrentMessage(msg) {
     if (this._errorIfDisposed(), msg.header.session !== this._kernelSession) throw new Error(`Canceling handling of old message: ${msg.header.msg_type}`);
    }
    async _handleCommOpen(msg) {
     this._assertCurrentMessage(msg);
     const content = msg.content, comm = new comm_1.CommHandler(content.target_name, content.comm_id, this, (() => {
      this._unregisterComm(content.comm_id);
     }));
     this._comms.set(content.comm_id, comm);
     try {
      const target = await Private.loadObject(content.target_name, content.target_module, this._targetRegistry);
      await target(comm, msg);
     } catch (e) {
      throw comm.close(), console.error("Exception opening new comm"), e;
     }
    }
    async _handleCommClose(msg) {
     this._assertCurrentMessage(msg);
     const content = msg.content, comm = this._comms.get(content.comm_id);
     if (!comm) return void console.error("Comm not found for comm id " + content.comm_id);
     this._unregisterComm(comm.commId);
     const onClose = comm.onClose;
     onClose && await onClose(msg), comm.dispose();
    }
    async _handleCommMsg(msg) {
     this._assertCurrentMessage(msg);
     const content = msg.content, comm = this._comms.get(content.comm_id);
     if (!comm) return;
     const onMsg = comm.onMsg;
     onMsg && await onMsg(msg);
    }
    _unregisterComm(commId) {
     this._comms.delete(commId);
    }
    _updateConnectionStatus(connectionStatus) {
     if (this._connectionStatus !== connectionStatus) {
      if (this._connectionStatus = connectionStatus, "connecting" !== connectionStatus && (this._reconnectAttempt = 0, 
      clearTimeout(this._reconnectTimeout)), "dead" !== this.status) if ("connected" === connectionStatus) {
       let restarting = "_RESTARTING_" === this._kernelSession, p = this.requestKernelInfo(), sendPendingCalled = !1, sendPendingOnce = () => {
        sendPendingCalled || (sendPendingCalled = !0, restarting && "_RESTARTING_" === this._kernelSession && (this._kernelSession = ""), 
        clearTimeout(timeoutHandle), this._pendingMessages.length > 0 && this._sendPending());
       };
       p.then(sendPendingOnce);
       let timeoutHandle = setTimeout(sendPendingOnce, 3e3);
      } else this._updateStatus("unknown");
      this._connectionStatusChanged.emit(connectionStatus);
     }
    }
    async _handleMessage(msg) {
     var _a, _b;
     let handled = !1;
     if (msg.parent_header && "iopub" === msg.channel && (KernelMessage.isDisplayDataMsg(msg) || KernelMessage.isUpdateDisplayDataMsg(msg) || KernelMessage.isExecuteResultMsg(msg))) {
      const displayId = (null !== (_a = msg.content.transient) && void 0 !== _a ? _a : {}).display_id;
      displayId && (handled = await this._handleDisplayId(displayId, msg), this._assertCurrentMessage(msg));
     }
     if (!handled && msg.parent_header) {
      const parentHeader = msg.parent_header, future = null === (_b = this._futures) || void 0 === _b ? void 0 : _b.get(parentHeader.msg_id);
      if (future) await future.handleMsg(msg), this._assertCurrentMessage(msg); else {
       const owned = parentHeader.session === this.clientId;
       "iopub" !== msg.channel && owned && this._unhandledMessage.emit(msg);
      }
     }
     if ("iopub" === msg.channel) {
      switch (msg.header.msg_type) {
      case "status":
       {
        const executionState = msg.content.execution_state;
        "restarting" === executionState && Promise.resolve().then((async () => {
         this._updateStatus("autorestarting"), this._clearKernelState(), await this.reconnect();
        })), this._updateStatus(executionState);
        break;
       }

      case "comm_open":
       this.handleComms && await this._handleCommOpen(msg);
       break;

      case "comm_msg":
       this.handleComms && await this._handleCommMsg(msg);
       break;

      case "comm_close":
       this.handleComms && await this._handleCommClose(msg);
      }
      this.isDisposed || (this._assertCurrentMessage(msg), this._iopubMessage.emit(msg));
     }
    }
    _reconnect() {
     if (this._errorIfDisposed(), clearTimeout(this._reconnectTimeout), this._reconnectAttempt < this._reconnectLimit) {
      this._updateConnectionStatus("connecting");
      const timeout = Private.getRandomIntInclusive(0, 1e3 * (Math.pow(2, this._reconnectAttempt) - 1));
      console.warn(`Connection lost, reconnecting in ${Math.floor(timeout / 1e3)} seconds.`), 
      this._reconnectTimeout = setTimeout(this._createSocket, timeout), this._reconnectAttempt += 1;
     } else this._updateConnectionStatus("disconnected");
     this._clearSocket();
    }
    _errorIfDisposed() {
     if (this.isDisposed) throw new Error("Kernel connection is disposed");
    }
    get hasPendingInput() {
     return this._hasPendingInput;
    }
    set hasPendingInput(value) {
     this._hasPendingInput = value, this._pendingInput.emit(value);
    }
   }
   var Private;
   exports.KernelConnection = KernelConnection, function(Private) {
    Private.logKernelStatus = function(kernel) {
     switch (kernel.status) {
     case "idle":
     case "busy":
     case "unknown":
      return;

     default:
      console.debug(`Kernel: ${kernel.status} (${kernel.id})`);
     }
    }, Private.handleShellMessage = async function(kernel, msg) {
     return kernel.sendShellMessage(msg, !0).done;
    }, Private.loadObject = function(name, moduleName, registry) {
     return new Promise(((resolve, reject) => {
      if (moduleName) {
       if ("undefined" == typeof requirejs) throw new Error("requirejs not found");
       requirejs([ moduleName ], (mod => {
        if (void 0 === mod[name]) {
         reject(new Error(`Object '${name}' not found in module '${moduleName}'`));
        } else resolve(mod[name]);
       }), reject);
      } else (null == registry ? void 0 : registry[name]) ? resolve(registry[name]) : reject(new Error(`Object '${name}' not found in registry`));
     }));
    }, Private.getRandomIntInclusive = function(min, max) {
     return min = Math.ceil(min), max = Math.floor(max), Math.floor(Math.random() * (max - min + 1)) + min;
    };
   }(Private || (Private = {}));
  },
  46073: function(__unused_webpack_module, exports, __webpack_require__) {
   "use strict";
   var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    void 0 === k2 && (k2 = k), Object.defineProperty(o, k2, {
     enumerable: !0,
     get: function() {
      return m[k];
     }
    });
   } : function(o, m, k, k2) {
    void 0 === k2 && (k2 = k), o[k2] = m[k];
   }), __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
     enumerable: !0,
     value: v
    });
   } : function(o, v) {
    o.default = v;
   }), __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (null != mod) for (var k in mod) "default" !== k && Object.prototype.hasOwnProperty.call(mod, k) && __createBinding(result, mod, k);
    return __setModuleDefault(result, mod), result;
   };
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.KernelShellFutureHandler = exports.KernelControlFutureHandler = exports.KernelFutureHandler = void 0;
   const coreutils_1 = __webpack_require__(64954), disposable_1 = __webpack_require__(83070), KernelMessage = __importStar(__webpack_require__(59798));
   class KernelFutureHandler extends disposable_1.DisposableDelegate {
    constructor(cb, msg, expectReply, disposeOnDone, kernel) {
     super(cb), this._status = 0, this._stdin = Private.noOp, this._iopub = Private.noOp, 
     this._reply = Private.noOp, this._done = new coreutils_1.PromiseDelegate, this._hooks = new Private.HookList, 
     this._disposeOnDone = !0, this._msg = msg, expectReply || this._setFlag(Private.KernelFutureFlag.GotReply), 
     this._disposeOnDone = disposeOnDone, this._kernel = kernel;
    }
    get msg() {
     return this._msg;
    }
    get done() {
     return this._done.promise;
    }
    get onReply() {
     return this._reply;
    }
    set onReply(cb) {
     this._reply = cb;
    }
    get onIOPub() {
     return this._iopub;
    }
    set onIOPub(cb) {
     this._iopub = cb;
    }
    get onStdin() {
     return this._stdin;
    }
    set onStdin(cb) {
     this._stdin = cb;
    }
    registerMessageHook(hook) {
     if (this.isDisposed) throw new Error("Kernel future is disposed");
     this._hooks.add(hook);
    }
    removeMessageHook(hook) {
     this.isDisposed || this._hooks.remove(hook);
    }
    sendInputReply(content, parent_header) {
     this._kernel.sendInputReply(content, parent_header);
    }
    dispose() {
     this._stdin = Private.noOp, this._iopub = Private.noOp, this._reply = Private.noOp, 
     this._hooks = null, this._testFlag(Private.KernelFutureFlag.IsDone) || (this._done.promise.catch((() => {})), 
     this._done.reject(new Error(`Canceled future for ${this.msg.header.msg_type} message before replies were done`))), 
     super.dispose();
    }
    async handleMsg(msg) {
     switch (msg.channel) {
     case "control":
     case "shell":
      msg.channel === this.msg.channel && msg.parent_header.msg_id === this.msg.header.msg_id && await this._handleReply(msg);
      break;

     case "stdin":
      await this._handleStdin(msg);
      break;

     case "iopub":
      await this._handleIOPub(msg);
     }
    }
    async _handleReply(msg) {
     const reply = this._reply;
     reply && await reply(msg), this._replyMsg = msg, this._setFlag(Private.KernelFutureFlag.GotReply), 
     this._testFlag(Private.KernelFutureFlag.GotIdle) && this._handleDone();
    }
    async _handleStdin(msg) {
     this._kernel.hasPendingInput = !0;
     const stdin = this._stdin;
     stdin && await stdin(msg);
    }
    async _handleIOPub(msg) {
     const process = await this._hooks.process(msg), iopub = this._iopub;
     process && iopub && await iopub(msg), KernelMessage.isStatusMsg(msg) && "idle" === msg.content.execution_state && (this._setFlag(Private.KernelFutureFlag.GotIdle), 
     this._testFlag(Private.KernelFutureFlag.GotReply) && this._handleDone());
    }
    _handleDone() {
     this._testFlag(Private.KernelFutureFlag.IsDone) || (this._setFlag(Private.KernelFutureFlag.IsDone), 
     this._done.resolve(this._replyMsg), this._disposeOnDone && this.dispose());
    }
    _testFlag(flag) {
     return !!(this._status & flag);
    }
    _setFlag(flag) {
     this._status |= flag;
    }
   }
   exports.KernelFutureHandler = KernelFutureHandler;
   exports.KernelControlFutureHandler = class extends KernelFutureHandler {};
   var Private;
   exports.KernelShellFutureHandler = class extends KernelFutureHandler {}, function(Private) {
    Private.noOp = () => {};
    const defer = "function" == typeof requestAnimationFrame ? requestAnimationFrame : setImmediate;
    let KernelFutureFlag;
    Private.HookList = class {
     constructor() {
      this._hooks = [];
     }
     add(hook) {
      this.remove(hook), this._hooks.push(hook);
     }
     remove(hook) {
      const index = this._hooks.indexOf(hook);
      index >= 0 && (this._hooks[index] = null, this._scheduleCompact());
     }
     async process(msg) {
      await this._processing;
      const processing = new coreutils_1.PromiseDelegate;
      let continueHandling;
      this._processing = processing.promise;
      for (let i = this._hooks.length - 1; i >= 0; i--) {
       const hook = this._hooks[i];
       if (null !== hook) {
        try {
         continueHandling = await hook(msg);
        } catch (err) {
         continueHandling = !0, console.error(err);
        }
        if (!1 === continueHandling) return processing.resolve(void 0), !1;
       }
      }
      return processing.resolve(void 0), !0;
     }
     _scheduleCompact() {
      this._compactScheduled || (this._compactScheduled = !0, defer((() => {
       this._processing = this._processing.then((() => {
        this._compactScheduled = !1, this._compact();
       }));
      })));
     }
     _compact() {
      let numNulls = 0;
      for (let i = 0, len = this._hooks.length; i < len; i++) {
       const hook = this._hooks[i];
       null === this._hooks[i] ? numNulls++ : this._hooks[i - numNulls] = hook;
      }
      this._hooks.length -= numNulls;
     }
    }, function(KernelFutureFlag) {
     KernelFutureFlag[KernelFutureFlag.GotReply = 1] = "GotReply", KernelFutureFlag[KernelFutureFlag.GotIdle = 2] = "GotIdle", 
     KernelFutureFlag[KernelFutureFlag.IsDone = 4] = "IsDone", KernelFutureFlag[KernelFutureFlag.DisposeOnDone = 8] = "DisposeOnDone";
    }(KernelFutureFlag = Private.KernelFutureFlag || (Private.KernelFutureFlag = {}));
   }(Private || (Private = {}));
  },
  14272: function(__unused_webpack_module, exports, __webpack_require__) {
   "use strict";
   var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    void 0 === k2 && (k2 = k), Object.defineProperty(o, k2, {
     enumerable: !0,
     get: function() {
      return m[k];
     }
    });
   } : function(o, m, k, k2) {
    void 0 === k2 && (k2 = k), o[k2] = m[k];
   }), __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
     enumerable: !0,
     value: v
    });
   } : function(o, v) {
    o.default = v;
   }), __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (null != mod) for (var k in mod) "default" !== k && Object.prototype.hasOwnProperty.call(mod, k) && __createBinding(result, mod, k);
    return __setModuleDefault(result, mod), result;
   }, __exportStar = this && this.__exportStar || function(m, exports) {
    for (var p in m) "default" === p || Object.prototype.hasOwnProperty.call(exports, p) || __createBinding(exports, m, p);
   };
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.KernelConnection = exports.KernelAPI = exports.KernelMessage = exports.Kernel = void 0;
   const Kernel = __importStar(__webpack_require__(92343));
   exports.Kernel = Kernel;
   const KernelMessage = __importStar(__webpack_require__(59798));
   exports.KernelMessage = KernelMessage;
   const KernelAPI = __importStar(__webpack_require__(38662));
   exports.KernelAPI = KernelAPI;
   const default_1 = __webpack_require__(45089);
   Object.defineProperty(exports, "KernelConnection", {
    enumerable: !0,
    get: function() {
     return default_1.KernelConnection;
    }
   }), __exportStar(__webpack_require__(47275), exports);
  },
  92343: (__unused_webpack_module, exports) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   });
  },
  47275: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.KernelManager = void 0;
   const algorithm_1 = __webpack_require__(56588), polling_1 = __webpack_require__(93498), signaling_1 = __webpack_require__(57082), __1 = __webpack_require__(50608), basemanager_1 = __webpack_require__(5412), restapi_1 = __webpack_require__(38662), default_1 = __webpack_require__(45089);
   class KernelManager extends basemanager_1.BaseManager {
    constructor(options = {}) {
     var _a;
     super(options), this._isReady = !1, this._kernelConnections = new Set, this._models = new Map, 
     this._runningChanged = new signaling_1.Signal(this), this._connectionFailure = new signaling_1.Signal(this), 
     this._pollModels = new polling_1.Poll({
      auto: !1,
      factory: () => this.requestRunning(),
      frequency: {
       interval: 1e4,
       backoff: !0,
       max: 3e5
      },
      name: "@jupyterlab/services:KernelManager#models",
      standby: null !== (_a = options.standby) && void 0 !== _a ? _a : "when-hidden"
     }), this._ready = (async () => {
      await this._pollModels.start(), await this._pollModels.tick, this._isReady = !0;
     })();
    }
    get isReady() {
     return this._isReady;
    }
    get ready() {
     return this._ready;
    }
    get runningChanged() {
     return this._runningChanged;
    }
    get connectionFailure() {
     return this._connectionFailure;
    }
    dispose() {
     this.isDisposed || (this._models.clear(), this._kernelConnections.forEach((x => x.dispose())), 
     this._pollModels.dispose(), super.dispose());
    }
    connectTo(options) {
     var _a;
     const {id} = options.model;
     let handleComms = null === (_a = options.handleComms) || void 0 === _a || _a;
     if (void 0 === options.handleComms) for (const kc of this._kernelConnections) if (kc.id === id && kc.handleComms) {
      handleComms = !1;
      break;
     }
     const kernelConnection = new default_1.KernelConnection(Object.assign(Object.assign({
      handleComms
     }, options), {
      serverSettings: this.serverSettings
     }));
     return this._onStarted(kernelConnection), this._models.has(id) || this.refreshRunning().catch((() => {})), 
     kernelConnection;
    }
    running() {
     return algorithm_1.iter([ ...this._models.values() ]);
    }
    async refreshRunning() {
     await this._pollModels.refresh(), await this._pollModels.tick;
    }
    async startNew(createOptions = {}, connectOptions = {}) {
     const model = await restapi_1.startNew(createOptions, this.serverSettings);
     return this.connectTo(Object.assign(Object.assign({}, connectOptions), {
      model
     }));
    }
    async shutdown(id) {
     await restapi_1.shutdownKernel(id, this.serverSettings), await this.refreshRunning();
    }
    async shutdownAll() {
     await this.refreshRunning(), await Promise.all([ ...this._models.keys() ].map((id => restapi_1.shutdownKernel(id, this.serverSettings)))), 
     await this.refreshRunning();
    }
    async findById(id) {
     return this._models.has(id) || await this.refreshRunning(), this._models.get(id);
    }
    async requestRunning() {
     var _a, _b;
     let models;
     try {
      models = await restapi_1.listRunning(this.serverSettings);
     } catch (err) {
      throw (err instanceof __1.ServerConnection.NetworkError || 503 === (null === (_a = err.response) || void 0 === _a ? void 0 : _a.status) || 424 === (null === (_b = err.response) || void 0 === _b ? void 0 : _b.status)) && this._connectionFailure.emit(err), 
      err;
     }
     this.isDisposed || this._models.size === models.length && algorithm_1.every(models, (x => {
      const existing = this._models.get(x.id);
      return !!existing && existing.name === x.name;
     })) || (this._models = new Map(models.map((x => [ x.id, x ]))), this._kernelConnections.forEach((kc => {
      this._models.has(kc.id) || kc.handleShutdown();
     })), this._runningChanged.emit(models));
    }
    _onStarted(kernelConnection) {
     this._kernelConnections.add(kernelConnection), kernelConnection.statusChanged.connect(this._onStatusChanged, this), 
     kernelConnection.disposed.connect(this._onDisposed, this);
    }
    _onDisposed(kernelConnection) {
     this._kernelConnections.delete(kernelConnection), this.refreshRunning().catch((() => {}));
    }
    _onStatusChanged(kernelConnection, status) {
     "dead" === status && this.refreshRunning().catch((() => {}));
    }
   }
   exports.KernelManager = KernelManager;
  },
  59798: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.isInputReplyMsg = exports.isInputRequestMsg = exports.isDebugReplyMsg = exports.isDebugRequestMsg = exports.isExecuteReplyMsg = exports.isInfoRequestMsg = exports.isCommMsgMsg = exports.isCommCloseMsg = exports.isCommOpenMsg = exports.isDebugEventMsg = exports.isClearOutputMsg = exports.isStatusMsg = exports.isErrorMsg = exports.isExecuteResultMsg = exports.isExecuteInputMsg = exports.isUpdateDisplayDataMsg = exports.isDisplayDataMsg = exports.isStreamMsg = exports.createMessage = void 0;
   const coreutils_1 = __webpack_require__(64954);
   exports.createMessage = function(options) {
    var _a, _b, _c, _d, _e;
    return {
     buffers: null !== (_a = options.buffers) && void 0 !== _a ? _a : [],
     channel: options.channel,
     content: options.content,
     header: {
      date: (new Date).toISOString(),
      msg_id: null !== (_b = options.msgId) && void 0 !== _b ? _b : coreutils_1.UUID.uuid4(),
      msg_type: options.msgType,
      session: options.session,
      username: null !== (_c = options.username) && void 0 !== _c ? _c : "",
      version: "5.2"
     },
     metadata: null !== (_d = options.metadata) && void 0 !== _d ? _d : {},
     parent_header: null !== (_e = options.parentHeader) && void 0 !== _e ? _e : {}
    };
   }, exports.isStreamMsg = function(msg) {
    return "stream" === msg.header.msg_type;
   }, exports.isDisplayDataMsg = function(msg) {
    return "display_data" === msg.header.msg_type;
   }, exports.isUpdateDisplayDataMsg = function(msg) {
    return "update_display_data" === msg.header.msg_type;
   }, exports.isExecuteInputMsg = function(msg) {
    return "execute_input" === msg.header.msg_type;
   }, exports.isExecuteResultMsg = function(msg) {
    return "execute_result" === msg.header.msg_type;
   }, exports.isErrorMsg = function(msg) {
    return "error" === msg.header.msg_type;
   }, exports.isStatusMsg = function(msg) {
    return "status" === msg.header.msg_type;
   }, exports.isClearOutputMsg = function(msg) {
    return "clear_output" === msg.header.msg_type;
   }, exports.isDebugEventMsg = function(msg) {
    return "debug_event" === msg.header.msg_type;
   }, exports.isCommOpenMsg = function(msg) {
    return "comm_open" === msg.header.msg_type;
   }, exports.isCommCloseMsg = function(msg) {
    return "comm_close" === msg.header.msg_type;
   }, exports.isCommMsgMsg = function(msg) {
    return "comm_msg" === msg.header.msg_type;
   }, exports.isInfoRequestMsg = function(msg) {
    return "kernel_info_request" === msg.header.msg_type;
   }, exports.isExecuteReplyMsg = function(msg) {
    return "execute_reply" === msg.header.msg_type;
   }, exports.isDebugRequestMsg = function(msg) {
    return "debug_request" === msg.header.msg_type;
   }, exports.isDebugReplyMsg = function(msg) {
    return "debug_reply" === msg.header.msg_type;
   }, exports.isInputRequestMsg = function(msg) {
    return "input_request" === msg.header.msg_type;
   }, exports.isInputReplyMsg = function(msg) {
    return "input_reply" === msg.header.msg_type;
   };
  },
  92175: function(__unused_webpack_module, exports, __webpack_require__) {
   "use strict";
   var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    void 0 === k2 && (k2 = k), Object.defineProperty(o, k2, {
     enumerable: !0,
     get: function() {
      return m[k];
     }
    });
   } : function(o, m, k, k2) {
    void 0 === k2 && (k2 = k), o[k2] = m[k];
   }), __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
     enumerable: !0,
     value: v
    });
   } : function(o, v) {
    o.default = v;
   }), __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (null != mod) for (var k in mod) "default" !== k && Object.prototype.hasOwnProperty.call(mod, k) && __createBinding(result, mod, k);
    return __setModuleDefault(result, mod), result;
   };
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.KernelConnection = void 0;
   const coreutils_1 = __webpack_require__(16015), coreutils_2 = __webpack_require__(64954), signaling_1 = __webpack_require__(57082), __1 = __webpack_require__(50608), comm_1 = __webpack_require__(52570), KernelMessage = __importStar(__webpack_require__(59798)), future_1 = __webpack_require__(46073), serialize_serialize = a => a, serialize_deserialize = a => a, validate = __importStar(__webpack_require__(38872)), kernelspec_1 = __webpack_require__(76807), restapi = __importStar(__webpack_require__(38662));
   class KernelConnection {
    constructor(options) {
     var _a, _b, _c, _d;
     this._createSocket = () => {
      this._errorIfDisposed(), this._clearSocket(), this._updateConnectionStatus("connecting");
      const settings = this.serverSettings, partialUrl = coreutils_1.URLExt.join(settings.wsUrl, restapi.KERNEL_SERVICE_URL, encodeURIComponent(this._id)), display = partialUrl.replace(/^((?:\w+:)?\/\/)(?:[^@\/]+@)/, "$1");
      console.debug(`Starting WebSocket: ${display}`);
      let url = coreutils_1.URLExt.join(partialUrl, "channels?session_id=" + encodeURIComponent(this._clientId));
      const token = settings.token;
      settings.appendToken && "" !== token && (url += `&token=${encodeURIComponent(token)}`), 
      this._ws = new settings.WebSocket(url), this._ws.binaryType = "arraybuffer";
      let alreadyCalledOnclose = !1;
      const getKernelModel = async evt => {
       var _a, _b;
       if (!this._isDisposed) {
        this._reason = "", this._model = void 0;
        try {
         const model = await restapi.getKernelModel(this._id, settings);
         this._model = model, "dead" === (null == model ? void 0 : model.execution_state) ? this._updateStatus("dead") : this._onWSClose(evt);
        } catch (err) {
         if (err instanceof __1.ServerConnection.NetworkError || 503 === (null === (_a = err.response) || void 0 === _a ? void 0 : _a.status) || 424 === (null === (_b = err.response) || void 0 === _b ? void 0 : _b.status)) {
          const timeout = 1e3 * Private.getRandomIntInclusive(10, 30);
          setTimeout(getKernelModel, timeout, evt);
         } else this._reason = "Kernel died unexpectedly", this._updateStatus("dead");
        }
       }
      }, earlyClose = async evt => {
       alreadyCalledOnclose || (alreadyCalledOnclose = !0, await getKernelModel(evt));
      };
      this._ws.onmessage = this._onWSMessage, this._ws.onopen = this._onWSOpen, this._ws.onclose = earlyClose, 
      this._ws.onerror = earlyClose;
     }, this._onWSOpen = evt => {
      this._ws.onclose = this._onWSClose, this._ws.onerror = this._onWSClose, this._updateConnectionStatus("connected");
     }, this._onWSMessage = evt => {
      let msg;
      try {
       msg = serialize_deserialize(evt.data), validate.validateMessage(msg);
      } catch (error) {
       throw error.message = `Kernel message validation error: ${error.message}`, error;
      }
      this._kernelSession = msg.header.session, this._msgChain = this._msgChain.then((() => this._handleMessage(msg))).catch((error => {
       error.message.startsWith("Canceled future for ") && console.error(error);
      })), this._anyMessage.emit({
       msg,
       direction: "recv"
      });
     }, this._onWSClose = evt => {
      this.isDisposed || this._reconnect();
     }, this._id = "", this._name = "", this._status = "unknown", this._connectionStatus = "connecting", 
     this._kernelSession = "", this._isDisposed = !1, this._ws = null, this._username = "", 
     this._reconnectLimit = 7, this._reconnectAttempt = 0, this._reconnectTimeout = null, 
     this._futures = new Map, this._comms = new Map, this._targetRegistry = Object.create(null), 
     this._info = new coreutils_2.PromiseDelegate, this._pendingMessages = [], this._statusChanged = new signaling_1.Signal(this), 
     this._connectionStatusChanged = new signaling_1.Signal(this), this._disposed = new signaling_1.Signal(this), 
     this._iopubMessage = new signaling_1.Signal(this), this._anyMessage = new signaling_1.Signal(this), 
     this._pendingInput = new signaling_1.Signal(this), this._unhandledMessage = new signaling_1.Signal(this), 
     this._displayIdToParentIds = new Map, this._msgIdToDisplayIds = new Map, this._msgChain = Promise.resolve(), 
     this._hasPendingInput = !1, this._reason = "", this._noOp = () => {}, this._name = options.model.name, 
     this._id = options.model.id, this.serverSettings = null !== (_a = options.serverSettings) && void 0 !== _a ? _a : __1.ServerConnection.makeSettings(), 
     this._clientId = null !== (_b = options.clientId) && void 0 !== _b ? _b : coreutils_2.UUID.uuid4(), 
     this._username = null !== (_c = options.username) && void 0 !== _c ? _c : "", this.handleComms = null === (_d = options.handleComms) || void 0 === _d || _d, 
     this._createSocket();
    }
    get disposed() {
     return this._disposed;
    }
    get statusChanged() {
     return this._statusChanged;
    }
    get connectionStatusChanged() {
     return this._connectionStatusChanged;
    }
    get iopubMessage() {
     return this._iopubMessage;
    }
    get unhandledMessage() {
     return this._unhandledMessage;
    }
    get model() {
     return this._model || {
      id: this.id,
      name: this.name,
      reason: this._reason
     };
    }
    get anyMessage() {
     return this._anyMessage;
    }
    get pendingInput() {
     return this._pendingInput;
    }
    get id() {
     return this._id;
    }
    get name() {
     return this._name;
    }
    get username() {
     return this._username;
    }
    get clientId() {
     return this._clientId;
    }
    get status() {
     return this._status;
    }
    get connectionStatus() {
     return this._connectionStatus;
    }
    get isDisposed() {
     return this._isDisposed;
    }
    get info() {
     return this._info.promise;
    }
    get spec() {
     return this._specPromise || (this._specPromise = kernelspec_1.KernelSpecAPI.getSpecs(this.serverSettings).then((specs => specs.kernelspecs[this._name]))), 
     this._specPromise;
    }
    clone(options = {}) {
     return new KernelConnection(Object.assign({
      model: this.model,
      username: this.username,
      serverSettings: this.serverSettings,
      handleComms: !1
     }, options));
    }
    dispose() {
     this.isDisposed || (this._isDisposed = !0, this._disposed.emit(), this._updateConnectionStatus("disconnected"), 
     this._clearKernelState(), this._pendingMessages = [], this._clearSocket(), signaling_1.Signal.clearData(this));
    }
    sendShellMessage(msg, expectReply = !1, disposeOnDone = !0) {
     return this._sendKernelShellControl(future_1.KernelShellFutureHandler, msg, expectReply, disposeOnDone);
    }
    sendControlMessage(msg, expectReply = !1, disposeOnDone = !0) {
     return this._sendKernelShellControl(future_1.KernelControlFutureHandler, msg, expectReply, disposeOnDone);
    }
    _sendKernelShellControl(ctor, msg, expectReply = !1, disposeOnDone = !0) {
     this._sendMessage(msg), this._anyMessage.emit({
      msg,
      direction: "send"
     });
     const future = new ctor((() => {
      const msgId = msg.header.msg_id;
      this._futures.delete(msgId);
      const displayIds = this._msgIdToDisplayIds.get(msgId);
      displayIds && (displayIds.forEach((displayId => {
       const msgIds = this._displayIdToParentIds.get(displayId);
       if (msgIds) {
        const idx = msgIds.indexOf(msgId);
        if (-1 === idx) return;
        1 === msgIds.length ? this._displayIdToParentIds.delete(displayId) : (msgIds.splice(idx, 1), 
        this._displayIdToParentIds.set(displayId, msgIds));
       }
      })), this._msgIdToDisplayIds.delete(msgId));
     }), msg, expectReply, disposeOnDone, this);
     return this._futures.set(msg.header.msg_id, future), future;
    }
    _sendMessage(msg, queue = !0) {
     if ("dead" === this.status) throw new Error("Kernel is dead");
     if (("" === this._kernelSession || "_RESTARTING_" === this._kernelSession) && KernelMessage.isInfoRequestMsg(msg)) {
      if ("connected" === this.connectionStatus) return void this._ws.send(serialize_serialize(msg));
      throw new Error("Could not send message: status is not connected");
     }
     if (queue && this._pendingMessages.length > 0) this._pendingMessages.push(msg); else if ("connected" === this.connectionStatus && "_RESTARTING_" !== this._kernelSession) this._ws.send(serialize_serialize(msg)); else {
      if (!queue) throw new Error("Could not send message");
      this._pendingMessages.push(msg);
     }
    }
    async interrupt() {
     if (this.hasPendingInput = !1, "dead" === this.status) throw new Error("Kernel is dead");
     return restapi.interruptKernel(this.id, this.serverSettings);
    }
    async restart() {
     if ("dead" === this.status) throw new Error("Kernel is dead");
     this._updateStatus("restarting"), this._clearKernelState(), this._kernelSession = "_RESTARTING_", 
     await restapi.restartKernel(this.id, this.serverSettings), await this.reconnect(), 
     this.hasPendingInput = !1;
    }
    reconnect() {
     this._errorIfDisposed();
     const result = new coreutils_2.PromiseDelegate, fulfill = (sender, status) => {
      "connected" === status ? (result.resolve(), this.connectionStatusChanged.disconnect(fulfill, this)) : "disconnected" === status && (result.reject(new Error("Kernel connection disconnected")), 
      this.connectionStatusChanged.disconnect(fulfill, this));
     };
     return this.connectionStatusChanged.connect(fulfill, this), this._reconnectAttempt = 0, 
     this._reconnect(), result.promise;
    }
    async shutdown() {
     "dead" !== this.status && await restapi.shutdownKernel(this.id, this.serverSettings), 
     this.handleShutdown();
    }
    handleShutdown() {
     this._updateStatus("dead"), this.dispose();
    }
    async requestKernelInfo() {
     const msg = KernelMessage.createMessage({
      msgType: "kernel_info_request",
      channel: "shell",
      username: this._username,
      session: this._clientId,
      content: {}
     });
     let reply;
     try {
      reply = await Private.handleShellMessage(this, msg);
     } catch (e) {
      if (this.isDisposed) return;
      throw e;
     }
     if (this._errorIfDisposed(), reply) return void 0 === reply.content.status && (reply.content.status = "ok"), 
     "ok" !== reply.content.status ? (this._info.reject("Kernel info reply errored"), 
     reply) : (this._info.resolve(reply.content), this._kernelSession = reply.header.session, 
     reply);
    }
    requestComplete(content) {
     const msg = KernelMessage.createMessage({
      msgType: "complete_request",
      channel: "shell",
      username: this._username,
      session: this._clientId,
      content
     });
     return Private.handleShellMessage(this, msg);
    }
    requestInspect(content) {
     const msg = KernelMessage.createMessage({
      msgType: "inspect_request",
      channel: "shell",
      username: this._username,
      session: this._clientId,
      content
     });
     return Private.handleShellMessage(this, msg);
    }
    requestHistory(content) {
     const msg = KernelMessage.createMessage({
      msgType: "history_request",
      channel: "shell",
      username: this._username,
      session: this._clientId,
      content
     });
     return Private.handleShellMessage(this, msg);
    }
    requestExecute(content, disposeOnDone = !0, metadata) {
     const msg = KernelMessage.createMessage({
      msgType: "execute_request",
      channel: "shell",
      username: this._username,
      session: this._clientId,
      content: Object.assign(Object.assign({}, {
       silent: !1,
       store_history: !0,
       user_expressions: {},
       allow_stdin: !0,
       stop_on_error: !1
      }), content),
      metadata
     });
     return this.sendShellMessage(msg, !0, disposeOnDone);
    }
    requestDebug(content, disposeOnDone = !0) {
     const msg = KernelMessage.createMessage({
      msgType: "debug_request",
      channel: "control",
      username: this._username,
      session: this._clientId,
      content
     });
     return this.sendControlMessage(msg, !0, disposeOnDone);
    }
    requestIsComplete(content) {
     const msg = KernelMessage.createMessage({
      msgType: "is_complete_request",
      channel: "shell",
      username: this._username,
      session: this._clientId,
      content
     });
     return Private.handleShellMessage(this, msg);
    }
    requestCommInfo(content) {
     const msg = KernelMessage.createMessage({
      msgType: "comm_info_request",
      channel: "shell",
      username: this._username,
      session: this._clientId,
      content
     });
     return Private.handleShellMessage(this, msg);
    }
    sendInputReply(content, parent_header) {
     const msg = KernelMessage.createMessage({
      msgType: "input_reply",
      channel: "stdin",
      username: this._username,
      session: this._clientId,
      content
     });
     parent_header && (msg.parent_header = parent_header), this._sendMessage(msg), this._anyMessage.emit({
      msg,
      direction: "send"
     }), this.hasPendingInput = !1;
    }
    createComm(targetName, commId = coreutils_2.UUID.uuid4()) {
     if (!this.handleComms) throw new Error("Comms are disabled on this kernel connection");
     if (this._comms.has(commId)) throw new Error("Comm is already created");
     const comm = new comm_1.CommHandler(targetName, commId, this, (() => {
      this._unregisterComm(commId);
     }));
     return this._comms.set(commId, comm), comm;
    }
    hasComm(commId) {
     return this._comms.has(commId);
    }
    registerCommTarget(targetName, callback) {
     this.handleComms && (this._targetRegistry[targetName] = callback);
    }
    removeCommTarget(targetName, callback) {
     this.handleComms && (this.isDisposed || this._targetRegistry[targetName] !== callback || delete this._targetRegistry[targetName]);
    }
    registerMessageHook(msgId, hook) {
     var _a;
     const future = null === (_a = this._futures) || void 0 === _a ? void 0 : _a.get(msgId);
     future && future.registerMessageHook(hook);
    }
    removeMessageHook(msgId, hook) {
     var _a;
     const future = null === (_a = this._futures) || void 0 === _a ? void 0 : _a.get(msgId);
     future && future.removeMessageHook(hook);
    }
    removeInputGuard() {
     this.hasPendingInput = !1;
    }
    async _handleDisplayId(displayId, msg) {
     var _a, _b;
     const msgId = msg.parent_header.msg_id;
     let parentIds = this._displayIdToParentIds.get(displayId);
     if (parentIds) {
      const updateMsg = {
       header: coreutils_2.JSONExt.deepCopy(msg.header),
       parent_header: coreutils_2.JSONExt.deepCopy(msg.parent_header),
       metadata: coreutils_2.JSONExt.deepCopy(msg.metadata),
       content: coreutils_2.JSONExt.deepCopy(msg.content),
       channel: msg.channel,
       buffers: msg.buffers ? msg.buffers.slice() : []
      };
      updateMsg.header.msg_type = "update_display_data", await Promise.all(parentIds.map((async parentId => {
       const future = this._futures && this._futures.get(parentId);
       future && await future.handleMsg(updateMsg);
      })));
     }
     if ("update_display_data" === msg.header.msg_type) return !0;
     parentIds = null !== (_a = this._displayIdToParentIds.get(displayId)) && void 0 !== _a ? _a : [], 
     -1 === parentIds.indexOf(msgId) && parentIds.push(msgId), this._displayIdToParentIds.set(displayId, parentIds);
     const displayIds = null !== (_b = this._msgIdToDisplayIds.get(msgId)) && void 0 !== _b ? _b : [];
     return -1 === displayIds.indexOf(msgId) && displayIds.push(msgId), this._msgIdToDisplayIds.set(msgId, displayIds), 
     !1;
    }
    _clearSocket() {
     null !== this._ws && (this._ws.onopen = this._noOp, this._ws.onclose = this._noOp, 
     this._ws.onerror = this._noOp, this._ws.onmessage = this._noOp, this._ws.close(), 
     this._ws = null);
    }
    _updateStatus(status) {
     this._status !== status && "dead" !== this._status && (this._status = status, Private.logKernelStatus(this), 
     this._statusChanged.emit(status), "dead" === status && this.dispose());
    }
    _sendPending() {
     for (;"connected" === this.connectionStatus && "_RESTARTING_" !== this._kernelSession && this._pendingMessages.length > 0; ) this._sendMessage(this._pendingMessages[0], !1), 
     this._pendingMessages.shift();
    }
    _clearKernelState() {
     this._kernelSession = "", this._pendingMessages = [], this._futures.forEach((future => {
      future.dispose();
     })), this._comms.forEach((comm => {
      comm.dispose();
     })), this._msgChain = Promise.resolve(), this._futures = new Map, this._comms = new Map, 
     this._displayIdToParentIds.clear(), this._msgIdToDisplayIds.clear();
    }
    _assertCurrentMessage(msg) {
     if (this._errorIfDisposed(), msg.header.session !== this._kernelSession) throw new Error(`Canceling handling of old message: ${msg.header.msg_type}`);
    }
    async _handleCommOpen(msg) {
     this._assertCurrentMessage(msg);
     const content = msg.content, comm = new comm_1.CommHandler(content.target_name, content.comm_id, this, (() => {
      this._unregisterComm(content.comm_id);
     }));
     this._comms.set(content.comm_id, comm);
     try {
      const target = await Private.loadObject(content.target_name, content.target_module, this._targetRegistry);
      await target(comm, msg);
     } catch (e) {
      throw comm.close(), console.error("Exception opening new comm"), e;
     }
    }
    async _handleCommClose(msg) {
     this._assertCurrentMessage(msg);
     const content = msg.content, comm = this._comms.get(content.comm_id);
     if (!comm) return void console.error("Comm not found for comm id " + content.comm_id);
     this._unregisterComm(comm.commId);
     const onClose = comm.onClose;
     onClose && await onClose(msg), comm.dispose();
    }
    async _handleCommMsg(msg) {
     this._assertCurrentMessage(msg);
     const content = msg.content, comm = this._comms.get(content.comm_id);
     if (!comm) return;
     const onMsg = comm.onMsg;
     onMsg && await onMsg(msg);
    }
    _unregisterComm(commId) {
     this._comms.delete(commId);
    }
    _updateConnectionStatus(connectionStatus) {
     if (this._connectionStatus !== connectionStatus) {
      if (this._connectionStatus = connectionStatus, "connecting" !== connectionStatus && (this._reconnectAttempt = 0, 
      clearTimeout(this._reconnectTimeout)), "dead" !== this.status) if ("connected" === connectionStatus) {
       let restarting = "_RESTARTING_" === this._kernelSession, p = this.requestKernelInfo(), sendPendingCalled = !1, sendPendingOnce = () => {
        sendPendingCalled || (sendPendingCalled = !0, restarting && "_RESTARTING_" === this._kernelSession && (this._kernelSession = ""), 
        clearTimeout(timeoutHandle), this._pendingMessages.length > 0 && this._sendPending());
       };
       p.then(sendPendingOnce);
       let timeoutHandle = setTimeout(sendPendingOnce, 3e3);
      } else this._updateStatus("unknown");
      this._connectionStatusChanged.emit(connectionStatus);
     }
    }
    async _handleMessage(msg) {
     var _a, _b;
     let handled = !1;
     if (msg.parent_header && "iopub" === msg.channel && (KernelMessage.isDisplayDataMsg(msg) || KernelMessage.isUpdateDisplayDataMsg(msg) || KernelMessage.isExecuteResultMsg(msg))) {
      const displayId = (null !== (_a = msg.content.transient) && void 0 !== _a ? _a : {}).display_id;
      displayId && (handled = await this._handleDisplayId(displayId, msg), this._assertCurrentMessage(msg));
     }
     if (!handled && msg.parent_header) {
      const parentHeader = msg.parent_header, future = null === (_b = this._futures) || void 0 === _b ? void 0 : _b.get(parentHeader.msg_id);
      if (future) await future.handleMsg(msg), this._assertCurrentMessage(msg); else {
       const owned = parentHeader.session === this.clientId;
       "iopub" !== msg.channel && owned && this._unhandledMessage.emit(msg);
      }
     }
     if ("iopub" === msg.channel) {
      switch (msg.header.msg_type) {
      case "status":
       {
        const executionState = msg.content.execution_state;
        "restarting" === executionState && Promise.resolve().then((async () => {
         this._updateStatus("autorestarting"), this._clearKernelState(), await this.reconnect();
        })), this._updateStatus(executionState);
        break;
       }

      case "comm_open":
       this.handleComms && await this._handleCommOpen(msg);
       break;

      case "comm_msg":
       this.handleComms && await this._handleCommMsg(msg);
       break;

      case "comm_close":
       this.handleComms && await this._handleCommClose(msg);
      }
      this.isDisposed || (this._assertCurrentMessage(msg), this._iopubMessage.emit(msg));
     }
    }
    _reconnect() {
     if (this._errorIfDisposed(), clearTimeout(this._reconnectTimeout), this._reconnectAttempt < this._reconnectLimit) {
      this._updateConnectionStatus("connecting");
      const timeout = Private.getRandomIntInclusive(0, 1e3 * (Math.pow(2, this._reconnectAttempt) - 1));
      console.warn(`Connection lost, reconnecting in ${Math.floor(timeout / 1e3)} seconds.`), 
      this._reconnectTimeout = setTimeout(this._createSocket, timeout), this._reconnectAttempt += 1;
     } else this._updateConnectionStatus("disconnected");
     this._clearSocket();
    }
    _errorIfDisposed() {
     if (this.isDisposed) throw new Error("Kernel connection is disposed");
    }
    get hasPendingInput() {
     return this._hasPendingInput;
    }
    set hasPendingInput(value) {
     this._hasPendingInput = value, this._pendingInput.emit(value);
    }
   }
   var Private;
   exports.KernelConnection = KernelConnection, function(Private) {
    Private.logKernelStatus = function(kernel) {
     switch (kernel.status) {
     case "idle":
     case "busy":
     case "unknown":
      return;

     default:
      console.debug(`Kernel: ${kernel.status} (${kernel.id})`);
     }
    }, Private.handleShellMessage = async function(kernel, msg) {
     return kernel.sendShellMessage(msg, !0).done;
    }, Private.loadObject = function(name, moduleName, registry) {
     return new Promise(((resolve, reject) => {
      if (moduleName) {
       if ("undefined" == typeof requirejs) throw new Error("requirejs not found");
       requirejs([ moduleName ], (mod => {
        if (void 0 === mod[name]) {
         reject(new Error(`Object '${name}' not found in module '${moduleName}'`));
        } else resolve(mod[name]);
       }), reject);
      } else (null == registry ? void 0 : registry[name]) ? resolve(registry[name]) : reject(new Error(`Object '${name}' not found in registry`));
     }));
    }, Private.getRandomIntInclusive = function(min, max) {
     return min = Math.ceil(min), max = Math.floor(max), Math.floor(Math.random() * (max - min + 1)) + min;
    };
   }(Private || (Private = {}));
  },
  38662: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.getKernelModel = exports.shutdownKernel = exports.interruptKernel = exports.restartKernel = exports.startNew = exports.listRunning = exports.KERNEL_SERVICE_URL = void 0;
   const serverconnection_1 = __webpack_require__(1089), coreutils_1 = __webpack_require__(16015), validate_1 = __webpack_require__(38872);
   exports.KERNEL_SERVICE_URL = "api/kernels", exports.listRunning = async function(settings = serverconnection_1.ServerConnection.makeSettings()) {
    const url = coreutils_1.URLExt.join(settings.baseUrl, exports.KERNEL_SERVICE_URL), response = await serverconnection_1.ServerConnection.makeRequest(url, {}, settings);
    if (200 !== response.status) {
     throw await serverconnection_1.ServerConnection.ResponseError.create(response);
    }
    const data = await response.json();
    return validate_1.validateModels(data), data;
   }, exports.startNew = async function(options = {}, settings = serverconnection_1.ServerConnection.makeSettings()) {
    const url = coreutils_1.URLExt.join(settings.baseUrl, exports.KERNEL_SERVICE_URL), init = {
     method: "POST",
     body: JSON.stringify(options)
    }, response = await serverconnection_1.ServerConnection.makeRequest(url, init, settings);
    if (201 !== response.status) {
     throw await serverconnection_1.ServerConnection.ResponseError.create(response);
    }
    const data = await response.json();
    return validate_1.validateModel(data), data;
   }, exports.restartKernel = async function(id, settings = serverconnection_1.ServerConnection.makeSettings()) {
    const url = coreutils_1.URLExt.join(settings.baseUrl, exports.KERNEL_SERVICE_URL, encodeURIComponent(id), "restart"), response = await serverconnection_1.ServerConnection.makeRequest(url, {
     method: "POST"
    }, settings);
    if (200 !== response.status) {
     throw await serverconnection_1.ServerConnection.ResponseError.create(response);
    }
    const data = await response.json();
    validate_1.validateModel(data);
   }, exports.interruptKernel = async function(id, settings = serverconnection_1.ServerConnection.makeSettings()) {
    const url = coreutils_1.URLExt.join(settings.baseUrl, exports.KERNEL_SERVICE_URL, encodeURIComponent(id), "interrupt"), response = await serverconnection_1.ServerConnection.makeRequest(url, {
     method: "POST"
    }, settings);
    if (204 !== response.status) {
     throw await serverconnection_1.ServerConnection.ResponseError.create(response);
    }
   }, exports.shutdownKernel = async function(id, settings = serverconnection_1.ServerConnection.makeSettings()) {
    const url = coreutils_1.URLExt.join(settings.baseUrl, exports.KERNEL_SERVICE_URL, encodeURIComponent(id)), response = await serverconnection_1.ServerConnection.makeRequest(url, {
     method: "DELETE"
    }, settings);
    if (404 === response.status) {
     const msg = `The kernel "${id}" does not exist on the server`;
     console.warn(msg);
    } else if (204 !== response.status) {
     throw await serverconnection_1.ServerConnection.ResponseError.create(response);
    }
   }, exports.getKernelModel = async function(id, settings = serverconnection_1.ServerConnection.makeSettings()) {
    const url = coreutils_1.URLExt.join(settings.baseUrl, exports.KERNEL_SERVICE_URL, encodeURIComponent(id)), response = await serverconnection_1.ServerConnection.makeRequest(url, {}, settings);
    if (404 === response.status) return;
    if (200 !== response.status) {
     throw await serverconnection_1.ServerConnection.ResponseError.create(response);
    }
    const data = await response.json();
    return validate_1.validateModel(data), data;
   };
  },
  93962: (__unused_webpack_module, exports) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.serialize = exports.deserialize = void 0, exports.deserialize = function(data) {
    let value;
    return value = "string" == typeof data ? JSON.parse(data) : function(buf) {
     const data = new DataView(buf), nbufs = data.getUint32(0), offsets = [];
     if (nbufs < 2) throw new Error("Invalid incoming Kernel Message");
     for (let i = 1; i <= nbufs; i++) offsets.push(data.getUint32(4 * i));
     const jsonBytes = new Uint8Array(buf.slice(offsets[0], offsets[1])), msg = JSON.parse(new TextDecoder("utf8").decode(jsonBytes));
     msg.buffers = [];
     for (let i = 1; i < nbufs; i++) {
      const start = offsets[i], stop = offsets[i + 1] || buf.byteLength;
      msg.buffers.push(new DataView(buf.slice(start, stop)));
     }
     return msg;
    }(data), value;
   }, exports.serialize = function(msg) {
    var _a;
    let value;
    return value = (null === (_a = msg.buffers) || void 0 === _a ? void 0 : _a.length) ? function(msg) {
     const offsets = [], buffers = [], encoder = new TextEncoder;
     let origBuffers = [];
     void 0 !== msg.buffers && (origBuffers = msg.buffers, delete msg.buffers);
     const jsonUtf8 = encoder.encode(JSON.stringify(msg));
     buffers.push(jsonUtf8.buffer);
     for (let i = 0; i < origBuffers.length; i++) {
      const b = origBuffers[i];
      buffers.push(ArrayBuffer.isView(b) ? b.buffer : b);
     }
     const nbufs = buffers.length;
     offsets.push(4 * (nbufs + 1));
     for (let i = 0; i + 1 < buffers.length; i++) offsets.push(offsets[offsets.length - 1] + buffers[i].byteLength);
     const msgBuf = new Uint8Array(offsets[offsets.length - 1] + buffers[buffers.length - 1].byteLength), view = new DataView(msgBuf.buffer);
     view.setUint32(0, nbufs);
     for (let i = 0; i < offsets.length; i++) view.setUint32(4 * (i + 1), offsets[i]);
     for (let i = 0; i < buffers.length; i++) msgBuf.set(new Uint8Array(buffers[i]), offsets[i]);
     return msgBuf.buffer;
    }(msg) : JSON.stringify(msg), value;
   };
  },
  38872: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.validateModels = exports.validateModel = exports.validateMessage = void 0;
   const validate_1 = __webpack_require__(1480), HEADER_FIELDS = [ "username", "version", "session", "msg_id", "msg_type" ], IOPUB_CONTENT_FIELDS = {
    stream: {
     name: "string",
     text: "string"
    },
    display_data: {
     data: "object",
     metadata: "object"
    },
    execute_input: {
     code: "string",
     execution_count: "number"
    },
    execute_result: {
     execution_count: "number",
     data: "object",
     metadata: "object"
    },
    error: {
     ename: "string",
     evalue: "string",
     traceback: "object"
    },
    status: {
     execution_state: [ "string", [ "starting", "idle", "busy", "restarting", "dead" ] ]
    },
    clear_output: {
     wait: "boolean"
    },
    comm_open: {
     comm_id: "string",
     target_name: "string",
     data: "object"
    },
    comm_msg: {
     comm_id: "string",
     data: "object"
    },
    comm_close: {
     comm_id: "string"
    },
    shutdown_reply: {
     restart: "boolean"
    }
   };
   function validateModel(model) {
    validate_1.validateProperty(model, "name", "string"), validate_1.validateProperty(model, "id", "string");
   }
   exports.validateMessage = function(msg) {
    validate_1.validateProperty(msg, "metadata", "object"), validate_1.validateProperty(msg, "content", "object"), 
    validate_1.validateProperty(msg, "channel", "string"), function(header) {
     for (let i = 0; i < HEADER_FIELDS.length; i++) validate_1.validateProperty(header, HEADER_FIELDS[i], "string");
    }(msg.header), "iopub" === msg.channel && function(msg) {
     if ("iopub" === msg.channel) {
      const fields = IOPUB_CONTENT_FIELDS[msg.header.msg_type];
      if (void 0 === fields) return;
      const names = Object.keys(fields), content = msg.content;
      for (let i = 0; i < names.length; i++) {
       let args = fields[names[i]];
       Array.isArray(args) || (args = [ args ]), validate_1.validateProperty(content, names[i], ...args);
      }
     }
    }(msg);
   }, exports.validateModel = validateModel, exports.validateModels = function(models) {
    if (!Array.isArray(models)) throw new Error("Invalid kernel list");
    models.forEach((d => validateModel(d)));
   };
  },
  76807: function(__unused_webpack_module, exports, __webpack_require__) {
   "use strict";
   var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    void 0 === k2 && (k2 = k), Object.defineProperty(o, k2, {
     enumerable: !0,
     get: function() {
      return m[k];
     }
    });
   } : function(o, m, k, k2) {
    void 0 === k2 && (k2 = k), o[k2] = m[k];
   }), __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
     enumerable: !0,
     value: v
    });
   } : function(o, v) {
    o.default = v;
   }), __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (null != mod) for (var k in mod) "default" !== k && Object.prototype.hasOwnProperty.call(mod, k) && __createBinding(result, mod, k);
    return __setModuleDefault(result, mod), result;
   }, __exportStar = this && this.__exportStar || function(m, exports) {
    for (var p in m) "default" === p || Object.prototype.hasOwnProperty.call(exports, p) || __createBinding(exports, m, p);
   };
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.KernelSpecAPI = exports.KernelSpec = void 0;
   const KernelSpec = __importStar(__webpack_require__(51229));
   exports.KernelSpec = KernelSpec;
   const KernelSpecAPI = __importStar(__webpack_require__(321));
   exports.KernelSpecAPI = KernelSpecAPI, __exportStar(__webpack_require__(26224), exports);
  },
  51229: (__unused_webpack_module, exports) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   });
  },
  26224: function(__unused_webpack_module, exports, __webpack_require__) {
   "use strict";
   var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    void 0 === k2 && (k2 = k), Object.defineProperty(o, k2, {
     enumerable: !0,
     get: function() {
      return m[k];
     }
    });
   } : function(o, m, k, k2) {
    void 0 === k2 && (k2 = k), o[k2] = m[k];
   }), __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
     enumerable: !0,
     value: v
    });
   } : function(o, v) {
    o.default = v;
   }), __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (null != mod) for (var k in mod) "default" !== k && Object.prototype.hasOwnProperty.call(mod, k) && __createBinding(result, mod, k);
    return __setModuleDefault(result, mod), result;
   };
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.KernelSpecManager = void 0;
   const coreutils_1 = __webpack_require__(64954), polling_1 = __webpack_require__(93498), signaling_1 = __webpack_require__(57082), restapi = __importStar(__webpack_require__(321)), basemanager_1 = __webpack_require__(5412);
   class KernelSpecManager extends basemanager_1.BaseManager {
    constructor(options = {}) {
     var _a;
     super(options), this._isReady = !1, this._connectionFailure = new signaling_1.Signal(this), 
     this._specs = null, this._specsChanged = new signaling_1.Signal(this), this._ready = Promise.all([ this.requestSpecs() ]).then((_ => {})).catch((_ => {})).then((() => {
      this.isDisposed || (this._isReady = !0);
     })), this._pollSpecs = new polling_1.Poll({
      auto: !1,
      factory: () => this.requestSpecs(),
      frequency: {
       interval: 61e3,
       backoff: !0,
       max: 3e5
      },
      name: "@jupyterlab/services:KernelSpecManager#specs",
      standby: null !== (_a = options.standby) && void 0 !== _a ? _a : "when-hidden"
     }), this.ready.then((() => {
      this._pollSpecs.start();
     }));
    }
    get isReady() {
     return this._isReady;
    }
    get ready() {
     return this._ready;
    }
    get specs() {
     return this._specs;
    }
    get specsChanged() {
     return this._specsChanged;
    }
    get connectionFailure() {
     return this._connectionFailure;
    }
    dispose() {
     this._pollSpecs.dispose(), super.dispose();
    }
    async refreshSpecs() {
     await this._pollSpecs.refresh(), await this._pollSpecs.tick;
    }
    async requestSpecs() {
     const specs = await restapi.getSpecs(this.serverSettings);
     this.isDisposed || coreutils_1.JSONExt.deepEqual(specs, this._specs) || (this._specs = specs, 
     this._specsChanged.emit(specs));
    }
   }
   exports.KernelSpecManager = KernelSpecManager;
  },
  321: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.getSpecs = void 0;
   const serverconnection_1 = __webpack_require__(1089), validate_1 = __webpack_require__(79237), coreutils_1 = __webpack_require__(16015);
   exports.getSpecs = async function(settings = serverconnection_1.ServerConnection.makeSettings()) {
    const url = coreutils_1.URLExt.join(settings.baseUrl, "api/kernelspecs"), response = await serverconnection_1.ServerConnection.makeRequest(url, {}, settings);
    if (200 !== response.status) {
     throw await serverconnection_1.ServerConnection.ResponseError.create(response);
    }
    const data = await response.json();
    return validate_1.validateSpecModels(data);
   };
  },
  79237: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.validateSpecModels = exports.validateSpecModel = void 0;
   const validate_1 = __webpack_require__(1480);
   function validateSpecModel(data) {
    const spec = data.spec;
    if (!spec) throw new Error("Invalid kernel spec");
    validate_1.validateProperty(data, "name", "string"), validate_1.validateProperty(data, "resources", "object"), 
    validate_1.validateProperty(spec, "language", "string"), validate_1.validateProperty(spec, "display_name", "string"), 
    validate_1.validateProperty(spec, "argv", "array");
    let metadata = null;
    spec.hasOwnProperty("metadata") && (validate_1.validateProperty(spec, "metadata", "object"), 
    metadata = spec.metadata);
    let env = null;
    return spec.hasOwnProperty("env") && (validate_1.validateProperty(spec, "env", "object"), 
    env = spec.env), {
     name: data.name,
     resources: data.resources,
     language: spec.language,
     display_name: spec.display_name,
     argv: spec.argv,
     metadata,
     env
    };
   }
   exports.validateSpecModel = validateSpecModel, exports.validateSpecModels = function(data) {
    if (!data.hasOwnProperty("kernelspecs")) throw new Error("No kernelspecs found");
    let keys = Object.keys(data.kernelspecs);
    const kernelspecs = Object.create(null);
    let defaultSpec = data.default;
    for (let i = 0; i < keys.length; i++) {
     const ks = data.kernelspecs[keys[i]];
     try {
      kernelspecs[keys[i]] = validateSpecModel(ks);
     } catch (err) {
      console.warn(`Removing errant kernel spec: ${keys[i]}`);
     }
    }
    if (keys = Object.keys(kernelspecs), !keys.length) throw new Error("No valid kernelspecs found");
    return defaultSpec && "string" == typeof defaultSpec && defaultSpec in kernelspecs || (defaultSpec = keys[0], 
    console.warn(`Default kernel not found, using '${keys[0]}'`)), {
     default: defaultSpec,
     kernelspecs
    };
   };
  },
  90139: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.ServiceManager = void 0;
   const signaling_1 = __webpack_require__(57082), builder_1 = __webpack_require__(44816), nbconvert_1 = __webpack_require__(93892), contents_1 = __webpack_require__(97375), event_1 = __webpack_require__(1091), kernel_1 = __webpack_require__(14272), kernelspec_1 = __webpack_require__(76807), session_1 = __webpack_require__(86923), setting_1 = __webpack_require__(95399), terminal_1 = __webpack_require__(67569), serverconnection_1 = __webpack_require__(1089), user_1 = __webpack_require__(18430), workspace_1 = __webpack_require__(90362);
   exports.ServiceManager = class {
    constructor(options = {}) {
     var _a, _b;
     this._isDisposed = !1, this._connectionFailure = new signaling_1.Signal(this), this._isReady = !1;
     const defaultDrive = options.defaultDrive, serverSettings = null !== (_a = options.serverSettings) && void 0 !== _a ? _a : serverconnection_1.ServerConnection.makeSettings(), normalized = {
      defaultDrive,
      serverSettings,
      standby: null !== (_b = options.standby) && void 0 !== _b ? _b : "when-hidden"
     }, kernelManager = new kernel_1.KernelManager(normalized);
     this.serverSettings = serverSettings, this.contents = new contents_1.ContentsManager(normalized), 
     this.events = new event_1.EventManager(normalized), this.sessions = new session_1.SessionManager(Object.assign(Object.assign({}, normalized), {
      kernelManager
     })), this.settings = new setting_1.SettingManager(normalized), this.terminals = new terminal_1.TerminalManager(normalized), 
     this.builder = new builder_1.BuildManager(normalized), this.workspaces = new workspace_1.WorkspaceManager(normalized), 
     this.nbconvert = new nbconvert_1.NbConvertManager(normalized), this.kernelspecs = new kernelspec_1.KernelSpecManager(normalized), 
     this.user = new user_1.UserManager(normalized), this.kernelspecs.connectionFailure.connect(this._onConnectionFailure, this), 
     this.sessions.connectionFailure.connect(this._onConnectionFailure, this), this.terminals.connectionFailure.connect(this._onConnectionFailure, this);
     const readyList = [ this.sessions.ready, this.kernelspecs.ready ];
     this.terminals.isAvailable() && readyList.push(this.terminals.ready), this._readyPromise = Promise.all(readyList).then((() => {
      this._isReady = !0;
     }));
    }
    get connectionFailure() {
     return this._connectionFailure;
    }
    get isDisposed() {
     return this._isDisposed;
    }
    dispose() {
     this.isDisposed || (this._isDisposed = !0, signaling_1.Signal.clearData(this), this.contents.dispose(), 
     this.events.dispose(), this.sessions.dispose(), this.terminals.dispose());
    }
    get isReady() {
     return this._isReady;
    }
    get ready() {
     return this._readyPromise;
    }
    _onConnectionFailure(sender, err) {
     this._connectionFailure.emit(err);
    }
   };
  },
  93892: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.NbConvertManager = void 0;
   const coreutils_1 = __webpack_require__(16015), serverconnection_1 = __webpack_require__(1089);
   exports.NbConvertManager = class {
    constructor(options = {}) {
     var _a;
     this.serverSettings = null !== (_a = options.serverSettings) && void 0 !== _a ? _a : serverconnection_1.ServerConnection.makeSettings();
    }
    async getExportFormats() {
     const base = this.serverSettings.baseUrl, url = coreutils_1.URLExt.join(base, "api/nbconvert"), {serverSettings} = this, response = await serverconnection_1.ServerConnection.makeRequest(url, {}, serverSettings);
     if (200 !== response.status) {
      throw await serverconnection_1.ServerConnection.ResponseError.create(response);
     }
     const data = await response.json(), exportList = {};
     return Object.keys(data).forEach((function(key) {
      const mimeType = data[key].output_mimetype;
      exportList[key] = {
       output_mimetype: mimeType
      };
     })), exportList;
    }
   };
  },
  1089: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var _a, _b, _c;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.ServerConnection = void 0;
   const coreutils_1 = __webpack_require__(16015);
   let FETCH, HEADERS, REQUEST, WEBSOCKET;
   if ("undefined" == typeof window) {
    const fetchMod = __webpack_require__(37615);
    FETCH = null !== (_a = global.fetch) && void 0 !== _a ? _a : fetchMod, REQUEST = null !== (_b = global.Request) && void 0 !== _b ? _b : fetchMod.Request, 
    HEADERS = null !== (_c = global.Headers) && void 0 !== _c ? _c : fetchMod.Headers, 
    WEBSOCKET = __webpack_require__(15734);
   } else FETCH = fetch, REQUEST = Request, HEADERS = Headers, WEBSOCKET = WebSocket;
   var ServerConnection, Private;
   !function(ServerConnection) {
    ServerConnection.makeSettings = function(options) {
     return Private.makeSettings(options);
    }, ServerConnection.makeRequest = function(url, init, settings) {
     return Private.handleRequest(url, init, settings);
    };
    class ResponseError extends Error {
     constructor(response, message = ResponseError._defaultMessage(response), traceback = "") {
      super(message), this.response = response, this.traceback = traceback;
     }
     static async create(response) {
      try {
       const data = await response.json(), {message, traceback} = data;
       return traceback && console.error(traceback), new ResponseError(response, null != message ? message : ResponseError._defaultMessage(response), null != traceback ? traceback : "");
      } catch (e) {
       return console.debug(e), new ResponseError(response);
      }
     }
     static _defaultMessage(response) {
      return `Invalid response: ${response.status} ${response.statusText}`;
     }
    }
    ServerConnection.ResponseError = ResponseError;
    class NetworkError extends TypeError {
     constructor(original) {
      super(original.message), this.stack = original.stack;
     }
    }
    ServerConnection.NetworkError = NetworkError;
   }(ServerConnection = exports.ServerConnection || (exports.ServerConnection = {})), 
   function(Private) {
    Private.makeSettings = function(options = {}) {
     var _a;
     const pageBaseUrl = coreutils_1.PageConfig.getBaseUrl(), pageWsUrl = coreutils_1.PageConfig.getWsUrl(), baseUrl = coreutils_1.URLExt.normalize(options.baseUrl) || pageBaseUrl;
     let wsUrl = options.wsUrl;
     return wsUrl || baseUrl !== pageBaseUrl || (wsUrl = pageWsUrl), wsUrl || 0 !== baseUrl.indexOf("http") || (wsUrl = "ws" + baseUrl.slice(4)), 
     wsUrl = null != wsUrl ? wsUrl : pageWsUrl, Object.assign(Object.assign({
      init: {
       cache: "no-store",
       credentials: "same-origin"
      },
      fetch: FETCH,
      Headers: HEADERS,
      Request: REQUEST,
      WebSocket: WEBSOCKET,
      token: coreutils_1.PageConfig.getToken(),
      appUrl: coreutils_1.PageConfig.getOption("appUrl"),
      appendToken: "undefined" == typeof window || "undefined" != typeof process && void 0 !== (null === (_a = null === process || void 0 === process ? void 0 : process.env) || void 0 === _a ? void 0 : _a.JEST_WORKER_ID) || coreutils_1.URLExt.getHostName(pageBaseUrl) !== coreutils_1.URLExt.getHostName(wsUrl)
     }, options), {
      baseUrl,
      wsUrl
     });
    }, Private.handleRequest = function(url, init, settings) {
     var _a;
     if (0 !== url.indexOf(settings.baseUrl)) throw new Error("Can only be used for notebook server requests");
     "no-store" === (null !== (_a = init.cache) && void 0 !== _a ? _a : settings.init.cache) && (url += (/\?/.test(url) ? "&" : "?") + (new Date).getTime());
     const request = new settings.Request(url, Object.assign(Object.assign({}, settings.init), init));
     let authenticated = !1;
     if (settings.token && (authenticated = !0, request.headers.append("Authorization", `token ${settings.token}`)), 
     "undefined" != typeof document && (null === document || void 0 === document ? void 0 : document.cookie)) {
      const xsrfToken = function(name) {
       const matches = document.cookie.match("\\b" + name + "=([^;]*)\\b");
       return null == matches ? void 0 : matches[1];
      }("_xsrf");
      void 0 !== xsrfToken && (authenticated = !0, request.headers.append("X-XSRFToken", xsrfToken));
     }
     return !request.headers.has("Content-Type") && authenticated && request.headers.set("Content-Type", "application/json"), 
     settings.fetch.call(null, request).catch((e => {
      throw new ServerConnection.NetworkError(e);
     }));
    };
   }(Private || (Private = {}));
  },
  26830: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.SessionConnection = void 0;
   const signaling_1 = __webpack_require__(57082), __1 = __webpack_require__(50608), restapi_1 = __webpack_require__(70637), coreutils_1 = __webpack_require__(64954);
   exports.SessionConnection = class {
    constructor(options) {
     var _a, _b, _c, _d;
     this._id = "", this._path = "", this._name = "", this._type = "", this._kernel = null, 
     this._isDisposed = !1, this._disposed = new signaling_1.Signal(this), this._kernelChanged = new signaling_1.Signal(this), 
     this._statusChanged = new signaling_1.Signal(this), this._connectionStatusChanged = new signaling_1.Signal(this), 
     this._pendingInput = new signaling_1.Signal(this), this._iopubMessage = new signaling_1.Signal(this), 
     this._unhandledMessage = new signaling_1.Signal(this), this._anyMessage = new signaling_1.Signal(this), 
     this._propertyChanged = new signaling_1.Signal(this), this._id = options.model.id, 
     this._name = options.model.name, this._path = options.model.path, this._type = options.model.type, 
     this._username = null !== (_a = options.username) && void 0 !== _a ? _a : "", this._clientId = null !== (_b = options.clientId) && void 0 !== _b ? _b : coreutils_1.UUID.uuid4(), 
     this._connectToKernel = options.connectToKernel, this._kernelConnectionOptions = null !== (_c = options.kernelConnectionOptions) && void 0 !== _c ? _c : {}, 
     this.serverSettings = null !== (_d = options.serverSettings) && void 0 !== _d ? _d : __1.ServerConnection.makeSettings(), 
     this.setupKernel(options.model.kernel);
    }
    get disposed() {
     return this._disposed;
    }
    get kernelChanged() {
     return this._kernelChanged;
    }
    get statusChanged() {
     return this._statusChanged;
    }
    get connectionStatusChanged() {
     return this._connectionStatusChanged;
    }
    get pendingInput() {
     return this._pendingInput;
    }
    get iopubMessage() {
     return this._iopubMessage;
    }
    get unhandledMessage() {
     return this._unhandledMessage;
    }
    get anyMessage() {
     return this._anyMessage;
    }
    get propertyChanged() {
     return this._propertyChanged;
    }
    get id() {
     return this._id;
    }
    get kernel() {
     return this._kernel;
    }
    get path() {
     return this._path;
    }
    get type() {
     return this._type;
    }
    get name() {
     return this._name;
    }
    get model() {
     return {
      id: this.id,
      kernel: this.kernel && {
       id: this.kernel.id,
       name: this.kernel.name
      },
      path: this._path,
      type: this._type,
      name: this._name
     };
    }
    get isDisposed() {
     return this._isDisposed;
    }
    update(model) {
     const oldModel = this.model;
     if (this._path = model.path, this._name = model.name, this._type = model.type, null === this._kernel && null !== model.kernel || null !== this._kernel && null === model.kernel || null !== this._kernel && null !== model.kernel && this._kernel.id !== model.kernel.id) {
      null !== this._kernel && this._kernel.dispose();
      const oldValue = this._kernel || null;
      this.setupKernel(model.kernel);
      const newValue = this._kernel || null;
      this._kernelChanged.emit({
       name: "kernel",
       oldValue,
       newValue
      });
     }
     this._handleModelChange(oldModel);
    }
    dispose() {
     if (!this.isDisposed) {
      if (this._isDisposed = !0, this._disposed.emit(), this._kernel) {
       this._kernel.dispose();
       const oldValue = this._kernel;
       this._kernel = null;
       const newValue = this._kernel;
       this._kernelChanged.emit({
        name: "kernel",
        oldValue,
        newValue
       });
      }
      signaling_1.Signal.clearData(this);
     }
    }
    async setPath(path) {
     if (this.isDisposed) throw new Error("Session is disposed");
     await this._patch({
      path
     });
    }
    async setName(name) {
     if (this.isDisposed) throw new Error("Session is disposed");
     await this._patch({
      name
     });
    }
    async setType(type) {
     if (this.isDisposed) throw new Error("Session is disposed");
     await this._patch({
      type
     });
    }
    async changeKernel(options) {
     if (this.isDisposed) throw new Error("Session is disposed");
     return await this._patch({
      kernel: options
     }), this.kernel;
    }
    async shutdown() {
     if (this.isDisposed) throw new Error("Session is disposed");
     await restapi_1.shutdownSession(this.id, this.serverSettings), this.dispose();
    }
    setupKernel(model) {
     if (null === model) return void (this._kernel = null);
     const kc = this._connectToKernel(Object.assign(Object.assign({}, this._kernelConnectionOptions), {
      model,
      username: this._username,
      clientId: this._clientId,
      serverSettings: this.serverSettings
     }));
     this._kernel = kc, kc.statusChanged.connect(this.onKernelStatus, this), kc.connectionStatusChanged.connect(this.onKernelConnectionStatus, this), 
     kc.pendingInput.connect(this.onPendingInput, this), kc.unhandledMessage.connect(this.onUnhandledMessage, this), 
     kc.iopubMessage.connect(this.onIOPubMessage, this), kc.anyMessage.connect(this.onAnyMessage, this);
    }
    onKernelStatus(sender, state) {
     this._statusChanged.emit(state);
    }
    onKernelConnectionStatus(sender, state) {
     this._connectionStatusChanged.emit(state);
    }
    onPendingInput(sender, state) {
     this._pendingInput.emit(state);
    }
    onIOPubMessage(sender, msg) {
     this._iopubMessage.emit(msg);
    }
    onUnhandledMessage(sender, msg) {
     this._unhandledMessage.emit(msg);
    }
    onAnyMessage(sender, args) {
     this._anyMessage.emit(args);
    }
    async _patch(body) {
     const model = await restapi_1.updateSession(Object.assign(Object.assign({}, body), {
      id: this._id
     }), this.serverSettings);
     return this.update(model), model;
    }
    _handleModelChange(oldModel) {
     oldModel.name !== this._name && this._propertyChanged.emit("name"), oldModel.type !== this._type && this._propertyChanged.emit("type"), 
     oldModel.path !== this._path && this._propertyChanged.emit("path");
    }
   };
  },
  86923: function(__unused_webpack_module, exports, __webpack_require__) {
   "use strict";
   var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    void 0 === k2 && (k2 = k), Object.defineProperty(o, k2, {
     enumerable: !0,
     get: function() {
      return m[k];
     }
    });
   } : function(o, m, k, k2) {
    void 0 === k2 && (k2 = k), o[k2] = m[k];
   }), __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
     enumerable: !0,
     value: v
    });
   } : function(o, v) {
    o.default = v;
   }), __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (null != mod) for (var k in mod) "default" !== k && Object.prototype.hasOwnProperty.call(mod, k) && __createBinding(result, mod, k);
    return __setModuleDefault(result, mod), result;
   }, __exportStar = this && this.__exportStar || function(m, exports) {
    for (var p in m) "default" === p || Object.prototype.hasOwnProperty.call(exports, p) || __createBinding(exports, m, p);
   };
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.SessionAPI = exports.Session = void 0;
   const Session = __importStar(__webpack_require__(82827));
   exports.Session = Session;
   const SessionAPI = __importStar(__webpack_require__(70637));
   exports.SessionAPI = SessionAPI, __exportStar(__webpack_require__(57740), exports);
  },
  57740: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.SessionManager = void 0;
   const algorithm_1 = __webpack_require__(56588), polling_1 = __webpack_require__(93498), signaling_1 = __webpack_require__(57082), serverconnection_1 = __webpack_require__(1089), basemanager_1 = __webpack_require__(5412), default_1 = __webpack_require__(26830), restapi_1 = __webpack_require__(70637);
   class SessionManager extends basemanager_1.BaseManager {
    constructor(options) {
     var _a;
     super(options), this._isReady = !1, this._sessionConnections = new Set, this._models = new Map, 
     this._runningChanged = new signaling_1.Signal(this), this._connectionFailure = new signaling_1.Signal(this), 
     this._connectToKernel = options => this._kernelManager.connectTo(options), this._kernelManager = options.kernelManager, 
     this._pollModels = new polling_1.Poll({
      auto: !1,
      factory: () => this.requestRunning(),
      frequency: {
       interval: 1e4,
       backoff: !0,
       max: 3e5
      },
      name: "@jupyterlab/services:SessionManager#models",
      standby: null !== (_a = options.standby) && void 0 !== _a ? _a : "when-hidden"
     }), this._ready = (async () => {
      await this._pollModels.start(), await this._pollModels.tick, await this._kernelManager.ready, 
      this._isReady = !0;
     })();
    }
    get isReady() {
     return this._isReady;
    }
    get ready() {
     return this._ready;
    }
    get runningChanged() {
     return this._runningChanged;
    }
    get connectionFailure() {
     return this._connectionFailure;
    }
    dispose() {
     this.isDisposed || (this._models.clear(), this._sessionConnections.forEach((x => x.dispose())), 
     this._pollModels.dispose(), super.dispose());
    }
    connectTo(options) {
     const sessionConnection = new default_1.SessionConnection(Object.assign(Object.assign({}, options), {
      connectToKernel: this._connectToKernel,
      serverSettings: this.serverSettings
     }));
     return this._onStarted(sessionConnection), this._models.has(options.model.id) || this.refreshRunning().catch((() => {})), 
     sessionConnection;
    }
    running() {
     return algorithm_1.iter([ ...this._models.values() ]);
    }
    async refreshRunning() {
     await this._pollModels.refresh(), await this._pollModels.tick;
    }
    async startNew(createOptions, connectOptions = {}) {
     const model = await restapi_1.startSession(createOptions, this.serverSettings);
     return await this.refreshRunning(), this.connectTo(Object.assign(Object.assign({}, connectOptions), {
      model
     }));
    }
    async shutdown(id) {
     await restapi_1.shutdownSession(id, this.serverSettings), await this.refreshRunning();
    }
    async shutdownAll() {
     await this.refreshRunning(), await Promise.all([ ...this._models.keys() ].map((id => restapi_1.shutdownSession(id, this.serverSettings)))), 
     await this.refreshRunning();
    }
    async stopIfNeeded(path) {
     try {
      const matches = (await restapi_1.listRunning(this.serverSettings)).filter((value => value.path === path));
      if (1 === matches.length) {
       const id = matches[0].id;
       await this.shutdown(id);
      }
     } catch (error) {}
    }
    async findById(id) {
     return this._models.has(id) || await this.refreshRunning(), this._models.get(id);
    }
    async findByPath(path) {
     for (const m of this._models.values()) if (m.path === path) return m;
     await this.refreshRunning();
     for (const m of this._models.values()) if (m.path === path) return m;
    }
    async requestRunning() {
     var _a, _b;
     let models;
     try {
      models = await restapi_1.listRunning(this.serverSettings);
     } catch (err) {
      throw (err instanceof serverconnection_1.ServerConnection.NetworkError || 503 === (null === (_a = err.response) || void 0 === _a ? void 0 : _a.status) || 424 === (null === (_b = err.response) || void 0 === _b ? void 0 : _b.status)) && this._connectionFailure.emit(err), 
      err;
     }
     this.isDisposed || this._models.size === models.length && algorithm_1.every(models, (x => {
      var _a, _b, _c, _d;
      const existing = this._models.get(x.id);
      return !!existing && ((null === (_a = existing.kernel) || void 0 === _a ? void 0 : _a.id) === (null === (_b = x.kernel) || void 0 === _b ? void 0 : _b.id) && (null === (_c = existing.kernel) || void 0 === _c ? void 0 : _c.name) === (null === (_d = x.kernel) || void 0 === _d ? void 0 : _d.name) && existing.name === x.name && existing.path === x.path && existing.type === x.type);
     })) || (this._models = new Map(models.map((x => [ x.id, x ]))), this._sessionConnections.forEach((sc => {
      this._models.has(sc.id) ? sc.update(this._models.get(sc.id)) : sc.dispose();
     })), this._runningChanged.emit(models));
    }
    _onStarted(sessionConnection) {
     this._sessionConnections.add(sessionConnection), sessionConnection.disposed.connect(this._onDisposed, this), 
     sessionConnection.propertyChanged.connect(this._onChanged, this), sessionConnection.kernelChanged.connect(this._onChanged, this);
    }
    _onDisposed(sessionConnection) {
     this._sessionConnections.delete(sessionConnection), this.refreshRunning().catch((() => {}));
    }
    _onChanged() {
     this.refreshRunning().catch((() => {}));
    }
   }
   exports.SessionManager = SessionManager;
  },
  70637: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.updateSession = exports.startSession = exports.getSessionModel = exports.shutdownSession = exports.getSessionUrl = exports.listRunning = exports.SESSION_SERVICE_URL = void 0;
   const serverconnection_1 = __webpack_require__(1089), coreutils_1 = __webpack_require__(16015), validate_1 = __webpack_require__(11521);
   function getSessionUrl(baseUrl, id) {
    const servicesBase = coreutils_1.URLExt.join(baseUrl, exports.SESSION_SERVICE_URL), result = coreutils_1.URLExt.join(servicesBase, id);
    if (!result.startsWith(servicesBase)) throw new Error("Can only be used for services requests");
    return result;
   }
   exports.SESSION_SERVICE_URL = "api/sessions", exports.listRunning = async function(settings = serverconnection_1.ServerConnection.makeSettings()) {
    const url = coreutils_1.URLExt.join(settings.baseUrl, exports.SESSION_SERVICE_URL), response = await serverconnection_1.ServerConnection.makeRequest(url, {}, settings);
    if (200 !== response.status) {
     throw await serverconnection_1.ServerConnection.ResponseError.create(response);
    }
    const data = await response.json();
    if (!Array.isArray(data)) throw new Error("Invalid Session list");
    return data.forEach((m => {
     validate_1.updateLegacySessionModel(m), validate_1.validateModel(m);
    })), data;
   }, exports.getSessionUrl = getSessionUrl, exports.shutdownSession = async function(id, settings = serverconnection_1.ServerConnection.makeSettings()) {
    var _a;
    const url = getSessionUrl(settings.baseUrl, id), response = await serverconnection_1.ServerConnection.makeRequest(url, {
     method: "DELETE"
    }, settings);
    if (404 === response.status) {
     const msg = null !== (_a = (await response.json()).message) && void 0 !== _a ? _a : `The session "${id}"" does not exist on the server`;
     console.warn(msg);
    } else {
     if (410 === response.status) throw new serverconnection_1.ServerConnection.ResponseError(response, "The kernel was deleted but the session was not");
     if (204 !== response.status) {
      throw await serverconnection_1.ServerConnection.ResponseError.create(response);
     }
    }
   }, exports.getSessionModel = async function(id, settings = serverconnection_1.ServerConnection.makeSettings()) {
    const url = getSessionUrl(settings.baseUrl, id), response = await serverconnection_1.ServerConnection.makeRequest(url, {}, settings);
    if (200 !== response.status) {
     throw await serverconnection_1.ServerConnection.ResponseError.create(response);
    }
    const data = await response.json();
    return validate_1.updateLegacySessionModel(data), validate_1.validateModel(data), 
    data;
   }, exports.startSession = async function(options, settings = serverconnection_1.ServerConnection.makeSettings()) {
    const url = coreutils_1.URLExt.join(settings.baseUrl, exports.SESSION_SERVICE_URL), init = {
     method: "POST",
     body: JSON.stringify(options)
    }, response = await serverconnection_1.ServerConnection.makeRequest(url, init, settings);
    if (201 !== response.status) {
     throw await serverconnection_1.ServerConnection.ResponseError.create(response);
    }
    const data = await response.json();
    return validate_1.updateLegacySessionModel(data), validate_1.validateModel(data), 
    data;
   }, exports.updateSession = async function(model, settings = serverconnection_1.ServerConnection.makeSettings()) {
    const url = getSessionUrl(settings.baseUrl, model.id), init = {
     method: "PATCH",
     body: JSON.stringify(model)
    }, response = await serverconnection_1.ServerConnection.makeRequest(url, init, settings);
    if (200 !== response.status) {
     throw await serverconnection_1.ServerConnection.ResponseError.create(response);
    }
    const data = await response.json();
    return validate_1.updateLegacySessionModel(data), validate_1.validateModel(data), 
    data;
   };
  },
  82827: (__unused_webpack_module, exports) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   });
  },
  11521: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.validateModels = exports.updateLegacySessionModel = exports.validateModel = void 0;
   const validate_1 = __webpack_require__(38872), validate_2 = __webpack_require__(1480);
   function validateModel(data) {
    validate_2.validateProperty(data, "id", "string"), validate_2.validateProperty(data, "type", "string"), 
    validate_2.validateProperty(data, "name", "string"), validate_2.validateProperty(data, "path", "string"), 
    validate_2.validateProperty(data, "kernel", "object"), validate_1.validateModel(data.kernel);
   }
   exports.validateModel = validateModel, exports.updateLegacySessionModel = function(data) {
    void 0 === data.path && void 0 !== data.notebook && (data.path = data.notebook.path, 
    data.type = "notebook", data.name = "");
   }, exports.validateModels = function(models) {
    if (!Array.isArray(models)) throw new Error("Invalid session list");
    models.forEach((d => validateModel(d)));
   };
  },
  95399: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.SettingManager = void 0;
   const coreutils_1 = __webpack_require__(16015), statedb_1 = __webpack_require__(19531), serverconnection_1 = __webpack_require__(1089);
   class SettingManager extends statedb_1.DataConnector {
    constructor(options = {}) {
     var _a;
     super(), this.serverSettings = null !== (_a = options.serverSettings) && void 0 !== _a ? _a : serverconnection_1.ServerConnection.makeSettings();
    }
    async fetch(id) {
     if (!id) throw new Error("Plugin `id` parameter is required for settings fetch.");
     const {serverSettings} = this, {baseUrl, appUrl} = serverSettings, {makeRequest, ResponseError} = serverconnection_1.ServerConnection, base = baseUrl + appUrl, url = Private.url(base, id), response = await makeRequest(url, {}, serverSettings);
     if (200 !== response.status) {
      throw await ResponseError.create(response);
     }
     return response.json();
    }
    async list() {
     var _a, _b;
     const {serverSettings} = this, {baseUrl, appUrl} = serverSettings, {makeRequest, ResponseError} = serverconnection_1.ServerConnection, base = baseUrl + appUrl, url = Private.url(base, ""), response = await makeRequest(url, {}, serverSettings);
     if (200 !== response.status) throw new ResponseError(response);
     const json = await response.json(), values = null !== (_b = null === (_a = null == json ? void 0 : json.settings) || void 0 === _a ? void 0 : _a.map((plugin => (plugin.data = {
      composite: {},
      user: {}
     }, plugin)))) && void 0 !== _b ? _b : [];
     return {
      ids: values.map((plugin => plugin.id)),
      values
     };
    }
    async save(id, raw) {
     const {serverSettings} = this, {baseUrl, appUrl} = serverSettings, {makeRequest, ResponseError} = serverconnection_1.ServerConnection, base = baseUrl + appUrl, url = Private.url(base, id), init = {
      body: JSON.stringify({
       raw
      }),
      method: "PUT"
     }, response = await makeRequest(url, init, serverSettings);
     if (204 !== response.status) throw new ResponseError(response);
    }
   }
   var Private;
   exports.SettingManager = SettingManager, function(Private) {
    Private.url = function(base, id) {
     const settingsBase = coreutils_1.URLExt.join(base, "api/settings"), result = coreutils_1.URLExt.join(settingsBase, id);
     if (!result.startsWith(settingsBase)) throw new Error("Can only be used for workspaces requests");
     return result;
    };
   }(Private || (Private = {}));
  },
  12100: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.TerminalConnection = void 0;
   const coreutils_1 = __webpack_require__(16015), coreutils_2 = __webpack_require__(64954), signaling_1 = __webpack_require__(57082), __1 = __webpack_require__(50608), restapi_1 = __webpack_require__(84903);
   class TerminalConnection {
    constructor(options) {
     var _a;
     this._createSocket = () => {
      this._errorIfDisposed(), this._clearSocket(), this._updateConnectionStatus("connecting");
      const name = this._name, settings = this.serverSettings;
      let url = coreutils_1.URLExt.join(settings.wsUrl, "terminals", "websocket", encodeURIComponent(name));
      const token = settings.token;
      settings.appendToken && "" !== token && (url += `?token=${encodeURIComponent(token)}`), 
      this._ws = new settings.WebSocket(url), this._ws.onmessage = this._onWSMessage, 
      this._ws.onclose = this._onWSClose, this._ws.onerror = this._onWSClose;
     }, this._onWSMessage = event => {
      if (this._isDisposed) return;
      const data = JSON.parse(event.data);
      "disconnect" === data[0] && this.dispose(), "connecting" !== this._connectionStatus ? this._messageReceived.emit({
       type: data[0],
       content: data.slice(1)
      }) : "setup" === data[0] && this._updateConnectionStatus("connected");
     }, this._onWSClose = event => {
      console.warn(`Terminal websocket closed: ${event.code}`), this.isDisposed || this._reconnect();
     }, this._connectionStatus = "connecting", this._connectionStatusChanged = new signaling_1.Signal(this), 
     this._isDisposed = !1, this._disposed = new signaling_1.Signal(this), this._messageReceived = new signaling_1.Signal(this), 
     this._reconnectTimeout = null, this._ws = null, this._noOp = () => {}, this._reconnectLimit = 7, 
     this._reconnectAttempt = 0, this._pendingMessages = [], this._name = options.model.name, 
     this.serverSettings = null !== (_a = options.serverSettings) && void 0 !== _a ? _a : __1.ServerConnection.makeSettings(), 
     this._createSocket();
    }
    get disposed() {
     return this._disposed;
    }
    get messageReceived() {
     return this._messageReceived;
    }
    get name() {
     return this._name;
    }
    get model() {
     return {
      name: this._name
     };
    }
    get isDisposed() {
     return this._isDisposed;
    }
    dispose() {
     this._isDisposed || (this._isDisposed = !0, this._disposed.emit(), this._updateConnectionStatus("disconnected"), 
     this._clearSocket(), signaling_1.Signal.clearData(this));
    }
    send(message) {
     this._sendMessage(message);
    }
    _sendMessage(message, queue = !0) {
     if (!this._isDisposed && message.content) if ("connected" === this.connectionStatus && this._ws) {
      const msg = [ message.type, ...message.content ];
      this._ws.send(JSON.stringify(msg));
     } else {
      if (!queue) throw new Error(`Could not send message: ${JSON.stringify(message)}`);
      this._pendingMessages.push(message);
     }
    }
    _sendPending() {
     for (;"connected" === this.connectionStatus && this._pendingMessages.length > 0; ) this._sendMessage(this._pendingMessages[0], !1), 
     this._pendingMessages.shift();
    }
    reconnect() {
     this._errorIfDisposed();
     const result = new coreutils_2.PromiseDelegate, fulfill = (sender, status) => {
      "connected" === status ? (result.resolve(), this.connectionStatusChanged.disconnect(fulfill, this)) : "disconnected" === status && (result.reject(new Error("Terminal connection disconnected")), 
      this.connectionStatusChanged.disconnect(fulfill, this));
     };
     return this.connectionStatusChanged.connect(fulfill, this), this._reconnectAttempt = 0, 
     this._reconnect(), result.promise;
    }
    _reconnect() {
     if (this._errorIfDisposed(), clearTimeout(this._reconnectTimeout), this._reconnectAttempt < this._reconnectLimit) {
      this._updateConnectionStatus("connecting");
      const timeout = Private.getRandomIntInclusive(0, 1e3 * (Math.pow(2, this._reconnectAttempt) - 1));
      console.error(`Connection lost, reconnecting in ${Math.floor(timeout / 1e3)} seconds.`), 
      this._reconnectTimeout = setTimeout(this._createSocket, timeout), this._reconnectAttempt += 1;
     } else this._updateConnectionStatus("disconnected");
     this._clearSocket();
    }
    _clearSocket() {
     null !== this._ws && (this._ws.onopen = this._noOp, this._ws.onclose = this._noOp, 
     this._ws.onerror = this._noOp, this._ws.onmessage = this._noOp, this._ws.close(), 
     this._ws = null);
    }
    async shutdown() {
     await restapi_1.shutdownTerminal(this.name, this.serverSettings), this.dispose();
    }
    clone() {
     return new TerminalConnection(this);
    }
    _updateConnectionStatus(connectionStatus) {
     this._connectionStatus !== connectionStatus && (this._connectionStatus = connectionStatus, 
     "connecting" !== connectionStatus && (this._reconnectAttempt = 0, clearTimeout(this._reconnectTimeout)), 
     "connected" === connectionStatus && this._sendPending(), this._connectionStatusChanged.emit(connectionStatus));
    }
    _errorIfDisposed() {
     if (this.isDisposed) throw new Error("Terminal connection is disposed");
    }
    get connectionStatusChanged() {
     return this._connectionStatusChanged;
    }
    get connectionStatus() {
     return this._connectionStatus;
    }
   }
   var Private;
   exports.TerminalConnection = TerminalConnection, function(Private) {
    Private.getTermUrl = function(baseUrl, name) {
     return coreutils_1.URLExt.join(baseUrl, restapi_1.TERMINAL_SERVICE_URL, encodeURIComponent(name));
    }, Private.getRandomIntInclusive = function(min, max) {
     return min = Math.ceil(min), max = Math.floor(max), Math.floor(Math.random() * (max - min + 1)) + min;
    };
   }(Private || (Private = {}));
  },
  67569: function(__unused_webpack_module, exports, __webpack_require__) {
   "use strict";
   var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    void 0 === k2 && (k2 = k), Object.defineProperty(o, k2, {
     enumerable: !0,
     get: function() {
      return m[k];
     }
    });
   } : function(o, m, k, k2) {
    void 0 === k2 && (k2 = k), o[k2] = m[k];
   }), __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
     enumerable: !0,
     value: v
    });
   } : function(o, v) {
    o.default = v;
   }), __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (null != mod) for (var k in mod) "default" !== k && Object.prototype.hasOwnProperty.call(mod, k) && __createBinding(result, mod, k);
    return __setModuleDefault(result, mod), result;
   }, __exportStar = this && this.__exportStar || function(m, exports) {
    for (var p in m) "default" === p || Object.prototype.hasOwnProperty.call(exports, p) || __createBinding(exports, m, p);
   };
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.TerminalAPI = exports.Terminal = void 0;
   const Terminal = __importStar(__webpack_require__(88917));
   exports.Terminal = Terminal;
   const TerminalAPI = __importStar(__webpack_require__(84903));
   exports.TerminalAPI = TerminalAPI, __exportStar(__webpack_require__(66810), exports);
  },
  66810: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.TerminalManager = void 0;
   const algorithm_1 = __webpack_require__(56588), polling_1 = __webpack_require__(93498), signaling_1 = __webpack_require__(57082), __1 = __webpack_require__(50608), basemanager_1 = __webpack_require__(5412), restapi_1 = __webpack_require__(84903), default_1 = __webpack_require__(12100);
   class TerminalManager extends basemanager_1.BaseManager {
    constructor(options = {}) {
     var _a;
     if (super(options), this._isReady = !1, this._names = [], this._terminalConnections = new Set, 
     this._runningChanged = new signaling_1.Signal(this), this._connectionFailure = new signaling_1.Signal(this), 
     !this.isAvailable()) return this._ready = Promise.reject("Terminals unavailable"), 
     void this._ready.catch((_ => {}));
     this._pollModels = new polling_1.Poll({
      auto: !1,
      factory: () => this.requestRunning(),
      frequency: {
       interval: 1e4,
       backoff: !0,
       max: 3e5
      },
      name: "@jupyterlab/services:TerminalManager#models",
      standby: null !== (_a = options.standby) && void 0 !== _a ? _a : "when-hidden"
     }), this._ready = (async () => {
      await this._pollModels.start(), await this._pollModels.tick, this._isReady = !0;
     })();
    }
    get isReady() {
     return this._isReady;
    }
    get ready() {
     return this._ready;
    }
    get runningChanged() {
     return this._runningChanged;
    }
    get connectionFailure() {
     return this._connectionFailure;
    }
    dispose() {
     this.isDisposed || (this._names.length = 0, this._terminalConnections.forEach((x => x.dispose())), 
     this._pollModels.dispose(), super.dispose());
    }
    isAvailable() {
     return restapi_1.isAvailable();
    }
    connectTo(options) {
     const terminalConnection = new default_1.TerminalConnection(Object.assign(Object.assign({}, options), {
      serverSettings: this.serverSettings
     }));
     return this._onStarted(terminalConnection), this._names.includes(options.model.name) || this.refreshRunning().catch((() => {})), 
     terminalConnection;
    }
    running() {
     return algorithm_1.iter(this._models);
    }
    async refreshRunning() {
     await this._pollModels.refresh(), await this._pollModels.tick;
    }
    async startNew(options) {
     const model = await restapi_1.startNew(this.serverSettings, null == options ? void 0 : options.name, null == options ? void 0 : options.cwd);
     return await this.refreshRunning(), this.connectTo({
      model
     });
    }
    async shutdown(name) {
     await restapi_1.shutdownTerminal(name, this.serverSettings), await this.refreshRunning();
    }
    async shutdownAll() {
     await this.refreshRunning(), await Promise.all(this._names.map((name => restapi_1.shutdownTerminal(name, this.serverSettings)))), 
     await this.refreshRunning();
    }
    async requestRunning() {
     var _a, _b;
     let models;
     try {
      models = await restapi_1.listRunning(this.serverSettings);
     } catch (err) {
      throw (err instanceof __1.ServerConnection.NetworkError || 503 === (null === (_a = err.response) || void 0 === _a ? void 0 : _a.status) || 424 === (null === (_b = err.response) || void 0 === _b ? void 0 : _b.status)) && this._connectionFailure.emit(err), 
      err;
     }
     if (this.isDisposed) return;
     const names = models.map((({name}) => name)).sort();
     names !== this._names && (this._names = names, this._terminalConnections.forEach((tc => {
      names.includes(tc.name) || tc.dispose();
     })), this._runningChanged.emit(this._models));
    }
    _onStarted(terminalConnection) {
     this._terminalConnections.add(terminalConnection), terminalConnection.disposed.connect(this._onDisposed, this);
    }
    _onDisposed(terminalConnection) {
     this._terminalConnections.delete(terminalConnection), this.refreshRunning().catch((() => {}));
    }
    get _models() {
     return this._names.map((name => ({
      name
     })));
    }
   }
   exports.TerminalManager = TerminalManager;
  },
  84903: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.shutdownTerminal = exports.listRunning = exports.startNew = exports.isAvailable = exports.TERMINAL_SERVICE_URL = void 0;
   const coreutils_1 = __webpack_require__(16015), serverconnection_1 = __webpack_require__(1089);
   function isAvailable() {
    return "true" === String(coreutils_1.PageConfig.getOption("terminalsAvailable")).toLowerCase();
   }
   var Private;
   exports.TERMINAL_SERVICE_URL = "api/terminals", exports.isAvailable = isAvailable, 
   exports.startNew = async function(settings = serverconnection_1.ServerConnection.makeSettings(), name, cwd) {
    Private.errorIfNotAvailable();
    const url = coreutils_1.URLExt.join(settings.baseUrl, exports.TERMINAL_SERVICE_URL), init = {
     method: "POST",
     body: JSON.stringify({
      name,
      cwd
     })
    }, response = await serverconnection_1.ServerConnection.makeRequest(url, init, settings);
    if (200 !== response.status) {
     throw await serverconnection_1.ServerConnection.ResponseError.create(response);
    }
    return await response.json();
   }, exports.listRunning = async function(settings = serverconnection_1.ServerConnection.makeSettings()) {
    Private.errorIfNotAvailable();
    const url = coreutils_1.URLExt.join(settings.baseUrl, exports.TERMINAL_SERVICE_URL), response = await serverconnection_1.ServerConnection.makeRequest(url, {}, settings);
    if (200 !== response.status) {
     throw await serverconnection_1.ServerConnection.ResponseError.create(response);
    }
    const data = await response.json();
    if (!Array.isArray(data)) throw new Error("Invalid terminal list");
    return data;
   }, exports.shutdownTerminal = async function(name, settings = serverconnection_1.ServerConnection.makeSettings()) {
    var _a;
    Private.errorIfNotAvailable();
    const workspacesBase = coreutils_1.URLExt.join(settings.baseUrl, exports.TERMINAL_SERVICE_URL), url = coreutils_1.URLExt.join(workspacesBase, name);
    if (!url.startsWith(workspacesBase)) throw new Error("Can only be used for terminal requests");
    const response = await serverconnection_1.ServerConnection.makeRequest(url, {
     method: "DELETE"
    }, settings);
    if (404 === response.status) {
     const msg = null !== (_a = (await response.json()).message) && void 0 !== _a ? _a : `The terminal session "${name}"" does not exist on the server`;
     console.warn(msg);
    } else if (204 !== response.status) {
     throw await serverconnection_1.ServerConnection.ResponseError.create(response);
    }
   }, function(Private) {
    Private.errorIfNotAvailable = function() {
     if (!isAvailable()) throw new Error("Terminals Unavailable");
    };
   }(Private || (Private = {}));
  },
  88917: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.isAvailable = void 0;
   const restapi_1 = __webpack_require__(84903);
   Object.defineProperty(exports, "isAvailable", {
    enumerable: !0,
    get: function() {
     return restapi_1.isAvailable;
    }
   });
  },
  18430: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.UserManager = void 0;
   const coreutils_1 = __webpack_require__(16015), coreutils_2 = __webpack_require__(64954), polling_1 = __webpack_require__(93498), signaling_1 = __webpack_require__(57082), serverconnection_1 = __webpack_require__(1089), basemanager_1 = __webpack_require__(5412), SERVICE_ID = "@jupyterlab/services:UserManager#user";
   class UserManager extends basemanager_1.BaseManager {
    constructor(options = {}) {
     var _a;
     super(options), this._isReady = !1, this._userChanged = new signaling_1.Signal(this), 
     this._connectionFailure = new signaling_1.Signal(this), this._ready = this.requestUser().then((() => {
      this.isDisposed || (this._isReady = !0);
     })).catch((_ => new Promise((() => {})))), this._pollSpecs = new polling_1.Poll({
      auto: !1,
      factory: () => this.requestUser(),
      frequency: {
       interval: 61e3,
       backoff: !0,
       max: 3e5
      },
      name: SERVICE_ID,
      standby: null !== (_a = options.standby) && void 0 !== _a ? _a : "when-hidden"
     }), this.ready.then((() => {
      this._pollSpecs.start();
     }));
    }
    get isReady() {
     return this._isReady;
    }
    get ready() {
     return this._ready;
    }
    get identity() {
     return this._identity;
    }
    get permissions() {
     return this._permissions;
    }
    get userChanged() {
     return this._userChanged;
    }
    get connectionFailure() {
     return this._connectionFailure;
    }
    dispose() {
     this._pollSpecs.dispose(), super.dispose();
    }
    async refreshUser() {
     await this._pollSpecs.refresh(), await this._pollSpecs.tick;
    }
    async requestUser() {
     if (this.isDisposed) return;
     const {baseUrl} = this.serverSettings, {makeRequest, ResponseError} = serverconnection_1.ServerConnection, url = coreutils_1.URLExt.join(baseUrl, "api/me"), response = await makeRequest(url, {}, this.serverSettings);
     if (200 !== response.status) {
      throw await ResponseError.create(response);
     }
     const oldUser = {
      identity: this._identity,
      permissions: this._permissions
     }, newUser = await response.json(), identity = newUser.identity, {localStorage} = window, data = localStorage.getItem(SERVICE_ID);
     if (data && (!identity.initials || !identity.color)) {
      const localUser = JSON.parse(data);
      identity.initials = identity.initials || localUser.initials || identity.name.substring(0, 1), 
      identity.color = identity.color || localUser.color || Private.getRandomColor();
     }
     coreutils_2.JSONExt.deepEqual(newUser, oldUser) || (this._identity = identity, this._permissions = newUser.permissions, 
     localStorage.setItem(SERVICE_ID, JSON.stringify(identity)), this._userChanged.emit(newUser));
    }
   }
   var Private;
   exports.UserManager = UserManager, function(Private) {
    const userColors = [ "var(--jp-collaborator-color1)", "var(--jp-collaborator-color2)", "var(--jp-collaborator-color3)", "var(--jp-collaborator-color4)", "var(--jp-collaborator-color5)", "var(--jp-collaborator-color6)", "var(--jp-collaborator-color7)" ];
    Private.getRandomColor = () => userColors[Math.floor(Math.random() * userColors.length)];
   }(Private || (Private = {}));
  },
  1480: (__unused_webpack_module, exports) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.validateProperty = void 0, exports.validateProperty = function(object, name, typeName, values = []) {
    if (!object.hasOwnProperty(name)) throw Error(`Missing property '${name}'`);
    const value = object[name];
    if (void 0 !== typeName) {
     let valid = !0;
     switch (typeName) {
     case "array":
      valid = Array.isArray(value);
      break;

     case "object":
      valid = void 0 !== value;
      break;

     default:
      valid = typeof value === typeName;
     }
     if (!valid) throw new Error(`Property '${name}' is not of type '${typeName}'`);
     if (values.length > 0) {
      let valid = !0;
      switch (typeName) {
      case "string":
      case "number":
      case "boolean":
       valid = values.includes(value);
       break;

      default:
       valid = values.findIndex((v => v === value)) >= 0;
      }
      if (!valid) throw new Error(`Property '${name}' is not one of the valid values ${JSON.stringify(values)}`);
     }
    }
   };
  },
  90362: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.WorkspaceManager = void 0;
   const coreutils_1 = __webpack_require__(16015), statedb_1 = __webpack_require__(19531), serverconnection_1 = __webpack_require__(1089);
   class WorkspaceManager extends statedb_1.DataConnector {
    constructor(options = {}) {
     var _a;
     super(), this.serverSettings = null !== (_a = options.serverSettings) && void 0 !== _a ? _a : serverconnection_1.ServerConnection.makeSettings();
    }
    async fetch(id) {
     const {serverSettings} = this, {baseUrl, appUrl} = serverSettings, {makeRequest, ResponseError} = serverconnection_1.ServerConnection, base = baseUrl + appUrl, url = Private.url(base, id), response = await makeRequest(url, {}, serverSettings);
     if (200 !== response.status) {
      throw await ResponseError.create(response);
     }
     return response.json();
    }
    async list() {
     const {serverSettings} = this, {baseUrl, appUrl} = serverSettings, {makeRequest, ResponseError} = serverconnection_1.ServerConnection, base = baseUrl + appUrl, url = Private.url(base, ""), response = await makeRequest(url, {}, serverSettings);
     if (200 !== response.status) {
      throw await ResponseError.create(response);
     }
     return (await response.json()).workspaces;
    }
    async remove(id) {
     const {serverSettings} = this, {baseUrl, appUrl} = serverSettings, {makeRequest, ResponseError} = serverconnection_1.ServerConnection, base = baseUrl + appUrl, url = Private.url(base, id), response = await makeRequest(url, {
      method: "DELETE"
     }, serverSettings);
     if (204 !== response.status) {
      throw await ResponseError.create(response);
     }
    }
    async save(id, workspace) {
     const {serverSettings} = this, {baseUrl, appUrl} = serverSettings, {makeRequest, ResponseError} = serverconnection_1.ServerConnection, base = baseUrl + appUrl, url = Private.url(base, id), init = {
      body: JSON.stringify(workspace),
      method: "PUT"
     }, response = await makeRequest(url, init, serverSettings);
     if (204 !== response.status) {
      throw await ResponseError.create(response);
     }
    }
   }
   var Private;
   exports.WorkspaceManager = WorkspaceManager, function(Private) {
    Private.url = function(base, id) {
     const workspacesBase = coreutils_1.URLExt.join(base, "api/workspaces"), result = coreutils_1.URLExt.join(workspacesBase, id);
     if (!result.startsWith(workspacesBase)) throw new Error("Can only be used for workspaces requests");
     return result;
    };
   }(Private || (Private = {}));
  },
  51062: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.ActivityMonitor = void 0;
   const signaling_1 = __webpack_require__(57082);
   exports.ActivityMonitor = class {
    constructor(options) {
     this._timer = -1, this._timeout = -1, this._isDisposed = !1, this._activityStopped = new signaling_1.Signal(this), 
     options.signal.connect(this._onSignalFired, this), this._timeout = options.timeout || 1e3;
    }
    get activityStopped() {
     return this._activityStopped;
    }
    get timeout() {
     return this._timeout;
    }
    set timeout(value) {
     this._timeout = value;
    }
    get isDisposed() {
     return this._isDisposed;
    }
    dispose() {
     this._isDisposed || (this._isDisposed = !0, signaling_1.Signal.clearData(this));
    }
    _onSignalFired(sender, args) {
     clearTimeout(this._timer), this._sender = sender, this._args = args, this._timer = setTimeout((() => {
      this._activityStopped.emit({
       sender: this._sender,
       args: this._args
      });
     }), this._timeout);
    }
   };
  },
  16015: function(__unused_webpack_module, exports, __webpack_require__) {
   "use strict";
   var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    void 0 === k2 && (k2 = k), Object.defineProperty(o, k2, {
     enumerable: !0,
     get: function() {
      return m[k];
     }
    });
   } : function(o, m, k, k2) {
    void 0 === k2 && (k2 = k), o[k2] = m[k];
   }), __exportStar = this && this.__exportStar || function(m, exports) {
    for (var p in m) "default" === p || Object.prototype.hasOwnProperty.call(exports, p) || __createBinding(exports, m, p);
   };
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), __exportStar(__webpack_require__(51062), exports), __exportStar(__webpack_require__(43307), exports), 
   __exportStar(__webpack_require__(74693), exports), __exportStar(__webpack_require__(27934), exports), 
   __exportStar(__webpack_require__(22192), exports), __exportStar(__webpack_require__(35936), exports), 
   __exportStar(__webpack_require__(47454), exports), __exportStar(__webpack_require__(31574), exports);
  },
  43307: (__unused_webpack_module, exports) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   });
  },
  74693: (__unused_webpack_module, exports) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.MarkdownCodeBlocks = void 0, function(MarkdownCodeBlocks) {
    MarkdownCodeBlocks.CODE_BLOCK_MARKER = "```";
    const markdownExtensions = [ ".markdown", ".mdown", ".mkdn", ".md", ".mkd", ".mdwn", ".mdtxt", ".mdtext", ".text", ".txt", ".Rmd" ];
    class MarkdownCodeBlock {
     constructor(startLine) {
      this.startLine = startLine, this.code = "", this.endLine = -1;
     }
    }
    MarkdownCodeBlocks.MarkdownCodeBlock = MarkdownCodeBlock, MarkdownCodeBlocks.isMarkdown = function(extension) {
     return markdownExtensions.indexOf(extension) > -1;
    }, MarkdownCodeBlocks.findMarkdownCodeBlocks = function(text) {
     if (!text || "" === text) return [];
     const lines = text.split("\n"), codeBlocks = [];
     let currentBlock = null;
     for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {
      const line = lines[lineIndex], lineContainsMarker = 0 === line.indexOf(MarkdownCodeBlocks.CODE_BLOCK_MARKER), constructingBlock = null != currentBlock;
      if (lineContainsMarker || constructingBlock) if (constructingBlock) currentBlock && (lineContainsMarker ? (currentBlock.endLine = lineIndex - 1, 
      codeBlocks.push(currentBlock), currentBlock = null) : currentBlock.code += line + "\n"); else {
       currentBlock = new MarkdownCodeBlock(lineIndex);
       const firstIndex = line.indexOf(MarkdownCodeBlocks.CODE_BLOCK_MARKER), lastIndex = line.lastIndexOf(MarkdownCodeBlocks.CODE_BLOCK_MARKER);
       firstIndex !== lastIndex && (currentBlock.code = line.substring(firstIndex + MarkdownCodeBlocks.CODE_BLOCK_MARKER.length, lastIndex), 
       currentBlock.endLine = lineIndex, codeBlocks.push(currentBlock), currentBlock = null);
      }
     }
     return codeBlocks;
    };
   }(exports.MarkdownCodeBlocks || (exports.MarkdownCodeBlocks = {}));
  },
  27934: function(__unused_webpack_module, exports, __webpack_require__) {
   "use strict";
   var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
     default: mod
    };
   };
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.PageConfig = void 0;
   const coreutils_1 = __webpack_require__(64954), minimist_1 = __importDefault(__webpack_require__(89031)), url_1 = __webpack_require__(31574);
   var PageConfig;
   (function(PageConfig) {
    function getOption(name) {
     if (configData) return configData[name] || getBodyData(name);
     configData = Object.create(null);
     let found = !1;
     if ("undefined" != typeof document && document) {
      const el = document.getElementById("jupyter-config-data");
      el && (configData = JSON.parse(el.textContent || ""), found = !0);
     }
     if (!found && "undefined" != typeof process && process.argv) try {
      const cli = minimist_1.default(process.argv.slice(2)), path = __webpack_require__(16928);
      let fullPath = "";
      "jupyter-config-data" in cli ? fullPath = path.resolve(cli["jupyter-config-data"]) : "JUPYTER_CONFIG_DATA" in process.env && (fullPath = path.resolve(process.env.JUPYTER_CONFIG_DATA)), 
      fullPath && (configData = eval("require")(fullPath));
     } catch (e) {
      console.error(e);
     }
     if (coreutils_1.JSONExt.isObject(configData)) for (const key in configData) "string" != typeof configData[key] && (configData[key] = JSON.stringify(configData[key])); else configData = Object.create(null);
     return configData[name] || getBodyData(name);
    }
    function setOption(name, value) {
     const last = getOption(name);
     return configData[name] = value, last;
    }
    function getBaseUrl() {
     return url_1.URLExt.normalize(getOption("baseUrl") || "/");
    }
    function getTreeUrl() {
     return url_1.URLExt.join(getBaseUrl(), getOption("treeUrl"));
    }
    function getShareUrl() {
     return url_1.URLExt.normalize(getOption("shareUrl") || getBaseUrl());
    }
    function getTreeShareUrl() {
     return url_1.URLExt.normalize(url_1.URLExt.join(getShareUrl(), getOption("treeUrl")));
    }
    function getUrl(options) {
     var _a, _b, _c, _d;
     let path = options.toShare ? getShareUrl() : getBaseUrl();
     const mode = null !== (_a = options.mode) && void 0 !== _a ? _a : getOption("mode"), workspace = null !== (_b = options.workspace) && void 0 !== _b ? _b : getOption("workspace"), labOrDoc = "single-document" === mode ? "doc" : "lab";
     path = url_1.URLExt.join(path, labOrDoc), workspace !== PageConfig.defaultWorkspace && (path = url_1.URLExt.join(path, "workspaces", encodeURIComponent(null !== (_c = getOption("workspace")) && void 0 !== _c ? _c : PageConfig.defaultWorkspace)));
     const treePath = null !== (_d = options.treePath) && void 0 !== _d ? _d : getOption("treePath");
     return treePath && (path = url_1.URLExt.join(path, "tree", url_1.URLExt.encodeParts(treePath))), 
     path;
    }
    function getWsUrl(baseUrl) {
     let wsUrl = getOption("wsUrl");
     if (!wsUrl) {
      if (0 !== (baseUrl = baseUrl ? url_1.URLExt.normalize(baseUrl) : getBaseUrl()).indexOf("http")) return "";
      wsUrl = "ws" + baseUrl.slice(4);
     }
     return url_1.URLExt.normalize(wsUrl);
    }
    function getNBConvertURL({path, format, download}) {
     const notebookPath = url_1.URLExt.encodeParts(path), url = url_1.URLExt.join(getBaseUrl(), "nbconvert", format, notebookPath);
     return download ? url + "?download=true" : url;
    }
    function getToken() {
     return getOption("token") || getBodyData("jupyterApiToken");
    }
    function getNotebookVersion() {
     const notebookVersion = getOption("notebookVersion");
     return "" === notebookVersion ? [ 0, 0, 0 ] : JSON.parse(notebookVersion);
    }
    PageConfig.getOption = getOption, PageConfig.setOption = setOption, PageConfig.getBaseUrl = getBaseUrl, 
    PageConfig.getTreeUrl = getTreeUrl, PageConfig.getShareUrl = getShareUrl, PageConfig.getTreeShareUrl = getTreeShareUrl, 
    PageConfig.getUrl = getUrl, PageConfig.defaultWorkspace = "default", PageConfig.getWsUrl = getWsUrl, 
    PageConfig.getNBConvertURL = getNBConvertURL, PageConfig.getToken = getToken, PageConfig.getNotebookVersion = getNotebookVersion;
    let configData = null, Extension;
    function getBodyData(key) {
     if ("undefined" == typeof document || !document.body) return "";
     const val = document.body.dataset[key];
     return void 0 === val ? "" : decodeURIComponent(val);
    }
    !function(Extension) {
     function populate(key) {
      try {
       const raw = getOption(key);
       if (raw) return JSON.parse(raw);
      } catch (error) {
       console.warn(`Unable to parse ${key}.`, error);
      }
      return [];
     }
     Extension.deferred = populate("deferredExtensions"), Extension.disabled = populate("disabledExtensions"), 
     Extension.isDeferred = function(id) {
      const separatorIndex = id.indexOf(":");
      let extName = "";
      return -1 !== separatorIndex && (extName = id.slice(0, separatorIndex)), Extension.deferred.some((val => val === id || extName && val === extName));
     }, Extension.isDisabled = function(id) {
      const separatorIndex = id.indexOf(":");
      let extName = "";
      return -1 !== separatorIndex && (extName = id.slice(0, separatorIndex)), Extension.disabled.some((val => val === id || extName && val === extName));
     };
    }(Extension = PageConfig.Extension || (PageConfig.Extension = {}));
   })(PageConfig = exports.PageConfig || (exports.PageConfig = {}));
  },
  22192: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.PathExt = void 0;
   const path_1 = __webpack_require__(16928);
   !function(PathExt) {
    function removeSlash(path) {
     return 0 === path.indexOf("/") && (path = path.slice(1)), path;
    }
    PathExt.join = function(...paths) {
     const path = path_1.posix.join(...paths);
     return "." === path ? "" : removeSlash(path);
    }, PathExt.basename = function(path, ext) {
     return path_1.posix.basename(path, ext);
    }, PathExt.dirname = function(path) {
     const dir = removeSlash(path_1.posix.dirname(path));
     return "." === dir ? "" : dir;
    }, PathExt.extname = function(path) {
     return path_1.posix.extname(path);
    }, PathExt.normalize = function(path) {
     return "" === path ? "" : removeSlash(path_1.posix.normalize(path));
    }, PathExt.resolve = function(...parts) {
     return removeSlash(path_1.posix.resolve(...parts));
    }, PathExt.relative = function(from, to) {
     return removeSlash(path_1.posix.relative(from, to));
    }, PathExt.normalizeExtension = function(extension) {
     return extension.length > 0 && 0 !== extension.indexOf(".") && (extension = `.${extension}`), 
     extension;
    }, PathExt.removeSlash = removeSlash;
   }(exports.PathExt || (exports.PathExt = {}));
  },
  35936: (__unused_webpack_module, exports) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.Text = void 0, function(Text) {
    Text.jsIndexToCharIndex = function(jsIdx, text) {
     return jsIdx;
    }, Text.charIndexToJsIndex = function(charIdx, text) {
     return charIdx;
    }, Text.camelCase = function(str, upper = !1) {
     return str.replace(/^(\w)|[\s-_:]+(\w)/g, (function(match, p1, p2) {
      return p2 ? p2.toUpperCase() : upper ? p1.toUpperCase() : p1.toLowerCase();
     }));
    }, Text.titleCase = function(str) {
     return (str || "").toLowerCase().split(" ").map((word => word.charAt(0).toUpperCase() + word.slice(1))).join(" ");
    };
   }(exports.Text || (exports.Text = {}));
  },
  47454: function(__unused_webpack_module, exports, __webpack_require__) {
   "use strict";
   var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
     default: mod
    };
   };
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.Time = void 0;
   const moment_1 = __importDefault(__webpack_require__(95093));
   !function(Time) {
    Time.formatHuman = function(value) {
     moment_1.default.locale(document.documentElement.lang);
     let time = moment_1.default(value).fromNow();
     return time = "a few seconds ago" === time ? "seconds ago" : time, time;
    }, Time.format = function(value, timeFormat = "YYYY-MM-DD HH:mm") {
     return moment_1.default(value).format(timeFormat);
    };
   }(exports.Time || (exports.Time = {}));
  },
  31574: function(__unused_webpack_module, exports, __webpack_require__) {
   "use strict";
   var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
     default: mod
    };
   };
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.URLExt = void 0;
   const path_1 = __webpack_require__(16928), url_parse_1 = __importDefault(__webpack_require__(61160));
   !function(URLExt) {
    function parse(url) {
     if ("undefined" != typeof document && document) {
      const a = document.createElement("a");
      return a.href = url, a;
     }
     return url_parse_1.default(url);
    }
    function join(...parts) {
     const u = url_parse_1.default(parts[0], {}), prefix = `${u.protocol}${u.slashes ? "//" : ""}${u.auth}${u.auth ? "@" : ""}${u.host}`, path = path_1.posix.join(`${prefix && "/" !== u.pathname[0] ? "/" : ""}${u.pathname}`, ...parts.slice(1));
     return `${prefix}${"." === path ? "" : path}`;
    }
    URLExt.parse = parse, URLExt.getHostName = function(url) {
     return url_parse_1.default(url).hostname;
    }, URLExt.normalize = function(url) {
     return url && parse(url).toString();
    }, URLExt.join = join, URLExt.encodeParts = function(url) {
     return join(...url.split("/").map(encodeURIComponent));
    }, URLExt.objectToQueryString = function(value) {
     const keys = Object.keys(value).filter((key => key.length > 0));
     return keys.length ? "?" + keys.map((key => {
      const content = encodeURIComponent(String(value[key]));
      return key + (content ? "=" + content : "");
     })).join("&") : "";
    }, URLExt.queryStringToObject = function(value) {
     return value.replace(/^\?/, "").split("&").reduce(((acc, val) => {
      const [key, value] = val.split("=");
      return key.length > 0 && (acc[key] = decodeURIComponent(value || "")), acc;
     }), {});
    }, URLExt.isLocal = function(url) {
     const {protocol} = parse(url);
     return (!protocol || 0 !== url.toLowerCase().indexOf(protocol)) && 0 !== url.indexOf("/");
    };
   }(exports.URLExt || (exports.URLExt = {}));
  },
  64954: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   var JSONExt;
   __webpack_require__.r(__webpack_exports__), __webpack_require__.d(__webpack_exports__, {
    JSONExt: () => JSONExt,
    MimeData: () => MimeData,
    PromiseDelegate: () => PromiseDelegate,
    Random: () => Random,
    Token: () => Token,
    UUID: () => UUID
   }), function(JSONExt) {
    function isPrimitive(value) {
     return null === value || "boolean" == typeof value || "number" == typeof value || "string" == typeof value;
    }
    function isArray(value) {
     return Array.isArray(value);
    }
    function deepEqual(first, second) {
     if (first === second) return !0;
     if (isPrimitive(first) || isPrimitive(second)) return !1;
     var a1 = isArray(first), a2 = isArray(second);
     return a1 === a2 && (a1 && a2 ? function(first, second) {
      if (first === second) return !0;
      if (first.length !== second.length) return !1;
      for (var i = 0, n = first.length; i < n; ++i) if (!deepEqual(first[i], second[i])) return !1;
      return !0;
     }(first, second) : function(first, second) {
      if (first === second) return !0;
      for (var key in first) if (void 0 !== first[key] && !(key in second)) return !1;
      for (var key in second) if (void 0 !== second[key] && !(key in first)) return !1;
      for (var key in first) {
       var firstValue = first[key], secondValue = second[key];
       if (void 0 !== firstValue || void 0 !== secondValue) {
        if (void 0 === firstValue || void 0 === secondValue) return !1;
        if (!deepEqual(firstValue, secondValue)) return !1;
       }
      }
      return !0;
     }(first, second));
    }
    function deepCopy(value) {
     return isPrimitive(value) ? value : isArray(value) ? function(value) {
      for (var result = new Array(value.length), i = 0, n = value.length; i < n; ++i) result[i] = deepCopy(value[i]);
      return result;
     }(value) : function(value) {
      var result = {};
      for (var key in value) {
       var subvalue = value[key];
       void 0 !== subvalue && (result[key] = deepCopy(subvalue));
      }
      return result;
     }(value);
    }
    JSONExt.emptyObject = Object.freeze({}), JSONExt.emptyArray = Object.freeze([]), 
    JSONExt.isPrimitive = isPrimitive, JSONExt.isArray = isArray, JSONExt.isObject = function(value) {
     return !isPrimitive(value) && !isArray(value);
    }, JSONExt.deepEqual = deepEqual, JSONExt.deepCopy = deepCopy;
   }(JSONExt || (JSONExt = {}));
   var Random, UUID, MimeData = function() {
    function MimeData() {
     this._types = [], this._values = [];
    }
    return MimeData.prototype.types = function() {
     return this._types.slice();
    }, MimeData.prototype.hasData = function(mime) {
     return -1 !== this._types.indexOf(mime);
    }, MimeData.prototype.getData = function(mime) {
     var i = this._types.indexOf(mime);
     return -1 !== i ? this._values[i] : void 0;
    }, MimeData.prototype.setData = function(mime, data) {
     this.clearData(mime), this._types.push(mime), this._values.push(data);
    }, MimeData.prototype.clearData = function(mime) {
     var i = this._types.indexOf(mime);
     -1 !== i && (this._types.splice(i, 1), this._values.splice(i, 1));
    }, MimeData.prototype.clear = function() {
     this._types.length = 0, this._values.length = 0;
    }, MimeData;
   }(), PromiseDelegate = function() {
    function PromiseDelegate() {
     var _this = this;
     this.promise = new Promise((function(resolve, reject) {
      _this._resolve = resolve, _this._reject = reject;
     }));
    }
    return PromiseDelegate.prototype.resolve = function(value) {
     (0, this._resolve)(value);
    }, PromiseDelegate.prototype.reject = function(reason) {
     (0, this._reject)(reason);
    }, PromiseDelegate;
   }(), Token = function(name) {
    this.name = name, this._tokenStructuralPropertyT = null;
   };
   function fallbackRandomValues(buffer) {
    for (var value = 0, i = 0, n = buffer.length; i < n; ++i) i % 4 == 0 && (value = 4294967295 * Math.random() >>> 0), 
    buffer[i] = 255 & value, value >>>= 8;
   }
   !function(Random) {
    Random.getRandomValues = function() {
     var crypto = "undefined" != typeof window && (window.crypto || window.msCrypto) || null;
     return crypto && "function" == typeof crypto.getRandomValues ? function(buffer) {
      return crypto.getRandomValues(buffer);
     } : fallbackRandomValues;
    }();
   }(Random || (Random = {})), function(UUID) {
    UUID.uuid4 = function(getRandomValues) {
     for (var bytes = new Uint8Array(16), lut = new Array(256), i = 0; i < 16; ++i) lut[i] = "0" + i.toString(16);
     for (i = 16; i < 256; ++i) lut[i] = i.toString(16);
     return function() {
      return getRandomValues(bytes), bytes[6] = 64 | 15 & bytes[6], bytes[8] = 128 | 63 & bytes[8], 
      lut[bytes[0]] + lut[bytes[1]] + lut[bytes[2]] + lut[bytes[3]] + "-" + lut[bytes[4]] + lut[bytes[5]] + "-" + lut[bytes[6]] + lut[bytes[7]] + "-" + lut[bytes[8]] + lut[bytes[9]] + "-" + lut[bytes[10]] + lut[bytes[11]] + lut[bytes[12]] + lut[bytes[13]] + lut[bytes[14]] + lut[bytes[15]];
     };
    }(Random.getRandomValues);
   }(UUID || (UUID = {}));
  },
  83070: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.r(__webpack_exports__), __webpack_require__.d(__webpack_exports__, {
    DisposableDelegate: () => DisposableDelegate,
    DisposableSet: () => DisposableSet,
    ObservableDisposableDelegate: () => ObservableDisposableDelegate,
    ObservableDisposableSet: () => ObservableDisposableSet
   });
   var _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(56588), _lumino_signaling__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(57082), extendStatics = function(d, b) {
    return extendStatics = Object.setPrototypeOf || {
     __proto__: []
    } instanceof Array && function(d, b) {
     d.__proto__ = b;
    } || function(d, b) {
     for (var p in b) Object.prototype.hasOwnProperty.call(b, p) && (d[p] = b[p]);
    }, extendStatics(d, b);
   };
   function __extends(d, b) {
    if ("function" != typeof b && null !== b) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    function __() {
     this.constructor = d;
    }
    extendStatics(d, b), d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, 
    new __);
   }
   var DisposableDelegate = function() {
    function DisposableDelegate(fn) {
     this._fn = fn;
    }
    return Object.defineProperty(DisposableDelegate.prototype, "isDisposed", {
     get: function() {
      return !this._fn;
     },
     enumerable: !0,
     configurable: !0
    }), DisposableDelegate.prototype.dispose = function() {
     if (this._fn) {
      var fn = this._fn;
      this._fn = null, fn();
     }
    }, DisposableDelegate;
   }(), ObservableDisposableDelegate = function(_super) {
    function ObservableDisposableDelegate() {
     var _this = null !== _super && _super.apply(this, arguments) || this;
     return _this._disposed = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_1__.Signal(_this), 
     _this;
    }
    return __extends(ObservableDisposableDelegate, _super), Object.defineProperty(ObservableDisposableDelegate.prototype, "disposed", {
     get: function() {
      return this._disposed;
     },
     enumerable: !0,
     configurable: !0
    }), ObservableDisposableDelegate.prototype.dispose = function() {
     this.isDisposed || (_super.prototype.dispose.call(this), this._disposed.emit(void 0), 
     _lumino_signaling__WEBPACK_IMPORTED_MODULE_1__.Signal.clearData(this));
    }, ObservableDisposableDelegate;
   }(DisposableDelegate), DisposableSet = function() {
    function DisposableSet() {
     this._isDisposed = !1, this._items = new Set;
    }
    return Object.defineProperty(DisposableSet.prototype, "isDisposed", {
     get: function() {
      return this._isDisposed;
     },
     enumerable: !0,
     configurable: !0
    }), DisposableSet.prototype.dispose = function() {
     this._isDisposed || (this._isDisposed = !0, this._items.forEach((function(item) {
      item.dispose();
     })), this._items.clear());
    }, DisposableSet.prototype.contains = function(item) {
     return this._items.has(item);
    }, DisposableSet.prototype.add = function(item) {
     this._items.add(item);
    }, DisposableSet.prototype.remove = function(item) {
     this._items.delete(item);
    }, DisposableSet.prototype.clear = function() {
     this._items.clear();
    }, DisposableSet;
   }();
   !function(DisposableSet) {
    DisposableSet.from = function(items) {
     var set = new DisposableSet;
     return (0, _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.each)(items, (function(item) {
      set.add(item);
     })), set;
    };
   }(DisposableSet || (DisposableSet = {}));
   var ObservableDisposableSet = function(_super) {
    function ObservableDisposableSet() {
     var _this = null !== _super && _super.apply(this, arguments) || this;
     return _this._disposed = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_1__.Signal(_this), 
     _this;
    }
    return __extends(ObservableDisposableSet, _super), Object.defineProperty(ObservableDisposableSet.prototype, "disposed", {
     get: function() {
      return this._disposed;
     },
     enumerable: !0,
     configurable: !0
    }), ObservableDisposableSet.prototype.dispose = function() {
     this.isDisposed || (_super.prototype.dispose.call(this), this._disposed.emit(void 0), 
     _lumino_signaling__WEBPACK_IMPORTED_MODULE_1__.Signal.clearData(this));
    }, ObservableDisposableSet;
   }(DisposableSet);
   !function(ObservableDisposableSet) {
    ObservableDisposableSet.from = function(items) {
     var set = new ObservableDisposableSet;
     return (0, _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.each)(items, (function(item) {
      set.add(item);
     })), set;
    };
   }(ObservableDisposableSet || (ObservableDisposableSet = {}));
  },
  57082: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.r(__webpack_exports__), __webpack_require__.d(__webpack_exports__, {
    Signal: () => Signal
   });
   var Private, _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(56588), _lumino_properties__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(21628), Signal = function() {
    function Signal(sender) {
     this._blockedCount = 0, this.sender = sender;
    }
    return Signal.prototype.block = function(fn) {
     this._blockedCount++;
     try {
      fn();
     } finally {
      this._blockedCount--;
     }
    }, Signal.prototype.connect = function(slot, thisArg) {
     return Private.connect(this, slot, thisArg);
    }, Signal.prototype.disconnect = function(slot, thisArg) {
     return Private.disconnect(this, slot, thisArg);
    }, Signal.prototype.emit = function(args) {
     this._blockedCount || Private.emit(this, args);
    }, Signal;
   }();
   !function(Signal) {
    Signal.blockAll = function(sender, fn) {
     var blockedProperty = Private.blockedProperty;
     blockedProperty.set(sender, blockedProperty.get(sender) + 1);
     try {
      fn();
     } finally {
      blockedProperty.set(sender, blockedProperty.get(sender) - 1);
     }
    }, Signal.disconnectBetween = function(sender, receiver) {
     Private.disconnectBetween(sender, receiver);
    }, Signal.disconnectSender = function(sender) {
     Private.disconnectSender(sender);
    }, Signal.disconnectReceiver = function(receiver) {
     Private.disconnectReceiver(receiver);
    }, Signal.disconnectAll = function(object) {
     Private.disconnectAll(object);
    }, Signal.clearData = function(object) {
     Private.disconnectAll(object);
    }, Signal.getExceptionHandler = function() {
     return Private.exceptionHandler;
    }, Signal.setExceptionHandler = function(handler) {
     var old = Private.exceptionHandler;
     return Private.exceptionHandler = handler, old;
    };
   }(Signal || (Signal = {})), function(Private) {
    function disconnectSender(sender) {
     var receivers = receiversForSender.get(sender);
     receivers && 0 !== receivers.length && ((0, _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.each)(receivers, (function(connection) {
      if (connection.signal) {
       var receiver = connection.thisArg || connection.slot;
       connection.signal = null, scheduleCleanup(sendersForReceiver.get(receiver));
      }
     })), scheduleCleanup(receivers));
    }
    function disconnectReceiver(receiver) {
     var senders = sendersForReceiver.get(receiver);
     senders && 0 !== senders.length && ((0, _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.each)(senders, (function(connection) {
      if (connection.signal) {
       var sender = connection.signal.sender;
       connection.signal = null, scheduleCleanup(receiversForSender.get(sender));
      }
     })), scheduleCleanup(senders));
    }
    Private.exceptionHandler = function(err) {
     console.error(err);
    }, Private.connect = function(signal, slot, thisArg) {
     thisArg = thisArg || void 0;
     var receivers = receiversForSender.get(signal.sender);
     if (receivers || (receivers = [], receiversForSender.set(signal.sender, receivers)), 
     findConnection(receivers, signal, slot, thisArg)) return !1;
     var receiver = thisArg || slot, senders = sendersForReceiver.get(receiver);
     senders || (senders = [], sendersForReceiver.set(receiver, senders));
     var connection = {
      signal,
      slot,
      thisArg
     };
     return receivers.push(connection), senders.push(connection), !0;
    }, Private.disconnect = function(signal, slot, thisArg) {
     thisArg = thisArg || void 0;
     var receivers = receiversForSender.get(signal.sender);
     if (!receivers || 0 === receivers.length) return !1;
     var connection = findConnection(receivers, signal, slot, thisArg);
     if (!connection) return !1;
     var receiver = thisArg || slot, senders = sendersForReceiver.get(receiver);
     return connection.signal = null, scheduleCleanup(receivers), scheduleCleanup(senders), 
     !0;
    }, Private.disconnectBetween = function(sender, receiver) {
     var receivers = receiversForSender.get(sender);
     if (receivers && 0 !== receivers.length) {
      var senders = sendersForReceiver.get(receiver);
      senders && 0 !== senders.length && ((0, _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.each)(senders, (function(connection) {
       connection.signal && connection.signal.sender === sender && (connection.signal = null);
      })), scheduleCleanup(receivers), scheduleCleanup(senders));
     }
    }, Private.disconnectSender = disconnectSender, Private.disconnectReceiver = disconnectReceiver, 
    Private.disconnectAll = function(object) {
     disconnectSender(object), disconnectReceiver(object);
    }, Private.emit = function(signal, args) {
     if (!(Private.blockedProperty.get(signal.sender) > 0)) {
      var receivers = receiversForSender.get(signal.sender);
      if (receivers && 0 !== receivers.length) for (var i = 0, n = receivers.length; i < n; ++i) {
       var connection = receivers[i];
       connection.signal === signal && invokeSlot(connection, args);
      }
     }
    };
    var receiversForSender = new WeakMap, sendersForReceiver = new WeakMap, dirtySet = new Set, schedule = "function" == typeof requestAnimationFrame ? requestAnimationFrame : setImmediate;
    function findConnection(connections, signal, slot, thisArg) {
     return (0, _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.find)(connections, (function(connection) {
      return connection.signal === signal && connection.slot === slot && connection.thisArg === thisArg;
     }));
    }
    function invokeSlot(connection, args) {
     var signal = connection.signal, slot = connection.slot, thisArg = connection.thisArg;
     try {
      slot.call(thisArg, signal.sender, args);
     } catch (err) {
      Private.exceptionHandler(err);
     }
    }
    function scheduleCleanup(array) {
     0 === dirtySet.size && schedule(cleanupDirtySet), dirtySet.add(array);
    }
    function cleanupDirtySet() {
     dirtySet.forEach(cleanupConnections), dirtySet.clear();
    }
    function cleanupConnections(connections) {
     _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.removeAllWhere(connections, isDeadConnection);
    }
    function isDeadConnection(connection) {
     return null === connection.signal;
    }
    Private.blockedProperty = new _lumino_properties__WEBPACK_IMPORTED_MODULE_1__.AttachedProperty({
     name: "blocked",
     create: function() {
      return 0;
     }
    });
   }(Private || (Private = {}));
  },
  15734: (module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   const WebSocket = __webpack_require__(39317);
   WebSocket.createWebSocketStream = __webpack_require__(40432), WebSocket.Server = __webpack_require__(29573), 
   WebSocket.Receiver = __webpack_require__(27049), WebSocket.Sender = __webpack_require__(93961), 
   module.exports = WebSocket;
  },
  26383: (module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   const {EMPTY_BUFFER} = __webpack_require__(54011);
   function concat(list, totalLength) {
    if (0 === list.length) return EMPTY_BUFFER;
    if (1 === list.length) return list[0];
    const target = Buffer.allocUnsafe(totalLength);
    let offset = 0;
    for (let i = 0; i < list.length; i++) {
     const buf = list[i];
     target.set(buf, offset), offset += buf.length;
    }
    return offset < totalLength ? target.slice(0, offset) : target;
   }
   function _mask(source, mask, output, offset, length) {
    for (let i = 0; i < length; i++) output[offset + i] = source[i] ^ mask[3 & i];
   }
   function _unmask(buffer, mask) {
    const length = buffer.length;
    for (let i = 0; i < length; i++) buffer[i] ^= mask[3 & i];
   }
   function toArrayBuffer(buf) {
    return buf.byteLength === buf.buffer.byteLength ? buf.buffer : buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
   }
   function toBuffer(data) {
    if (toBuffer.readOnly = !0, Buffer.isBuffer(data)) return data;
    let buf;
    return data instanceof ArrayBuffer ? buf = Buffer.from(data) : ArrayBuffer.isView(data) ? buf = Buffer.from(data.buffer, data.byteOffset, data.byteLength) : (buf = Buffer.from(data), 
    toBuffer.readOnly = !1), buf;
   }
   try {
    const bufferUtil = __webpack_require__(Object(function() {
     var e = new Error("Cannot find module 'bufferutil'");
     throw e.code = "MODULE_NOT_FOUND", e;
    }())), bu = bufferUtil.BufferUtil || bufferUtil;
    module.exports = {
     concat,
     mask(source, mask, output, offset, length) {
      length < 48 ? _mask(source, mask, output, offset, length) : bu.mask(source, mask, output, offset, length);
     },
     toArrayBuffer,
     toBuffer,
     unmask(buffer, mask) {
      buffer.length < 32 ? _unmask(buffer, mask) : bu.unmask(buffer, mask);
     }
    };
   } catch (e) {
    module.exports = {
     concat,
     mask: _mask,
     toArrayBuffer,
     toBuffer,
     unmask: _unmask
    };
   }
  },
  54011: module => {
   "use strict";
   module.exports = {
    BINARY_TYPES: [ "nodebuffer", "arraybuffer", "fragments" ],
    GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
    kStatusCode: Symbol("status-code"),
    kWebSocket: Symbol("websocket"),
    EMPTY_BUFFER: Buffer.alloc(0),
    NOOP: () => {}
   };
  },
  62134: module => {
   "use strict";
   class Event {
    constructor(type, target) {
     this.target = target, this.type = type;
    }
   }
   class MessageEvent extends Event {
    constructor(data, target) {
     super("message", target), this.data = data;
    }
   }
   class CloseEvent extends Event {
    constructor(code, reason, target) {
     super("close", target), this.wasClean = target._closeFrameReceived && target._closeFrameSent, 
     this.reason = reason, this.code = code;
    }
   }
   class OpenEvent extends Event {
    constructor(target) {
     super("open", target);
    }
   }
   class ErrorEvent extends Event {
    constructor(error, target) {
     super("error", target), this.message = error.message, this.error = error;
    }
   }
   const EventTarget = {
    addEventListener(type, listener, options) {
     if ("function" != typeof listener) return;
     function onMessage(data) {
      listener.call(this, new MessageEvent(data, this));
     }
     function onClose(code, message) {
      listener.call(this, new CloseEvent(code, message, this));
     }
     function onError(error) {
      listener.call(this, new ErrorEvent(error, this));
     }
     function onOpen() {
      listener.call(this, new OpenEvent(this));
     }
     const method = options && options.once ? "once" : "on";
     "message" === type ? (onMessage._listener = listener, this[method](type, onMessage)) : "close" === type ? (onClose._listener = listener, 
     this[method](type, onClose)) : "error" === type ? (onError._listener = listener, 
     this[method](type, onError)) : "open" === type ? (onOpen._listener = listener, this[method](type, onOpen)) : this[method](type, listener);
    },
    removeEventListener(type, listener) {
     const listeners = this.listeners(type);
     for (let i = 0; i < listeners.length; i++) listeners[i] !== listener && listeners[i]._listener !== listener || this.removeListener(type, listeners[i]);
    }
   };
   module.exports = EventTarget;
  },
  70427: module => {
   "use strict";
   const tokenChars = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0 ];
   function push(dest, name, elem) {
    void 0 === dest[name] ? dest[name] = [ elem ] : dest[name].push(elem);
   }
   module.exports = {
    format: function(extensions) {
     return Object.keys(extensions).map((extension => {
      let configurations = extensions[extension];
      return Array.isArray(configurations) || (configurations = [ configurations ]), configurations.map((params => [ extension ].concat(Object.keys(params).map((k => {
       let values = params[k];
       return Array.isArray(values) || (values = [ values ]), values.map((v => !0 === v ? k : `${k}=${v}`)).join("; ");
      }))).join("; "))).join(", ");
     })).join(", ");
    },
    parse: function(header) {
     const offers = Object.create(null);
     if (void 0 === header || "" === header) return offers;
     let extensionName, paramName, params = Object.create(null), mustUnescape = !1, isEscaping = !1, inQuotes = !1, start = -1, end = -1, i = 0;
     for (;i < header.length; i++) {
      const code = header.charCodeAt(i);
      if (void 0 === extensionName) if (-1 === end && 1 === tokenChars[code]) -1 === start && (start = i); else if (32 === code || 9 === code) -1 === end && -1 !== start && (end = i); else {
       if (59 !== code && 44 !== code) throw new SyntaxError(`Unexpected character at index ${i}`);
       {
        if (-1 === start) throw new SyntaxError(`Unexpected character at index ${i}`);
        -1 === end && (end = i);
        const name = header.slice(start, end);
        44 === code ? (push(offers, name, params), params = Object.create(null)) : extensionName = name, 
        start = end = -1;
       }
      } else if (void 0 === paramName) if (-1 === end && 1 === tokenChars[code]) -1 === start && (start = i); else if (32 === code || 9 === code) -1 === end && -1 !== start && (end = i); else if (59 === code || 44 === code) {
       if (-1 === start) throw new SyntaxError(`Unexpected character at index ${i}`);
       -1 === end && (end = i), push(params, header.slice(start, end), !0), 44 === code && (push(offers, extensionName, params), 
       params = Object.create(null), extensionName = void 0), start = end = -1;
      } else {
       if (61 !== code || -1 === start || -1 !== end) throw new SyntaxError(`Unexpected character at index ${i}`);
       paramName = header.slice(start, i), start = end = -1;
      } else if (isEscaping) {
       if (1 !== tokenChars[code]) throw new SyntaxError(`Unexpected character at index ${i}`);
       -1 === start ? start = i : mustUnescape || (mustUnescape = !0), isEscaping = !1;
      } else if (inQuotes) if (1 === tokenChars[code]) -1 === start && (start = i); else if (34 === code && -1 !== start) inQuotes = !1, 
      end = i; else {
       if (92 !== code) throw new SyntaxError(`Unexpected character at index ${i}`);
       isEscaping = !0;
      } else if (34 === code && 61 === header.charCodeAt(i - 1)) inQuotes = !0; else if (-1 === end && 1 === tokenChars[code]) -1 === start && (start = i); else if (-1 === start || 32 !== code && 9 !== code) {
       if (59 !== code && 44 !== code) throw new SyntaxError(`Unexpected character at index ${i}`);
       {
        if (-1 === start) throw new SyntaxError(`Unexpected character at index ${i}`);
        -1 === end && (end = i);
        let value = header.slice(start, end);
        mustUnescape && (value = value.replace(/\\/g, ""), mustUnescape = !1), push(params, paramName, value), 
        44 === code && (push(offers, extensionName, params), params = Object.create(null), 
        extensionName = void 0), paramName = void 0, start = end = -1;
       }
      } else -1 === end && (end = i);
     }
     if (-1 === start || inQuotes) throw new SyntaxError("Unexpected end of input");
     -1 === end && (end = i);
     const token = header.slice(start, end);
     return void 0 === extensionName ? push(offers, token, params) : (void 0 === paramName ? push(params, token, !0) : push(params, paramName, mustUnescape ? token.replace(/\\/g, "") : token), 
     push(offers, extensionName, params)), offers;
    }
   };
  },
  43954: module => {
   "use strict";
   const kDone = Symbol("kDone"), kRun = Symbol("kRun");
   module.exports = class {
    constructor(concurrency) {
     this[kDone] = () => {
      this.pending--, this[kRun]();
     }, this.concurrency = concurrency || 1 / 0, this.jobs = [], this.pending = 0;
    }
    add(job) {
     this.jobs.push(job), this[kRun]();
    }
    [kRun]() {
     if (this.pending !== this.concurrency && this.jobs.length) {
      const job = this.jobs.shift();
      this.pending++, job(this[kDone]);
     }
    }
   };
  },
  16228: (module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   const zlib = __webpack_require__(43106), bufferUtil = __webpack_require__(26383), Limiter = __webpack_require__(43954), {kStatusCode, NOOP} = __webpack_require__(54011), TRAILER = Buffer.from([ 0, 0, 255, 255 ]), kPerMessageDeflate = Symbol("permessage-deflate"), kTotalLength = Symbol("total-length"), kCallback = Symbol("callback"), kBuffers = Symbol("buffers"), kError = Symbol("error");
   let zlibLimiter;
   function deflateOnData(chunk) {
    this[kBuffers].push(chunk), this[kTotalLength] += chunk.length;
   }
   function inflateOnData(chunk) {
    this[kTotalLength] += chunk.length, this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload ? this[kBuffers].push(chunk) : (this[kError] = new RangeError("Max payload size exceeded"), 
    this[kError].code = "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH", this[kError][kStatusCode] = 1009, 
    this.removeListener("data", inflateOnData), this.reset());
   }
   function inflateOnError(err) {
    this[kPerMessageDeflate]._inflate = null, err[kStatusCode] = 1007, this[kCallback](err);
   }
   module.exports = class {
    constructor(options, isServer, maxPayload) {
     if (this._maxPayload = 0 | maxPayload, this._options = options || {}, this._threshold = void 0 !== this._options.threshold ? this._options.threshold : 1024, 
     this._isServer = !!isServer, this._deflate = null, this._inflate = null, this.params = null, 
     !zlibLimiter) {
      const concurrency = void 0 !== this._options.concurrencyLimit ? this._options.concurrencyLimit : 10;
      zlibLimiter = new Limiter(concurrency);
     }
    }
    static get extensionName() {
     return "permessage-deflate";
    }
    offer() {
     const params = {};
     return this._options.serverNoContextTakeover && (params.server_no_context_takeover = !0), 
     this._options.clientNoContextTakeover && (params.client_no_context_takeover = !0), 
     this._options.serverMaxWindowBits && (params.server_max_window_bits = this._options.serverMaxWindowBits), 
     this._options.clientMaxWindowBits ? params.client_max_window_bits = this._options.clientMaxWindowBits : null == this._options.clientMaxWindowBits && (params.client_max_window_bits = !0), 
     params;
    }
    accept(configurations) {
     return configurations = this.normalizeParams(configurations), this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations), 
     this.params;
    }
    cleanup() {
     if (this._inflate && (this._inflate.close(), this._inflate = null), this._deflate) {
      const callback = this._deflate[kCallback];
      this._deflate.close(), this._deflate = null, callback && callback(new Error("The deflate stream was closed while data was being processed"));
     }
    }
    acceptAsServer(offers) {
     const opts = this._options, accepted = offers.find((params => !(!1 === opts.serverNoContextTakeover && params.server_no_context_takeover || params.server_max_window_bits && (!1 === opts.serverMaxWindowBits || "number" == typeof opts.serverMaxWindowBits && opts.serverMaxWindowBits > params.server_max_window_bits) || "number" == typeof opts.clientMaxWindowBits && !params.client_max_window_bits)));
     if (!accepted) throw new Error("None of the extension offers can be accepted");
     return opts.serverNoContextTakeover && (accepted.server_no_context_takeover = !0), 
     opts.clientNoContextTakeover && (accepted.client_no_context_takeover = !0), "number" == typeof opts.serverMaxWindowBits && (accepted.server_max_window_bits = opts.serverMaxWindowBits), 
     "number" == typeof opts.clientMaxWindowBits ? accepted.client_max_window_bits = opts.clientMaxWindowBits : !0 !== accepted.client_max_window_bits && !1 !== opts.clientMaxWindowBits || delete accepted.client_max_window_bits, 
     accepted;
    }
    acceptAsClient(response) {
     const params = response[0];
     if (!1 === this._options.clientNoContextTakeover && params.client_no_context_takeover) throw new Error('Unexpected parameter "client_no_context_takeover"');
     if (params.client_max_window_bits) {
      if (!1 === this._options.clientMaxWindowBits || "number" == typeof this._options.clientMaxWindowBits && params.client_max_window_bits > this._options.clientMaxWindowBits) throw new Error('Unexpected or invalid parameter "client_max_window_bits"');
     } else "number" == typeof this._options.clientMaxWindowBits && (params.client_max_window_bits = this._options.clientMaxWindowBits);
     return params;
    }
    normalizeParams(configurations) {
     return configurations.forEach((params => {
      Object.keys(params).forEach((key => {
       let value = params[key];
       if (value.length > 1) throw new Error(`Parameter "${key}" must have only a single value`);
       if (value = value[0], "client_max_window_bits" === key) {
        if (!0 !== value) {
         const num = +value;
         if (!Number.isInteger(num) || num < 8 || num > 15) throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
         value = num;
        } else if (!this._isServer) throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
       } else if ("server_max_window_bits" === key) {
        const num = +value;
        if (!Number.isInteger(num) || num < 8 || num > 15) throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
        value = num;
       } else {
        if ("client_no_context_takeover" !== key && "server_no_context_takeover" !== key) throw new Error(`Unknown parameter "${key}"`);
        if (!0 !== value) throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
       }
       params[key] = value;
      }));
     })), configurations;
    }
    decompress(data, fin, callback) {
     zlibLimiter.add((done => {
      this._decompress(data, fin, ((err, result) => {
       done(), callback(err, result);
      }));
     }));
    }
    compress(data, fin, callback) {
     zlibLimiter.add((done => {
      this._compress(data, fin, ((err, result) => {
       done(), callback(err, result);
      }));
     }));
    }
    _decompress(data, fin, callback) {
     const endpoint = this._isServer ? "client" : "server";
     if (!this._inflate) {
      const key = `${endpoint}_max_window_bits`, windowBits = "number" != typeof this.params[key] ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
      this._inflate = zlib.createInflateRaw({
       ...this._options.zlibInflateOptions,
       windowBits
      }), this._inflate[kPerMessageDeflate] = this, this._inflate[kTotalLength] = 0, this._inflate[kBuffers] = [], 
      this._inflate.on("error", inflateOnError), this._inflate.on("data", inflateOnData);
     }
     this._inflate[kCallback] = callback, this._inflate.write(data), fin && this._inflate.write(TRAILER), 
     this._inflate.flush((() => {
      const err = this._inflate[kError];
      if (err) return this._inflate.close(), this._inflate = null, void callback(err);
      const data = bufferUtil.concat(this._inflate[kBuffers], this._inflate[kTotalLength]);
      this._inflate._readableState.endEmitted ? (this._inflate.close(), this._inflate = null) : (this._inflate[kTotalLength] = 0, 
      this._inflate[kBuffers] = [], fin && this.params[`${endpoint}_no_context_takeover`] && this._inflate.reset()), 
      callback(null, data);
     }));
    }
    _compress(data, fin, callback) {
     const endpoint = this._isServer ? "server" : "client";
     if (!this._deflate) {
      const key = `${endpoint}_max_window_bits`, windowBits = "number" != typeof this.params[key] ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
      this._deflate = zlib.createDeflateRaw({
       ...this._options.zlibDeflateOptions,
       windowBits
      }), this._deflate[kTotalLength] = 0, this._deflate[kBuffers] = [], this._deflate.on("error", NOOP), 
      this._deflate.on("data", deflateOnData);
     }
     this._deflate[kCallback] = callback, this._deflate.write(data), this._deflate.flush(zlib.Z_SYNC_FLUSH, (() => {
      if (!this._deflate) return;
      let data = bufferUtil.concat(this._deflate[kBuffers], this._deflate[kTotalLength]);
      fin && (data = data.slice(0, data.length - 4)), this._deflate[kCallback] = null, 
      this._deflate[kTotalLength] = 0, this._deflate[kBuffers] = [], fin && this.params[`${endpoint}_no_context_takeover`] && this._deflate.reset(), 
      callback(null, data);
     }));
    }
   };
  },
  27049: (module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   const {Writable} = __webpack_require__(2203), PerMessageDeflate = __webpack_require__(16228), {BINARY_TYPES, EMPTY_BUFFER, kStatusCode, kWebSocket} = __webpack_require__(54011), {concat, toArrayBuffer, unmask} = __webpack_require__(26383), {isValidStatusCode, isValidUTF8} = __webpack_require__(2659);
   function error(ErrorCtor, message, prefix, statusCode, errorCode) {
    const err = new ErrorCtor(prefix ? `Invalid WebSocket frame: ${message}` : message);
    return Error.captureStackTrace(err, error), err.code = errorCode, err[kStatusCode] = statusCode, 
    err;
   }
   module.exports = class extends Writable {
    constructor(binaryType, extensions, isServer, maxPayload) {
     super(), this._binaryType = binaryType || BINARY_TYPES[0], this[kWebSocket] = void 0, 
     this._extensions = extensions || {}, this._isServer = !!isServer, this._maxPayload = 0 | maxPayload, 
     this._bufferedBytes = 0, this._buffers = [], this._compressed = !1, this._payloadLength = 0, 
     this._mask = void 0, this._fragmented = 0, this._masked = !1, this._fin = !1, this._opcode = 0, 
     this._totalPayloadLength = 0, this._messageLength = 0, this._fragments = [], this._state = 0, 
     this._loop = !1;
    }
    _write(chunk, encoding, cb) {
     if (8 === this._opcode && 0 == this._state) return cb();
     this._bufferedBytes += chunk.length, this._buffers.push(chunk), this.startLoop(cb);
    }
    consume(n) {
     if (this._bufferedBytes -= n, n === this._buffers[0].length) return this._buffers.shift();
     if (n < this._buffers[0].length) {
      const buf = this._buffers[0];
      return this._buffers[0] = buf.slice(n), buf.slice(0, n);
     }
     const dst = Buffer.allocUnsafe(n);
     do {
      const buf = this._buffers[0], offset = dst.length - n;
      n >= buf.length ? dst.set(this._buffers.shift(), offset) : (dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset), 
      this._buffers[0] = buf.slice(n)), n -= buf.length;
     } while (n > 0);
     return dst;
    }
    startLoop(cb) {
     let err;
     this._loop = !0;
     do {
      switch (this._state) {
      case 0:
       err = this.getInfo();
       break;

      case 1:
       err = this.getPayloadLength16();
       break;

      case 2:
       err = this.getPayloadLength64();
       break;

      case 3:
       this.getMask();
       break;

      case 4:
       err = this.getData(cb);
       break;

      default:
       return void (this._loop = !1);
      }
     } while (this._loop);
     cb(err);
    }
    getInfo() {
     if (this._bufferedBytes < 2) return void (this._loop = !1);
     const buf = this.consume(2);
     if (48 & buf[0]) return this._loop = !1, error(RangeError, "RSV2 and RSV3 must be clear", !0, 1002, "WS_ERR_UNEXPECTED_RSV_2_3");
     const compressed = !(64 & ~buf[0]);
     if (compressed && !this._extensions[PerMessageDeflate.extensionName]) return this._loop = !1, 
     error(RangeError, "RSV1 must be clear", !0, 1002, "WS_ERR_UNEXPECTED_RSV_1");
     if (this._fin = !(128 & ~buf[0]), this._opcode = 15 & buf[0], this._payloadLength = 127 & buf[1], 
     0 === this._opcode) {
      if (compressed) return this._loop = !1, error(RangeError, "RSV1 must be clear", !0, 1002, "WS_ERR_UNEXPECTED_RSV_1");
      if (!this._fragmented) return this._loop = !1, error(RangeError, "invalid opcode 0", !0, 1002, "WS_ERR_INVALID_OPCODE");
      this._opcode = this._fragmented;
     } else if (1 === this._opcode || 2 === this._opcode) {
      if (this._fragmented) return this._loop = !1, error(RangeError, `invalid opcode ${this._opcode}`, !0, 1002, "WS_ERR_INVALID_OPCODE");
      this._compressed = compressed;
     } else {
      if (!(this._opcode > 7 && this._opcode < 11)) return this._loop = !1, error(RangeError, `invalid opcode ${this._opcode}`, !0, 1002, "WS_ERR_INVALID_OPCODE");
      if (!this._fin) return this._loop = !1, error(RangeError, "FIN must be set", !0, 1002, "WS_ERR_EXPECTED_FIN");
      if (compressed) return this._loop = !1, error(RangeError, "RSV1 must be clear", !0, 1002, "WS_ERR_UNEXPECTED_RSV_1");
      if (this._payloadLength > 125) return this._loop = !1, error(RangeError, `invalid payload length ${this._payloadLength}`, !0, 1002, "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH");
     }
     if (this._fin || this._fragmented || (this._fragmented = this._opcode), this._masked = !(128 & ~buf[1]), 
     this._isServer) {
      if (!this._masked) return this._loop = !1, error(RangeError, "MASK must be set", !0, 1002, "WS_ERR_EXPECTED_MASK");
     } else if (this._masked) return this._loop = !1, error(RangeError, "MASK must be clear", !0, 1002, "WS_ERR_UNEXPECTED_MASK");
     if (126 === this._payloadLength) this._state = 1; else {
      if (127 !== this._payloadLength) return this.haveLength();
      this._state = 2;
     }
    }
    getPayloadLength16() {
     if (!(this._bufferedBytes < 2)) return this._payloadLength = this.consume(2).readUInt16BE(0), 
     this.haveLength();
     this._loop = !1;
    }
    getPayloadLength64() {
     if (this._bufferedBytes < 8) return void (this._loop = !1);
     const buf = this.consume(8), num = buf.readUInt32BE(0);
     return num > Math.pow(2, 21) - 1 ? (this._loop = !1, error(RangeError, "Unsupported WebSocket frame: payload length > 2^53 - 1", !1, 1009, "WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH")) : (this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4), 
     this.haveLength());
    }
    haveLength() {
     if (this._payloadLength && this._opcode < 8 && (this._totalPayloadLength += this._payloadLength, 
     this._totalPayloadLength > this._maxPayload && this._maxPayload > 0)) return this._loop = !1, 
     error(RangeError, "Max payload size exceeded", !1, 1009, "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH");
     this._masked ? this._state = 3 : this._state = 4;
    }
    getMask() {
     this._bufferedBytes < 4 ? this._loop = !1 : (this._mask = this.consume(4), this._state = 4);
    }
    getData(cb) {
     let data = EMPTY_BUFFER;
     if (this._payloadLength) {
      if (this._bufferedBytes < this._payloadLength) return void (this._loop = !1);
      data = this.consume(this._payloadLength), this._masked && unmask(data, this._mask);
     }
     return this._opcode > 7 ? this.controlMessage(data) : this._compressed ? (this._state = 5, 
     void this.decompress(data, cb)) : (data.length && (this._messageLength = this._totalPayloadLength, 
     this._fragments.push(data)), this.dataMessage());
    }
    decompress(data, cb) {
     this._extensions[PerMessageDeflate.extensionName].decompress(data, this._fin, ((err, buf) => {
      if (err) return cb(err);
      if (buf.length) {
       if (this._messageLength += buf.length, this._messageLength > this._maxPayload && this._maxPayload > 0) return cb(error(RangeError, "Max payload size exceeded", !1, 1009, "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"));
       this._fragments.push(buf);
      }
      const er = this.dataMessage();
      if (er) return cb(er);
      this.startLoop(cb);
     }));
    }
    dataMessage() {
     if (this._fin) {
      const messageLength = this._messageLength, fragments = this._fragments;
      if (this._totalPayloadLength = 0, this._messageLength = 0, this._fragmented = 0, 
      this._fragments = [], 2 === this._opcode) {
       let data;
       data = "nodebuffer" === this._binaryType ? concat(fragments, messageLength) : "arraybuffer" === this._binaryType ? toArrayBuffer(concat(fragments, messageLength)) : fragments, 
       this.emit("message", data);
      } else {
       const buf = concat(fragments, messageLength);
       if (!isValidUTF8(buf)) return this._loop = !1, error(Error, "invalid UTF-8 sequence", !0, 1007, "WS_ERR_INVALID_UTF8");
       this.emit("message", buf.toString());
      }
     }
     this._state = 0;
    }
    controlMessage(data) {
     if (8 === this._opcode) if (this._loop = !1, 0 === data.length) this.emit("conclude", 1005, ""), 
     this.end(); else {
      if (1 === data.length) return error(RangeError, "invalid payload length 1", !0, 1002, "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH");
      {
       const code = data.readUInt16BE(0);
       if (!isValidStatusCode(code)) return error(RangeError, `invalid status code ${code}`, !0, 1002, "WS_ERR_INVALID_CLOSE_CODE");
       const buf = data.slice(2);
       if (!isValidUTF8(buf)) return error(Error, "invalid UTF-8 sequence", !0, 1007, "WS_ERR_INVALID_UTF8");
       this.emit("conclude", code, buf.toString()), this.end();
      }
     } else 9 === this._opcode ? this.emit("ping", data) : this.emit("pong", data);
     this._state = 0;
    }
   };
  },
  93961: (module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   __webpack_require__(69278), __webpack_require__(64756);
   const {randomFillSync} = __webpack_require__(76982), PerMessageDeflate = __webpack_require__(16228), {EMPTY_BUFFER} = __webpack_require__(54011), {isValidStatusCode} = __webpack_require__(2659), {mask: applyMask, toBuffer} = __webpack_require__(26383), mask = Buffer.alloc(4);
   class Sender {
    constructor(socket, extensions) {
     this._extensions = extensions || {}, this._socket = socket, this._firstFragment = !0, 
     this._compress = !1, this._bufferedBytes = 0, this._deflating = !1, this._queue = [];
    }
    static frame(data, options) {
     const merge = options.mask && options.readOnly;
     let offset = options.mask ? 6 : 2, payloadLength = data.length;
     data.length >= 65536 ? (offset += 8, payloadLength = 127) : data.length > 125 && (offset += 2, 
     payloadLength = 126);
     const target = Buffer.allocUnsafe(merge ? data.length + offset : offset);
     return target[0] = options.fin ? 128 | options.opcode : options.opcode, options.rsv1 && (target[0] |= 64), 
     target[1] = payloadLength, 126 === payloadLength ? target.writeUInt16BE(data.length, 2) : 127 === payloadLength && (target.writeUInt32BE(0, 2), 
     target.writeUInt32BE(data.length, 6)), options.mask ? (randomFillSync(mask, 0, 4), 
     target[1] |= 128, target[offset - 4] = mask[0], target[offset - 3] = mask[1], target[offset - 2] = mask[2], 
     target[offset - 1] = mask[3], merge ? (applyMask(data, mask, target, offset, data.length), 
     [ target ]) : (applyMask(data, mask, data, 0, data.length), [ target, data ])) : [ target, data ];
    }
    close(code, data, mask, cb) {
     let buf;
     if (void 0 === code) buf = EMPTY_BUFFER; else {
      if ("number" != typeof code || !isValidStatusCode(code)) throw new TypeError("First argument must be a valid error code number");
      if (void 0 === data || "" === data) buf = Buffer.allocUnsafe(2), buf.writeUInt16BE(code, 0); else {
       const length = Buffer.byteLength(data);
       if (length > 123) throw new RangeError("The message must not be greater than 123 bytes");
       buf = Buffer.allocUnsafe(2 + length), buf.writeUInt16BE(code, 0), buf.write(data, 2);
      }
     }
     this._deflating ? this.enqueue([ this.doClose, buf, mask, cb ]) : this.doClose(buf, mask, cb);
    }
    doClose(data, mask, cb) {
     this.sendFrame(Sender.frame(data, {
      fin: !0,
      rsv1: !1,
      opcode: 8,
      mask,
      readOnly: !1
     }), cb);
    }
    ping(data, mask, cb) {
     const buf = toBuffer(data);
     if (buf.length > 125) throw new RangeError("The data size must not be greater than 125 bytes");
     this._deflating ? this.enqueue([ this.doPing, buf, mask, toBuffer.readOnly, cb ]) : this.doPing(buf, mask, toBuffer.readOnly, cb);
    }
    doPing(data, mask, readOnly, cb) {
     this.sendFrame(Sender.frame(data, {
      fin: !0,
      rsv1: !1,
      opcode: 9,
      mask,
      readOnly
     }), cb);
    }
    pong(data, mask, cb) {
     const buf = toBuffer(data);
     if (buf.length > 125) throw new RangeError("The data size must not be greater than 125 bytes");
     this._deflating ? this.enqueue([ this.doPong, buf, mask, toBuffer.readOnly, cb ]) : this.doPong(buf, mask, toBuffer.readOnly, cb);
    }
    doPong(data, mask, readOnly, cb) {
     this.sendFrame(Sender.frame(data, {
      fin: !0,
      rsv1: !1,
      opcode: 10,
      mask,
      readOnly
     }), cb);
    }
    send(data, options, cb) {
     const buf = toBuffer(data), perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
     let opcode = options.binary ? 2 : 1, rsv1 = options.compress;
     if (this._firstFragment ? (this._firstFragment = !1, rsv1 && perMessageDeflate && (rsv1 = buf.length >= perMessageDeflate._threshold), 
     this._compress = rsv1) : (rsv1 = !1, opcode = 0), options.fin && (this._firstFragment = !0), 
     perMessageDeflate) {
      const opts = {
       fin: options.fin,
       rsv1,
       opcode,
       mask: options.mask,
       readOnly: toBuffer.readOnly
      };
      this._deflating ? this.enqueue([ this.dispatch, buf, this._compress, opts, cb ]) : this.dispatch(buf, this._compress, opts, cb);
     } else this.sendFrame(Sender.frame(buf, {
      fin: options.fin,
      rsv1: !1,
      opcode,
      mask: options.mask,
      readOnly: toBuffer.readOnly
     }), cb);
    }
    dispatch(data, compress, options, cb) {
     if (!compress) return void this.sendFrame(Sender.frame(data, options), cb);
     const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
     this._bufferedBytes += data.length, this._deflating = !0, perMessageDeflate.compress(data, options.fin, ((_, buf) => {
      if (this._socket.destroyed) {
       const err = new Error("The socket was closed while data was being compressed");
       "function" == typeof cb && cb(err);
       for (let i = 0; i < this._queue.length; i++) {
        const callback = this._queue[i][4];
        "function" == typeof callback && callback(err);
       }
      } else this._bufferedBytes -= data.length, this._deflating = !1, options.readOnly = !1, 
      this.sendFrame(Sender.frame(buf, options), cb), this.dequeue();
     }));
    }
    dequeue() {
     for (;!this._deflating && this._queue.length; ) {
      const params = this._queue.shift();
      this._bufferedBytes -= params[1].length, Reflect.apply(params[0], this, params.slice(1));
     }
    }
    enqueue(params) {
     this._bufferedBytes += params[1].length, this._queue.push(params);
    }
    sendFrame(list, cb) {
     2 === list.length ? (this._socket.cork(), this._socket.write(list[0]), this._socket.write(list[1], cb), 
     this._socket.uncork()) : this._socket.write(list[0], cb);
    }
   }
   module.exports = Sender;
  },
  40432: (module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   const {Duplex} = __webpack_require__(2203);
   function emitClose(stream) {
    stream.emit("close");
   }
   function duplexOnEnd() {
    !this.destroyed && this._writableState.finished && this.destroy();
   }
   function duplexOnError(err) {
    this.removeListener("error", duplexOnError), this.destroy(), 0 === this.listenerCount("error") && this.emit("error", err);
   }
   module.exports = function(ws, options) {
    let resumeOnReceiverDrain = !0, terminateOnDestroy = !0;
    function receiverOnDrain() {
     resumeOnReceiverDrain && ws._socket.resume();
    }
    ws.readyState === ws.CONNECTING ? ws.once("open", (function() {
     ws._receiver.removeAllListeners("drain"), ws._receiver.on("drain", receiverOnDrain);
    })) : (ws._receiver.removeAllListeners("drain"), ws._receiver.on("drain", receiverOnDrain));
    const duplex = new Duplex({
     ...options,
     autoDestroy: !1,
     emitClose: !1,
     objectMode: !1,
     writableObjectMode: !1
    });
    return ws.on("message", (function(msg) {
     duplex.push(msg) || (resumeOnReceiverDrain = !1, ws._socket.pause());
    })), ws.once("error", (function(err) {
     duplex.destroyed || (terminateOnDestroy = !1, duplex.destroy(err));
    })), ws.once("close", (function() {
     duplex.destroyed || duplex.push(null);
    })), duplex._destroy = function(err, callback) {
     if (ws.readyState === ws.CLOSED) return callback(err), void process.nextTick(emitClose, duplex);
     let called = !1;
     ws.once("error", (function(err) {
      called = !0, callback(err);
     })), ws.once("close", (function() {
      called || callback(err), process.nextTick(emitClose, duplex);
     })), terminateOnDestroy && ws.terminate();
    }, duplex._final = function(callback) {
     ws.readyState !== ws.CONNECTING ? null !== ws._socket && (ws._socket._writableState.finished ? (callback(), 
     duplex._readableState.endEmitted && duplex.destroy()) : (ws._socket.once("finish", (function() {
      callback();
     })), ws.close())) : ws.once("open", (function() {
      duplex._final(callback);
     }));
    }, duplex._read = function() {
     ws.readyState !== ws.OPEN && ws.readyState !== ws.CLOSING || resumeOnReceiverDrain || (resumeOnReceiverDrain = !0, 
     ws._receiver._writableState.needDrain || ws._socket.resume());
    }, duplex._write = function(chunk, encoding, callback) {
     ws.readyState !== ws.CONNECTING ? ws.send(chunk, callback) : ws.once("open", (function() {
      duplex._write(chunk, encoding, callback);
     }));
    }, duplex.on("end", duplexOnEnd), duplex.on("error", duplexOnError), duplex;
   };
  },
  2659: (module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   function isValidStatusCode(code) {
    return code >= 1e3 && code <= 1014 && 1004 !== code && 1005 !== code && 1006 !== code || code >= 3e3 && code <= 4999;
   }
   function _isValidUTF8(buf) {
    const len = buf.length;
    let i = 0;
    for (;i < len; ) if (128 & buf[i]) if (192 == (224 & buf[i])) {
     if (i + 1 === len || 128 != (192 & buf[i + 1]) || 192 == (254 & buf[i])) return !1;
     i += 2;
    } else if (224 == (240 & buf[i])) {
     if (i + 2 >= len || 128 != (192 & buf[i + 1]) || 128 != (192 & buf[i + 2]) || 224 === buf[i] && 128 == (224 & buf[i + 1]) || 237 === buf[i] && 160 == (224 & buf[i + 1])) return !1;
     i += 3;
    } else {
     if (240 != (248 & buf[i])) return !1;
     if (i + 3 >= len || 128 != (192 & buf[i + 1]) || 128 != (192 & buf[i + 2]) || 128 != (192 & buf[i + 3]) || 240 === buf[i] && 128 == (240 & buf[i + 1]) || 244 === buf[i] && buf[i + 1] > 143 || buf[i] > 244) return !1;
     i += 4;
    } else i++;
    return !0;
   }
   try {
    let isValidUTF8 = __webpack_require__(Object(function() {
     var e = new Error("Cannot find module 'utf-8-validate'");
     throw e.code = "MODULE_NOT_FOUND", e;
    }()));
    "object" == typeof isValidUTF8 && (isValidUTF8 = isValidUTF8.Validation.isValidUTF8), 
    module.exports = {
     isValidStatusCode,
     isValidUTF8: buf => buf.length < 150 ? _isValidUTF8(buf) : isValidUTF8(buf)
    };
   } catch (e) {
    module.exports = {
     isValidStatusCode,
     isValidUTF8: _isValidUTF8
    };
   }
  },
  29573: (module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   const EventEmitter = __webpack_require__(24434), http = __webpack_require__(58611), {createHash} = (__webpack_require__(65692), 
   __webpack_require__(69278), __webpack_require__(64756), __webpack_require__(76982)), PerMessageDeflate = __webpack_require__(16228), WebSocket = __webpack_require__(39317), {format, parse} = __webpack_require__(70427), {GUID, kWebSocket} = __webpack_require__(54011), keyRegex = /^[+/0-9A-Za-z]{22}==$/;
   function emitClose(server) {
    server._state = 2, server.emit("close");
   }
   function socketOnError() {
    this.destroy();
   }
   function abortHandshake(socket, code, message, headers) {
    socket.writable && (message = message || http.STATUS_CODES[code], headers = {
     Connection: "close",
     "Content-Type": "text/html",
     "Content-Length": Buffer.byteLength(message),
     ...headers
    }, socket.write(`HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\r\n` + Object.keys(headers).map((h => `${h}: ${headers[h]}`)).join("\r\n") + "\r\n\r\n" + message)), 
    socket.removeListener("error", socketOnError), socket.destroy();
   }
   function trim(str) {
    return str.trim();
   }
   module.exports = class extends EventEmitter {
    constructor(options, callback) {
     if (super(), null == (options = {
      maxPayload: 104857600,
      perMessageDeflate: !1,
      handleProtocols: null,
      clientTracking: !0,
      verifyClient: null,
      noServer: !1,
      backlog: null,
      server: null,
      host: null,
      path: null,
      port: null,
      ...options
     }).port && !options.server && !options.noServer || null != options.port && (options.server || options.noServer) || options.server && options.noServer) throw new TypeError('One and only one of the "port", "server", or "noServer" options must be specified');
     if (null != options.port ? (this._server = http.createServer(((req, res) => {
      const body = http.STATUS_CODES[426];
      res.writeHead(426, {
       "Content-Length": body.length,
       "Content-Type": "text/plain"
      }), res.end(body);
     })), this._server.listen(options.port, options.host, options.backlog, callback)) : options.server && (this._server = options.server), 
     this._server) {
      const emitConnection = this.emit.bind(this, "connection");
      this._removeListeners = function(server, map) {
       for (const event of Object.keys(map)) server.on(event, map[event]);
       return function() {
        for (const event of Object.keys(map)) server.removeListener(event, map[event]);
       };
      }(this._server, {
       listening: this.emit.bind(this, "listening"),
       error: this.emit.bind(this, "error"),
       upgrade: (req, socket, head) => {
        this.handleUpgrade(req, socket, head, emitConnection);
       }
      });
     }
     !0 === options.perMessageDeflate && (options.perMessageDeflate = {}), options.clientTracking && (this.clients = new Set), 
     this.options = options, this._state = 0;
    }
    address() {
     if (this.options.noServer) throw new Error('The server is operating in "noServer" mode');
     return this._server ? this._server.address() : null;
    }
    close(cb) {
     if (cb && this.once("close", cb), 2 === this._state) return void process.nextTick(emitClose, this);
     if (1 === this._state) return;
     if (this._state = 1, this.clients) for (const client of this.clients) client.terminate();
     const server = this._server;
     server && (this._removeListeners(), this._removeListeners = this._server = null, 
     null != this.options.port) ? server.close(emitClose.bind(void 0, this)) : process.nextTick(emitClose, this);
    }
    shouldHandle(req) {
     if (this.options.path) {
      const index = req.url.indexOf("?");
      if ((-1 !== index ? req.url.slice(0, index) : req.url) !== this.options.path) return !1;
     }
     return !0;
    }
    handleUpgrade(req, socket, head, cb) {
     socket.on("error", socketOnError);
     const key = void 0 !== req.headers["sec-websocket-key"] && req.headers["sec-websocket-key"].trim(), upgrade = req.headers.upgrade, version = +req.headers["sec-websocket-version"], extensions = {};
     if ("GET" !== req.method || void 0 === upgrade || "websocket" !== upgrade.toLowerCase() || !key || !keyRegex.test(key) || 8 !== version && 13 !== version || !this.shouldHandle(req)) return abortHandshake(socket, 400);
     if (this.options.perMessageDeflate) {
      const perMessageDeflate = new PerMessageDeflate(this.options.perMessageDeflate, !0, this.options.maxPayload);
      try {
       const offers = parse(req.headers["sec-websocket-extensions"]);
       offers[PerMessageDeflate.extensionName] && (perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]), 
       extensions[PerMessageDeflate.extensionName] = perMessageDeflate);
      } catch (err) {
       return abortHandshake(socket, 400);
      }
     }
     if (this.options.verifyClient) {
      const info = {
       origin: req.headers["" + (8 === version ? "sec-websocket-origin" : "origin")],
       secure: !(!req.socket.authorized && !req.socket.encrypted),
       req
      };
      if (2 === this.options.verifyClient.length) return void this.options.verifyClient(info, ((verified, code, message, headers) => {
       if (!verified) return abortHandshake(socket, code || 401, message, headers);
       this.completeUpgrade(key, extensions, req, socket, head, cb);
      }));
      if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);
     }
     this.completeUpgrade(key, extensions, req, socket, head, cb);
    }
    completeUpgrade(key, extensions, req, socket, head, cb) {
     if (!socket.readable || !socket.writable) return socket.destroy();
     if (socket[kWebSocket]) throw new Error("server.handleUpgrade() was called more than once with the same socket, possibly due to a misconfiguration");
     if (this._state > 0) return abortHandshake(socket, 503);
     const headers = [ "HTTP/1.1 101 Switching Protocols", "Upgrade: websocket", "Connection: Upgrade", `Sec-WebSocket-Accept: ${createHash("sha1").update(key + GUID).digest("base64")}` ], ws = new WebSocket(null);
     let protocol = req.headers["sec-websocket-protocol"];
     if (protocol && (protocol = protocol.split(",").map(trim), protocol = this.options.handleProtocols ? this.options.handleProtocols(protocol, req) : protocol[0], 
     protocol && (headers.push(`Sec-WebSocket-Protocol: ${protocol}`), ws._protocol = protocol)), 
     extensions[PerMessageDeflate.extensionName]) {
      const params = extensions[PerMessageDeflate.extensionName].params, value = format({
       [PerMessageDeflate.extensionName]: [ params ]
      });
      headers.push(`Sec-WebSocket-Extensions: ${value}`), ws._extensions = extensions;
     }
     this.emit("headers", headers, req), socket.write(headers.concat("\r\n").join("\r\n")), 
     socket.removeListener("error", socketOnError), ws.setSocket(socket, head, this.options.maxPayload), 
     this.clients && (this.clients.add(ws), ws.on("close", (() => this.clients.delete(ws)))), 
     cb(ws, req);
    }
   };
  },
  39317: (module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   const EventEmitter = __webpack_require__(24434), https = __webpack_require__(65692), http = __webpack_require__(58611), net = __webpack_require__(69278), tls = __webpack_require__(64756), {randomBytes, createHash} = __webpack_require__(76982), {Readable} = __webpack_require__(2203), {URL} = __webpack_require__(87016), PerMessageDeflate = __webpack_require__(16228), Receiver = __webpack_require__(27049), Sender = __webpack_require__(93961), {BINARY_TYPES, EMPTY_BUFFER, GUID, kStatusCode, kWebSocket, NOOP} = __webpack_require__(54011), {addEventListener, removeEventListener} = __webpack_require__(62134), {format, parse} = __webpack_require__(70427), {toBuffer} = __webpack_require__(26383), readyStates = [ "CONNECTING", "OPEN", "CLOSING", "CLOSED" ], protocolVersions = [ 8, 13 ];
   class WebSocket extends EventEmitter {
    constructor(address, protocols, options) {
     super(), this._binaryType = BINARY_TYPES[0], this._closeCode = 1006, this._closeFrameReceived = !1, 
     this._closeFrameSent = !1, this._closeMessage = "", this._closeTimer = null, this._extensions = {}, 
     this._protocol = "", this._readyState = WebSocket.CONNECTING, this._receiver = null, 
     this._sender = null, this._socket = null, null !== address ? (this._bufferedAmount = 0, 
     this._isServer = !1, this._redirects = 0, Array.isArray(protocols) ? protocols = protocols.join(", ") : "object" == typeof protocols && null !== protocols && (options = protocols, 
     protocols = void 0), initAsClient(this, address, protocols, options)) : this._isServer = !0;
    }
    get binaryType() {
     return this._binaryType;
    }
    set binaryType(type) {
     BINARY_TYPES.includes(type) && (this._binaryType = type, this._receiver && (this._receiver._binaryType = type));
    }
    get bufferedAmount() {
     return this._socket ? this._socket._writableState.length + this._sender._bufferedBytes : this._bufferedAmount;
    }
    get extensions() {
     return Object.keys(this._extensions).join();
    }
    get onclose() {}
    set onclose(listener) {}
    get onerror() {}
    set onerror(listener) {}
    get onopen() {}
    set onopen(listener) {}
    get onmessage() {}
    set onmessage(listener) {}
    get protocol() {
     return this._protocol;
    }
    get readyState() {
     return this._readyState;
    }
    get url() {
     return this._url;
    }
    setSocket(socket, head, maxPayload) {
     const receiver = new Receiver(this.binaryType, this._extensions, this._isServer, maxPayload);
     this._sender = new Sender(socket, this._extensions), this._receiver = receiver, 
     this._socket = socket, receiver[kWebSocket] = this, socket[kWebSocket] = this, receiver.on("conclude", receiverOnConclude), 
     receiver.on("drain", receiverOnDrain), receiver.on("error", receiverOnError), receiver.on("message", receiverOnMessage), 
     receiver.on("ping", receiverOnPing), receiver.on("pong", receiverOnPong), socket.setTimeout(0), 
     socket.setNoDelay(), head.length > 0 && socket.unshift(head), socket.on("close", socketOnClose), 
     socket.on("data", socketOnData), socket.on("end", socketOnEnd), socket.on("error", socketOnError), 
     this._readyState = WebSocket.OPEN, this.emit("open");
    }
    emitClose() {
     if (!this._socket) return this._readyState = WebSocket.CLOSED, void this.emit("close", this._closeCode, this._closeMessage);
     this._extensions[PerMessageDeflate.extensionName] && this._extensions[PerMessageDeflate.extensionName].cleanup(), 
     this._receiver.removeAllListeners(), this._readyState = WebSocket.CLOSED, this.emit("close", this._closeCode, this._closeMessage);
    }
    close(code, data) {
     if (this.readyState !== WebSocket.CLOSED) {
      if (this.readyState === WebSocket.CONNECTING) {
       const msg = "WebSocket was closed before the connection was established";
       return abortHandshake(this, this._req, msg);
      }
      this.readyState !== WebSocket.CLOSING ? (this._readyState = WebSocket.CLOSING, this._sender.close(code, data, !this._isServer, (err => {
       err || (this._closeFrameSent = !0, (this._closeFrameReceived || this._receiver._writableState.errorEmitted) && this._socket.end());
      })), this._closeTimer = setTimeout(this._socket.destroy.bind(this._socket), 3e4)) : this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted) && this._socket.end();
     }
    }
    ping(data, mask, cb) {
     if (this.readyState === WebSocket.CONNECTING) throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
     "function" == typeof data ? (cb = data, data = mask = void 0) : "function" == typeof mask && (cb = mask, 
     mask = void 0), "number" == typeof data && (data = data.toString()), this.readyState === WebSocket.OPEN ? (void 0 === mask && (mask = !this._isServer), 
     this._sender.ping(data || EMPTY_BUFFER, mask, cb)) : sendAfterClose(this, data, cb);
    }
    pong(data, mask, cb) {
     if (this.readyState === WebSocket.CONNECTING) throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
     "function" == typeof data ? (cb = data, data = mask = void 0) : "function" == typeof mask && (cb = mask, 
     mask = void 0), "number" == typeof data && (data = data.toString()), this.readyState === WebSocket.OPEN ? (void 0 === mask && (mask = !this._isServer), 
     this._sender.pong(data || EMPTY_BUFFER, mask, cb)) : sendAfterClose(this, data, cb);
    }
    send(data, options, cb) {
     if (this.readyState === WebSocket.CONNECTING) throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
     if ("function" == typeof options && (cb = options, options = {}), "number" == typeof data && (data = data.toString()), 
     this.readyState !== WebSocket.OPEN) return void sendAfterClose(this, data, cb);
     const opts = {
      binary: "string" != typeof data,
      mask: !this._isServer,
      compress: !0,
      fin: !0,
      ...options
     };
     this._extensions[PerMessageDeflate.extensionName] || (opts.compress = !1), this._sender.send(data || EMPTY_BUFFER, opts, cb);
    }
    terminate() {
     if (this.readyState !== WebSocket.CLOSED) {
      if (this.readyState === WebSocket.CONNECTING) {
       const msg = "WebSocket was closed before the connection was established";
       return abortHandshake(this, this._req, msg);
      }
      this._socket && (this._readyState = WebSocket.CLOSING, this._socket.destroy());
     }
    }
   }
   function initAsClient(websocket, address, protocols, options) {
    const opts = {
     protocolVersion: protocolVersions[1],
     maxPayload: 104857600,
     perMessageDeflate: !0,
     followRedirects: !1,
     maxRedirects: 10,
     ...options,
     createConnection: void 0,
     socketPath: void 0,
     hostname: void 0,
     protocol: void 0,
     timeout: void 0,
     method: void 0,
     host: void 0,
     path: void 0,
     port: void 0
    };
    if (!protocolVersions.includes(opts.protocolVersion)) throw new RangeError(`Unsupported protocol version: ${opts.protocolVersion} (supported versions: ${protocolVersions.join(", ")})`);
    let parsedUrl;
    address instanceof URL ? (parsedUrl = address, websocket._url = address.href) : (parsedUrl = new URL(address), 
    websocket._url = address);
    const isUnixSocket = "ws+unix:" === parsedUrl.protocol;
    if (!(parsedUrl.host || isUnixSocket && parsedUrl.pathname)) {
     const err = new Error(`Invalid URL: ${websocket.url}`);
     if (0 === websocket._redirects) throw err;
     return void emitErrorAndClose(websocket, err);
    }
    const isSecure = "wss:" === parsedUrl.protocol || "https:" === parsedUrl.protocol, defaultPort = isSecure ? 443 : 80, key = randomBytes(16).toString("base64"), get = isSecure ? https.get : http.get;
    let perMessageDeflate;
    if (opts.createConnection = isSecure ? tlsConnect : netConnect, opts.defaultPort = opts.defaultPort || defaultPort, 
    opts.port = parsedUrl.port || defaultPort, opts.host = parsedUrl.hostname.startsWith("[") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname, 
    opts.headers = {
     "Sec-WebSocket-Version": opts.protocolVersion,
     "Sec-WebSocket-Key": key,
     Connection: "Upgrade",
     Upgrade: "websocket",
     ...opts.headers
    }, opts.path = parsedUrl.pathname + parsedUrl.search, opts.timeout = opts.handshakeTimeout, 
    opts.perMessageDeflate && (perMessageDeflate = new PerMessageDeflate(!0 !== opts.perMessageDeflate ? opts.perMessageDeflate : {}, !1, opts.maxPayload), 
    opts.headers["Sec-WebSocket-Extensions"] = format({
     [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
    })), protocols && (opts.headers["Sec-WebSocket-Protocol"] = protocols), opts.origin && (opts.protocolVersion < 13 ? opts.headers["Sec-WebSocket-Origin"] = opts.origin : opts.headers.Origin = opts.origin), 
    (parsedUrl.username || parsedUrl.password) && (opts.auth = `${parsedUrl.username}:${parsedUrl.password}`), 
    isUnixSocket) {
     const parts = opts.path.split(":");
     opts.socketPath = parts[0], opts.path = parts[1];
    }
    if (opts.followRedirects) {
     if (0 === websocket._redirects) {
      websocket._originalUnixSocket = isUnixSocket, websocket._originalSecure = isSecure, 
      websocket._originalHostOrSocketPath = isUnixSocket ? opts.socketPath : parsedUrl.host;
      const headers = options && options.headers;
      if (options = {
       ...options,
       headers: {}
      }, headers) for (const [key, value] of Object.entries(headers)) options.headers[key.toLowerCase()] = value;
     } else {
      const isSameHost = isUnixSocket ? !!websocket._originalUnixSocket && opts.socketPath === websocket._originalHostOrSocketPath : !websocket._originalUnixSocket && parsedUrl.host === websocket._originalHostOrSocketPath;
      (!isSameHost || websocket._originalSecure && !isSecure) && (delete opts.headers.authorization, 
      delete opts.headers.cookie, isSameHost || delete opts.headers.host, opts.auth = void 0);
     }
     opts.auth && !options.headers.authorization && (options.headers.authorization = "Basic " + Buffer.from(opts.auth).toString("base64"));
    }
    let req = websocket._req = get(opts);
    opts.timeout && req.on("timeout", (() => {
     abortHandshake(websocket, req, "Opening handshake has timed out");
    })), req.on("error", (err => {
     null === req || req.aborted || (req = websocket._req = null, emitErrorAndClose(websocket, err));
    })), req.on("response", (res => {
     const location = res.headers.location, statusCode = res.statusCode;
     if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
      if (++websocket._redirects > opts.maxRedirects) return void abortHandshake(websocket, req, "Maximum redirects exceeded");
      let addr;
      req.abort();
      try {
       addr = new URL(location, address);
      } catch (err) {
       return void emitErrorAndClose(websocket, err);
      }
      initAsClient(websocket, addr, protocols, options);
     } else websocket.emit("unexpected-response", req, res) || abortHandshake(websocket, req, `Unexpected server response: ${res.statusCode}`);
    })), req.on("upgrade", ((res, socket, head) => {
     if (websocket.emit("upgrade", res), websocket.readyState !== WebSocket.CONNECTING) return;
     req = websocket._req = null;
     const upgrade = res.headers.upgrade;
     if (void 0 === upgrade || "websocket" !== upgrade.toLowerCase()) return void abortHandshake(websocket, socket, "Invalid Upgrade header");
     const digest = createHash("sha1").update(key + GUID).digest("base64");
     if (res.headers["sec-websocket-accept"] !== digest) return void abortHandshake(websocket, socket, "Invalid Sec-WebSocket-Accept header");
     const serverProt = res.headers["sec-websocket-protocol"], protList = (protocols || "").split(/, */);
     let protError;
     if (!protocols && serverProt ? protError = "Server sent a subprotocol but none was requested" : protocols && !serverProt ? protError = "Server sent no subprotocol" : serverProt && !protList.includes(serverProt) && (protError = "Server sent an invalid subprotocol"), 
     protError) return void abortHandshake(websocket, socket, protError);
     serverProt && (websocket._protocol = serverProt);
     const secWebSocketExtensions = res.headers["sec-websocket-extensions"];
     if (void 0 !== secWebSocketExtensions) {
      if (!perMessageDeflate) {
       return void abortHandshake(websocket, socket, "Server sent a Sec-WebSocket-Extensions header but no extension was requested");
      }
      let extensions;
      try {
       extensions = parse(secWebSocketExtensions);
      } catch (err) {
       return void abortHandshake(websocket, socket, "Invalid Sec-WebSocket-Extensions header");
      }
      const extensionNames = Object.keys(extensions);
      if (extensionNames.length) {
       if (1 !== extensionNames.length || extensionNames[0] !== PerMessageDeflate.extensionName) {
        return void abortHandshake(websocket, socket, "Server indicated an extension that was not requested");
       }
       try {
        perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
       } catch (err) {
        return void abortHandshake(websocket, socket, "Invalid Sec-WebSocket-Extensions header");
       }
       websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
      }
     }
     websocket.setSocket(socket, head, opts.maxPayload);
    }));
   }
   function emitErrorAndClose(websocket, err) {
    websocket._readyState = WebSocket.CLOSING, websocket.emit("error", err), websocket.emitClose();
   }
   function netConnect(options) {
    return options.path = options.socketPath, net.connect(options);
   }
   function tlsConnect(options) {
    return options.path = void 0, options.servername || "" === options.servername || (options.servername = net.isIP(options.host) ? "" : options.host), 
    tls.connect(options);
   }
   function abortHandshake(websocket, stream, message) {
    websocket._readyState = WebSocket.CLOSING;
    const err = new Error(message);
    Error.captureStackTrace(err, abortHandshake), stream.setHeader ? (stream.abort(), 
    stream.socket && !stream.socket.destroyed && stream.socket.destroy(), stream.once("abort", websocket.emitClose.bind(websocket)), 
    websocket.emit("error", err)) : (stream.destroy(err), stream.once("error", websocket.emit.bind(websocket, "error")), 
    stream.once("close", websocket.emitClose.bind(websocket)));
   }
   function sendAfterClose(websocket, data, cb) {
    if (data) {
     const length = toBuffer(data).length;
     websocket._socket ? websocket._sender._bufferedBytes += length : websocket._bufferedAmount += length;
    }
    if (cb) {
     cb(new Error(`WebSocket is not open: readyState ${websocket.readyState} (${readyStates[websocket.readyState]})`));
    }
   }
   function receiverOnConclude(code, reason) {
    const websocket = this[kWebSocket];
    websocket._closeFrameReceived = !0, websocket._closeMessage = reason, websocket._closeCode = code, 
    void 0 !== websocket._socket[kWebSocket] && (websocket._socket.removeListener("data", socketOnData), 
    process.nextTick(resume, websocket._socket), 1005 === code ? websocket.close() : websocket.close(code, reason));
   }
   function receiverOnDrain() {
    this[kWebSocket]._socket.resume();
   }
   function receiverOnError(err) {
    const websocket = this[kWebSocket];
    void 0 !== websocket._socket[kWebSocket] && (websocket._socket.removeListener("data", socketOnData), 
    process.nextTick(resume, websocket._socket), websocket.close(err[kStatusCode])), 
    websocket.emit("error", err);
   }
   function receiverOnFinish() {
    this[kWebSocket].emitClose();
   }
   function receiverOnMessage(data) {
    this[kWebSocket].emit("message", data);
   }
   function receiverOnPing(data) {
    const websocket = this[kWebSocket];
    websocket.pong(data, !websocket._isServer, NOOP), websocket.emit("ping", data);
   }
   function receiverOnPong(data) {
    this[kWebSocket].emit("pong", data);
   }
   function resume(stream) {
    stream.resume();
   }
   function socketOnClose() {
    const websocket = this[kWebSocket];
    let chunk;
    this.removeListener("close", socketOnClose), this.removeListener("data", socketOnData), 
    this.removeListener("end", socketOnEnd), websocket._readyState = WebSocket.CLOSING, 
    this._readableState.endEmitted || websocket._closeFrameReceived || websocket._receiver._writableState.errorEmitted || null === (chunk = websocket._socket.read()) || websocket._receiver.write(chunk), 
    websocket._receiver.end(), this[kWebSocket] = void 0, clearTimeout(websocket._closeTimer), 
    websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted ? websocket.emitClose() : (websocket._receiver.on("error", receiverOnFinish), 
    websocket._receiver.on("finish", receiverOnFinish));
   }
   function socketOnData(chunk) {
    this[kWebSocket]._receiver.write(chunk) || this.pause();
   }
   function socketOnEnd() {
    const websocket = this[kWebSocket];
    websocket._readyState = WebSocket.CLOSING, websocket._receiver.end(), this.end();
   }
   function socketOnError() {
    const websocket = this[kWebSocket];
    this.removeListener("error", socketOnError), this.on("error", NOOP), websocket && (websocket._readyState = WebSocket.CLOSING, 
    this.destroy());
   }
   Object.defineProperty(WebSocket, "CONNECTING", {
    enumerable: !0,
    value: readyStates.indexOf("CONNECTING")
   }), Object.defineProperty(WebSocket.prototype, "CONNECTING", {
    enumerable: !0,
    value: readyStates.indexOf("CONNECTING")
   }), Object.defineProperty(WebSocket, "OPEN", {
    enumerable: !0,
    value: readyStates.indexOf("OPEN")
   }), Object.defineProperty(WebSocket.prototype, "OPEN", {
    enumerable: !0,
    value: readyStates.indexOf("OPEN")
   }), Object.defineProperty(WebSocket, "CLOSING", {
    enumerable: !0,
    value: readyStates.indexOf("CLOSING")
   }), Object.defineProperty(WebSocket.prototype, "CLOSING", {
    enumerable: !0,
    value: readyStates.indexOf("CLOSING")
   }), Object.defineProperty(WebSocket, "CLOSED", {
    enumerable: !0,
    value: readyStates.indexOf("CLOSED")
   }), Object.defineProperty(WebSocket.prototype, "CLOSED", {
    enumerable: !0,
    value: readyStates.indexOf("CLOSED")
   }), [ "binaryType", "bufferedAmount", "extensions", "protocol", "readyState", "url" ].forEach((property => {
    Object.defineProperty(WebSocket.prototype, property, {
     enumerable: !0
    });
   })), [ "open", "error", "close", "message" ].forEach((method => {
    Object.defineProperty(WebSocket.prototype, `on${method}`, {
     enumerable: !0,
     get() {
      const listeners = this.listeners(method);
      for (let i = 0; i < listeners.length; i++) if (listeners[i]._listener) return listeners[i]._listener;
     },
     set(listener) {
      const listeners = this.listeners(method);
      for (let i = 0; i < listeners.length; i++) listeners[i]._listener && this.removeListener(method, listeners[i]);
      this.addEventListener(method, listener);
     }
    });
   })), WebSocket.prototype.addEventListener = addEventListener, WebSocket.prototype.removeEventListener = removeEventListener, 
   module.exports = WebSocket;
  },
  4056: (__unused_webpack_module, exports) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.DataConnector = void 0;
   exports.DataConnector = class {
    async list(query) {
     throw new Error("DataConnector#list method has not been implemented.");
    }
    async remove(id) {
     throw new Error("DataConnector#remove method has not been implemented.");
    }
    async save(id, value) {
     throw new Error("DataConnector#save method has not been implemented.");
    }
   };
  },
  19531: function(__unused_webpack_module, exports, __webpack_require__) {
   "use strict";
   var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    void 0 === k2 && (k2 = k), Object.defineProperty(o, k2, {
     enumerable: !0,
     get: function() {
      return m[k];
     }
    });
   } : function(o, m, k, k2) {
    void 0 === k2 && (k2 = k), o[k2] = m[k];
   }), __exportStar = this && this.__exportStar || function(m, exports) {
    for (var p in m) "default" === p || Object.prototype.hasOwnProperty.call(exports, p) || __createBinding(exports, m, p);
   };
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), __exportStar(__webpack_require__(4056), exports), __exportStar(__webpack_require__(78031), exports), 
   __exportStar(__webpack_require__(45310), exports), __exportStar(__webpack_require__(19864), exports), 
   __exportStar(__webpack_require__(82877), exports);
  },
  78031: (__unused_webpack_module, exports) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   });
  },
  45310: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.RestorablePool = void 0;
   const coreutils_1 = __webpack_require__(82729), properties_1 = __webpack_require__(21628), signaling_1 = __webpack_require__(95813);
   var Private;
   exports.RestorablePool = class {
    constructor(options) {
     this._added = new signaling_1.Signal(this), this._current = null, this._currentChanged = new signaling_1.Signal(this), 
     this._hasRestored = !1, this._isDisposed = !1, this._objects = new Set, this._restore = null, 
     this._restored = new coreutils_1.PromiseDelegate, this._updated = new signaling_1.Signal(this), 
     this.namespace = options.namespace;
    }
    get added() {
     return this._added;
    }
    get current() {
     return this._current;
    }
    set current(obj) {
     this._current !== obj && null !== obj && this._objects.has(obj) && (this._current = obj, 
     this._currentChanged.emit(this._current));
    }
    get currentChanged() {
     return this._currentChanged;
    }
    get isDisposed() {
     return this._isDisposed;
    }
    get restored() {
     return this._restored.promise;
    }
    get size() {
     return this._objects.size;
    }
    get updated() {
     return this._updated;
    }
    async add(obj) {
     var _a, _b;
     if (obj.isDisposed) {
      const warning = "A disposed object cannot be added.";
      throw console.warn(warning, obj), new Error(warning);
     }
     if (this._objects.has(obj)) {
      const warning = "This object already exists in the pool.";
      throw console.warn(warning, obj), new Error(warning);
     }
     if (this._objects.add(obj), obj.disposed.connect(this._onInstanceDisposed, this), 
     !Private.injectedProperty.get(obj)) {
      if (this._restore) {
       const {connector} = this._restore, objName = this._restore.name(obj);
       if (objName) {
        const name = `${this.namespace}:${objName}`, data = null === (_b = (_a = this._restore).args) || void 0 === _b ? void 0 : _b.call(_a, obj);
        Private.nameProperty.set(obj, name), await connector.save(name, {
         data
        });
       }
      }
      this._added.emit(obj);
     }
    }
    dispose() {
     this.isDisposed || (this._current = null, this._isDisposed = !0, this._objects.clear(), 
     signaling_1.Signal.clearData(this));
    }
    find(fn) {
     const values = this._objects.values();
     for (const value of values) if (fn(value)) return value;
    }
    forEach(fn) {
     this._objects.forEach(fn);
    }
    filter(fn) {
     const filtered = [];
     return this.forEach((obj => {
      fn(obj) && filtered.push(obj);
     })), filtered;
    }
    inject(obj) {
     return Private.injectedProperty.set(obj, !0), this.add(obj);
    }
    has(obj) {
     return this._objects.has(obj);
    }
    async restore(options) {
     if (this._hasRestored) throw new Error("This pool has already been restored.");
     this._hasRestored = !0;
     const {command, connector, registry, when} = options, namespace = this.namespace, promises = when ? [ connector.list(namespace) ].concat(when) : [ connector.list(namespace) ];
     this._restore = options;
     const [saved] = await Promise.all(promises), values = await Promise.all(saved.ids.map((async (id, index) => {
      const value = saved.values[index], args = value && value.data;
      return void 0 === args ? connector.remove(id) : registry.execute(command, args).catch((() => connector.remove(id)));
     })));
     return this._restored.resolve(), values;
    }
    async save(obj) {
     var _a, _b;
     const injected = Private.injectedProperty.get(obj);
     if (!this._restore || !this.has(obj) || injected) return;
     const {connector} = this._restore, objName = this._restore.name(obj), oldName = Private.nameProperty.get(obj), newName = objName ? `${this.namespace}:${objName}` : "";
     if (oldName && oldName !== newName && await connector.remove(oldName), Private.nameProperty.set(obj, newName), 
     newName) {
      const data = null === (_b = (_a = this._restore).args) || void 0 === _b ? void 0 : _b.call(_a, obj);
      await connector.save(newName, {
       data
      });
     }
     oldName !== newName && this._updated.emit(obj);
    }
    _onInstanceDisposed(obj) {
     if (this._objects.delete(obj), obj === this._current && (this._current = null, this._currentChanged.emit(this._current)), 
     Private.injectedProperty.get(obj)) return;
     if (!this._restore) return;
     const {connector} = this._restore, name = Private.nameProperty.get(obj);
     name && connector.remove(name);
    }
   }, function(Private) {
    Private.injectedProperty = new properties_1.AttachedProperty({
     name: "injected",
     create: () => !1
    }), Private.nameProperty = new properties_1.AttachedProperty({
     name: "name",
     create: () => ""
    });
   }(Private || (Private = {}));
  },
  19864: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.StateDB = void 0;
   const signaling_1 = __webpack_require__(95813);
   class StateDB {
    constructor(options = {}) {
     this._changed = new signaling_1.Signal(this);
     const {connector, transform} = options;
     this._connector = connector || new StateDB.Connector, this._ready = transform ? transform.then((transformation => {
      const {contents, type} = transformation;
      switch (type) {
      case "cancel":
      default:
       return;

      case "clear":
       return this._clear();

      case "merge":
       return this._merge(contents || {});

      case "overwrite":
       return this._overwrite(contents || {});
      }
     })) : Promise.resolve(void 0);
    }
    get changed() {
     return this._changed;
    }
    async clear() {
     await this._ready, await this._clear();
    }
    async fetch(id) {
     return await this._ready, this._fetch(id);
    }
    async list(namespace) {
     return await this._ready, this._list(namespace);
    }
    async remove(id) {
     await this._ready, await this._remove(id), this._changed.emit({
      id,
      type: "remove"
     });
    }
    async save(id, value) {
     await this._ready, await this._save(id, value), this._changed.emit({
      id,
      type: "save"
     });
    }
    async toJSON() {
     await this._ready;
     const {ids, values} = await this._list();
     return values.reduce(((acc, val, idx) => (acc[ids[idx]] = val, acc)), {});
    }
    async _clear() {
     await Promise.all((await this._list()).ids.map((id => this._remove(id))));
    }
    async _fetch(id) {
     const value = await this._connector.fetch(id);
     if (value) return JSON.parse(value).v;
    }
    async _list(namespace = "") {
     const {ids, values} = await this._connector.list(namespace);
     return {
      ids,
      values: values.map((val => JSON.parse(val).v))
     };
    }
    async _merge(contents) {
     await Promise.all(Object.keys(contents).map((key => contents[key] && this._save(key, contents[key]))));
    }
    async _overwrite(contents) {
     await this._clear(), await this._merge(contents);
    }
    async _remove(id) {
     return this._connector.remove(id);
    }
    async _save(id, value) {
     return this._connector.save(id, JSON.stringify({
      v: value
     }));
    }
   }
   exports.StateDB = StateDB, function(StateDB) {
    StateDB.Connector = class {
     constructor() {
      this._storage = {};
     }
     async fetch(id) {
      return this._storage[id];
     }
     async list(namespace = "") {
      return Object.keys(this._storage).reduce(((acc, val) => ("" !== namespace && namespace !== val.split(":")[0] || (acc.ids.push(val), 
      acc.values.push(this._storage[val])), acc)), {
       ids: [],
       values: []
      });
     }
     async remove(id) {
      delete this._storage[id];
     }
     async save(id, value) {
      this._storage[id] = value;
     }
    };
   }(StateDB = exports.StateDB || (exports.StateDB = {}));
  },
  82877: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.IStateDB = void 0;
   const coreutils_1 = __webpack_require__(82729);
   exports.IStateDB = new coreutils_1.Token("@jupyterlab/coreutils:IStateDB");
  },
  82729: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   var JSONExt;
   __webpack_require__.r(__webpack_exports__), __webpack_require__.d(__webpack_exports__, {
    JSONExt: () => JSONExt,
    MimeData: () => MimeData,
    PromiseDelegate: () => PromiseDelegate,
    Random: () => Random,
    Token: () => Token,
    UUID: () => UUID
   }), function(JSONExt) {
    function isPrimitive(value) {
     return null === value || "boolean" == typeof value || "number" == typeof value || "string" == typeof value;
    }
    function isArray(value) {
     return Array.isArray(value);
    }
    function deepEqual(first, second) {
     if (first === second) return !0;
     if (isPrimitive(first) || isPrimitive(second)) return !1;
     var a1 = isArray(first), a2 = isArray(second);
     return a1 === a2 && (a1 && a2 ? function(first, second) {
      if (first === second) return !0;
      if (first.length !== second.length) return !1;
      for (var i = 0, n = first.length; i < n; ++i) if (!deepEqual(first[i], second[i])) return !1;
      return !0;
     }(first, second) : function(first, second) {
      if (first === second) return !0;
      for (var key in first) if (void 0 !== first[key] && !(key in second)) return !1;
      for (var key in second) if (void 0 !== second[key] && !(key in first)) return !1;
      for (var key in first) {
       var firstValue = first[key], secondValue = second[key];
       if (void 0 !== firstValue || void 0 !== secondValue) {
        if (void 0 === firstValue || void 0 === secondValue) return !1;
        if (!deepEqual(firstValue, secondValue)) return !1;
       }
      }
      return !0;
     }(first, second));
    }
    function deepCopy(value) {
     return isPrimitive(value) ? value : isArray(value) ? function(value) {
      for (var result = new Array(value.length), i = 0, n = value.length; i < n; ++i) result[i] = deepCopy(value[i]);
      return result;
     }(value) : function(value) {
      var result = {};
      for (var key in value) {
       var subvalue = value[key];
       void 0 !== subvalue && (result[key] = deepCopy(subvalue));
      }
      return result;
     }(value);
    }
    JSONExt.emptyObject = Object.freeze({}), JSONExt.emptyArray = Object.freeze([]), 
    JSONExt.isPrimitive = isPrimitive, JSONExt.isArray = isArray, JSONExt.isObject = function(value) {
     return !isPrimitive(value) && !isArray(value);
    }, JSONExt.deepEqual = deepEqual, JSONExt.deepCopy = deepCopy;
   }(JSONExt || (JSONExt = {}));
   var Random, UUID, MimeData = function() {
    function MimeData() {
     this._types = [], this._values = [];
    }
    return MimeData.prototype.types = function() {
     return this._types.slice();
    }, MimeData.prototype.hasData = function(mime) {
     return -1 !== this._types.indexOf(mime);
    }, MimeData.prototype.getData = function(mime) {
     var i = this._types.indexOf(mime);
     return -1 !== i ? this._values[i] : void 0;
    }, MimeData.prototype.setData = function(mime, data) {
     this.clearData(mime), this._types.push(mime), this._values.push(data);
    }, MimeData.prototype.clearData = function(mime) {
     var i = this._types.indexOf(mime);
     -1 !== i && (this._types.splice(i, 1), this._values.splice(i, 1));
    }, MimeData.prototype.clear = function() {
     this._types.length = 0, this._values.length = 0;
    }, MimeData;
   }(), PromiseDelegate = function() {
    function PromiseDelegate() {
     var _this = this;
     this.promise = new Promise((function(resolve, reject) {
      _this._resolve = resolve, _this._reject = reject;
     }));
    }
    return PromiseDelegate.prototype.resolve = function(value) {
     (0, this._resolve)(value);
    }, PromiseDelegate.prototype.reject = function(reason) {
     (0, this._reject)(reason);
    }, PromiseDelegate;
   }(), Token = function(name) {
    this.name = name, this._tokenStructuralPropertyT = null;
   };
   function fallbackRandomValues(buffer) {
    for (var value = 0, i = 0, n = buffer.length; i < n; ++i) i % 4 == 0 && (value = 4294967295 * Math.random() >>> 0), 
    buffer[i] = 255 & value, value >>>= 8;
   }
   !function(Random) {
    Random.getRandomValues = function() {
     var crypto = "undefined" != typeof window && (window.crypto || window.msCrypto) || null;
     return crypto && "function" == typeof crypto.getRandomValues ? function(buffer) {
      return crypto.getRandomValues(buffer);
     } : fallbackRandomValues;
    }();
   }(Random || (Random = {})), function(UUID) {
    UUID.uuid4 = function(getRandomValues) {
     for (var bytes = new Uint8Array(16), lut = new Array(256), i = 0; i < 16; ++i) lut[i] = "0" + i.toString(16);
     for (i = 16; i < 256; ++i) lut[i] = i.toString(16);
     return function() {
      return getRandomValues(bytes), bytes[6] = 64 | 15 & bytes[6], bytes[8] = 128 | 63 & bytes[8], 
      lut[bytes[0]] + lut[bytes[1]] + lut[bytes[2]] + lut[bytes[3]] + "-" + lut[bytes[4]] + lut[bytes[5]] + "-" + lut[bytes[6]] + lut[bytes[7]] + "-" + lut[bytes[8]] + lut[bytes[9]] + "-" + lut[bytes[10]] + lut[bytes[11]] + lut[bytes[12]] + lut[bytes[13]] + lut[bytes[14]] + lut[bytes[15]];
     };
    }(Random.getRandomValues);
   }(UUID || (UUID = {}));
  },
  95813: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.r(__webpack_exports__), __webpack_require__.d(__webpack_exports__, {
    Signal: () => Signal
   });
   var Private, _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(56588), _lumino_properties__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(21628), Signal = function() {
    function Signal(sender) {
     this._blockedCount = 0, this.sender = sender;
    }
    return Signal.prototype.block = function(fn) {
     this._blockedCount++;
     try {
      fn();
     } finally {
      this._blockedCount--;
     }
    }, Signal.prototype.connect = function(slot, thisArg) {
     return Private.connect(this, slot, thisArg);
    }, Signal.prototype.disconnect = function(slot, thisArg) {
     return Private.disconnect(this, slot, thisArg);
    }, Signal.prototype.emit = function(args) {
     this._blockedCount || Private.emit(this, args);
    }, Signal;
   }();
   !function(Signal) {
    Signal.blockAll = function(sender, fn) {
     var blockedProperty = Private.blockedProperty;
     blockedProperty.set(sender, blockedProperty.get(sender) + 1);
     try {
      fn();
     } finally {
      blockedProperty.set(sender, blockedProperty.get(sender) - 1);
     }
    }, Signal.disconnectBetween = function(sender, receiver) {
     Private.disconnectBetween(sender, receiver);
    }, Signal.disconnectSender = function(sender) {
     Private.disconnectSender(sender);
    }, Signal.disconnectReceiver = function(receiver) {
     Private.disconnectReceiver(receiver);
    }, Signal.disconnectAll = function(object) {
     Private.disconnectAll(object);
    }, Signal.clearData = function(object) {
     Private.disconnectAll(object);
    }, Signal.getExceptionHandler = function() {
     return Private.exceptionHandler;
    }, Signal.setExceptionHandler = function(handler) {
     var old = Private.exceptionHandler;
     return Private.exceptionHandler = handler, old;
    };
   }(Signal || (Signal = {})), function(Private) {
    function disconnectSender(sender) {
     var receivers = receiversForSender.get(sender);
     receivers && 0 !== receivers.length && ((0, _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.each)(receivers, (function(connection) {
      if (connection.signal) {
       var receiver = connection.thisArg || connection.slot;
       connection.signal = null, scheduleCleanup(sendersForReceiver.get(receiver));
      }
     })), scheduleCleanup(receivers));
    }
    function disconnectReceiver(receiver) {
     var senders = sendersForReceiver.get(receiver);
     senders && 0 !== senders.length && ((0, _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.each)(senders, (function(connection) {
      if (connection.signal) {
       var sender = connection.signal.sender;
       connection.signal = null, scheduleCleanup(receiversForSender.get(sender));
      }
     })), scheduleCleanup(senders));
    }
    Private.exceptionHandler = function(err) {
     console.error(err);
    }, Private.connect = function(signal, slot, thisArg) {
     thisArg = thisArg || void 0;
     var receivers = receiversForSender.get(signal.sender);
     if (receivers || (receivers = [], receiversForSender.set(signal.sender, receivers)), 
     findConnection(receivers, signal, slot, thisArg)) return !1;
     var receiver = thisArg || slot, senders = sendersForReceiver.get(receiver);
     senders || (senders = [], sendersForReceiver.set(receiver, senders));
     var connection = {
      signal,
      slot,
      thisArg
     };
     return receivers.push(connection), senders.push(connection), !0;
    }, Private.disconnect = function(signal, slot, thisArg) {
     thisArg = thisArg || void 0;
     var receivers = receiversForSender.get(signal.sender);
     if (!receivers || 0 === receivers.length) return !1;
     var connection = findConnection(receivers, signal, slot, thisArg);
     if (!connection) return !1;
     var receiver = thisArg || slot, senders = sendersForReceiver.get(receiver);
     return connection.signal = null, scheduleCleanup(receivers), scheduleCleanup(senders), 
     !0;
    }, Private.disconnectBetween = function(sender, receiver) {
     var receivers = receiversForSender.get(sender);
     if (receivers && 0 !== receivers.length) {
      var senders = sendersForReceiver.get(receiver);
      senders && 0 !== senders.length && ((0, _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.each)(senders, (function(connection) {
       connection.signal && connection.signal.sender === sender && (connection.signal = null);
      })), scheduleCleanup(receivers), scheduleCleanup(senders));
     }
    }, Private.disconnectSender = disconnectSender, Private.disconnectReceiver = disconnectReceiver, 
    Private.disconnectAll = function(object) {
     disconnectSender(object), disconnectReceiver(object);
    }, Private.emit = function(signal, args) {
     if (!(Private.blockedProperty.get(signal.sender) > 0)) {
      var receivers = receiversForSender.get(signal.sender);
      if (receivers && 0 !== receivers.length) for (var i = 0, n = receivers.length; i < n; ++i) {
       var connection = receivers[i];
       connection.signal === signal && invokeSlot(connection, args);
      }
     }
    };
    var receiversForSender = new WeakMap, sendersForReceiver = new WeakMap, dirtySet = new Set, schedule = "function" == typeof requestAnimationFrame ? requestAnimationFrame : setImmediate;
    function findConnection(connections, signal, slot, thisArg) {
     return (0, _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.find)(connections, (function(connection) {
      return connection.signal === signal && connection.slot === slot && connection.thisArg === thisArg;
     }));
    }
    function invokeSlot(connection, args) {
     var signal = connection.signal, slot = connection.slot, thisArg = connection.thisArg;
     try {
      slot.call(thisArg, signal.sender, args);
     } catch (err) {
      Private.exceptionHandler(err);
     }
    }
    function scheduleCleanup(array) {
     0 === dirtySet.size && schedule(cleanupDirtySet), dirtySet.add(array);
    }
    function cleanupDirtySet() {
     dirtySet.forEach(cleanupConnections), dirtySet.clear();
    }
    function cleanupConnections(connections) {
     _lumino_algorithm__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.removeAllWhere(connections, isDeadConnection);
    }
    function isDeadConnection(connection) {
     return null === connection.signal;
    }
    Private.blockedProperty = new _lumino_properties__WEBPACK_IMPORTED_MODULE_1__.AttachedProperty({
     name: "blocked",
     create: function() {
      return 0;
     }
    });
   }(Private || (Private = {}));
  },
  56588: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   var ArrayExt;
   function iter(object) {
    return "function" == typeof object.iter ? object.iter() : new ArrayIterator(object);
   }
   function iterKeys(object) {
    return new KeyIterator(object);
   }
   function iterValues(object) {
    return new ValueIterator(object);
   }
   function iterItems(object) {
    return new ItemIterator(object);
   }
   function iterFn(fn) {
    return new FnIterator(fn);
   }
   function each(object, fn) {
    for (var value, index = 0, it = iter(object); void 0 !== (value = it.next()); ) if (!1 === fn(value, index++)) return;
   }
   function every(object, fn) {
    for (var value, index = 0, it = iter(object); void 0 !== (value = it.next()); ) if (!fn(value, index++)) return !1;
    return !0;
   }
   function some(object, fn) {
    for (var value, index = 0, it = iter(object); void 0 !== (value = it.next()); ) if (fn(value, index++)) return !0;
    return !1;
   }
   function toArray(object) {
    for (var value, index = 0, result = [], it = iter(object); void 0 !== (value = it.next()); ) result[index++] = value;
    return result;
   }
   function toObject(object) {
    for (var pair, it = iter(object), result = {}; void 0 !== (pair = it.next()); ) result[pair[0]] = pair[1];
    return result;
   }
   __webpack_require__.r(__webpack_exports__), __webpack_require__.d(__webpack_exports__, {
    ArrayExt: () => ArrayExt,
    ArrayIterator: () => ArrayIterator,
    ChainIterator: () => ChainIterator,
    EmptyIterator: () => EmptyIterator,
    EnumerateIterator: () => EnumerateIterator,
    FilterIterator: () => FilterIterator,
    FnIterator: () => FnIterator,
    ItemIterator: () => ItemIterator,
    KeyIterator: () => KeyIterator,
    MapIterator: () => MapIterator,
    RangeIterator: () => RangeIterator,
    RepeatIterator: () => RepeatIterator,
    RetroArrayIterator: () => RetroArrayIterator,
    StrideIterator: () => StrideIterator,
    StringExt: () => StringExt,
    TakeIterator: () => TakeIterator,
    ValueIterator: () => ValueIterator,
    ZipIterator: () => ZipIterator,
    chain: () => chain,
    each: () => each,
    empty: () => empty,
    enumerate: () => enumerate,
    every: () => every,
    filter: () => filter,
    find: () => find,
    findIndex: () => findIndex,
    iter: () => iter,
    iterFn: () => iterFn,
    iterItems: () => iterItems,
    iterKeys: () => iterKeys,
    iterValues: () => iterValues,
    map: () => map,
    max: () => max,
    min: () => min,
    minmax: () => minmax,
    once: () => once,
    range: () => range,
    reduce: () => reduce,
    repeat: () => repeat,
    retro: () => retro,
    some: () => some,
    stride: () => stride,
    take: () => take,
    toArray: () => toArray,
    toObject: () => toObject,
    topologicSort: () => topologicSort,
    zip: () => zip
   }), function(ArrayExt) {
    function firstIndexOf(array, value, start, stop) {
     void 0 === start && (start = 0), void 0 === stop && (stop = -1);
     var span, n = array.length;
     if (0 === n) return -1;
     start = start < 0 ? Math.max(0, start + n) : Math.min(start, n - 1), span = (stop = stop < 0 ? Math.max(0, stop + n) : Math.min(stop, n - 1)) < start ? stop + 1 + (n - start) : stop - start + 1;
     for (var i = 0; i < span; ++i) {
      var j = (start + i) % n;
      if (array[j] === value) return j;
     }
     return -1;
    }
    function lastIndexOf(array, value, start, stop) {
     void 0 === start && (start = -1), void 0 === stop && (stop = 0);
     var span, n = array.length;
     if (0 === n) return -1;
     span = (start = start < 0 ? Math.max(0, start + n) : Math.min(start, n - 1)) < (stop = stop < 0 ? Math.max(0, stop + n) : Math.min(stop, n - 1)) ? start + 1 + (n - stop) : start - stop + 1;
     for (var i = 0; i < span; ++i) {
      var j = (start - i + n) % n;
      if (array[j] === value) return j;
     }
     return -1;
    }
    function findFirstIndex(array, fn, start, stop) {
     void 0 === start && (start = 0), void 0 === stop && (stop = -1);
     var span, n = array.length;
     if (0 === n) return -1;
     start = start < 0 ? Math.max(0, start + n) : Math.min(start, n - 1), span = (stop = stop < 0 ? Math.max(0, stop + n) : Math.min(stop, n - 1)) < start ? stop + 1 + (n - start) : stop - start + 1;
     for (var i = 0; i < span; ++i) {
      var j = (start + i) % n;
      if (fn(array[j], j)) return j;
     }
     return -1;
    }
    function findLastIndex(array, fn, start, stop) {
     void 0 === start && (start = -1), void 0 === stop && (stop = 0);
     var d, n = array.length;
     if (0 === n) return -1;
     d = (start = start < 0 ? Math.max(0, start + n) : Math.min(start, n - 1)) < (stop = stop < 0 ? Math.max(0, stop + n) : Math.min(stop, n - 1)) ? start + 1 + (n - stop) : start - stop + 1;
     for (var i = 0; i < d; ++i) {
      var j = (start - i + n) % n;
      if (fn(array[j], j)) return j;
     }
     return -1;
    }
    function reverse(array, start, stop) {
     void 0 === start && (start = 0), void 0 === stop && (stop = -1);
     var n = array.length;
     if (!(n <= 1)) for (start = start < 0 ? Math.max(0, start + n) : Math.min(start, n - 1), 
     stop = stop < 0 ? Math.max(0, stop + n) : Math.min(stop, n - 1); start < stop; ) {
      var a = array[start], b = array[stop];
      array[start++] = b, array[stop--] = a;
     }
    }
    function removeAt(array, index) {
     var n = array.length;
     if (index < 0 && (index += n), !(index < 0 || index >= n)) {
      for (var value = array[index], i = index + 1; i < n; ++i) array[i - 1] = array[i];
      return array.length = n - 1, value;
     }
    }
    ArrayExt.firstIndexOf = firstIndexOf, ArrayExt.lastIndexOf = lastIndexOf, ArrayExt.findFirstIndex = findFirstIndex, 
    ArrayExt.findLastIndex = findLastIndex, ArrayExt.findFirstValue = function(array, fn, start, stop) {
     void 0 === start && (start = 0), void 0 === stop && (stop = -1);
     var index = findFirstIndex(array, fn, start, stop);
     return -1 !== index ? array[index] : void 0;
    }, ArrayExt.findLastValue = function(array, fn, start, stop) {
     void 0 === start && (start = -1), void 0 === stop && (stop = 0);
     var index = findLastIndex(array, fn, start, stop);
     return -1 !== index ? array[index] : void 0;
    }, ArrayExt.lowerBound = function(array, value, fn, start, stop) {
     void 0 === start && (start = 0), void 0 === stop && (stop = -1);
     var n = array.length;
     if (0 === n) return 0;
     for (var begin = start = start < 0 ? Math.max(0, start + n) : Math.min(start, n - 1), span = (stop = stop < 0 ? Math.max(0, stop + n) : Math.min(stop, n - 1)) - start + 1; span > 0; ) {
      var half = span >> 1, middle = begin + half;
      fn(array[middle], value) < 0 ? (begin = middle + 1, span -= half + 1) : span = half;
     }
     return begin;
    }, ArrayExt.upperBound = function(array, value, fn, start, stop) {
     void 0 === start && (start = 0), void 0 === stop && (stop = -1);
     var n = array.length;
     if (0 === n) return 0;
     for (var begin = start = start < 0 ? Math.max(0, start + n) : Math.min(start, n - 1), span = (stop = stop < 0 ? Math.max(0, stop + n) : Math.min(stop, n - 1)) - start + 1; span > 0; ) {
      var half = span >> 1, middle = begin + half;
      fn(array[middle], value) > 0 ? span = half : (begin = middle + 1, span -= half + 1);
     }
     return begin;
    }, ArrayExt.shallowEqual = function(a, b, fn) {
     if (a === b) return !0;
     if (a.length !== b.length) return !1;
     for (var i = 0, n = a.length; i < n; ++i) if (fn ? !fn(a[i], b[i]) : a[i] !== b[i]) return !1;
     return !0;
    }, ArrayExt.slice = function(array, options) {
     void 0 === options && (options = {});
     var start = options.start, stop = options.stop, step = options.step;
     if (void 0 === step && (step = 1), 0 === step) throw new Error("Slice `step` cannot be zero.");
     var length, n = array.length;
     void 0 === start ? start = step < 0 ? n - 1 : 0 : start < 0 ? start = Math.max(start + n, step < 0 ? -1 : 0) : start >= n && (start = step < 0 ? n - 1 : n), 
     void 0 === stop ? stop = step < 0 ? -1 : n : stop < 0 ? stop = Math.max(stop + n, step < 0 ? -1 : 0) : stop >= n && (stop = step < 0 ? n - 1 : n), 
     length = step < 0 && stop >= start || step > 0 && start >= stop ? 0 : step < 0 ? Math.floor((stop - start + 1) / step + 1) : Math.floor((stop - start - 1) / step + 1);
     for (var result = [], i = 0; i < length; ++i) result[i] = array[start + i * step];
     return result;
    }, ArrayExt.move = function(array, fromIndex, toIndex) {
     var n = array.length;
     if (!(n <= 1) && (fromIndex = fromIndex < 0 ? Math.max(0, fromIndex + n) : Math.min(fromIndex, n - 1)) !== (toIndex = toIndex < 0 ? Math.max(0, toIndex + n) : Math.min(toIndex, n - 1))) {
      for (var value = array[fromIndex], d = fromIndex < toIndex ? 1 : -1, i = fromIndex; i !== toIndex; i += d) array[i] = array[i + d];
      array[toIndex] = value;
     }
    }, ArrayExt.reverse = reverse, ArrayExt.rotate = function(array, delta, start, stop) {
     void 0 === start && (start = 0), void 0 === stop && (stop = -1);
     var n = array.length;
     if (!(n <= 1 || (start = start < 0 ? Math.max(0, start + n) : Math.min(start, n - 1)) >= (stop = stop < 0 ? Math.max(0, stop + n) : Math.min(stop, n - 1)))) {
      var length = stop - start + 1;
      if (delta > 0 ? delta %= length : delta < 0 && (delta = (delta % length + length) % length), 
      0 !== delta) {
       var pivot = start + delta;
       reverse(array, start, pivot - 1), reverse(array, pivot, stop), reverse(array, start, stop);
      }
     }
    }, ArrayExt.fill = function(array, value, start, stop) {
     void 0 === start && (start = 0), void 0 === stop && (stop = -1);
     var n = array.length;
     if (0 !== n) {
      var span;
      start = start < 0 ? Math.max(0, start + n) : Math.min(start, n - 1), span = (stop = stop < 0 ? Math.max(0, stop + n) : Math.min(stop, n - 1)) < start ? stop + 1 + (n - start) : stop - start + 1;
      for (var i = 0; i < span; ++i) array[(start + i) % n] = value;
     }
    }, ArrayExt.insert = function(array, index, value) {
     var n = array.length;
     index = index < 0 ? Math.max(0, index + n) : Math.min(index, n);
     for (var i = n; i > index; --i) array[i] = array[i - 1];
     array[index] = value;
    }, ArrayExt.removeAt = removeAt, ArrayExt.removeFirstOf = function(array, value, start, stop) {
     void 0 === start && (start = 0), void 0 === stop && (stop = -1);
     var index = firstIndexOf(array, value, start, stop);
     return -1 !== index && removeAt(array, index), index;
    }, ArrayExt.removeLastOf = function(array, value, start, stop) {
     void 0 === start && (start = -1), void 0 === stop && (stop = 0);
     var index = lastIndexOf(array, value, start, stop);
     return -1 !== index && removeAt(array, index), index;
    }, ArrayExt.removeAllOf = function(array, value, start, stop) {
     void 0 === start && (start = 0), void 0 === stop && (stop = -1);
     var n = array.length;
     if (0 === n) return 0;
     start = start < 0 ? Math.max(0, start + n) : Math.min(start, n - 1), stop = stop < 0 ? Math.max(0, stop + n) : Math.min(stop, n - 1);
     for (var count = 0, i = 0; i < n; ++i) start <= stop && i >= start && i <= stop && array[i] === value || stop < start && (i <= stop || i >= start) && array[i] === value ? count++ : count > 0 && (array[i - count] = array[i]);
     return count > 0 && (array.length = n - count), count;
    }, ArrayExt.removeFirstWhere = function(array, fn, start, stop) {
     var value;
     void 0 === start && (start = 0), void 0 === stop && (stop = -1);
     var index = findFirstIndex(array, fn, start, stop);
     return -1 !== index && (value = removeAt(array, index)), {
      index,
      value
     };
    }, ArrayExt.removeLastWhere = function(array, fn, start, stop) {
     var value;
     void 0 === start && (start = -1), void 0 === stop && (stop = 0);
     var index = findLastIndex(array, fn, start, stop);
     return -1 !== index && (value = removeAt(array, index)), {
      index,
      value
     };
    }, ArrayExt.removeAllWhere = function(array, fn, start, stop) {
     void 0 === start && (start = 0), void 0 === stop && (stop = -1);
     var n = array.length;
     if (0 === n) return 0;
     start = start < 0 ? Math.max(0, start + n) : Math.min(start, n - 1), stop = stop < 0 ? Math.max(0, stop + n) : Math.min(stop, n - 1);
     for (var count = 0, i = 0; i < n; ++i) start <= stop && i >= start && i <= stop && fn(array[i], i) || stop < start && (i <= stop || i >= start) && fn(array[i], i) ? count++ : count > 0 && (array[i - count] = array[i]);
     return count > 0 && (array.length = n - count), count;
    };
   }(ArrayExt || (ArrayExt = {}));
   var ArrayIterator = function() {
    function ArrayIterator(source) {
     this._index = 0, this._source = source;
    }
    return ArrayIterator.prototype.iter = function() {
     return this;
    }, ArrayIterator.prototype.clone = function() {
     var result = new ArrayIterator(this._source);
     return result._index = this._index, result;
    }, ArrayIterator.prototype.next = function() {
     if (!(this._index >= this._source.length)) return this._source[this._index++];
    }, ArrayIterator;
   }(), KeyIterator = function() {
    function KeyIterator(source, keys) {
     void 0 === keys && (keys = Object.keys(source)), this._index = 0, this._source = source, 
     this._keys = keys;
    }
    return KeyIterator.prototype.iter = function() {
     return this;
    }, KeyIterator.prototype.clone = function() {
     var result = new KeyIterator(this._source, this._keys);
     return result._index = this._index, result;
    }, KeyIterator.prototype.next = function() {
     if (!(this._index >= this._keys.length)) {
      var key = this._keys[this._index++];
      return key in this._source ? key : this.next();
     }
    }, KeyIterator;
   }(), ValueIterator = function() {
    function ValueIterator(source, keys) {
     void 0 === keys && (keys = Object.keys(source)), this._index = 0, this._source = source, 
     this._keys = keys;
    }
    return ValueIterator.prototype.iter = function() {
     return this;
    }, ValueIterator.prototype.clone = function() {
     var result = new ValueIterator(this._source, this._keys);
     return result._index = this._index, result;
    }, ValueIterator.prototype.next = function() {
     if (!(this._index >= this._keys.length)) {
      var key = this._keys[this._index++];
      return key in this._source ? this._source[key] : this.next();
     }
    }, ValueIterator;
   }(), ItemIterator = function() {
    function ItemIterator(source, keys) {
     void 0 === keys && (keys = Object.keys(source)), this._index = 0, this._source = source, 
     this._keys = keys;
    }
    return ItemIterator.prototype.iter = function() {
     return this;
    }, ItemIterator.prototype.clone = function() {
     var result = new ItemIterator(this._source, this._keys);
     return result._index = this._index, result;
    }, ItemIterator.prototype.next = function() {
     if (!(this._index >= this._keys.length)) {
      var key = this._keys[this._index++];
      return key in this._source ? [ key, this._source[key] ] : this.next();
     }
    }, ItemIterator;
   }(), FnIterator = function() {
    function FnIterator(fn) {
     this._fn = fn;
    }
    return FnIterator.prototype.iter = function() {
     return this;
    }, FnIterator.prototype.clone = function() {
     throw new Error("An `FnIterator` cannot be cloned.");
    }, FnIterator.prototype.next = function() {
     return this._fn.call(void 0);
    }, FnIterator;
   }();
   function chain() {
    for (var objects = [], _i = 0; _i < arguments.length; _i++) objects[_i] = arguments[_i];
    return new ChainIterator(iter(objects.map(iter)));
   }
   var ChainIterator = function() {
    function ChainIterator(source) {
     this._cloned = !1, this._source = source, this._active = void 0;
    }
    return ChainIterator.prototype.iter = function() {
     return this;
    }, ChainIterator.prototype.clone = function() {
     var result = new ChainIterator(this._source.clone());
     return result._active = this._active && this._active.clone(), result._cloned = !0, 
     this._cloned = !0, result;
    }, ChainIterator.prototype.next = function() {
     if (void 0 === this._active) {
      var active = this._source.next();
      if (void 0 === active) return;
      this._active = this._cloned ? active.clone() : active;
     }
     var value = this._active.next();
     return void 0 !== value ? value : (this._active = void 0, this.next());
    }, ChainIterator;
   }();
   function empty() {
    return new EmptyIterator;
   }
   var EmptyIterator = function() {
    function EmptyIterator() {}
    return EmptyIterator.prototype.iter = function() {
     return this;
    }, EmptyIterator.prototype.clone = function() {
     return new EmptyIterator;
    }, EmptyIterator.prototype.next = function() {}, EmptyIterator;
   }();
   function enumerate(object, start) {
    return void 0 === start && (start = 0), new EnumerateIterator(iter(object), start);
   }
   var EnumerateIterator = function() {
    function EnumerateIterator(source, start) {
     this._source = source, this._index = start;
    }
    return EnumerateIterator.prototype.iter = function() {
     return this;
    }, EnumerateIterator.prototype.clone = function() {
     return new EnumerateIterator(this._source.clone(), this._index);
    }, EnumerateIterator.prototype.next = function() {
     var value = this._source.next();
     if (void 0 !== value) return [ this._index++, value ];
    }, EnumerateIterator;
   }();
   function filter(object, fn) {
    return new FilterIterator(iter(object), fn);
   }
   var FilterIterator = function() {
    function FilterIterator(source, fn) {
     this._index = 0, this._source = source, this._fn = fn;
    }
    return FilterIterator.prototype.iter = function() {
     return this;
    }, FilterIterator.prototype.clone = function() {
     var result = new FilterIterator(this._source.clone(), this._fn);
     return result._index = this._index, result;
    }, FilterIterator.prototype.next = function() {
     for (var value, fn = this._fn, it = this._source; void 0 !== (value = it.next()); ) if (fn(value, this._index++)) return value;
    }, FilterIterator;
   }();
   function find(object, fn) {
    for (var value, index = 0, it = iter(object); void 0 !== (value = it.next()); ) if (fn(value, index++)) return value;
   }
   function findIndex(object, fn) {
    for (var value, index = 0, it = iter(object); void 0 !== (value = it.next()); ) if (fn(value, index++)) return index - 1;
    return -1;
   }
   function min(object, fn) {
    var it = iter(object), value = it.next();
    if (void 0 !== value) {
     for (var result = value; void 0 !== (value = it.next()); ) fn(value, result) < 0 && (result = value);
     return result;
    }
   }
   function max(object, fn) {
    var it = iter(object), value = it.next();
    if (void 0 !== value) {
     for (var result = value; void 0 !== (value = it.next()); ) fn(value, result) > 0 && (result = value);
     return result;
    }
   }
   function minmax(object, fn) {
    var it = iter(object), value = it.next();
    if (void 0 !== value) {
     for (var vmin = value, vmax = value; void 0 !== (value = it.next()); ) fn(value, vmin) < 0 ? vmin = value : fn(value, vmax) > 0 && (vmax = value);
     return [ vmin, vmax ];
    }
   }
   function map(object, fn) {
    return new MapIterator(iter(object), fn);
   }
   var MapIterator = function() {
    function MapIterator(source, fn) {
     this._index = 0, this._source = source, this._fn = fn;
    }
    return MapIterator.prototype.iter = function() {
     return this;
    }, MapIterator.prototype.clone = function() {
     var result = new MapIterator(this._source.clone(), this._fn);
     return result._index = this._index, result;
    }, MapIterator.prototype.next = function() {
     var value = this._source.next();
     if (void 0 !== value) return this._fn.call(void 0, value, this._index++);
    }, MapIterator;
   }();
   function range(start, stop, step) {
    return void 0 === stop ? new RangeIterator(0, start, 1) : new RangeIterator(start, stop, void 0 === step ? 1 : step);
   }
   var Private, RangeIterator = function() {
    function RangeIterator(start, stop, step) {
     this._index = 0, this._start = start, this._stop = stop, this._step = step, this._length = Private.rangeLength(start, stop, step);
    }
    return RangeIterator.prototype.iter = function() {
     return this;
    }, RangeIterator.prototype.clone = function() {
     var result = new RangeIterator(this._start, this._stop, this._step);
     return result._index = this._index, result;
    }, RangeIterator.prototype.next = function() {
     if (!(this._index >= this._length)) return this._start + this._step * this._index++;
    }, RangeIterator;
   }();
   function reduce(object, fn, initial) {
    var index = 0, it = iter(object), first = it.next();
    if (void 0 === first && void 0 === initial) throw new TypeError("Reduce of empty iterable with no initial value.");
    if (void 0 === first) return initial;
    var accumulator, next, second = it.next();
    if (void 0 === second && void 0 === initial) return first;
    if (void 0 === second) return fn(initial, first, index++);
    for (accumulator = fn(void 0 === initial ? first : fn(initial, first, index++), second, index++); void 0 !== (next = it.next()); ) accumulator = fn(accumulator, next, index++);
    return accumulator;
   }
   function repeat(value, count) {
    return new RepeatIterator(value, count);
   }
   function once(value) {
    return new RepeatIterator(value, 1);
   }
   !function(Private) {
    Private.rangeLength = function(start, stop, step) {
     return 0 === step ? 1 / 0 : start > stop && step > 0 || start < stop && step < 0 ? 0 : Math.ceil((stop - start) / step);
    };
   }(Private || (Private = {}));
   var RepeatIterator = function() {
    function RepeatIterator(value, count) {
     this._value = value, this._count = count;
    }
    return RepeatIterator.prototype.iter = function() {
     return this;
    }, RepeatIterator.prototype.clone = function() {
     return new RepeatIterator(this._value, this._count);
    }, RepeatIterator.prototype.next = function() {
     if (!(this._count <= 0)) return this._count--, this._value;
    }, RepeatIterator;
   }();
   function retro(object) {
    return "function" == typeof object.retro ? object.retro() : new RetroArrayIterator(object);
   }
   var RetroArrayIterator = function() {
    function RetroArrayIterator(source) {
     this._source = source, this._index = source.length - 1;
    }
    return RetroArrayIterator.prototype.iter = function() {
     return this;
    }, RetroArrayIterator.prototype.clone = function() {
     var result = new RetroArrayIterator(this._source);
     return result._index = this._index, result;
    }, RetroArrayIterator.prototype.next = function() {
     if (!(this._index < 0 || this._index >= this._source.length)) return this._source[this._index--];
    }, RetroArrayIterator;
   }();
   function topologicSort(edges) {
    var sorted = [], visited = new Set, graph = new Map;
    return each(edges, (function(edge) {
     var fromNode = edge[0], toNode = edge[1], children = graph.get(toNode);
     children ? children.push(fromNode) : graph.set(toNode, [ fromNode ]);
    })), graph.forEach((function(v, k) {
     visit(k);
    })), sorted;
    function visit(node) {
     if (!visited.has(node)) {
      visited.add(node);
      var children = graph.get(node);
      children && children.forEach(visit), sorted.push(node);
     }
    }
   }
   function stride(object, step) {
    return new StrideIterator(iter(object), step);
   }
   var StringExt, StrideIterator = function() {
    function StrideIterator(source, step) {
     this._source = source, this._step = step;
    }
    return StrideIterator.prototype.iter = function() {
     return this;
    }, StrideIterator.prototype.clone = function() {
     return new StrideIterator(this._source.clone(), this._step);
    }, StrideIterator.prototype.next = function() {
     for (var value = this._source.next(), n = this._step - 1; n > 0; --n) this._source.next();
     return value;
    }, StrideIterator;
   }();
   function take(object, count) {
    return new TakeIterator(iter(object), count);
   }
   !function(StringExt) {
    function findIndices(source, query, start) {
     void 0 === start && (start = 0);
     for (var indices = new Array(query.length), i = 0, j = start, n = query.length; i < n; ++i, 
     ++j) {
      if (-1 === (j = source.indexOf(query[i], j))) return null;
      indices[i] = j;
     }
     return indices;
    }
    StringExt.findIndices = findIndices, StringExt.matchSumOfSquares = function(source, query, start) {
     void 0 === start && (start = 0);
     var indices = findIndices(source, query, start);
     if (!indices) return null;
     for (var score = 0, i = 0, n = indices.length; i < n; ++i) {
      var j = indices[i] - start;
      score += j * j;
     }
     return {
      score,
      indices
     };
    }, StringExt.matchSumOfDeltas = function(source, query, start) {
     void 0 === start && (start = 0);
     var indices = findIndices(source, query, start);
     if (!indices) return null;
     for (var score = 0, last = start - 1, i = 0, n = indices.length; i < n; ++i) {
      var j = indices[i];
      score += j - last - 1, last = j;
     }
     return {
      score,
      indices
     };
    }, StringExt.highlight = function(source, indices, fn) {
     for (var result = [], k = 0, last = 0, n = indices.length; k < n; ) {
      for (var i = indices[k], j = indices[k]; ++k < n && indices[k] === j + 1; ) j++;
      last < i && result.push(source.slice(last, i)), i < j + 1 && result.push(fn(source.slice(i, j + 1))), 
      last = j + 1;
     }
     return last < source.length && result.push(source.slice(last)), result;
    }, StringExt.cmp = function(a, b) {
     return a < b ? -1 : a > b ? 1 : 0;
    };
   }(StringExt || (StringExt = {}));
   var TakeIterator = function() {
    function TakeIterator(source, count) {
     this._source = source, this._count = count;
    }
    return TakeIterator.prototype.iter = function() {
     return this;
    }, TakeIterator.prototype.clone = function() {
     return new TakeIterator(this._source.clone(), this._count);
    }, TakeIterator.prototype.next = function() {
     if (!(this._count <= 0)) {
      var value = this._source.next();
      if (void 0 !== value) return this._count--, value;
     }
    }, TakeIterator;
   }();
   function zip() {
    for (var objects = [], _i = 0; _i < arguments.length; _i++) objects[_i] = arguments[_i];
    return new ZipIterator(objects.map(iter));
   }
   var ZipIterator = function() {
    function ZipIterator(source) {
     this._source = source;
    }
    return ZipIterator.prototype.iter = function() {
     return this;
    }, ZipIterator.prototype.clone = function() {
     return new ZipIterator(this._source.map((function(it) {
      return it.clone();
     })));
    }, ZipIterator.prototype.next = function() {
     for (var result = new Array(this._source.length), i = 0, n = this._source.length; i < n; ++i) {
      var value = this._source[i].next();
      if (void 0 === value) return;
      result[i] = value;
     }
     return result;
    }, ZipIterator;
   }();
  },
  93498: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   var JSONExt;
   __webpack_require__.r(__webpack_exports__), __webpack_require__.d(__webpack_exports__, {
    Debouncer: () => Debouncer,
    Poll: () => Poll,
    RateLimiter: () => RateLimiter,
    Throttler: () => Throttler
   }), function(JSONExt) {
    function isPrimitive(value) {
     return null === value || "boolean" == typeof value || "number" == typeof value || "string" == typeof value;
    }
    function isArray(value) {
     return Array.isArray(value);
    }
    function deepEqual(first, second) {
     if (first === second) return !0;
     if (isPrimitive(first) || isPrimitive(second)) return !1;
     var a1 = isArray(first), a2 = isArray(second);
     return a1 === a2 && (a1 && a2 ? function(first, second) {
      if (first === second) return !0;
      if (first.length !== second.length) return !1;
      for (var i = 0, n = first.length; i < n; ++i) if (!deepEqual(first[i], second[i])) return !1;
      return !0;
     }(first, second) : function(first, second) {
      if (first === second) return !0;
      for (var key in first) if (void 0 !== first[key] && !(key in second)) return !1;
      for (var key in second) if (void 0 !== second[key] && !(key in first)) return !1;
      for (var key in first) {
       var firstValue = first[key], secondValue = second[key];
       if (void 0 !== firstValue || void 0 !== secondValue) {
        if (void 0 === firstValue || void 0 === secondValue) return !1;
        if (!deepEqual(firstValue, secondValue)) return !1;
       }
      }
      return !0;
     }(first, second));
    }
    function deepCopy(value) {
     return isPrimitive(value) ? value : isArray(value) ? function(value) {
      for (var result = new Array(value.length), i = 0, n = value.length; i < n; ++i) result[i] = deepCopy(value[i]);
      return result;
     }(value) : function(value) {
      var result = {};
      for (var key in value) {
       var subvalue = value[key];
       void 0 !== subvalue && (result[key] = deepCopy(subvalue));
      }
      return result;
     }(value);
    }
    JSONExt.emptyObject = Object.freeze({}), JSONExt.emptyArray = Object.freeze([]), 
    JSONExt.isPrimitive = isPrimitive, JSONExt.isArray = isArray, JSONExt.isObject = function(value) {
     return !isPrimitive(value) && !isArray(value);
    }, JSONExt.deepEqual = deepEqual, JSONExt.deepCopy = deepCopy;
   }(JSONExt || (JSONExt = {}));
   !function() {
    function MimeData() {
     this._types = [], this._values = [];
    }
    MimeData.prototype.types = function() {
     return this._types.slice();
    }, MimeData.prototype.hasData = function(mime) {
     return -1 !== this._types.indexOf(mime);
    }, MimeData.prototype.getData = function(mime) {
     var i = this._types.indexOf(mime);
     return -1 !== i ? this._values[i] : void 0;
    }, MimeData.prototype.setData = function(mime, data) {
     this.clearData(mime), this._types.push(mime), this._values.push(data);
    }, MimeData.prototype.clearData = function(mime) {
     var i = this._types.indexOf(mime);
     -1 !== i && (this._types.splice(i, 1), this._values.splice(i, 1));
    }, MimeData.prototype.clear = function() {
     this._types.length = 0, this._values.length = 0;
    };
   }();
   var Random, UUID, PromiseDelegate = function() {
    function PromiseDelegate() {
     var _this = this;
     this.promise = new Promise((function(resolve, reject) {
      _this._resolve = resolve, _this._reject = reject;
     }));
    }
    return PromiseDelegate.prototype.resolve = function(value) {
     (0, this._resolve)(value);
    }, PromiseDelegate.prototype.reject = function(reason) {
     (0, this._reject)(reason);
    }, PromiseDelegate;
   }();
   function fallbackRandomValues(buffer) {
    for (var value = 0, i = 0, n = buffer.length; i < n; ++i) i % 4 == 0 && (value = 4294967295 * Math.random() >>> 0), 
    buffer[i] = 255 & value, value >>>= 8;
   }
   !function(Random) {
    Random.getRandomValues = function() {
     var crypto = "undefined" != typeof window && (window.crypto || window.msCrypto) || null;
     return crypto && "function" == typeof crypto.getRandomValues ? function(buffer) {
      return crypto.getRandomValues(buffer);
     } : fallbackRandomValues;
    }();
   }(Random || (Random = {})), function(UUID) {
    UUID.uuid4 = function(getRandomValues) {
     for (var bytes = new Uint8Array(16), lut = new Array(256), i = 0; i < 16; ++i) lut[i] = "0" + i.toString(16);
     for (i = 16; i < 256; ++i) lut[i] = i.toString(16);
     return function() {
      return getRandomValues(bytes), bytes[6] = 64 | 15 & bytes[6], bytes[8] = 128 | 63 & bytes[8], 
      lut[bytes[0]] + lut[bytes[1]] + lut[bytes[2]] + lut[bytes[3]] + "-" + lut[bytes[4]] + lut[bytes[5]] + "-" + lut[bytes[6]] + lut[bytes[7]] + "-" + lut[bytes[8]] + lut[bytes[9]] + "-" + lut[bytes[10]] + lut[bytes[11]] + lut[bytes[12]] + lut[bytes[13]] + lut[bytes[14]] + lut[bytes[15]];
     };
    }(Random.getRandomValues);
   }(UUID || (UUID = {}));
   var Private, index_es6 = __webpack_require__(56588), dist_index_es6 = __webpack_require__(21628), Signal = function() {
    function Signal(sender) {
     this._blockedCount = 0, this.sender = sender;
    }
    return Signal.prototype.block = function(fn) {
     this._blockedCount++;
     try {
      fn();
     } finally {
      this._blockedCount--;
     }
    }, Signal.prototype.connect = function(slot, thisArg) {
     return Private.connect(this, slot, thisArg);
    }, Signal.prototype.disconnect = function(slot, thisArg) {
     return Private.disconnect(this, slot, thisArg);
    }, Signal.prototype.emit = function(args) {
     this._blockedCount || Private.emit(this, args);
    }, Signal;
   }();
   !function(Signal) {
    Signal.blockAll = function(sender, fn) {
     var blockedProperty = Private.blockedProperty;
     blockedProperty.set(sender, blockedProperty.get(sender) + 1);
     try {
      fn();
     } finally {
      blockedProperty.set(sender, blockedProperty.get(sender) - 1);
     }
    }, Signal.disconnectBetween = function(sender, receiver) {
     Private.disconnectBetween(sender, receiver);
    }, Signal.disconnectSender = function(sender) {
     Private.disconnectSender(sender);
    }, Signal.disconnectReceiver = function(receiver) {
     Private.disconnectReceiver(receiver);
    }, Signal.disconnectAll = function(object) {
     Private.disconnectAll(object);
    }, Signal.clearData = function(object) {
     Private.disconnectAll(object);
    }, Signal.getExceptionHandler = function() {
     return Private.exceptionHandler;
    }, Signal.setExceptionHandler = function(handler) {
     var old = Private.exceptionHandler;
     return Private.exceptionHandler = handler, old;
    };
   }(Signal || (Signal = {})), function(Private) {
    function disconnectSender(sender) {
     var receivers = receiversForSender.get(sender);
     receivers && 0 !== receivers.length && ((0, index_es6.each)(receivers, (function(connection) {
      if (connection.signal) {
       var receiver = connection.thisArg || connection.slot;
       connection.signal = null, scheduleCleanup(sendersForReceiver.get(receiver));
      }
     })), scheduleCleanup(receivers));
    }
    function disconnectReceiver(receiver) {
     var senders = sendersForReceiver.get(receiver);
     senders && 0 !== senders.length && ((0, index_es6.each)(senders, (function(connection) {
      if (connection.signal) {
       var sender = connection.signal.sender;
       connection.signal = null, scheduleCleanup(receiversForSender.get(sender));
      }
     })), scheduleCleanup(senders));
    }
    Private.exceptionHandler = function(err) {
     console.error(err);
    }, Private.connect = function(signal, slot, thisArg) {
     thisArg = thisArg || void 0;
     var receivers = receiversForSender.get(signal.sender);
     if (receivers || (receivers = [], receiversForSender.set(signal.sender, receivers)), 
     findConnection(receivers, signal, slot, thisArg)) return !1;
     var receiver = thisArg || slot, senders = sendersForReceiver.get(receiver);
     senders || (senders = [], sendersForReceiver.set(receiver, senders));
     var connection = {
      signal,
      slot,
      thisArg
     };
     return receivers.push(connection), senders.push(connection), !0;
    }, Private.disconnect = function(signal, slot, thisArg) {
     thisArg = thisArg || void 0;
     var receivers = receiversForSender.get(signal.sender);
     if (!receivers || 0 === receivers.length) return !1;
     var connection = findConnection(receivers, signal, slot, thisArg);
     if (!connection) return !1;
     var receiver = thisArg || slot, senders = sendersForReceiver.get(receiver);
     return connection.signal = null, scheduleCleanup(receivers), scheduleCleanup(senders), 
     !0;
    }, Private.disconnectBetween = function(sender, receiver) {
     var receivers = receiversForSender.get(sender);
     if (receivers && 0 !== receivers.length) {
      var senders = sendersForReceiver.get(receiver);
      senders && 0 !== senders.length && ((0, index_es6.each)(senders, (function(connection) {
       connection.signal && connection.signal.sender === sender && (connection.signal = null);
      })), scheduleCleanup(receivers), scheduleCleanup(senders));
     }
    }, Private.disconnectSender = disconnectSender, Private.disconnectReceiver = disconnectReceiver, 
    Private.disconnectAll = function(object) {
     disconnectSender(object), disconnectReceiver(object);
    }, Private.emit = function(signal, args) {
     if (!(Private.blockedProperty.get(signal.sender) > 0)) {
      var receivers = receiversForSender.get(signal.sender);
      if (receivers && 0 !== receivers.length) for (var i = 0, n = receivers.length; i < n; ++i) {
       var connection = receivers[i];
       connection.signal === signal && invokeSlot(connection, args);
      }
     }
    };
    var receiversForSender = new WeakMap, sendersForReceiver = new WeakMap, dirtySet = new Set, schedule = "function" == typeof requestAnimationFrame ? requestAnimationFrame : setImmediate;
    function findConnection(connections, signal, slot, thisArg) {
     return (0, index_es6.find)(connections, (function(connection) {
      return connection.signal === signal && connection.slot === slot && connection.thisArg === thisArg;
     }));
    }
    function invokeSlot(connection, args) {
     var signal = connection.signal, slot = connection.slot, thisArg = connection.thisArg;
     try {
      slot.call(thisArg, signal.sender, args);
     } catch (err) {
      Private.exceptionHandler(err);
     }
    }
    function scheduleCleanup(array) {
     0 === dirtySet.size && schedule(cleanupDirtySet), dirtySet.add(array);
    }
    function cleanupDirtySet() {
     dirtySet.forEach(cleanupConnections), dirtySet.clear();
    }
    function cleanupConnections(connections) {
     index_es6.ArrayExt.removeAllWhere(connections, isDeadConnection);
    }
    function isDeadConnection(connection) {
     return null === connection.signal;
    }
    Private.blockedProperty = new dist_index_es6.AttachedProperty({
     name: "blocked",
     create: function() {
      return 0;
     }
    });
   }(Private || (Private = {}));
   var extendStatics = function(d, b) {
    return extendStatics = Object.setPrototypeOf || {
     __proto__: []
    } instanceof Array && function(d, b) {
     d.__proto__ = b;
    } || function(d, b) {
     for (var p in b) Object.prototype.hasOwnProperty.call(b, p) && (d[p] = b[p]);
    }, extendStatics(d, b);
   };
   function __extends(d, b) {
    if ("function" != typeof b && null !== b) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    function __() {
     this.constructor = d;
    }
    extendStatics(d, b), d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, 
    new __);
   }
   var __assign = function() {
    return __assign = Object.assign || function(t) {
     for (var s, i = 1, n = arguments.length; i < n; i++) for (var p in s = arguments[i]) Object.prototype.hasOwnProperty.call(s, p) && (t[p] = s[p]);
     return t;
    }, __assign.apply(this, arguments);
   };
   function __awaiter(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))((function(resolve, reject) {
     function fulfilled(value) {
      try {
       step(generator.next(value));
      } catch (e) {
       reject(e);
      }
     }
     function rejected(value) {
      try {
       step(generator.throw(value));
      } catch (e) {
       reject(e);
      }
     }
     function step(result) {
      var value;
      result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P((function(resolve) {
       resolve(value);
      }))).then(fulfilled, rejected);
     }
     step((generator = generator.apply(thisArg, _arguments || [])).next());
    }));
   }
   function __generator(thisArg, body) {
    var f, y, t, g, _ = {
     label: 0,
     sent: function() {
      if (1 & t[0]) throw t[1];
      return t[1];
     },
     trys: [],
     ops: []
    };
    return g = {
     next: verb(0),
     throw: verb(1),
     return: verb(2)
    }, "function" == typeof Symbol && (g[Symbol.iterator] = function() {
     return this;
    }), g;
    function verb(n) {
     return function(v) {
      return function(op) {
       if (f) throw new TypeError("Generator is already executing.");
       for (;_; ) try {
        if (f = 1, y && (t = 2 & op[0] ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 
        0) : y.next) && !(t = t.call(y, op[1])).done) return t;
        switch (y = 0, t && (op = [ 2 & op[0], t.value ]), op[0]) {
        case 0:
        case 1:
         t = op;
         break;

        case 4:
         return _.label++, {
          value: op[1],
          done: !1
         };

        case 5:
         _.label++, y = op[1], op = [ 0 ];
         continue;

        case 7:
         op = _.ops.pop(), _.trys.pop();
         continue;

        default:
         if (!(t = _.trys, (t = t.length > 0 && t[t.length - 1]) || 6 !== op[0] && 2 !== op[0])) {
          _ = 0;
          continue;
         }
         if (3 === op[0] && (!t || op[1] > t[0] && op[1] < t[3])) {
          _.label = op[1];
          break;
         }
         if (6 === op[0] && _.label < t[1]) {
          _.label = t[1], t = op;
          break;
         }
         if (t && _.label < t[2]) {
          _.label = t[2], _.ops.push(op);
          break;
         }
         t[2] && _.ops.pop(), _.trys.pop();
         continue;
        }
        op = body.call(thisArg, _);
       } catch (e) {
        op = [ 6, e ], y = 0;
       } finally {
        f = t = 0;
       }
       if (5 & op[0]) throw op[1];
       return {
        value: op[0] ? op[1] : void 0,
        done: !0
       };
      }([ n, v ]);
     };
    }
   }
   var index_es6_Private, defer = "function" == typeof requestAnimationFrame ? requestAnimationFrame : setImmediate, cancel = "function" == typeof cancelAnimationFrame ? cancelAnimationFrame : clearImmediate, Poll = function() {
    function Poll(options) {
     var _this = this;
     this._disposed = new Signal(this), this._tick = new PromiseDelegate, this._ticked = new Signal(this), 
     this._timeout = -1, this._factory = options.factory, this._standby = options.standby || index_es6_Private.DEFAULT_STANDBY, 
     this._state = __assign(__assign({}, index_es6_Private.DEFAULT_STATE), {
      timestamp: (new Date).getTime()
     });
     var frequency = options.frequency || {}, max = Math.max(frequency.interval || 0, frequency.max || 0, index_es6_Private.DEFAULT_FREQUENCY.max);
     this.frequency = __assign(__assign(__assign({}, index_es6_Private.DEFAULT_FREQUENCY), frequency), {
      max
     }), this.name = options.name || index_es6_Private.DEFAULT_NAME, "auto" in options && !options.auto || defer((function() {
      _this.start();
     }));
    }
    return Object.defineProperty(Poll.prototype, "disposed", {
     get: function() {
      return this._disposed;
     },
     enumerable: !0,
     configurable: !0
    }), Object.defineProperty(Poll.prototype, "frequency", {
     get: function() {
      return this._frequency;
     },
     set: function(frequency) {
      if (!this.isDisposed && !JSONExt.deepEqual(frequency, this.frequency || {})) {
       var backoff = frequency.backoff, interval = frequency.interval, max = frequency.max;
       if (interval = Math.round(interval), max = Math.round(max), "number" == typeof backoff && backoff < 1) throw new Error("Poll backoff growth factor must be at least 1");
       if ((interval < 0 || interval > max) && interval !== Poll.NEVER) throw new Error("Poll interval must be between 0 and max");
       if (max > Poll.MAX_INTERVAL && max !== Poll.NEVER) throw new Error("Max interval must be less than " + Poll.MAX_INTERVAL);
       this._frequency = {
        backoff,
        interval,
        max
       };
      }
     },
     enumerable: !0,
     configurable: !0
    }), Object.defineProperty(Poll.prototype, "isDisposed", {
     get: function() {
      return "disposed" === this.state.phase;
     },
     enumerable: !0,
     configurable: !0
    }), Object.defineProperty(Poll.prototype, "standby", {
     get: function() {
      return this._standby;
     },
     set: function(standby) {
      this.isDisposed || this.standby === standby || (this._standby = standby);
     },
     enumerable: !0,
     configurable: !0
    }), Object.defineProperty(Poll.prototype, "state", {
     get: function() {
      return this._state;
     },
     enumerable: !0,
     configurable: !0
    }), Object.defineProperty(Poll.prototype, "tick", {
     get: function() {
      return this._tick.promise;
     },
     enumerable: !0,
     configurable: !0
    }), Object.defineProperty(Poll.prototype, "ticked", {
     get: function() {
      return this._ticked;
     },
     enumerable: !0,
     configurable: !0
    }), Poll.prototype.dispose = function() {
     this.isDisposed || (this._state = __assign(__assign({}, index_es6_Private.DISPOSED_STATE), {
      timestamp: (new Date).getTime()
     }), this._tick.promise.catch((function(_) {})), this._tick.reject(new Error("Poll (" + this.name + ") is disposed.")), 
     this._disposed.emit(void 0), Signal.clearData(this));
    }, Poll.prototype.refresh = function() {
     return this.schedule({
      cancel: function(_a) {
       return "refreshed" === _a.phase;
      },
      interval: Poll.IMMEDIATE,
      phase: "refreshed"
     });
    }, Poll.prototype.schedule = function(next) {
     return void 0 === next && (next = {}), __awaiter(this, void 0, void 0, (function() {
      var last, pending, scheduled, state, execute, _this = this;
      return __generator(this, (function(_a) {
       switch (_a.label) {
       case 0:
        return this.isDisposed || next.cancel && next.cancel(this.state) ? [ 2 ] : (last = this.state, 
        pending = this._tick, scheduled = new PromiseDelegate, state = __assign({
         interval: this.frequency.interval,
         payload: null,
         phase: "standby",
         timestamp: (new Date).getTime()
        }, next), this._state = state, this._tick = scheduled, last.interval === Poll.IMMEDIATE ? cancel(this._timeout) : clearTimeout(this._timeout), 
        this._ticked.emit(this.state), pending.resolve(this), [ 4, pending.promise ]);

       case 1:
        return _a.sent(), execute = function() {
         _this.isDisposed || _this.tick !== scheduled.promise || _this._execute();
        }, this._timeout = state.interval === Poll.IMMEDIATE ? defer(execute) : state.interval === Poll.NEVER ? -1 : setTimeout(execute, state.interval), 
        [ 2 ];
       }
      }));
     }));
    }, Poll.prototype.start = function() {
     return this.schedule({
      cancel: function(_a) {
       var phase = _a.phase;
       return "constructed" !== phase && "standby" !== phase && "stopped" !== phase;
      },
      interval: Poll.IMMEDIATE,
      phase: "started"
     });
    }, Poll.prototype.stop = function() {
     return this.schedule({
      cancel: function(_a) {
       return "stopped" === _a.phase;
      },
      interval: Poll.NEVER,
      phase: "stopped"
     });
    }, Poll.prototype._execute = function() {
     var _this = this, standby = "function" == typeof this.standby ? this.standby() : this.standby;
     if (standby = "never" !== standby && ("when-hidden" === standby ? !("undefined" == typeof document || !document || !document.hidden) : standby)) this.schedule(); else {
      var pending = this.tick;
      this._factory(this.state).then((function(resolved) {
       _this.isDisposed || _this.tick !== pending || _this.schedule({
        payload: resolved,
        phase: "rejected" === _this.state.phase ? "reconnected" : "resolved"
       });
      })).catch((function(rejected) {
       _this.isDisposed || _this.tick !== pending || _this.schedule({
        interval: index_es6_Private.sleep(_this.frequency, _this.state),
        payload: rejected,
        phase: "rejected"
       });
      }));
     }
    }, Poll;
   }();
   !function(Poll) {
    Poll.IMMEDIATE = 0, Poll.MAX_INTERVAL = 2147483647, Poll.NEVER = 1 / 0;
   }(Poll || (Poll = {})), function(Private) {
    Private.DEFAULT_BACKOFF = 3, Private.DEFAULT_FREQUENCY = {
     backoff: !0,
     interval: 1e3,
     max: 3e4
    }, Private.DEFAULT_NAME = "unknown", Private.DEFAULT_STANDBY = "when-hidden", Private.DEFAULT_STATE = {
     interval: Poll.NEVER,
     payload: null,
     phase: "constructed",
     timestamp: new Date(0).getTime()
    }, Private.DISPOSED_STATE = {
     interval: Poll.NEVER,
     payload: null,
     phase: "disposed",
     timestamp: new Date(0).getTime()
    }, Private.sleep = function(frequency, last) {
     var backoff = frequency.backoff, interval = frequency.interval, max = frequency.max;
     if (interval === Poll.NEVER) return interval;
     var growth = !0 === backoff ? Private.DEFAULT_BACKOFF : !1 === backoff ? 1 : backoff, random = function(min, max) {
      return min = Math.ceil(min), max = Math.floor(max), Math.floor(Math.random() * (max - min + 1)) + min;
     }(interval, last.interval * growth);
     return Math.min(max, random);
    };
   }(index_es6_Private || (index_es6_Private = {}));
   var RateLimiter = function() {
    function RateLimiter(fn, limit) {
     var _this = this;
     void 0 === limit && (limit = 500), this.args = void 0, this.payload = null, this.limit = limit, 
     this.poll = new Poll({
      auto: !1,
      factory: function() {
       return __awaiter(_this, void 0, void 0, (function() {
        var args;
        return __generator(this, (function(_a) {
         return args = this.args, this.args = void 0, [ 2, fn.apply(void 0, args) ];
        }));
       }));
      },
      frequency: {
       backoff: !1,
       interval: Poll.NEVER,
       max: Poll.NEVER
      },
      standby: "never"
     }), this.payload = new PromiseDelegate, this.poll.ticked.connect((function(_, state) {
      var payload = _this.payload;
      return "resolved" === state.phase ? (_this.payload = new PromiseDelegate, void payload.resolve(state.payload)) : "rejected" === state.phase || "stopped" === state.phase ? (_this.payload = new PromiseDelegate, 
      payload.promise.catch((function(_) {})), void payload.reject(state.payload)) : void 0;
     }), this);
    }
    return Object.defineProperty(RateLimiter.prototype, "isDisposed", {
     get: function() {
      return null === this.payload;
     },
     enumerable: !0,
     configurable: !0
    }), RateLimiter.prototype.dispose = function() {
     this.isDisposed || (this.args = void 0, this.payload = null, this.poll.dispose());
    }, RateLimiter.prototype.stop = function() {
     return __awaiter(this, void 0, void 0, (function() {
      return __generator(this, (function(_a) {
       return [ 2, this.poll.stop() ];
      }));
     }));
    }, RateLimiter;
   }(), Debouncer = function(_super) {
    function Debouncer() {
     return null !== _super && _super.apply(this, arguments) || this;
    }
    return __extends(Debouncer, _super), Debouncer.prototype.invoke = function() {
     for (var args = [], _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
     return this.args = args, this.poll.schedule({
      interval: this.limit,
      phase: "invoked"
     }), this.payload.promise;
    }, Debouncer;
   }(RateLimiter), Throttler = function(_super) {
    function Throttler(fn, options) {
     var _this = _super.call(this, fn, "number" == typeof options ? options : options && options.limit) || this;
     return _this._trailing = !1, "number" != typeof options && options && "trailing" === options.edge && (_this._trailing = !0), 
     _this._interval = _this._trailing ? _this.limit : Poll.IMMEDIATE, _this;
    }
    return __extends(Throttler, _super), Throttler.prototype.invoke = function() {
     for (var args = [], _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
     var idle = "invoked" !== this.poll.state.phase;
     return (idle || this._trailing) && (this.args = args), idle && this.poll.schedule({
      interval: this._interval,
      phase: "invoked"
     }), this.payload.promise;
    }, Throttler;
   }(RateLimiter);
  },
  21628: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.r(__webpack_exports__), __webpack_require__.d(__webpack_exports__, {
    AttachedProperty: () => AttachedProperty
   });
   var Private, AttachedProperty = function() {
    function AttachedProperty(options) {
     this._pid = Private.nextPID(), this.name = options.name, this._create = options.create, 
     this._coerce = options.coerce || null, this._compare = options.compare || null, 
     this._changed = options.changed || null;
    }
    return AttachedProperty.prototype.get = function(owner) {
     var map = Private.ensureMap(owner);
     return this._pid in map ? map[this._pid] : map[this._pid] = this._createValue(owner);
    }, AttachedProperty.prototype.set = function(owner, value) {
     var oldValue, map = Private.ensureMap(owner);
     oldValue = this._pid in map ? map[this._pid] : map[this._pid] = this._createValue(owner);
     var newValue = this._coerceValue(owner, value);
     this._maybeNotify(owner, oldValue, map[this._pid] = newValue);
    }, AttachedProperty.prototype.coerce = function(owner) {
     var oldValue, map = Private.ensureMap(owner);
     oldValue = this._pid in map ? map[this._pid] : map[this._pid] = this._createValue(owner);
     var newValue = this._coerceValue(owner, oldValue);
     this._maybeNotify(owner, oldValue, map[this._pid] = newValue);
    }, AttachedProperty.prototype._createValue = function(owner) {
     return (0, this._create)(owner);
    }, AttachedProperty.prototype._coerceValue = function(owner, value) {
     var coerce = this._coerce;
     return coerce ? coerce(owner, value) : value;
    }, AttachedProperty.prototype._compareValue = function(oldValue, newValue) {
     var compare = this._compare;
     return compare ? compare(oldValue, newValue) : oldValue === newValue;
    }, AttachedProperty.prototype._maybeNotify = function(owner, oldValue, newValue) {
     var changed = this._changed;
     changed && !this._compareValue(oldValue, newValue) && changed(owner, oldValue, newValue);
    }, AttachedProperty;
   }();
   !function(AttachedProperty) {
    AttachedProperty.clearData = function(owner) {
     Private.ownerData.delete(owner);
    };
   }(AttachedProperty || (AttachedProperty = {})), function(Private) {
    var id;
    Private.ownerData = new WeakMap, Private.nextPID = (id = 0, function() {
     return "pid-" + ("" + Math.random()).slice(2) + "-" + id++;
    }), Private.ensureMap = function(owner) {
     var map = Private.ownerData.get(owner);
     return map || (map = Object.create(null), Private.ownerData.set(owner, map), map);
    };
   }(Private || (Private = {}));
  },
  80956: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.r(__webpack_exports__), __webpack_require__.d(__webpack_exports__, {
    ActiveStatus: () => InitActiveStatusEnum.f,
    AppInsightsCore: () => AppInsightsCore_AppInsightsCore,
    BaseTelemetryPlugin: () => BaseTelemetryPlugin.s,
    DiagnosticLogger: () => DiagnosticLogger.wq,
    EventLatency: () => EventLatency,
    EventPersistence: () => EventPersistence,
    EventPropertyType: () => EventPropertyType,
    EventsDiscardedReason: () => EventsDiscardedReason.x,
    FullVersionString: () => Utils.xE,
    InternalAppInsightsCore: () => AppInsightsCore._,
    LoggingSeverity: () => LoggingSeverity,
    MinChannelPriorty: () => MinChannelPriorty,
    NotificationManager: () => NotificationManager.h,
    PerfEvent: () => PerfManager.Q6,
    PerfManager: () => PerfManager.NS,
    ProcessTelemetryContext: () => ProcessTelemetryContext.W0,
    SenderPostManager: () => SenderPostManager.v,
    TraceLevel: () => TraceLevel,
    Undefined: () => Constants.bA,
    ValueKind: () => ValueKind,
    ValueSanitizer: () => ValueSanitizer,
    Version: () => Utils.Rx,
    _InternalLogMessage: () => DiagnosticLogger.WD,
    __getRegisteredEvents: () => EventHelpers.El,
    _appendHeader: () => HelperFuncs.LU,
    _getAllResponseHeaders: () => HelperFuncs.w3,
    _logInternalMessage: () => DiagnosticLogger.Oc,
    _testHookMaxUnloadHooksCb: () => UnloadHookContainer.d,
    _throwInternal: () => DiagnosticLogger.ZP,
    _warnToConsole: () => DiagnosticLogger.OG,
    addEventHandler: () => EventHelpers.So,
    addEventListeners: () => EventHelpers.lQ,
    addPageHideEventListener: () => EventHelpers.Fc,
    addPageShowEventListener: () => EventHelpers.oS,
    addPageUnloadEventListener: () => EventHelpers.ee,
    areCookiesSupported: () => CookieMgr.gi,
    arrForEach: () => ts_utils.Iuo,
    arrIndexOf: () => ts_utils.rDm,
    arrMap: () => ts_utils.W$7,
    arrReduce: () => ts_utils.KTd,
    attachEvent: () => EventHelpers.Q3,
    blockDynamicConversion: () => DynamicSupport.V9,
    convertAllHeadersToMap: () => HelperFuncs.IL,
    cookieAvailable: () => CookieMgr.gi,
    createCookieMgr: () => CookieMgr.xN,
    createDynamicConfig: () => DynamicConfig.e,
    createEnumStyle: () => EnumHelperFuncs.H,
    createGuid: () => Utils.gj,
    createProcessTelemetryContext: () => ProcessTelemetryContext.i8,
    createTraceParent: () => W3cTraceParent.wk,
    createUniqueNamespace: () => DataCacheHelper.Z,
    createUnloadHandlerContainer: () => UnloadHandlerContainer.P,
    dateNow: () => ts_utils.f0d,
    detachEvent: () => EventHelpers.Ym,
    disallowsSameSiteNone: () => CookieMgr.It,
    doPerf: () => PerfManager.r2,
    dumpObj: () => ts_utils.mmD,
    eventOff: () => EventHelpers.ML,
    eventOn: () => EventHelpers.mB,
    extend: () => Utils.X$,
    findW3cTraceParent: () => W3cTraceParent.ef,
    forceDynamicConversion: () => DynamicSupport.Hf,
    formatErrorMessageXdr: () => HelperFuncs.HU,
    formatErrorMessageXhr: () => HelperFuncs.r4,
    formatTraceParent: () => W3cTraceParent.L0,
    generateW3CId: () => CoreUtils.cL,
    getCommonSchemaMetaData: () => Utils.Go,
    getConsole: () => EnvUtils.U5,
    getCookieValue: () => Utils.UM,
    getCrypto: () => EnvUtils.MY,
    getDocument: () => ts_utils.YEm,
    getDynamicConfigHandler: () => DynamicSupport.QA,
    getExceptionName: () => HelperFuncs.lL,
    getFieldValueType: () => Utils.cq,
    getGlobal: () => ts_utils.mS$,
    getGlobalInst: () => ts_utils.zS2,
    getHistory: () => ts_utils.JKf,
    getIEVersion: () => EnvUtils.L0,
    getISOString: () => HelperFuncs._u,
    getJSON: () => EnvUtils.hm,
    getLocation: () => EnvUtils.g$,
    getMsCrypto: () => EnvUtils.iN,
    getNavigator: () => ts_utils.w3n,
    getPerformance: () => ts_utils.FJj,
    getResponseText: () => HelperFuncs.Lo,
    getSetValue: () => HelperFuncs.c2,
    getTenantId: () => Utils.EO,
    getTime: () => Utils.WB,
    getWindow: () => ts_utils.zkX,
    hasDocument: () => ts_utils.Wtk,
    hasHistory: () => ts_utils.twz,
    hasJSON: () => EnvUtils.Z,
    hasNavigator: () => ts_utils.w9M,
    hasOwnProperty: () => ts_utils.v0u,
    hasWindow: () => ts_utils.Vdv,
    isArray: () => ts_utils.cyL,
    isArrayValid: () => Utils.wJ,
    isBeaconsSupported: () => EnvUtils.Uf,
    isBoolean: () => ts_utils.Lmq,
    isChromium: () => Utils.F2,
    isDate: () => ts_utils.$PY,
    isDocumentObjectAvailable: () => Utils.g8,
    isError: () => ts_utils.bJ7,
    isFetchSupported: () => EnvUtils.R7,
    isFunction: () => ts_utils.Tnt,
    isGreaterThanZero: () => Utils.ei,
    isIE: () => EnvUtils.lT,
    isLatency: () => Utils.Hh,
    isNotTruthy: () => ts_utils.woc,
    isNullOrUndefined: () => ts_utils.hXl,
    isNumber: () => ts_utils.EtT,
    isObject: () => ts_utils.Gvm,
    isReactNative: () => EnvUtils.lV,
    isSampledFlag: () => W3cTraceParent.N7,
    isString: () => ts_utils.KgX,
    isTruthy: () => ts_utils.zzB,
    isTypeof: () => ts_utils.Edw,
    isUint8ArrayAvailable: () => Utils.h3,
    isUndefined: () => ts_utils.b07,
    isValidSpanId: () => W3cTraceParent.wN,
    isValidTraceId: () => W3cTraceParent.hX,
    isValidTraceParent: () => W3cTraceParent.mJ,
    isValueAssigned: () => Utils.yD,
    isValueKind: () => Utils.m0,
    isWindowObjectAvailable: () => Utils.P$,
    isXhrSupported: () => EnvUtils.xk,
    mergeEvtNamespace: () => EventHelpers.Hm,
    newGuid: () => CoreUtils.aq,
    newId: () => RandomHelper.Si,
    normalizeJsName: () => HelperFuncs.cH,
    objDefineAccessors: () => ts_utils.raO,
    objForEachKey: () => ts_utils.zav,
    objFreeze: () => ts_utils.N6t,
    objKeys: () => ts_utils.cGk,
    objSeal: () => ts_utils.jsL,
    onConfigChange: () => DynamicConfig.a,
    openXhr: () => Utils.H$,
    optimizeObject: () => HelperFuncs.hW,
    parseResponse: () => ResponseHelpers.x,
    parseTraceParent: () => W3cTraceParent.ZI,
    perfNow: () => ts_utils.UUD,
    prependTransports: () => HelperFuncs.jL,
    proxyAssign: () => HelperFuncs.qz,
    proxyFunctionAs: () => HelperFuncs.RF,
    proxyFunctions: () => HelperFuncs.o$,
    random32: () => RandomHelper.VN,
    randomValue: () => RandomHelper.Z1,
    removeEventHandler: () => EventHelpers.zh,
    removeEventListeners: () => EventHelpers.Wg,
    removePageHideEventListener: () => EventHelpers.sq,
    removePageShowEventListener: () => EventHelpers.vF,
    removePageUnloadEventListener: () => EventHelpers.Ds,
    safeGetCookieMgr: () => CookieMgr.um,
    safeGetLogger: () => DiagnosticLogger.y0,
    sanitizeProperty: () => Utils.TC,
    setEnableEnvMocks: () => EnvUtils.cU,
    setProcessTelemetryTimings: () => Utils.u9,
    setValue: () => HelperFuncs.KY,
    strContains: () => HelperFuncs.Ju,
    strEndsWith: () => ts_utils.Cv9,
    strFunction: () => Constants.hW,
    strObject: () => Constants._1,
    strPrototype: () => Constants.vR,
    strStartsWith: () => ts_utils.tGl,
    strTrim: () => ts_utils.EHq,
    strUndefined: () => Constants.bA,
    throwError: () => ts_utils.$8,
    toISOString: () => HelperFuncs._u,
    useXDomainRequest: () => EnvUtils.PV
   });
   var TsLibShims = __webpack_require__(10659), DynamicProto = __webpack_require__(68279), ts_utils = __webpack_require__(269), PerfManager = __webpack_require__(28156), DynamicConfig = __webpack_require__(19749), DiagnosticLogger = __webpack_require__(23775), AppInsightsCore = __webpack_require__(82774), InternalConstants = __webpack_require__(90937), Utils = __webpack_require__(14822), _DynamicConstants = __webpack_require__(61739), defaultConfig = (0, 
   ts_utils.ZHX)({
    endpointUrl: InternalConstants.S,
    propertyStorageOverride: {
     isVal: function(propertyStorageOverride) {
      !propertyStorageOverride || propertyStorageOverride.getProperty && propertyStorageOverride.setProperty || (0, 
      ts_utils.$8)("Invalid property storage override passed.");
      return !0;
     }
    }
   });
   var AppInsightsCore_AppInsightsCore = function(_super) {
    function AppInsightsCore() {
     var _this = _super.call(this) || this;
     return (0, DynamicProto.A)(AppInsightsCore, _this, (function(_self, _base) {
      _self[_DynamicConstants.mE] = function(config, extensions, logger, notificationManager) {
       (0, PerfManager.r2)(_self, (function() {
        return "AppInsightsCore.initialize";
       }), (function() {
        try {
         _base[_DynamicConstants.mE]((0, DynamicConfig.e)(config, defaultConfig, logger || _self[_DynamicConstants.Uw], !1).cfg, extensions, logger, notificationManager);
        } catch (e) {
         var logger_1 = _self[_DynamicConstants.Uw], message = (0, ts_utils.mmD)(e);
         -1 !== message[_DynamicConstants.Sj]("channels") && (message += "\n - Channels must be provided through config.channels only!"), 
         (0, DiagnosticLogger.ZP)(logger_1, 1, 514, "SDK Initialization Failed - no telemetry will be sent: " + message);
        }
       }), (function() {
        return {
         config,
         extensions,
         logger,
         notificationManager
        };
       }));
      }, _self.track = function(item) {
       (0, PerfManager.r2)(_self, (function() {
        return "AppInsightsCore.track";
       }), (function() {
        var telemetryItem = item;
        if (telemetryItem) {
         telemetryItem[_DynamicConstants.dg] = telemetryItem[_DynamicConstants.dg] || {}, 
         telemetryItem[_DynamicConstants.dg].trackStart = (0, Utils.WB)(), (0, Utils.Hh)(telemetryItem.latency) || (telemetryItem.latency = 1);
         var itemExt = telemetryItem.ext = telemetryItem.ext || {};
         itemExt.sdk = itemExt.sdk || {}, itemExt.sdk.ver = Utils.xE;
         var baseData = telemetryItem.baseData = telemetryItem.baseData || {};
         baseData[InternalConstants._0] = baseData[InternalConstants._0] || {};
         var itemProperties = baseData[InternalConstants._0];
         itemProperties[InternalConstants.hj] = itemProperties[InternalConstants.hj] || _self.pluginVersionString || InternalConstants.m5;
        }
        _base.track(telemetryItem);
       }), (function() {
        return {
         item
        };
       }), !item.sync);
      }, _self[_DynamicConstants.h4] = function(eventName) {
       return _base[_DynamicConstants.h4](eventName || "InternalLog");
      };
     })), _this;
    }
    return (0, TsLibShims.qU)(AppInsightsCore, _super), AppInsightsCore.__ieDyn = 1, 
    AppInsightsCore;
   }(AppInsightsCore._), EnumHelperFuncs = __webpack_require__(84282), ValueKind = (0, 
   EnumHelperFuncs.H)({
    NotSet: 0,
    Pii_DistinguishedName: 1,
    Pii_GenericData: 2,
    Pii_IPV4Address: 3,
    Pii_IPv6Address: 4,
    Pii_MailSubject: 5,
    Pii_PhoneNumber: 6,
    Pii_QueryString: 7,
    Pii_SipAddress: 8,
    Pii_SmtpAddress: 9,
    Pii_Identity: 10,
    Pii_Uri: 11,
    Pii_Fqdn: 12,
    Pii_IPV4AddressLegacy: 13,
    Pii_IPv6ScrubLastHextets: 14,
    Pii_DropValue: 15,
    CustomerContent_GenericContent: 32
   }), EventLatency = (0, EnumHelperFuncs.H)({
    Normal: 1,
    CostDeferred: 2,
    RealTime: 3,
    Immediate: 4
   }), EventPropertyType = (0, EnumHelperFuncs.H)({
    Unspecified: 0,
    String: 1,
    Int32: 2,
    UInt32: 3,
    Int64: 4,
    UInt64: 5,
    Double: 6,
    Bool: 7,
    Guid: 8,
    DateTime: 9
   }), EventPersistence = (0, EnumHelperFuncs.H)({
    Normal: 1,
    Critical: 2
   }), TraceLevel = (0, EnumHelperFuncs.H)({
    NONE: 0,
    ERROR: 1,
    WARNING: 2,
    INFORMATION: 3
   }), ValueSanitizer = function() {
    function ValueSanitizer(fieldSanitizerProvider) {
     var _self = this, _sanitizerMap = {}, _sanitizers = [], _fieldSanitizers = [];
     function _getFieldSanitizer(path, name) {
      var result, fieldLookup = _sanitizerMap[path];
      if (fieldLookup && (result = fieldLookup[name]), !result && null !== result) {
       if ((0, ts_utils.KgX)(path) && (0, ts_utils.KgX)(name)) if (_fieldSanitizers[_DynamicConstants.oI] > 0) {
        for (var lp = 0; lp < _fieldSanitizers[_DynamicConstants.oI]; lp++) if (_fieldSanitizers[lp][_DynamicConstants.hF](path, name)) {
         result = {
          canHandle: !0,
          fieldHandler: _fieldSanitizers[lp]
         };
         break;
        }
       } else 0 === _sanitizers[_DynamicConstants.oI] && (result = {
        canHandle: !0
       });
       if (!result && null !== result) {
        result = null;
        for (lp = 0; lp < _sanitizers[_DynamicConstants.oI]; lp++) if (_sanitizers[lp][_DynamicConstants.hF](path, name)) {
         result = {
          canHandle: !0,
          handler: _sanitizers[lp],
          fieldHandler: null
         };
         break;
        }
       }
       fieldLookup || (fieldLookup = _sanitizerMap[path] = {}), fieldLookup[name] = result;
      }
      return result;
     }
     function _handleProperty(mapValue, path, name, fieldType, property, stringifyObjects) {
      if (mapValue.handler) return mapValue.handler.property(path, name, property, stringifyObjects);
      if (!(0, ts_utils.hXl)(property[_DynamicConstants.QV])) {
       if (!(4096 & ~fieldType && (0, Utils.m0)(property[_DynamicConstants.QV]))) return null;
       property[_DynamicConstants.pF] = property[_DynamicConstants.pF].toString();
      }
      return _callFieldSanitizer(mapValue.fieldHandler, path, name, fieldType, property);
     }
     function _convertToProperty(path, name, value) {
      return (0, Utils.yD)(value) ? {
       value
      } : null;
     }
     function _callFieldSanitizer(fieldProvider, path, name, theType, property) {
      if (property && fieldProvider) {
       var sanitizer = fieldProvider.getSanitizer(path, name, theType, property[_DynamicConstants.QV], property.propertyType);
       if (sanitizer) if (4 === theType) {
        var newValue_1 = {}, propValue = property[_DynamicConstants.pF];
        (0, ts_utils.zav)(propValue, (function(propKey, theValue) {
         var newPath = path + "." + name;
         if ((0, Utils.yD)(theValue)) {
          var newProp = _convertToProperty(0, 0, theValue);
          (newProp = _callFieldSanitizer(fieldProvider, newPath, propKey, (0, Utils.cq)(theValue), newProp)) && (newValue_1[propKey] = newProp[_DynamicConstants.pF]);
         }
        })), property[_DynamicConstants.pF] = newValue_1;
       } else {
        var details = {
         path,
         name,
         type: theType,
         prop: property,
         sanitizer: _self
        };
        property = sanitizer.call(_self, details);
       }
      }
      return property;
     }
     fieldSanitizerProvider && _fieldSanitizers.push(fieldSanitizerProvider), _self.clearCache = function() {
      _sanitizerMap = {};
     }, _self.addSanitizer = function(newSanitizer) {
      newSanitizer && ((0, ts_utils.Nq2)(_sanitizers, newSanitizer) || _sanitizers.push(newSanitizer), 
      _sanitizerMap = {});
     }, _self.addFieldSanitizer = function(fieldSanitizer) {
      fieldSanitizer && ((0, ts_utils.Nq2)(_fieldSanitizers, fieldSanitizer) || _fieldSanitizers.push(fieldSanitizer), 
      _sanitizerMap = {});
     }, _self[_DynamicConstants.Rl] = function(theSanitizer) {
      if (theSanitizer) {
       var idx = (0, ts_utils.rDm)(_sanitizers, theSanitizer);
       -1 !== idx && (_sanitizers.splice(idx, 1), _sanitizerMap = {}), (0, ts_utils.Iuo)(_sanitizers, (function(sanitizer) {
        sanitizer && sanitizer[_DynamicConstants.Rl] && sanitizer[_DynamicConstants.Rl](theSanitizer);
       }));
      }
     }, _self[_DynamicConstants.Mr] = function(theFieldSanitizer) {
      if (theFieldSanitizer) {
       var idx = (0, ts_utils.rDm)(_fieldSanitizers, theFieldSanitizer);
       -1 !== idx && (_fieldSanitizers.splice(idx, 1), _sanitizerMap = {}), (0, ts_utils.Iuo)(_sanitizers, (function(sanitizer) {
        sanitizer && sanitizer[_DynamicConstants.Mr] && sanitizer[_DynamicConstants.Mr](theFieldSanitizer);
       }));
      }
     }, _self.isEmpty = function() {
      return (0, ts_utils.R3R)(_sanitizers) + (0, ts_utils.R3R)(_fieldSanitizers) === 0;
     }, _self[_DynamicConstants.hF] = function(path, name) {
      var mapValue = _getFieldSanitizer(path, name);
      return !!mapValue && mapValue[_DynamicConstants.nw];
     }, _self[_DynamicConstants.pF] = function(path, name, value, stringifyObjects) {
      var mapValue = _getFieldSanitizer(path, name);
      if (mapValue && mapValue[_DynamicConstants.nw]) {
       if (!mapValue || !mapValue[_DynamicConstants.nw]) return null;
       if (mapValue.handler) return mapValue.handler[_DynamicConstants.pF](path, name, value, stringifyObjects);
       if (!(0, ts_utils.KgX)(name) || (0, ts_utils.hXl)(value) || value === InternalConstants.m5) return null;
       var property = null, fieldType = (0, Utils.cq)(value);
       if (8192 & ~fieldType) 1 !== fieldType && 2 !== fieldType && 3 !== fieldType && 4096 & ~fieldType ? 4 === fieldType && (property = _convertToProperty(path, name, stringifyObjects ? JSON.stringify(value) : value)) : property = _convertToProperty(path, name, value); else {
        var subType = -8193 & fieldType;
        if (property = value, !(0, Utils.yD)(property[_DynamicConstants.pF]) || 1 !== subType && 2 !== subType && 3 !== subType && 4096 & ~subType) return null;
       }
       if (property) return _handleProperty(mapValue, path, name, fieldType, property, stringifyObjects);
      }
      return null;
     }, _self.property = function(path, name, property, stringifyObjects) {
      var mapValue = _getFieldSanitizer(path, name);
      if (!mapValue || !mapValue[_DynamicConstants.nw]) return null;
      if (!(0, ts_utils.KgX)(name) || (0, ts_utils.hXl)(property) || !(0, Utils.yD)(property[_DynamicConstants.pF])) return null;
      var fieldType = (0, Utils.cq)(property[_DynamicConstants.pF]);
      return 0 === fieldType ? null : _handleProperty(mapValue, path, name, fieldType, property, stringifyObjects);
     };
    }
    return ValueSanitizer.getFieldType = Utils.cq, ValueSanitizer;
   }(), MinChannelPriorty = 100, LoggingSeverity = (0, EnumHelperFuncs.H)({
    DISABLED: 0,
    CRITICAL: 1,
    WARNING: 2,
    DEBUG: 3
   }), NotificationManager = __webpack_require__(51356), BaseTelemetryPlugin = __webpack_require__(98257), ProcessTelemetryContext = __webpack_require__(72317), EventsDiscardedReason = __webpack_require__(13662), InitActiveStatusEnum = __webpack_require__(54875), EventHelpers = __webpack_require__(56149), HelperFuncs = __webpack_require__(13673), CoreUtils = __webpack_require__(69882), RandomHelper = __webpack_require__(76535), EnvUtils = __webpack_require__(7292), Constants = __webpack_require__(45664), CookieMgr = __webpack_require__(25034), DataCacheHelper = __webpack_require__(24276), UnloadHandlerContainer = __webpack_require__(60836), W3cTraceParent = __webpack_require__(91864), DynamicSupport = __webpack_require__(99147), SenderPostManager = __webpack_require__(90856), ResponseHelpers = __webpack_require__(31190), UnloadHookContainer = __webpack_require__(98969);
  },
  90937: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    S: () => STR_DEFAULT_ENDPOINT_URL,
    _0: () => STR_PROPERTIES,
    hj: () => STR_VERSION,
    m5: () => STR_EMPTY
   });
   var STR_EMPTY = "", STR_DEFAULT_ENDPOINT_URL = "https://browser.events.data.microsoft.com/OneCollector/1.0/", STR_VERSION = "version", STR_PROPERTIES = "properties";
  },
  14822: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    EO: () => getTenantId,
    F2: () => isChromium,
    Go: () => getCommonSchemaMetaData,
    H$: () => openXhr,
    Hh: () => isLatency,
    P$: () => isWindowObjectAvailable,
    Rx: () => Version,
    TC: () => sanitizeProperty,
    UM: () => getCookieValue,
    WB: () => getTime,
    X$: () => extend,
    cq: () => getFieldValueType,
    ei: () => isGreaterThanZero,
    g8: () => isDocumentObjectAvailable,
    gj: () => createGuid,
    h3: () => isUint8ArrayAvailable,
    m0: () => isValueKind,
    u9: () => setProcessTelemetryTimings,
    wJ: () => isArrayValid,
    xE: () => FullVersionString,
    yD: () => isValueAssigned
   });
   var _a, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(269), _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(7292), _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(69882), _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(45664), _InternalConstants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(90937), _DynamicConstants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(61739), Version = "4.3.3", FullVersionString = "1DS-Web-JS-" + Version, ObjHasOwnProperty = _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__.Wy.hasOwnProperty, strDisabledPropertyName = "Microsoft_ApplicationInsights_BypassAjaxInstrumentation", strWithCredentials = "withCredentials", strTimeout = "timeout", _fieldTypeEventPropMap = ((_a = {})[0] = 0, 
   _a[2] = 6, _a[1] = 1, _a[3] = 7, _a[4098] = 6, _a[4097] = 1, _a[4099] = 7, _a), uInt8ArraySupported = null, isDocumentObjectAvailable = (0, 
   _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.Wtk)(), isWindowObjectAvailable = (0, 
   _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.Vdv)();
   function isValueAssigned(value) {
    return !(value === _InternalConstants__WEBPACK_IMPORTED_MODULE_2__.m5 || (0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.hXl)(value));
   }
   function getTenantId(apiKey) {
    if (apiKey) {
     var indexTenantId = (0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.HzD)(apiKey, "-");
     if (indexTenantId > -1) return (0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.ZWZ)(apiKey, indexTenantId);
    }
    return _InternalConstants__WEBPACK_IMPORTED_MODULE_2__.m5;
   }
   function isUint8ArrayAvailable() {
    return null === uInt8ArraySupported && (uInt8ArraySupported = !(0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.b07)(Uint8Array) && !function() {
     var nav = (0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.w3n)();
     if (!(0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.b07)(nav) && nav.userAgent) {
      var ua = nav.userAgent.toLowerCase();
      if ((ua[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__.Sj]("safari") >= 0 || ua[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__.Sj]("firefox") >= 0) && ua[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__.Sj]("chrome") < 0) return !0;
     }
     return !1;
    }() && !(0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_3__.lV)()), 
    uInt8ArraySupported;
   }
   function isLatency(value) {
    return !!(value && (0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.EtT)(value) && value >= 1 && value <= 4);
   }
   function sanitizeProperty(name, property, stringifyObjects) {
    if (!property && !isValueAssigned(property) || "string" != typeof name) return null;
    var propType = typeof property;
    if ("string" === propType || "number" === propType || "boolean" === propType || (0, 
    _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.cyL)(property)) property = {
     value: property
    }; else if ("object" !== propType || ObjHasOwnProperty.call(property, "value")) {
     if ((0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.hXl)(property[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__.pF]) || property[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__.pF] === _InternalConstants__WEBPACK_IMPORTED_MODULE_2__.m5 || !(0, 
     _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.KgX)(property[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__.pF]) && !(0, 
     _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.EtT)(property[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__.pF]) && !(0, 
     _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.Lmq)(property[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__.pF]) && !(0, 
     _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.cyL)(property[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__.pF])) return null;
    } else property = {
     value: stringifyObjects ? JSON.stringify(property) : property
    };
    if ((0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.cyL)(property[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__.pF]) && !isArrayValid(property[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__.pF])) return null;
    if (!(0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.hXl)(property[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__.QV])) {
     if ((0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.cyL)(property[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__.pF]) || !isValueKind(property[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__.QV])) return null;
     property[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__.pF] = property[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__.pF].toString();
    }
    return property;
   }
   function getCommonSchemaMetaData(value, kind, type) {
    var encodedTypeValue = -1;
    if (!(0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.b07)(value)) if (kind > 0 && (32 === kind ? encodedTypeValue = 8192 : kind <= 13 && (encodedTypeValue = kind << 5)), 
    function(value) {
     if (value >= 0 && value <= 9) return !0;
     return !1;
    }(type)) -1 === encodedTypeValue && (encodedTypeValue = 0), encodedTypeValue |= type; else {
     var propType = _fieldTypeEventPropMap[getFieldValueType(value)] || -1;
     -1 !== encodedTypeValue && -1 !== propType ? encodedTypeValue |= propType : 6 === propType && (encodedTypeValue = propType);
    }
    return encodedTypeValue;
   }
   function getCookieValue(cookieMgr, name, decode) {
    var cookieValue;
    return void 0 === decode && (decode = !0), cookieMgr && (cookieValue = cookieMgr.get(name), 
    decode && cookieValue && decodeURIComponent && (cookieValue = decodeURIComponent(cookieValue))), 
    cookieValue || _InternalConstants__WEBPACK_IMPORTED_MODULE_2__.m5;
   }
   function createGuid(style) {
    void 0 === style && (style = "D");
    var theGuid = (0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_5__.aq)();
    return "B" === style ? theGuid = "{" + theGuid + "}" : "P" === style ? theGuid = "(" + theGuid + ")" : "N" === style && (theGuid = theGuid.replace(/-/g, _InternalConstants__WEBPACK_IMPORTED_MODULE_2__.m5)), 
    theGuid;
   }
   function extend(obj, obj2, obj3, obj4, obj5) {
    var extended = {}, deep = !1, i = 0, length = arguments[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__.oI], theArgs = arguments;
    for ((0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.Lmq)(theArgs[0]) && (deep = theArgs[0], 
    i++); i < length; i++) {
     obj = theArgs[i];
     (0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.zav)(obj, (function(prop, value) {
      deep && value && (0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.Gvm)(value) ? (0, 
      _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.cyL)(value) ? (extended[prop] = extended[prop] || [], 
      (0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.Iuo)(value, (function(arrayValue, arrayIndex) {
       arrayValue && (0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.Gvm)(arrayValue) ? extended[prop][arrayIndex] = extend(!0, extended[prop][arrayIndex], arrayValue) : extended[prop][arrayIndex] = arrayValue;
      }))) : extended[prop] = extend(!0, extended[prop], value) : extended[prop] = value;
     }));
    }
    return extended;
   }
   var getTime = _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.UUD;
   function isValueKind(value) {
    return 0 === value || value > 0 && value <= 13 || 32 === value;
   }
   function isArrayValid(value) {
    return value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__.oI] > 0;
   }
   function setProcessTelemetryTimings(event, identifier) {
    var evt = event;
    evt[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__.dg] = evt[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__.dg] || {}, 
    evt[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__.dg][_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__.Jg] = evt[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__.dg][_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__.Jg] || {}, 
    evt[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__.dg][_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__.Jg][identifier] = getTime();
   }
   function getFieldValueType(value) {
    var theType = 0;
    if (null != value) {
     var objType = typeof value;
     "string" === objType ? theType = 1 : "number" === objType ? theType = 2 : "boolean" === objType ? theType = 3 : objType === _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__._1 && (theType = 4, 
     (0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.cyL)(value) ? (theType = 4096, 
     value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__.oI] > 0 && (theType |= getFieldValueType(value[0]))) : ObjHasOwnProperty.call(value, "value") && (theType = 8192 | getFieldValueType(value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__.pF])));
    }
    return theType;
   }
   function isChromium() {
    return !!(0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.zS2)("chrome");
   }
   function openXhr(method, urlString, withCredentials, disabled, isSync, timeout) {
    function _wrapSetXhrProp(xhr, prop, value) {
     try {
      xhr[prop] = value;
     } catch (e) {}
    }
    void 0 === disabled && (disabled = !1), void 0 === isSync && (isSync = !1);
    var xhr = new XMLHttpRequest;
    return disabled && _wrapSetXhrProp(xhr, strDisabledPropertyName, disabled), withCredentials && _wrapSetXhrProp(xhr, strWithCredentials, withCredentials), 
    xhr.open(method, urlString, !isSync), withCredentials && _wrapSetXhrProp(xhr, strWithCredentials, withCredentials), 
    !isSync && timeout && _wrapSetXhrProp(xhr, strTimeout, timeout), xhr;
   }
   function isGreaterThanZero(value) {
    return value > 0;
   }
  },
  61739: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    Jg: () => _DYN_PROCESS_TELEMETRY_ST0,
    Mr: () => _DYN_RM_FIELD_SANITIZER,
    QV: () => _DYN_KIND,
    Rl: () => _DYN_RM_SANITIZER,
    Sj: () => _DYN_INDEX_OF,
    Uw: () => _DYN_LOGGER,
    dg: () => _DYN_TIMINGS,
    h4: () => _DYN_POLL_INTERNAL_LOGS,
    hF: () => _DYN_HANDLE_FIELD,
    mE: () => _DYN_INITIALIZE,
    nw: () => _DYN_CAN_HANDLE,
    oI: () => _DYN_LENGTH,
    pF: () => _DYN_VALUE
   });
   var _DYN_INITIALIZE = "initialize", _DYN_LOGGER = "logger", _DYN_INDEX_OF = "indexOf", _DYN_TIMINGS = "timings", _DYN_POLL_INTERNAL_LOGS = "pollInternalLogs", _DYN_VALUE = "value", _DYN_KIND = "kind", _DYN_LENGTH = "length", _DYN_PROCESS_TELEMETRY_ST0 = "processTelemetryStart", _DYN_HANDLE_FIELD = "handleField", _DYN_RM_SANITIZER = "rmSanitizer", _DYN_RM_FIELD_SANITIZER = "rmFieldSanitizer", _DYN_CAN_HANDLE = "canHandle";
  },
  78916: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.r(__webpack_exports__), __webpack_require__.d(__webpack_exports__, {
    BE_PROFILE: () => BE_PROFILE,
    NRT_PROFILE: () => NRT_PROFILE,
    PostChannel: () => PostChannel,
    RT_PROFILE: () => RT_PROFILE
   });
   var RT_PROFILE = "REAL_TIME", NRT_PROFILE = "NEAR_REAL_TIME", BE_PROFILE = "BEST_EFFORT", TsLibShims = __webpack_require__(10659), DynamicProto = __webpack_require__(68279), Utils = __webpack_require__(14822), ts_utils = __webpack_require__(269), PerfManager = __webpack_require__(28156), EventHelpers = __webpack_require__(56149), DataCacheHelper = __webpack_require__(24276), DynamicConfig = __webpack_require__(19749), ProcessTelemetryContext = __webpack_require__(72317), HelperFuncs = __webpack_require__(13673), EventsDiscardedReason = __webpack_require__(13662), DiagnosticLogger = __webpack_require__(23775), BaseTelemetryPlugin = __webpack_require__(98257), ts_async = __webpack_require__(8205);
   function _getEventMsfpc(theEvent) {
    var intWeb = (theEvent.ext || {}).intweb;
    return intWeb && (0, Utils.yD)(intWeb.msfpc) ? intWeb.msfpc : null;
   }
   function _getMsfpc(theEvents) {
    for (var msfpc = null, lp = 0; null === msfpc && lp < theEvents.length; lp++) msfpc = _getEventMsfpc(theEvents[lp]);
    return msfpc;
   }
   var EventBatch = function() {
    function EventBatch(iKey, addEvents) {
     var events = addEvents ? [].concat(addEvents) : [], _msfpc = _getMsfpc(events);
     this.iKey = function() {
      return iKey;
     }, this.Msfpc = function() {
      return _msfpc || "";
     }, this.count = function() {
      return events.length;
     }, this.events = function() {
      return events;
     }, this.addEvent = function(theEvent) {
      return !!theEvent && (events.push(theEvent), _msfpc || (_msfpc = _getEventMsfpc(theEvent)), 
      !0);
     }, this.split = function(fromEvent, numEvents) {
      var theEvents;
      if (fromEvent < events.length) {
       var cnt = events.length - fromEvent;
       (0, ts_utils.hXl)(numEvents) || (cnt = numEvents < cnt ? numEvents : cnt), theEvents = events.splice(fromEvent, cnt), 
       _msfpc = _getMsfpc(events);
      }
      return new EventBatch(iKey, theEvents);
     };
    }
    return EventBatch.create = function(iKey, theEvents) {
     return new EventBatch(iKey, theEvents);
    }, EventBatch;
   }(), EnvUtils = __webpack_require__(7292), SenderPostManager = __webpack_require__(90856), Constants = __webpack_require__(45664), ClockSkewManager = function() {
    function ClockSkewManager() {
     var _allowRequestSending = !0, _shouldAddClockSkewHeaders = !0, _isFirstRequest = !0, _clockSkewHeaderValue = "use-collector-delta", _clockSkewSet = !1;
     (0, DynamicProto.A)(ClockSkewManager, this, (function(_self) {
      _self.allowRequestSending = function() {
       return _allowRequestSending;
      }, _self.firstRequestSent = function() {
       _isFirstRequest && (_isFirstRequest = !1, _clockSkewSet || (_allowRequestSending = !1));
      }, _self.shouldAddClockSkewHeaders = function() {
       return _shouldAddClockSkewHeaders;
      }, _self.getClockSkewHeaderValue = function() {
       return _clockSkewHeaderValue;
      }, _self.setClockSkew = function(timeDeltaInMillis) {
       _clockSkewSet || (timeDeltaInMillis ? (_clockSkewHeaderValue = timeDeltaInMillis, 
       _shouldAddClockSkewHeaders = !0, _clockSkewSet = !0) : _shouldAddClockSkewHeaders = !1, 
       _allowRequestSending = !0);
      };
     }));
    }
    return ClockSkewManager.__ieDyn = 1, ClockSkewManager;
   }(), KillSwitch = function() {
    function KillSwitch() {
     var _killedTokenDictionary = {};
     (0, DynamicProto.A)(KillSwitch, this, (function(_self) {
      _self.setKillSwitchTenants = function(killTokens, killDuration) {
       if (killTokens && killDuration) try {
        var killedTokens = (values = killTokens.split(","), result = [], values && (0, ts_utils.Iuo)(values, (function(value) {
         result.push((0, ts_utils.EHq)(value));
        })), result);
        if ("this-request-only" === killDuration) return killedTokens;
        for (var durationMs = 1e3 * parseInt(killDuration, 10), i = 0; i < killedTokens.length; ++i) _killedTokenDictionary[killedTokens[i]] = (0, 
        ts_utils.f0d)() + durationMs;
       } catch (ex) {
        return [];
       }
       var values, result;
       return [];
      }, _self.isTenantKilled = function(tenantToken) {
       var killDictionary = _killedTokenDictionary, name = (0, ts_utils.EHq)(tenantToken);
       return void 0 !== killDictionary[name] && killDictionary[name] > (0, ts_utils.f0d)() || (delete killDictionary[name], 
       !1);
      };
     }));
    }
    return KillSwitch.__ieDyn = 1, KillSwitch;
   }();
   function retryPolicyGetMillisToBackoffForRetry(retriesSoFar) {
    var waitDuration, randomBackoff = Math.floor(1200 * Math.random()) + 2400;
    return waitDuration = Math.pow(2, retriesSoFar) * randomBackoff, Math.min(waitDuration, 6e5);
   }
   var _a, MaxBeaconRecordSize = Math.min(2e6, 65e3), f = "f", rCheckDot = /\./, Serializer = function() {
    function Serializer(perfManager, valueSanitizer, stringifyObjects, enableCompoundKey, getEncodedTypeOverride, excludeCsMetaData) {
     var _checkForCompoundkey = !!enableCompoundKey, _theSanitizer = valueSanitizer, _isReservedCache = {}, _excludeCsMetaData = !!excludeCsMetaData, _getEncodedType = getEncodedTypeOverride || Utils.Go;
     (0, DynamicProto.A)(Serializer, this, (function(_self) {
      function _processPathKeys(srcObj, target, thePath, checkReserved, metadataPathKeys, metadataCallback, processSubKeys) {
       (0, ts_utils.zav)(srcObj, (function(key, srcValue) {
        var prop = null;
        if (srcValue || (0, Utils.yD)(srcValue)) {
         var path = thePath, name_1 = key, theMetaPathKeys = metadataPathKeys, destObj = target;
         if (_checkForCompoundkey && !checkReserved && rCheckDot.test(key)) {
          var subKeys = key.split("."), keyLen = subKeys.length;
          if (keyLen > 1) {
           theMetaPathKeys && (theMetaPathKeys = theMetaPathKeys.slice());
           for (var lp = 0; lp < keyLen - 1; lp++) {
            var subKey = subKeys[lp];
            destObj = destObj[subKey] = destObj[subKey] || {}, path += "." + subKey, theMetaPathKeys && theMetaPathKeys.push(subKey);
           }
           name_1 = subKeys[keyLen - 1];
          }
         }
         var isReserved = checkReserved && function(path) {
          var result = _isReservedCache[path];
          return void 0 === result && (path.length >= 7 && (result = (0, ts_utils.tGl)(path, "ext.metadata") || (0, 
          ts_utils.tGl)(path, "ext.web")), _isReservedCache[path] = result), result;
         }(path);
         if (prop = !isReserved && _theSanitizer && _theSanitizer.handleField(path, name_1) ? _theSanitizer.value(path, name_1, srcValue, stringifyObjects) : (0, 
         Utils.TC)(name_1, srcValue, stringifyObjects)) {
          var newValue = prop.value;
          if (destObj[name_1] = newValue, metadataCallback && metadataCallback(theMetaPathKeys, name_1, prop), 
          processSubKeys && "object" == typeof newValue && !(0, ts_utils.cyL)(newValue)) {
           var newPath = theMetaPathKeys;
           newPath && (newPath = newPath.slice()).push(name_1), _processPathKeys(srcValue, newValue, path + "." + name_1, checkReserved, newPath, metadataCallback, processSubKeys);
          }
         }
        }
       }));
      }
      _self.createPayload = function(retryCnt, isTeardown, isSync, isReducedPayload, sendReason, sendType) {
       return {
        apiKeys: [],
        payloadBlob: "",
        overflow: null,
        sizeExceed: [],
        failedEvts: [],
        batches: [],
        numEvents: 0,
        retryCnt,
        isTeardown,
        isSync,
        isBeacon: isReducedPayload,
        sendType,
        sendReason
       };
      }, _self.appendPayload = function(payload, theBatch, maxEventsPerBatch) {
       var canAddEvents = payload && theBatch && !payload.overflow;
       return canAddEvents && (0, PerfManager.r2)(perfManager, (function() {
        return "Serializer:appendPayload";
       }), (function() {
        for (var theEvents = theBatch.events(), payloadBlob = payload.payloadBlob, payloadEvents = payload.numEvents, eventsAdded = !1, sizeExceeded = [], failedEvts = [], isBeaconPayload = payload.isBeacon, requestMaxSize = isBeaconPayload ? 65e3 : 3984588, recordMaxSize = isBeaconPayload ? MaxBeaconRecordSize : 2e6, lp = 0, joinCount = 0; lp < theEvents.length; ) {
         var theEvent = theEvents[lp];
         if (theEvent) {
          if (payloadEvents >= maxEventsPerBatch) {
           payload.overflow = theBatch.split(lp);
           break;
          }
          var eventBlob = _self.getEventBlob(theEvent);
          if (eventBlob && eventBlob.length <= recordMaxSize) {
           var blobLength = eventBlob.length;
           if (payloadBlob.length + blobLength > requestMaxSize) {
            payload.overflow = theBatch.split(lp);
            break;
           }
           payloadBlob && (payloadBlob += "\n"), payloadBlob += eventBlob, ++joinCount > 20 && ((0, 
           ts_utils.hKY)(payloadBlob, 0, 1), joinCount = 0), eventsAdded = !0, payloadEvents++;
          } else eventBlob ? sizeExceeded.push(theEvent) : failedEvts.push(theEvent), theEvents.splice(lp, 1), 
          lp--;
         }
         lp++;
        }
        if (sizeExceeded.length > 0 && payload.sizeExceed.push(EventBatch.create(theBatch.iKey(), sizeExceeded)), 
        failedEvts.length > 0 && payload.failedEvts.push(EventBatch.create(theBatch.iKey(), failedEvts)), 
        eventsAdded) {
         payload.batches.push(theBatch), payload.payloadBlob = payloadBlob, payload.numEvents = payloadEvents;
         var apiKey = theBatch.iKey();
         -1 === (0, ts_utils.rDm)(payload.apiKeys, apiKey) && payload.apiKeys.push(apiKey);
        }
       }), (function() {
        return {
         payload,
         theBatch: {
          iKey: theBatch.iKey(),
          evts: theBatch.events()
         },
         max: maxEventsPerBatch
        };
       })), canAddEvents;
      }, _self.getEventBlob = function(eventData) {
       try {
        return (0, PerfManager.r2)(perfManager, (function() {
         return "Serializer.getEventBlob";
        }), (function() {
         var serializedEvent = {};
         serializedEvent.name = eventData.name, serializedEvent.time = eventData.time, serializedEvent.ver = eventData.ver, 
         serializedEvent.iKey = "o:" + (0, Utils.EO)(eventData.iKey);
         var _addMetadataCallback, serializedExt = {};
         _excludeCsMetaData || (_addMetadataCallback = function(pathKeys, key, value) {
          !function(getEncodedType, json, propKeys, name, propertyValue) {
           if (propertyValue && json) {
            var encodedTypeValue = getEncodedType(propertyValue.value, propertyValue.kind, propertyValue.propertyType);
            if (encodedTypeValue > -1) {
             var metaData = json.metadata;
             metaData || (metaData = json.metadata = {
              f: {}
             });
             var metaTarget = metaData[f];
             if (metaTarget || (metaTarget = metaData[f] = {}), propKeys) for (var lp = 0; lp < propKeys.length; lp++) {
              var key = propKeys[lp];
              metaTarget[key] || (metaTarget[key] = {
               f: {}
              });
              var newTarget = metaTarget[key][f];
              newTarget || (newTarget = metaTarget[key][f] = {}), metaTarget = newTarget;
             }
             metaTarget = metaTarget[name] = {}, (0, ts_utils.cyL)(propertyValue.value) ? metaTarget.a = {
              t: encodedTypeValue
             } : metaTarget.t = encodedTypeValue;
            }
           }
          }(_getEncodedType, serializedExt, pathKeys, key, value);
         });
         var eventExt = eventData.ext;
         eventExt && (serializedEvent.ext = serializedExt, (0, ts_utils.zav)(eventExt, (function(key, value) {
          _processPathKeys(value, serializedExt[key] = {}, "ext." + key, !0, null, null, !0);
         })));
         var serializedData = serializedEvent.data = {};
         serializedData.baseType = eventData.baseType;
         var serializedBaseData = serializedData.baseData = {};
         return _processPathKeys(eventData.baseData, serializedBaseData, "baseData", !1, [ "baseData" ], _addMetadataCallback, true), 
         _processPathKeys(eventData.data, serializedData, "data", !1, [], _addMetadataCallback, true), 
         JSON.stringify(serializedEvent);
        }), (function() {
         return {
          item: eventData
         };
        }));
       } catch (e) {
        return null;
       }
      };
     }));
    }
    return Serializer.__ieDyn = 1, Serializer;
   }();
   function createTimeoutWrapper(argSetTimeout, argClearTimeout) {
    return {
     set: function(callback, ms) {
      for (var args = [], _i = 2; _i < arguments.length; _i++) args[_i - 2] = arguments[_i];
      return (0, ts_utils.vKV)([ argSetTimeout, argClearTimeout ], callback, ms, args);
     }
    };
   }
   var UrlQueryString = "?cors=true&" + "content-type".toLowerCase() + "=application/x-json-stream", _eventActionMap = ((_a = {})[1] = "requeue", 
   _a[100] = "requeue", _a[200] = "sent", _a[8004] = "drop", _a[8003] = "drop", _a), _collectorQsHeaders = {}, _collectorHeaderToQs = {};
   function _addCollectorHeaderQsMapping(qsName, headerName, allowQs) {
    _collectorQsHeaders[qsName] = headerName, !1 !== allowQs && (_collectorHeaderToQs[headerName] = qsName);
   }
   function _hasHeader(headers, header) {
    var hasHeader = !1;
    if (headers && header) {
     var keys = (0, ts_utils.cGk)(headers);
     if (keys && keys.length > 0) for (var lowerHeader = header.toLowerCase(), lp = 0; lp < keys.length; lp++) {
      var value = keys[lp];
      if (value && (0, ts_utils.v0u)(header, value) && value.toLowerCase() === lowerHeader) {
       hasHeader = !0;
       break;
      }
     }
    }
    return hasHeader;
   }
   function _addRequestDetails(details, name, value, useHeaders) {
    name && value && value.length > 0 && (useHeaders && _collectorQsHeaders[name] ? (details.hdrs[_collectorQsHeaders[name]] = value, 
    details.useHdrs = !0) : details.url += "&" + name + "=" + value);
   }
   _addCollectorHeaderQsMapping("AuthMsaDeviceTicket", "AuthMsaDeviceTicket", !1), 
   _addCollectorHeaderQsMapping("client-version", "client-version"), _addCollectorHeaderQsMapping("client-id", "Client-Id"), 
   _addCollectorHeaderQsMapping("apikey", "apikey"), _addCollectorHeaderQsMapping("time-delta-to-apply-millis", "time-delta-to-apply-millis"), 
   _addCollectorHeaderQsMapping("upload-time", "upload-time"), _addCollectorHeaderQsMapping("AuthXToken", "AuthXToken");
   var HttpManager = function() {
    function HttpManager(maxEventsPerBatch, maxConnections, maxRequestRetriesBeforeBackoff, actions) {
     var _urlString, _killSwitch, _paused, _clockSkewManager, _outstandingRequests, _postManager, _logger, _sendInterfaces, _core, _customHttpInterface, _queryStringParameters, _headers, _batchQueue, _serializer, _enableEventTimings, _cookieMgr, _isUnloading, _useHeaders, _xhrTimeout, _disableXhrSync, _disableFetchKeepAlive, _canHaveReducedPayload, _addNoResponse, _unloadHooks, _sendHook, _sendListener, _responseHandlers, _isInitialized, _timeoutWrapper, _excludeCsMetaData, _sendPostMgr, _fetchCredentials, _useBeacons = !1;
     (0, DynamicProto.A)(HttpManager, this, (function(_self) {
      _urlString = null, _killSwitch = new KillSwitch, _paused = !1, _clockSkewManager = new ClockSkewManager, 
      _useBeacons = !1, _outstandingRequests = 0, _postManager = null, _logger = null, 
      _sendInterfaces = null, _core = null, _customHttpInterface = !0, _queryStringParameters = [], 
      _headers = {}, _batchQueue = [], _serializer = null, _enableEventTimings = !1, _cookieMgr = null, 
      _isUnloading = !1, _useHeaders = !1, _xhrTimeout = void 0, _disableXhrSync = void 0, 
      _disableFetchKeepAlive = void 0, _canHaveReducedPayload = void 0, _addNoResponse = void 0, 
      _unloadHooks = [], _sendHook = void 0, _sendListener = void 0, _responseHandlers = [], 
      _isInitialized = !1, _timeoutWrapper = createTimeoutWrapper(), _excludeCsMetaData = !1, 
      _sendPostMgr = null;
      function _getSenderInterface(transports, syncSupport) {
       try {
        return _sendPostMgr && _sendPostMgr.getSenderInst(transports, syncSupport);
       } catch (e) {}
       return null;
      }
      function _getSendPostMgrConfig() {
       try {
        return {
         enableSendPromise: !1,
         isOneDs: !0,
         disableCredentials: !1,
         fetchCredentials: _fetchCredentials,
         disableXhr: !1,
         disableBeacon: !_useBeacons,
         disableBeaconSync: !_useBeacons,
         disableFetchKeepAlive: _disableFetchKeepAlive,
         timeWrapper: _timeoutWrapper,
         addNoResponse: _addNoResponse,
         senderOnCompleteCallBack: {
          xdrOnComplete: _xdrOncomplete,
          fetchOnComplete: _fetchOnComplete,
          xhrOnComplete: _xhrOnComplete,
          beaconOnRetry: _onBeaconRetry
         }
        };
       } catch (e) {}
       return null;
      }
      function _xdrOncomplete(xdr, oncomplete, payload) {
       var response = (0, HelperFuncs.Lo)(xdr);
       _doOnComplete(oncomplete, 200, {}, response), _handleCollectorResponse(response);
      }
      function _fetchOnComplete(response, onComplete, resValue, payload) {
       var headerMap = {}, headers = response.headers;
       headers && headers.forEach((function(value, name) {
        headerMap[name] = value;
       })), function(status, headerMap, responseText) {
        _doOnComplete(onComplete, status, headerMap, responseText), _handleCollectorResponse(responseText);
       }(response.status, headerMap, resValue || "");
      }
      function _xhrOnComplete(request, oncomplete, payload) {
       var response = (0, HelperFuncs.Lo)(request);
       _doOnComplete(oncomplete, request.status, (0, HelperFuncs.w3)(request, !0), response), 
       _handleCollectorResponse(response);
      }
      function _doOnComplete(oncomplete, status, headers, response) {
       try {
        oncomplete(status, headers, response);
       } catch (e) {
        (0, DiagnosticLogger.ZP)(_logger, 2, 518, (0, ts_utils.mmD)(e));
       }
      }
      function _onBeaconRetry(payload, onComplete, canSend) {
       var status = 200, thePayload = payload._thePayload, theUrl = payload.urlString + (_addNoResponse ? "&NoResponseBody=true" : "");
       try {
        var nav_1 = (0, ts_utils.w3n)();
        if (thePayload) {
         var persistStorage = !!_core.getPlugin("LocalStorage"), droppedBatches_1 = [], sentBatches_1 = [];
         (0, ts_utils.Iuo)(thePayload.batches, (function(theBatch) {
          if (droppedBatches_1 && theBatch && theBatch.count() > 0) for (var theEvents = theBatch.events(), lp = 0; lp < theEvents.length; lp++) {
           if (!nav_1.sendBeacon(theUrl, _serializer.getEventBlob(theEvents[lp]))) {
            droppedBatches_1.push(theBatch.split(lp));
            break;
           }
           sentBatches_1.push(theBatch[lp]);
          } else droppedBatches_1.push(theBatch.split(0));
         })), sentBatches_1.length > 0 && (thePayload.sentEvts = sentBatches_1), persistStorage || _sendBatchesNotification(droppedBatches_1, 8003, thePayload.sendType, !0);
        } else status = 0;
       } catch (ex) {
        (0, DiagnosticLogger.OG)(_logger, "Failed to send telemetry using sendBeacon API. Ex:" + (0, 
        ts_utils.mmD)(ex)), status = 0;
       } finally {
        _doOnComplete(onComplete, status, {}, "");
       }
      }
      function _isBeaconPayload(sendType) {
       return 2 === sendType || 3 === sendType;
      }
      function _adjustSendType(sendType) {
       return _isUnloading && _isBeaconPayload(sendType) && (sendType = 2), sendType;
      }
      function _hasIdleConnection() {
       return !_paused && _outstandingRequests < maxConnections;
      }
      function _clearQueue() {
       var theQueue = _batchQueue;
       return _batchQueue = [], theQueue;
      }
      function _canSendPayload(theBatches, sendType, retryCnt) {
       var result = !1;
       return theBatches && theBatches.length > 0 && !_paused && _sendInterfaces[sendType] && _serializer && (result = 0 !== sendType || _hasIdleConnection() && (retryCnt > 0 || _clockSkewManager.allowRequestSending())), 
       result;
      }
      function _createDebugBatches(theBatches) {
       var values = {};
       return theBatches && (0, ts_utils.Iuo)(theBatches, (function(theBatch, idx) {
        values[idx] = {
         iKey: theBatch.iKey(),
         evts: theBatch.events()
        };
       })), values;
      }
      function _sendBatches(theBatches, retryCount, isTeardown, sendType, sendReason) {
       if (theBatches && 0 !== theBatches.length) if (_paused) _sendBatchesNotification(theBatches, 1, sendType); else {
        sendType = _adjustSendType(sendType);
        try {
         var orgBatches_1 = theBatches, isSynchronous_1 = 0 !== sendType;
         (0, PerfManager.r2)(_core, (function() {
          return "HttpManager:_sendBatches";
         }), (function(perfEvt) {
          perfEvt && (theBatches = theBatches.slice(0));
          for (var droppedBatches = [], thePayload = null, serializationStart = (0, Utils.WB)(), sendInterface = _sendInterfaces[sendType] || (isSynchronous_1 ? _sendInterfaces[1] : _sendInterfaces[0]), sendTransport = sendInterface && sendInterface._transport, isReducedPayload = _canHaveReducedPayload && (_isUnloading || _isBeaconPayload(sendType) || 3 === sendTransport || sendInterface._isSync && 2 === sendTransport); _canSendPayload(theBatches, sendType, retryCount); ) {
           var theBatch = theBatches.shift();
           theBatch && theBatch.count() > 0 && (_killSwitch.isTenantKilled(theBatch.iKey()) ? droppedBatches.push(theBatch) : (thePayload = thePayload || _serializer.createPayload(retryCount, isTeardown, isSynchronous_1, isReducedPayload, sendReason, sendType), 
           _serializer.appendPayload(thePayload, theBatch, maxEventsPerBatch) ? null !== thePayload.overflow && (theBatches = [ thePayload.overflow ].concat(theBatches), 
           thePayload.overflow = null, _doPayloadSend(thePayload, serializationStart, (0, Utils.WB)(), sendReason), 
           serializationStart = (0, Utils.WB)(), thePayload = null) : (_doPayloadSend(thePayload, serializationStart, (0, 
           Utils.WB)(), sendReason), serializationStart = (0, Utils.WB)(), theBatches = [ theBatch ].concat(theBatches), 
           thePayload = null)));
          }
          thePayload && _doPayloadSend(thePayload, serializationStart, (0, Utils.WB)(), sendReason), 
          theBatches.length > 0 && (_batchQueue = theBatches.concat(_batchQueue)), _sendBatchesNotification(droppedBatches, 8004, sendType);
         }), (function() {
          return {
           batches: _createDebugBatches(orgBatches_1),
           retryCount,
           isTeardown,
           isSynchronous: isSynchronous_1,
           sendReason,
           useSendBeacon: _isBeaconPayload(sendType),
           sendType
          };
         }), !isSynchronous_1);
        } catch (ex) {
         (0, DiagnosticLogger.ZP)(_logger, 2, 48, "Unexpected Exception sending batch: " + (0, 
         ts_utils.mmD)(ex));
        }
       }
      }
      function _buildRequestDetails(thePayload, useHeaders) {
       var requestDetails = {
        url: _urlString,
        hdrs: {},
        useHdrs: !1
       };
       useHeaders ? (requestDetails.hdrs = (0, Utils.X$)(requestDetails.hdrs, _headers), 
       requestDetails.useHdrs = (0, ts_utils.cGk)(requestDetails.hdrs).length > 0) : (0, 
       ts_utils.zav)(_headers, (function(name, value) {
        _collectorHeaderToQs[name] ? _addRequestDetails(requestDetails, _collectorHeaderToQs[name], value, !1) : (requestDetails.hdrs[name] = value, 
        requestDetails.useHdrs = !0);
       })), _addRequestDetails(requestDetails, "client-id", "NO_AUTH", useHeaders), _addRequestDetails(requestDetails, "client-version", Utils.xE, useHeaders);
       var apiQsKeys = "";
       (0, ts_utils.Iuo)(thePayload.apiKeys, (function(apiKey) {
        apiQsKeys.length > 0 && (apiQsKeys += ","), apiQsKeys += apiKey;
       })), _addRequestDetails(requestDetails, "apikey", apiQsKeys, useHeaders), _addRequestDetails(requestDetails, "upload-time", (0, 
       ts_utils.f0d)().toString(), useHeaders);
       var msfpc = function(thePayload) {
        for (var lp = 0; lp < thePayload.batches.length; lp++) {
         var msfpc = thePayload.batches[lp].Msfpc();
         if (msfpc) return encodeURIComponent(msfpc);
        }
        return "";
       }(thePayload);
       if ((0, Utils.yD)(msfpc) && (requestDetails.url += "&ext.intweb.msfpc=" + msfpc), 
       _clockSkewManager.shouldAddClockSkewHeaders() && _addRequestDetails(requestDetails, "time-delta-to-apply-millis", _clockSkewManager.getClockSkewHeaderValue(), useHeaders), 
       _core.getWParam) {
        var wParam = _core.getWParam();
        wParam >= 0 && (requestDetails.url += "&w=" + wParam);
       }
       for (var i = 0; i < _queryStringParameters.length; i++) requestDetails.url += "&" + _queryStringParameters[i].name + "=" + _queryStringParameters[i].value;
       return requestDetails;
      }
      function _setTimingValue(timings, name, value) {
       timings[name] = timings[name] || {}, timings[name][_postManager.identifier] = value;
      }
      function _doPayloadSend(thePayload, serializationStart, serializationCompleted, sendReason) {
       if (thePayload && thePayload.payloadBlob && thePayload.payloadBlob.length > 0) {
        var useSendHook_1 = !!_sendHook, sendInterface_1 = _sendInterfaces[thePayload.sendType];
        !_isBeaconPayload(thePayload.sendType) && thePayload.isBeacon && 2 === thePayload.sendReason && (sendInterface_1 = _sendInterfaces[2] || _sendInterfaces[3] || sendInterface_1);
        var useHeaders_1 = _useHeaders;
        (thePayload.isBeacon || 3 === sendInterface_1._transport) && (useHeaders_1 = !1);
        var requestDetails_1 = _buildRequestDetails(thePayload, useHeaders_1);
        useHeaders_1 = useHeaders_1 || requestDetails_1.useHdrs;
        var sendEventStart_1 = (0, Utils.WB)();
        (0, PerfManager.r2)(_core, (function() {
         return "HttpManager:_doPayloadSend";
        }), (function() {
         for (var batchLp = 0; batchLp < thePayload.batches.length; batchLp++) for (var theEvents = thePayload.batches[batchLp].events(), evtLp = 0; evtLp < theEvents.length; evtLp++) {
          var telemetryItem = theEvents[evtLp];
          if (_enableEventTimings) {
           var timings = telemetryItem.timings = telemetryItem.timings || {};
           _setTimingValue(timings, "sendEventStart", sendEventStart_1), _setTimingValue(timings, "serializationStart", serializationStart), 
           _setTimingValue(timings, "serializationCompleted", serializationCompleted);
          }
          telemetryItem.sendAttempt > 0 ? telemetryItem.sendAttempt++ : telemetryItem.sendAttempt = 1;
         }
         _sendBatchesNotification(thePayload.batches, 1e3 + (sendReason || 0), thePayload.sendType, !0);
         var orgPayloadData = {
          data: thePayload.payloadBlob,
          urlString: requestDetails_1.url,
          headers: requestDetails_1.hdrs,
          _thePayload: thePayload,
          _sendReason: sendReason,
          timeout: _xhrTimeout,
          disableXhrSync: _disableXhrSync,
          disableFetchKeepAlive: _disableFetchKeepAlive
         };
         useHeaders_1 && (_hasHeader(orgPayloadData.headers, "cache-control") || (orgPayloadData.headers["cache-control"] = "no-cache, no-store"), 
         _hasHeader(orgPayloadData.headers, "content-type") || (orgPayloadData.headers["content-type"] = "application/x-json-stream"));
         var sender = null;
         sendInterface_1 && (sender = function(payload) {
          _clockSkewManager.firstRequestSent();
          var onComplete = function(status, headers) {
           !function(status, headers, thePayload, sendReason) {
            var reason = 9e3, droppedBatches = null, isRetrying = !1, backOffTrans = !1;
            try {
             var shouldRetry = !0;
             if (typeof status !== Constants.bA) {
              if (headers) {
               _clockSkewManager.setClockSkew(headers["time-delta-millis"]);
               var killDuration = headers["kill-duration"] || headers["kill-duration-seconds"];
               (0, ts_utils.Iuo)(_killSwitch.setKillSwitchTenants(headers["kill-tokens"], killDuration), (function(killToken) {
                (0, ts_utils.Iuo)(thePayload.batches, (function(theBatch) {
                 if (theBatch.iKey() === killToken) {
                  droppedBatches = droppedBatches || [];
                  var removedEvents = theBatch.split(0);
                  thePayload.numEvents -= removedEvents.count(), droppedBatches.push(removedEvents);
                 }
                }));
               }));
              }
              if (200 == status || 204 == status) return void (reason = 200);
              ((httpStatusCode = status) >= 300 && httpStatusCode < 500 && 429 != httpStatusCode || 501 == httpStatusCode || 505 == httpStatusCode || thePayload.numEvents <= 0) && (shouldRetry = !1), 
              reason = 9e3 + status % 1e3;
             }
             if (shouldRetry) {
              reason = 100;
              var retryCount_1 = thePayload.retryCnt;
              0 === thePayload.sendType && (retryCount_1 < maxRequestRetriesBeforeBackoff ? (isRetrying = !0, 
              _doAction((function() {
               0 === thePayload.sendType && _outstandingRequests--, _sendBatches(thePayload.batches, retryCount_1 + 1, thePayload.isTeardown, _isUnloading ? 2 : thePayload.sendType, 5);
              }), _isUnloading, retryPolicyGetMillisToBackoffForRetry(retryCount_1))) : (backOffTrans = !0, 
              _isUnloading && (reason = 8001)));
             }
            } finally {
             isRetrying || (_clockSkewManager.setClockSkew(), function(thePayload, batchReason, sendReason, backOffTrans) {
              try {
               backOffTrans && _postManager._backOffTransmission();
               var theBatches = thePayload.batches;
               200 === batchReason && (theBatches = thePayload.sentEvts || thePayload.batches, 
               backOffTrans || thePayload.isSync || _postManager._clearBackOff(), function(theBatches) {
                if (_enableEventTimings) {
                 var sendEventCompleted_1 = (0, Utils.WB)();
                 (0, ts_utils.Iuo)(theBatches, (function(theBatch) {
                  theBatch && theBatch.count() > 0 && function(theEvents, sendEventCompleted) {
                   _enableEventTimings && (0, ts_utils.Iuo)(theEvents, (function(theEvent) {
                    _setTimingValue(theEvent.timings = theEvent.timings || {}, "sendEventCompleted", sendEventCompleted);
                   }));
                  }(theBatch.events(), sendEventCompleted_1);
                 }));
                }
               }(theBatches)), _sendBatchesNotification(theBatches, batchReason, thePayload.sendType, !0);
              } finally {
               0 === thePayload.sendType && (_outstandingRequests--, 5 !== sendReason && _self.sendQueuedRequests(thePayload.sendType, sendReason));
              }
             }(thePayload, reason, sendReason, backOffTrans)), _sendBatchesNotification(droppedBatches, 8004, thePayload.sendType);
            }
            var httpStatusCode;
           }(status, headers, thePayload, sendReason);
          }, isSync = thePayload.isTeardown || thePayload.isSync;
          try {
           sendInterface_1.sendPOST(payload, onComplete, isSync), _sendListener && _sendListener(orgPayloadData, payload, isSync, thePayload.isBeacon);
          } catch (ex) {
           (0, DiagnosticLogger.OG)(_logger, "Unexpected exception sending payload. Ex:" + (0, 
           ts_utils.mmD)(ex)), _doOnComplete(onComplete, 0, {});
          }
         }), (0, PerfManager.r2)(_core, (function() {
          return "HttpManager:_doPayloadSend.sender";
         }), (function() {
          if (sender) if (0 === thePayload.sendType && _outstandingRequests++, useSendHook_1 && !thePayload.isBeacon && 3 !== sendInterface_1._transport) {
           var hookData_1 = {
            data: orgPayloadData.data,
            urlString: orgPayloadData.urlString,
            headers: (0, Utils.X$)({}, orgPayloadData.headers),
            timeout: orgPayloadData.timeout,
            disableXhrSync: orgPayloadData.disableXhrSync,
            disableFetchKeepAlive: orgPayloadData.disableFetchKeepAlive
           }, senderCalled_1 = !1;
           (0, PerfManager.r2)(_core, (function() {
            return "HttpManager:_doPayloadSend.sendHook";
           }), (function() {
            try {
             _sendHook(hookData_1, (function(payload) {
              senderCalled_1 = !0, _customHttpInterface || payload._thePayload || (payload._thePayload = payload._thePayload || orgPayloadData._thePayload, 
              payload._sendReason = payload._sendReason || orgPayloadData._sendReason), sender(payload);
             }), thePayload.isSync || thePayload.isTeardown);
            } catch (ex) {
             senderCalled_1 || sender(orgPayloadData);
            }
           }));
          } else sender(orgPayloadData);
         }));
        }), (function() {
         return {
          thePayload,
          serializationStart,
          serializationCompleted,
          sendReason
         };
        }), thePayload.isSync);
       }
       thePayload.sizeExceed && thePayload.sizeExceed.length > 0 && _sendBatchesNotification(thePayload.sizeExceed, 8003, thePayload.sendType), 
       thePayload.failedEvts && thePayload.failedEvts.length > 0 && _sendBatchesNotification(thePayload.failedEvts, 8002, thePayload.sendType);
      }
      function _doAction(cb, isSync, interval) {
       isSync ? cb() : _timeoutWrapper.set(cb, interval);
      }
      function _handleCollectorResponse(responseText) {
       var responseHandlers = _responseHandlers;
       try {
        for (var i = 0; i < responseHandlers.length; i++) try {
         responseHandlers[i](responseText);
        } catch (e) {
         (0, DiagnosticLogger.ZP)(_logger, 1, 519, "Response handler failed: " + e);
        }
        if (responseText) {
         var response = JSON.parse(responseText);
         (0, Utils.yD)(response.webResult) && (0, Utils.yD)(response.webResult.msfpc) && _cookieMgr.set("MSFPC", response.webResult.msfpc, 31536e3);
        }
       } catch (ex) {}
      }
      function _sendBatchesNotification(theBatches, batchReason, sendType, sendSync) {
       if (theBatches && theBatches.length > 0 && actions) {
        var theAction_1 = actions[function(reason) {
         var action = _eventActionMap[reason];
         (0, Utils.yD)(action) || (action = "oth", reason >= 9e3 && reason <= 9999 ? action = "rspFail" : reason >= 8e3 && reason <= 8999 ? action = "drop" : reason >= 1e3 && reason <= 1999 && (action = "send"));
         return action;
        }(batchReason)];
        if (theAction_1) {
         var isSyncRequest_1 = 0 !== sendType;
         (0, PerfManager.r2)(_core, (function() {
          return "HttpManager:_sendBatchesNotification";
         }), (function() {
          _doAction((function() {
           try {
            theAction_1.call(actions, theBatches, batchReason, isSyncRequest_1, sendType);
           } catch (e) {
            (0, DiagnosticLogger.ZP)(_logger, 1, 74, "send request notification failed: " + e);
           }
          }), sendSync || isSyncRequest_1, 0);
         }), (function() {
          return {
           batches: _createDebugBatches(theBatches),
           reason: batchReason,
           isSync: isSyncRequest_1,
           sendSync,
           sendType
          };
         }), !isSyncRequest_1);
        }
       }
      }
      _self.initialize = function(theConfig, core, postChannel) {
       _isInitialized || (_core = core, _cookieMgr = core.getCookieMgr(), _logger = (_postManager = postChannel).diagLog(), 
       (0, ts_utils.Yny)(_unloadHooks, (0, DynamicConfig.a)(theConfig, (function(details) {
        var _a, coreConfig = details.cfg, channelConfig = details.cfg.extensionConfig[postChannel.identifier];
        _timeoutWrapper = createTimeoutWrapper(channelConfig.setTimeoutOverride, channelConfig.clearTimeoutOverride), 
        (0, Utils.yD)(coreConfig.anonCookieName) ? function(qsParams, name, value) {
         for (var i = 0; i < qsParams.length; i++) if (qsParams[i].name === name) return void (qsParams[i].value = value);
         qsParams.push({
          name,
          value
         });
        }(_queryStringParameters, "anoncknm", coreConfig.anonCookieName) : function(qsParams, name) {
         for (var i = 0; i < qsParams.length; i++) if (qsParams[i].name === name) return void qsParams.splice(i, 1);
        }(_queryStringParameters, "anoncknm"), _sendHook = channelConfig.payloadPreprocessor, 
        _sendListener = channelConfig.payloadListener;
        var httpInterface = channelConfig.httpXHROverride, endpointUrl = channelConfig.overrideEndpointUrl ? channelConfig.overrideEndpointUrl : coreConfig.endpointUrl;
        _urlString = endpointUrl + UrlQueryString, _useHeaders = !!(0, ts_utils.b07)(channelConfig.avoidOptions) || !channelConfig.avoidOptions, 
        _enableEventTimings = !channelConfig.disableEventTimings;
        var valueSanitizer = channelConfig.valueSanitizer, stringifyObjects = channelConfig.stringifyObjects, enableCompoundKey = !!coreConfig.enableCompoundKey;
        (0, ts_utils.b07)(channelConfig.enableCompoundKey) || (enableCompoundKey = !!channelConfig.enableCompoundKey), 
        _xhrTimeout = channelConfig.xhrTimeout, _disableXhrSync = !!channelConfig.disableXhrSync, 
        _disableFetchKeepAlive = !!channelConfig.disableFetchKeepAlive, _addNoResponse = !1 !== channelConfig.addNoResponse, 
        _excludeCsMetaData = !!channelConfig.excludeCsMetaData, core.getPlugin("LocalStorage") && (_disableFetchKeepAlive = !0), 
        _useBeacons = !(0, EnvUtils.lV)(), _serializer = new Serializer(_core, valueSanitizer, stringifyObjects, enableCompoundKey, Utils.Go, _excludeCsMetaData), 
        (0, ts_utils.hXl)(channelConfig.useSendBeacon) || (_useBeacons = !!channelConfig.useSendBeacon), 
        channelConfig.fetchCredentials && (_fetchCredentials = channelConfig.fetchCredentials);
        var sendPostConfig = _getSendPostMgrConfig();
        _sendPostMgr ? _sendPostMgr.SetConfig(sendPostConfig) : (_sendPostMgr = new SenderPostManager.v).initialize(sendPostConfig, _logger);
        var syncHttpInterface = httpInterface, beaconHttpInterface = channelConfig.alwaysUseXhrOverride ? httpInterface : null, fetchSyncHttpInterface = channelConfig.alwaysUseXhrOverride ? httpInterface : null, beaconUnloadTransports = [ 3, 2 ];
        if (!httpInterface) {
         _customHttpInterface = !1;
         var theTransports = [];
         (0, EnvUtils.lV)() ? (theTransports = [ 2, 1 ], beaconUnloadTransports = [ 2, 1, 3 ]) : theTransports = [ 1, 2, 3 ], 
         (httpInterface = _getSenderInterface(theTransports = (0, HelperFuncs.jL)(theTransports, channelConfig.transports), !1)) || (0, 
         DiagnosticLogger.OG)(_logger, "No available transport to send events"), syncHttpInterface = _getSenderInterface(theTransports, !0);
        }
        beaconHttpInterface || (beaconHttpInterface = _getSenderInterface(beaconUnloadTransports = (0, 
        HelperFuncs.jL)(beaconUnloadTransports, channelConfig.unloadTransports), !0)), _canHaveReducedPayload = !_customHttpInterface && (_useBeacons && (0, 
        EnvUtils.Uf)() || !_disableFetchKeepAlive && (0, EnvUtils.R7)(!0)), (_a = {})[0] = httpInterface, 
        _a[1] = syncHttpInterface || _getSenderInterface([ 1, 2, 3 ], !0), _a[2] = beaconHttpInterface || syncHttpInterface || _getSenderInterface([ 1 ], !0), 
        _a[3] = fetchSyncHttpInterface || _getSenderInterface([ 2, 3 ], !0) || syncHttpInterface || _getSenderInterface([ 1 ], !0), 
        _sendInterfaces = _a;
       }))), _isInitialized = !0);
      }, _self.addResponseHandler = function(responseHandler) {
       return _responseHandlers.push(responseHandler), {
        rm: function() {
         var index = _responseHandlers.indexOf(responseHandler);
         index >= 0 && _responseHandlers.splice(index, 1);
        }
       };
      }, _self.serializeOfflineEvt = function(evt) {
       try {
        if (_serializer) return _serializer.getEventBlob(evt);
       } catch (e) {}
       return "";
      }, _self.getOfflineRequestDetails = function() {
       try {
        return _buildRequestDetails(_serializer && _serializer.createPayload(0, !1, !1, !1, 1, 0), _useHeaders);
       } catch (e) {}
       return null;
      }, _self.createOneDSPayload = function(evts, optimize) {
       try {
        var theBatches_1 = [];
        (0, ts_utils.Iuo)(evts, (function(evt) {
         optimize && (evt = (0, HelperFuncs.hW)(evt));
         var batch = EventBatch.create(evt.iKey, [ evt ]);
         theBatches_1.push(batch);
        }));
        for (var thePayload = null; theBatches_1.length > 0 && _serializer; ) {
         var theBatch = theBatches_1.shift();
         theBatch && theBatch.count() > 0 && (thePayload = thePayload || _serializer.createPayload(0, !1, !1, !1, 1, 0), 
         _serializer.appendPayload(thePayload, theBatch, maxEventsPerBatch));
        }
        var requestDetails = _buildRequestDetails(thePayload, _useHeaders), payloadData = {
         data: thePayload.payloadBlob,
         urlString: requestDetails.url,
         headers: requestDetails.hdrs,
         timeout: _xhrTimeout,
         disableXhrSync: _disableXhrSync,
         disableFetchKeepAlive: _disableFetchKeepAlive
        };
        return _useHeaders && (_hasHeader(payloadData.headers, "cache-control") || (payloadData.headers["cache-control"] = "no-cache, no-store"), 
        _hasHeader(payloadData.headers, "content-type") || (payloadData.headers["content-type"] = "application/x-json-stream")), 
        payloadData;
       } catch (e) {}
       return null;
      }, _self._getDbgPlgTargets = function() {
       return [ _sendInterfaces[0], _killSwitch, _serializer, _sendInterfaces, _getSendPostMgrConfig(), _urlString ];
      }, _self.addHeader = function(name, value) {
       _headers[name] = value;
      }, _self.removeHeader = function(name) {
       delete _headers[name];
      }, _self.canSendRequest = function() {
       return _hasIdleConnection() && _clockSkewManager.allowRequestSending();
      }, _self.sendQueuedRequests = function(sendType, sendReason) {
       (0, ts_utils.b07)(sendType) && (sendType = 0), _isUnloading && (sendType = _adjustSendType(sendType), 
       sendReason = 2), _canSendPayload(_batchQueue, sendType, 0) && _sendBatches(_clearQueue(), 0, !1, sendType, sendReason || 0);
      }, _self.isCompletelyIdle = function() {
       return !_paused && 0 === _outstandingRequests && 0 === _batchQueue.length;
      }, _self.setUnloading = function(value) {
       _isUnloading = value;
      }, _self.addBatch = function(theBatch) {
       if (theBatch && theBatch.count() > 0) {
        if (_killSwitch.isTenantKilled(theBatch.iKey())) return !1;
        _batchQueue.push(theBatch);
       }
       return !0;
      }, _self.teardown = function() {
       _batchQueue.length > 0 && _sendBatches(_clearQueue(), 0, !0, 2, 2), (0, ts_utils.Iuo)(_unloadHooks, (function(hook) {
        hook && hook.rm && hook.rm();
       })), _unloadHooks = [];
      }, _self.pause = function() {
       _paused = !0;
      }, _self.resume = function() {
       _paused = !1, _self.sendQueuedRequests(0, 4);
      }, _self.sendSynchronousBatch = function(batch, sendType, sendReason) {
       batch && batch.count() > 0 && ((0, ts_utils.hXl)(sendType) && (sendType = 1), _isUnloading && (sendType = _adjustSendType(sendType), 
       sendReason = 2), _sendBatches([ batch ], 0, !1, sendType, sendReason || 0));
      };
     }));
    }
    return HttpManager.__ieDyn = 1, HttpManager;
   }(), defaultPostChannelConfig = (0, ts_utils.ZHX)({
    eventsLimitInMem: {
     isVal: Utils.ei,
     v: 1e4
    },
    immediateEventLimit: {
     isVal: Utils.ei,
     v: 500
    },
    autoFlushEventsLimit: {
     isVal: Utils.ei,
     v: 0
    },
    disableAutoBatchFlushLimit: !1,
    httpXHROverride: {
     isVal: function(httpXHROverride) {
      return httpXHROverride && httpXHROverride.sendPOST;
     },
     v: undefined
    },
    overrideInstrumentationKey: undefined,
    overrideEndpointUrl: undefined,
    disableTelemetry: !1,
    ignoreMc1Ms0CookieProcessing: !1,
    setTimeoutOverride: undefined,
    clearTimeoutOverride: undefined,
    payloadPreprocessor: undefined,
    payloadListener: undefined,
    disableEventTimings: undefined,
    valueSanitizer: undefined,
    stringifyObjects: undefined,
    enableCompoundKey: undefined,
    disableOptimizeObj: !1,
    fetchCredentials: undefined,
    transports: undefined,
    unloadTransports: undefined,
    useSendBeacon: undefined,
    disableFetchKeepAlive: undefined,
    avoidOptions: !1,
    xhrTimeout: undefined,
    disableXhrSync: undefined,
    alwaysUseXhrOverride: !1,
    maxEventRetryAttempts: {
     isVal: ts_utils.EtT,
     v: 6
    },
    maxUnloadEventRetryAttempts: {
     isVal: ts_utils.EtT,
     v: 2
    },
    addNoResponse: undefined,
    excludeCsMetaData: undefined
   });
   var PostChannel = function(_super) {
    function PostChannel() {
     var _postConfig, _this = _super.call(this) || this;
     _this.identifier = "PostChannel", _this.priority = 1011, _this.version = "4.3.3";
     var _flushCallbackTimer, _immediateQueueSizeLimit, _queueSizeLimit, _scheduledTimer, _immediateTimer, _currentBackoffCount, _timerCount, _httpManager, _batchQueues, _autoFlushEventsLimit, _autoFlushBatchLimit, _delayedBatchSendLatency, _delayedBatchReason, _optimizeObject, _isPageUnloadTriggered, _maxEventSendAttempts, _maxUnloadEventSendAttempts, _evtNamespace, _timeoutWrapper, _ignoreMc1Ms0CookieProcessing, _disableAutoBatchFlushLimit, _notificationManager, _unloadHandlersAdded, _overrideInstrumentationKey, _disableTelemetry, _isTeardownCalled = !1, _flushCallbackQueue = [], _paused = !1, _immediateQueueSize = 0, _queueSize = 0, _profiles = {}, _currentProfile = RT_PROFILE;
     return (0, DynamicProto.A)(PostChannel, _this, (function(_self, _base) {
      function _removeUnloadHandlers() {
       (0, EventHelpers.Ds)(null, _evtNamespace), (0, EventHelpers.sq)(null, _evtNamespace), 
       (0, EventHelpers.vF)(null, _evtNamespace);
      }
      function _batch(arr) {
       var rlt = "";
       return arr && arr.length && (0, ts_utils.Iuo)(arr, (function(item) {
        rlt && (rlt += "\n"), rlt += item;
       })), rlt;
      }
      function _serialize(event) {
       var rlt = "";
       try {
        _cleanEvent(event), rlt = _httpManager.serializeOfflineEvt(event);
       } catch (e) {}
       return rlt;
      }
      function _handleUnloadEvents(evt) {
       "beforeunload" !== (evt || (0, ts_utils.zkX)().event).type && (_isPageUnloadTriggered = !0, 
       _httpManager.setUnloading(_isPageUnloadTriggered)), _releaseAllQueues(2, 2);
      }
      function _handleShowEvents(evt) {
       _isPageUnloadTriggered = !1, _httpManager.setUnloading(_isPageUnloadTriggered);
      }
      function _cleanEvent(event) {
       event.ext && event.ext.trace && delete event.ext.trace, event.ext && event.ext.user && event.ext.user.id && delete event.ext.user.id, 
       _optimizeObject && (event.ext = (0, HelperFuncs.hW)(event.ext), event.baseData && (event.baseData = (0, 
       HelperFuncs.hW)(event.baseData)), event.data && (event.data = (0, HelperFuncs.hW)(event.data)));
      }
      function _addEventToQueues(event, append) {
       if (event.sendAttempt || (event.sendAttempt = 0), event.latency || (event.latency = 1), 
       _cleanEvent(event), event.sync) if (_currentBackoffCount || _paused) event.latency = 3, 
       event.sync = !1; else if (_httpManager) return _optimizeObject && (event = (0, HelperFuncs.hW)(event)), 
       void _httpManager.sendSynchronousBatch(EventBatch.create(event.iKey, [ event ]), !0 === event.sync ? 1 : event.sync, 3);
       var evtLatency = event.latency, queueSize = _queueSize, queueLimit = _queueSizeLimit;
       4 === evtLatency && (queueSize = _immediateQueueSize, queueLimit = _immediateQueueSizeLimit);
       var eventDropped = !1;
       if (queueSize < queueLimit) eventDropped = !_addEventToProperQueue(event, append); else {
        var dropLatency = 1, dropNumber = 20;
        4 === evtLatency && (dropLatency = 4, dropNumber = 1), eventDropped = !0, function(iKey, latency, currentLatency, dropNumber) {
         for (;currentLatency <= latency; ) {
          var eventBatch = _getEventBatch(iKey, latency, !0);
          if (eventBatch && eventBatch.count() > 0) {
           var droppedEvents = eventBatch.split(0, dropNumber), droppedCount = droppedEvents.count();
           if (droppedCount > 0) return 4 === currentLatency ? _immediateQueueSize -= droppedCount : _queueSize -= droppedCount, 
           _notifyBatchEvents("eventsDiscarded", [ droppedEvents ], EventsDiscardedReason.x.QueueFull), 
           !0;
          }
          currentLatency++;
         }
         return _resetQueueCounts(), !1;
        }(event.iKey, event.latency, dropLatency, dropNumber) && (eventDropped = !_addEventToProperQueue(event, append));
       }
       eventDropped && _notifyEvents("eventsDiscarded", [ event ], EventsDiscardedReason.x.QueueFull);
      }
      function _sendEventsForLatencyAndAbove(latency, sendType, sendReason) {
       var queued = _queueBatches(latency, sendType, sendReason);
       return _httpManager.sendQueuedRequests(sendType, sendReason), queued;
      }
      function _hasEvents() {
       return _queueSize > 0;
      }
      function _scheduleTimer() {
       if (_delayedBatchSendLatency >= 0 && _queueBatches(_delayedBatchSendLatency, 0, _delayedBatchReason) && _httpManager.sendQueuedRequests(0, _delayedBatchReason), 
       _immediateQueueSize > 0 && !_immediateTimer && !_paused) {
        var immediateTimeOut = _profiles[_currentProfile][2];
        immediateTimeOut >= 0 && (_immediateTimer = _createTimer((function() {
         _immediateTimer = null, _sendEventsForLatencyAndAbove(4, 0, 1), _scheduleTimer();
        }), immediateTimeOut));
       }
       var timeOut = _profiles[_currentProfile][1];
       !_scheduledTimer && !_flushCallbackTimer && timeOut >= 0 && !_paused && (_hasEvents() ? _scheduledTimer = _createTimer((function() {
        _scheduledTimer = null, _sendEventsForLatencyAndAbove(0 === _timerCount ? 3 : 1, 0, 1), 
        _timerCount++, _timerCount %= 2, _scheduleTimer();
       }), timeOut) : _timerCount = 0);
      }
      function _initDefaults() {
       _postConfig = null, _isTeardownCalled = !1, _flushCallbackQueue = [], _flushCallbackTimer = null, 
       _paused = !1, _immediateQueueSize = 0, _immediateQueueSizeLimit = 500, _queueSize = 0, 
       _queueSizeLimit = 1e4, _profiles = {}, _currentProfile = RT_PROFILE, _scheduledTimer = null, 
       _immediateTimer = null, _currentBackoffCount = 0, _timerCount = 0, _batchQueues = {}, 
       _autoFlushEventsLimit = 0, _unloadHandlersAdded = !1, _autoFlushBatchLimit = 0, 
       _delayedBatchSendLatency = -1, _delayedBatchReason = null, _optimizeObject = !0, 
       _isPageUnloadTriggered = !1, _maxEventSendAttempts = 6, _maxUnloadEventSendAttempts = 2, 
       _evtNamespace = null, _overrideInstrumentationKey = null, _disableTelemetry = !1, 
       _timeoutWrapper = createTimeoutWrapper(), _httpManager = new HttpManager(500, 2, 1, {
        requeue: _requeueEvents,
        send: _sendingEvent,
        sent: _eventsSentEvent,
        drop: _eventsDropped,
        rspFail: _eventsResponseFail,
        oth: _otherEvent
       }), _initializeProfiles(), _batchQueues[4] = {
        batches: [],
        iKeyMap: {}
       }, _batchQueues[3] = {
        batches: [],
        iKeyMap: {}
       }, _batchQueues[2] = {
        batches: [],
        iKeyMap: {}
       }, _batchQueues[1] = {
        batches: [],
        iKeyMap: {}
       }, _setAutoLimits();
      }
      function _createTimer(theTimerFunc, timeOut) {
       0 === timeOut && _currentBackoffCount && (timeOut = 1);
       var timerMultiplier = 1e3;
       return _currentBackoffCount && (timerMultiplier = retryPolicyGetMillisToBackoffForRetry(_currentBackoffCount - 1)), 
       _timeoutWrapper.set(theTimerFunc, timeOut * timerMultiplier);
      }
      function _clearScheduledTimer() {
       return null !== _scheduledTimer && (_scheduledTimer.cancel(), _scheduledTimer = null, 
       _timerCount = 0, !0);
      }
      function _releaseAllQueues(sendType, sendReason) {
       _clearScheduledTimer(), _flushCallbackTimer && (_flushCallbackTimer.cancel(), _flushCallbackTimer = null), 
       _paused || _sendEventsForLatencyAndAbove(1, sendType, sendReason);
      }
      function _getEventBatch(iKey, latency, create) {
       var batchQueue = _batchQueues[latency];
       batchQueue || (batchQueue = _batchQueues[latency = 1]);
       var eventBatch = batchQueue.iKeyMap[iKey];
       return !eventBatch && create && (eventBatch = EventBatch.create(iKey), batchQueue.batches.push(eventBatch), 
       batchQueue.iKeyMap[iKey] = eventBatch), eventBatch;
      }
      function _performAutoFlush(isAsync, doFlush) {
       _httpManager.canSendRequest() && !_currentBackoffCount && (_autoFlushEventsLimit > 0 && _queueSize > _autoFlushEventsLimit && (doFlush = !0), 
       doFlush && null == _flushCallbackTimer && _self.flush(isAsync, (function() {}), 20));
      }
      function _addEventToProperQueue(event, append) {
       _optimizeObject && (event = (0, HelperFuncs.hW)(event));
       var latency = event.latency, eventBatch = _getEventBatch(event.iKey, latency, !0);
       return !!eventBatch.addEvent(event) && (4 !== latency ? (_queueSize++, append && 0 === event.sendAttempt && _performAutoFlush(!event.sync, _autoFlushBatchLimit > 0 && eventBatch.count() >= _autoFlushBatchLimit)) : _immediateQueueSize++, 
       !0);
      }
      function _resetQueueCounts() {
       for (var immediateQueue = 0, normalQueue = 0, _loop_1 = function(latency) {
        var batchQueue = _batchQueues[latency];
        batchQueue && batchQueue.batches && (0, ts_utils.Iuo)(batchQueue.batches, (function(theBatch) {
         4 === latency ? immediateQueue += theBatch.count() : normalQueue += theBatch.count();
        }));
       }, latency = 1; latency <= 4; latency++) _loop_1(latency);
       _queueSize = normalQueue, _immediateQueueSize = immediateQueue;
      }
      function _queueBatches(latency, sendType, sendReason) {
       var eventsQueued = !1, isAsync = 0 === sendType;
       return !isAsync || _httpManager.canSendRequest() ? (0, PerfManager.r2)(_self.core, (function() {
        return "PostChannel._queueBatches";
       }), (function() {
        for (var droppedEvents = [], latencyToProcess = 4; latencyToProcess >= latency; ) {
         var batchQueue = _batchQueues[latencyToProcess];
         batchQueue && batchQueue.batches && batchQueue.batches.length > 0 && ((0, ts_utils.Iuo)(batchQueue.batches, (function(theBatch) {
          _httpManager.addBatch(theBatch) ? eventsQueued = eventsQueued || theBatch && theBatch.count() > 0 : droppedEvents = droppedEvents.concat(theBatch.events()), 
          4 === latencyToProcess ? _immediateQueueSize -= theBatch.count() : _queueSize -= theBatch.count();
         })), batchQueue.batches = [], batchQueue.iKeyMap = {}), latencyToProcess--;
        }
        droppedEvents.length > 0 && _notifyEvents("eventsDiscarded", droppedEvents, EventsDiscardedReason.x.KillSwitch), 
        eventsQueued && _delayedBatchSendLatency >= latency && (_delayedBatchSendLatency = -1, 
        _delayedBatchReason = 0);
       }), (function() {
        return {
         latency,
         sendType,
         sendReason
        };
       }), !isAsync) : (_delayedBatchSendLatency = _delayedBatchSendLatency >= 0 ? Math.min(_delayedBatchSendLatency, latency) : latency, 
       _delayedBatchReason = Math.max(_delayedBatchReason, sendReason)), eventsQueued;
      }
      function _flushImpl(callback, sendReason) {
       _sendEventsForLatencyAndAbove(1, 0, sendReason), _resetQueueCounts(), _waitForIdleManager((function() {
        callback && callback(), _flushCallbackQueue.length > 0 ? _flushCallbackTimer = _createTimer((function() {
         _flushCallbackTimer = null, _flushImpl(_flushCallbackQueue.shift(), sendReason);
        }), 0) : (_flushCallbackTimer = null, _scheduleTimer());
       }));
      }
      function _waitForIdleManager(callback) {
       _httpManager.isCompletelyIdle() ? callback() : _flushCallbackTimer = _createTimer((function() {
        _flushCallbackTimer = null, _waitForIdleManager(callback);
       }), .25);
      }
      function _initializeProfiles() {
       (_profiles = {})[RT_PROFILE] = [ 2, 1, 0 ], _profiles[NRT_PROFILE] = [ 6, 3, 0 ], 
       _profiles[BE_PROFILE] = [ 18, 9, 0 ];
      }
      function _requeueEvents(batches, reason) {
       var droppedEvents = [], maxSendAttempts = _maxEventSendAttempts;
       _isPageUnloadTriggered && (maxSendAttempts = _maxUnloadEventSendAttempts), (0, ts_utils.Iuo)(batches, (function(theBatch) {
        theBatch && theBatch.count() > 0 && (0, ts_utils.Iuo)(theBatch.events(), (function(theEvent) {
         theEvent && (theEvent.sync && (theEvent.latency = 4, theEvent.sync = !1), theEvent.sendAttempt < maxSendAttempts ? ((0, 
         Utils.u9)(theEvent, _self.identifier), _addEventToQueues(theEvent, !1)) : droppedEvents.push(theEvent));
        }));
       })), droppedEvents.length > 0 && _notifyEvents("eventsDiscarded", droppedEvents, EventsDiscardedReason.x.NonRetryableStatus), 
       _isPageUnloadTriggered && _releaseAllQueues(2, 2);
      }
      function _callNotification(evtName, theArgs) {
       var manager = _notificationManager || {}, notifyFunc = manager[evtName];
       if (notifyFunc) try {
        notifyFunc.apply(manager, theArgs);
       } catch (e) {
        (0, DiagnosticLogger.ZP)(_self.diagLog(), 1, 74, evtName + " notification failed: " + e);
       }
      }
      function _notifyEvents(evtName, theEvents) {
       for (var extraArgs = [], _i = 2; _i < arguments.length; _i++) extraArgs[_i - 2] = arguments[_i];
       theEvents && theEvents.length > 0 && _callNotification(evtName, [ theEvents ].concat(extraArgs));
      }
      function _notifyBatchEvents(evtName, batches) {
       for (var extraArgs = [], _i = 2; _i < arguments.length; _i++) extraArgs[_i - 2] = arguments[_i];
       batches && batches.length > 0 && (0, ts_utils.Iuo)(batches, (function(theBatch) {
        theBatch && theBatch.count() > 0 && _callNotification(evtName, [ theBatch.events() ].concat(extraArgs));
       }));
      }
      function _sendingEvent(batches, reason, isSyncRequest) {
       batches && batches.length > 0 && _callNotification("eventsSendRequest", [ reason >= 1e3 && reason <= 1999 ? reason - 1e3 : 0, !0 !== isSyncRequest ]);
      }
      function _eventsSentEvent(batches, reason) {
       _notifyBatchEvents("eventsSent", batches, reason), _scheduleTimer();
      }
      function _eventsDropped(batches, reason) {
       _notifyBatchEvents("eventsDiscarded", batches, reason >= 8e3 && reason <= 8999 ? reason - 8e3 : EventsDiscardedReason.x.Unknown);
      }
      function _eventsResponseFail(batches) {
       _notifyBatchEvents("eventsDiscarded", batches, EventsDiscardedReason.x.NonRetryableStatus), 
       _scheduleTimer();
      }
      function _otherEvent(batches, reason) {
       _notifyBatchEvents("eventsDiscarded", batches, EventsDiscardedReason.x.Unknown), 
       _scheduleTimer();
      }
      function _setAutoLimits() {
       _autoFlushBatchLimit = _disableAutoBatchFlushLimit ? 0 : Math.max(1500, _queueSizeLimit / 6);
      }
      _initDefaults(), _self._getDbgPlgTargets = function() {
       return [ _httpManager, _postConfig ];
      }, _self.initialize = function(theConfig, core, extensions) {
       (0, PerfManager.r2)(core, (function() {
        return "PostChannel:initialize";
       }), (function() {
        _base.initialize(theConfig, core, extensions), _notificationManager = core.getNotifyMgr();
        try {
         _evtNamespace = (0, EventHelpers.Hm)((0, DataCacheHelper.Z)(_self.identifier), core.evtNamespace && core.evtNamespace()), 
         _self._addHook((0, DynamicConfig.a)(theConfig, (function(details) {
          var coreConfig = details.cfg, ctx = (0, ProcessTelemetryContext.i8)(null, coreConfig, core);
          _postConfig = ctx.getExtCfg(_self.identifier, defaultPostChannelConfig), _timeoutWrapper = createTimeoutWrapper(_postConfig.setTimeoutOverride, _postConfig.clearTimeoutOverride), 
          _optimizeObject = !_postConfig.disableOptimizeObj && (0, Utils.F2)(), _ignoreMc1Ms0CookieProcessing = _postConfig.ignoreMc1Ms0CookieProcessing, 
          function(core) {
           var existingGetWParamMethod = core.getWParam;
           core.getWParam = function() {
            var wparam = 0;
            return _ignoreMc1Ms0CookieProcessing && (wparam |= 2), wparam | existingGetWParamMethod.call(core);
           };
          }(core), _queueSizeLimit = _postConfig.eventsLimitInMem, _immediateQueueSizeLimit = _postConfig.immediateEventLimit, 
          _autoFlushEventsLimit = _postConfig.autoFlushEventsLimit, _maxEventSendAttempts = _postConfig.maxEventRetryAttempts, 
          _maxUnloadEventSendAttempts = _postConfig.maxUnloadEventRetryAttempts, _disableAutoBatchFlushLimit = _postConfig.disableAutoBatchFlushLimit, 
          (0, ts_utils.$XS)(coreConfig.endpointUrl) ? _self.pause() : _paused && _self.resume(), 
          _setAutoLimits(), _overrideInstrumentationKey = _postConfig.overrideInstrumentationKey, 
          _disableTelemetry = !!_postConfig.disableTelemetry, _unloadHandlersAdded && _removeUnloadHandlers();
          var excludePageUnloadEvents = coreConfig.disablePageUnloadEvents || [];
          _unloadHandlersAdded = (0, EventHelpers.ee)(_handleUnloadEvents, excludePageUnloadEvents, _evtNamespace), 
          _unloadHandlersAdded = (0, EventHelpers.Fc)(_handleUnloadEvents, excludePageUnloadEvents, _evtNamespace) || _unloadHandlersAdded, 
          _unloadHandlersAdded = (0, EventHelpers.oS)(_handleShowEvents, coreConfig.disablePageShowEvents, _evtNamespace) || _unloadHandlersAdded;
         }))), _httpManager.initialize(theConfig, _self.core, _self);
        } catch (e) {
         throw _self.setInitialized(!1), e;
        }
       }), (function() {
        return {
         theConfig,
         core,
         extensions
        };
       }));
      }, _self.processTelemetry = function(ev, itemCtx) {
       (0, Utils.u9)(ev, _self.identifier), itemCtx = itemCtx || _self._getTelCtx(itemCtx);
       var event = ev;
       _disableTelemetry || _isTeardownCalled || (_overrideInstrumentationKey && (event.iKey = _overrideInstrumentationKey), 
       _addEventToQueues(event, !0), _isPageUnloadTriggered ? _releaseAllQueues(2, 2) : _scheduleTimer()), 
       _self.processNext(event, itemCtx);
      }, _self.getOfflineSupport = function() {
       try {
        var details_1 = _httpManager && _httpManager.getOfflineRequestDetails();
        if (_httpManager) return {
         getUrl: function() {
          return details_1 ? details_1.url : null;
         },
         serialize: _serialize,
         batch: _batch,
         shouldProcess: function(evt) {
          return !_disableTelemetry;
         },
         createPayload: function(evt) {
          return null;
         },
         createOneDSPayload: function(evts) {
          if (_httpManager.createOneDSPayload) return _httpManager.createOneDSPayload(evts, _optimizeObject);
         }
        };
       } catch (e) {}
       return null;
      }, _self._doTeardown = function(unloadCtx, unloadState) {
       _releaseAllQueues(2, 2), _isTeardownCalled = !0, _httpManager.teardown(), _removeUnloadHandlers(), 
       _initDefaults();
      }, _self.setEventQueueLimits = function(eventLimit, autoFlushLimit) {
       _postConfig.eventsLimitInMem = _queueSizeLimit = (0, Utils.ei)(eventLimit) ? eventLimit : 1e4, 
       _postConfig.autoFlushEventsLimit = _autoFlushEventsLimit = (0, Utils.ei)(autoFlushLimit) ? autoFlushLimit : 0, 
       _setAutoLimits();
       var doFlush = _queueSize > eventLimit;
       if (!doFlush && _autoFlushBatchLimit > 0) for (var latency = 1; !doFlush && latency <= 3; latency++) {
        var batchQueue = _batchQueues[latency];
        batchQueue && batchQueue.batches && (0, ts_utils.Iuo)(batchQueue.batches, (function(theBatch) {
         theBatch && theBatch.count() >= _autoFlushBatchLimit && (doFlush = !0);
        }));
       }
       _performAutoFlush(!0, doFlush);
      }, _self.pause = function() {
       _clearScheduledTimer(), _paused = !0, _httpManager && _httpManager.pause();
      }, _self.resume = function() {
       _paused = !1, _httpManager && _httpManager.resume(), _scheduleTimer();
      }, _self._loadTransmitProfiles = function(profiles) {
       _clearScheduledTimer(), _initializeProfiles(), _currentProfile = RT_PROFILE, _scheduleTimer(), 
       (0, ts_utils.zav)(profiles, (function(profileName, profileValue) {
        var profLen = profileValue.length;
        if (profLen >= 2) {
         var directValue = profLen > 2 ? profileValue[2] : 0;
         if (profileValue.splice(0, profLen - 2), profileValue[1] < 0 && (profileValue[0] = -1), 
         profileValue[1] > 0 && profileValue[0] > 0) {
          var timerMultiplier = profileValue[0] / profileValue[1];
          profileValue[0] = Math.ceil(timerMultiplier) * profileValue[1];
         }
         directValue >= 0 && profileValue[1] >= 0 && directValue > profileValue[1] && (directValue = profileValue[1]), 
         profileValue.push(directValue), _profiles[profileName] = profileValue;
        }
       }));
      }, _self.flush = function(async, callback, sendReason) {
       var result;
       if (void 0 === async && (async = !0), !_paused) if (sendReason = sendReason || 1, 
       async) callback || (result = (0, ts_async.Qo)((function(resolve) {
        callback = resolve;
       }))), null == _flushCallbackTimer ? (_clearScheduledTimer(), _queueBatches(1, 0, sendReason), 
       _flushCallbackTimer = _createTimer((function() {
        _flushCallbackTimer = null, _flushImpl(callback, sendReason);
       }), 0)) : _flushCallbackQueue.push(callback); else {
        var cleared = _clearScheduledTimer();
        _sendEventsForLatencyAndAbove(1, 1, sendReason), callback && callback(), cleared && _scheduleTimer();
       }
       return result;
      }, _self.setMsaAuthTicket = function(ticket) {
       _httpManager.addHeader("AuthMsaDeviceTicket", ticket);
      }, _self.setAuthPluginHeader = function(token) {
       _httpManager.addHeader("WebAuthToken", token);
      }, _self.removeAuthPluginHeader = function() {
       _httpManager.removeHeader("WebAuthToken");
      }, _self.hasEvents = _hasEvents, _self._setTransmitProfile = function(profileName) {
       _currentProfile !== profileName && void 0 !== _profiles[profileName] && (_clearScheduledTimer(), 
       _currentProfile = profileName, _scheduleTimer());
      }, (0, HelperFuncs.o$)(_self, (function() {
       return _httpManager;
      }), [ "addResponseHandler" ]), _self._backOffTransmission = function() {
       _currentBackoffCount < 4 && (_currentBackoffCount++, _clearScheduledTimer(), _scheduleTimer());
      }, _self._clearBackOff = function() {
       _currentBackoffCount && (_currentBackoffCount = 0, _clearScheduledTimer(), _scheduleTimer());
      };
     })), _this;
    }
    return (0, TsLibShims.qU)(PostChannel, _super), PostChannel.__ieDyn = 1, PostChannel;
   }(BaseTelemetryPlugin.s);
  },
  74484: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    F: () => ConnectionStringParser,
    H: () => parseConnectionString
   });
   var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(269), _Constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(55025), _DynamicConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15130), _FIELDS_SEPARATOR = ";", _FIELD_KEY_VALUE_SEPARATOR = "=";
   function parseConnectionString(connectionString) {
    if (!connectionString) return {};
    var kvPairs = connectionString[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.sY](_FIELDS_SEPARATOR), result = (0, 
    _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.KTd)(kvPairs, (function(fields, kv) {
     var kvParts = kv[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.sY](_FIELD_KEY_VALUE_SEPARATOR);
     if (2 === kvParts[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.oI]) {
      var key = kvParts[0][_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.OL](), value = kvParts[1];
      fields[key] = value;
     }
     return fields;
    }), {});
    if ((0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.cGk)(result)[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.oI] > 0) {
     if (result.endpointsuffix) {
      var locationPrefix = result.location ? result.location + "." : "";
      result[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.zV] = result[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.zV] || "https://" + locationPrefix + "dc." + result.endpointsuffix;
     }
     result[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.zV] = result[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.zV] || _Constants__WEBPACK_IMPORTED_MODULE_2__._G, 
     (0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.Cv9)(result[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.zV], "/") && (result[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.zV] = result[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.zV].slice(0, -1));
    }
    return result;
   }
   var ConnectionStringParser = {
    parse: parseConnectionString
   };
  },
  55025: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    R2: () => strNotSpecified,
    _G: () => DEFAULT_BREEZE_ENDPOINT,
    jp: () => ProcessLegacy,
    ks: () => strIkey,
    tU: () => SampleRate,
    wc: () => DEFAULT_BREEZE_PATH,
    xF: () => DisabledPropertyName,
    ym: () => HttpMethod
   });
   var DisabledPropertyName = "Microsoft_ApplicationInsights_BypassAjaxInstrumentation", SampleRate = "sampleRate", ProcessLegacy = "ProcessLegacy", HttpMethod = "http.method", DEFAULT_BREEZE_ENDPOINT = "https://dc.services.visualstudio.com", DEFAULT_BREEZE_PATH = "/v2/track", strNotSpecified = "not_specified", strIkey = "iKey";
  },
  7374: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    eL: () => StorageType,
    iD: () => EventPersistence,
    uG: () => DistributedTracingModes
   });
   var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(84282), StorageType = (0, 
   _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.H)({
    LocalStorage: 0,
    SessionStorage: 1
   }), DistributedTracingModes = (0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.H)({
    AI: 0,
    AI_AND_W3C: 1,
    W3C: 2
   }), EventPersistence = (0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.H)({
    Normal: 1,
    Critical: 2
   });
  },
  60087: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    Dt: () => stringToBoolOrDefault,
    Y8: () => getExtensionByName,
    bb: () => msToTimeSpan,
    vv: () => isCrossOriginError
   });
   var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(269), _DynamicConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15130), strEmpty = "";
   function stringToBoolOrDefault(str, defaultValue) {
    return void 0 === defaultValue && (defaultValue = !1), null == str ? defaultValue : "true" === str.toString()[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.OL]();
   }
   function msToTimeSpan(totalms) {
    (isNaN(totalms) || totalms < 0) && (totalms = 0), totalms = Math.round(totalms);
    var ms = strEmpty + totalms % 1e3, sec = strEmpty + Math.floor(totalms / 1e3) % 60, min = strEmpty + Math.floor(totalms / 6e4) % 60, hour = strEmpty + Math.floor(totalms / 36e5) % 24, days = Math.floor(totalms / 864e5);
    return ms = 1 === ms[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.oI] ? "00" + ms : 2 === ms[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.oI] ? "0" + ms : ms, 
    sec = sec[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.oI] < 2 ? "0" + sec : sec, 
    min = min[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.oI] < 2 ? "0" + min : min, 
    hour = hour[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.oI] < 2 ? "0" + hour : hour, 
    (days > 0 ? days + "." : strEmpty) + hour + ":" + min + ":" + sec + "." + ms;
   }
   function getExtensionByName(extensions, identifier) {
    var extension = null;
    return (0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.Iuo)(extensions, (function(value) {
     if (value.identifier === identifier) return extension = value, -1;
    })), extension;
   }
   function isCrossOriginError(message, url, lineNumber, columnNumber, error) {
    return !error && (0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.KgX)(message) && ("Script error." === message || "Script error" === message);
   }
  },
  8596: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    o: () => ContextTagKeys
   });
   var _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(10659), _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(13673);
   function _aiNameFunc(baseName) {
    var aiName = "ai." + baseName + ".";
    return function(name) {
     return aiName + name;
    };
   }
   var _aiApplication = _aiNameFunc("application"), _aiDevice = _aiNameFunc("device"), _aiLocation = _aiNameFunc("location"), _aiOperation = _aiNameFunc("operation"), _aiSession = _aiNameFunc("session"), _aiUser = _aiNameFunc("user"), _aiCloud = _aiNameFunc("cloud"), _aiInternal = _aiNameFunc("internal"), ContextTagKeys = function(_super) {
    function ContextTagKeys() {
     return _super.call(this) || this;
    }
    return (0, _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__.qU)(ContextTagKeys, _super), 
    ContextTagKeys;
   }((0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.SZ)({
    applicationVersion: _aiApplication("ver"),
    applicationBuild: _aiApplication("build"),
    applicationTypeId: _aiApplication("typeId"),
    applicationId: _aiApplication("applicationId"),
    applicationLayer: _aiApplication("layer"),
    deviceId: _aiDevice("id"),
    deviceIp: _aiDevice("ip"),
    deviceLanguage: _aiDevice("language"),
    deviceLocale: _aiDevice("locale"),
    deviceModel: _aiDevice("model"),
    deviceFriendlyName: _aiDevice("friendlyName"),
    deviceNetwork: _aiDevice("network"),
    deviceNetworkName: _aiDevice("networkName"),
    deviceOEMName: _aiDevice("oemName"),
    deviceOS: _aiDevice("os"),
    deviceOSVersion: _aiDevice("osVersion"),
    deviceRoleInstance: _aiDevice("roleInstance"),
    deviceRoleName: _aiDevice("roleName"),
    deviceScreenResolution: _aiDevice("screenResolution"),
    deviceType: _aiDevice("type"),
    deviceMachineName: _aiDevice("machineName"),
    deviceVMName: _aiDevice("vmName"),
    deviceBrowser: _aiDevice("browser"),
    deviceBrowserVersion: _aiDevice("browserVersion"),
    locationIp: _aiLocation("ip"),
    locationCountry: _aiLocation("country"),
    locationProvince: _aiLocation("province"),
    locationCity: _aiLocation("city"),
    operationId: _aiOperation("id"),
    operationName: _aiOperation("name"),
    operationParentId: _aiOperation("parentId"),
    operationRootId: _aiOperation("rootId"),
    operationSyntheticSource: _aiOperation("syntheticSource"),
    operationCorrelationVector: _aiOperation("correlationVector"),
    sessionId: _aiSession("id"),
    sessionIsFirst: _aiSession("isFirst"),
    sessionIsNew: _aiSession("isNew"),
    userAccountAcquisitionDate: _aiUser("accountAcquisitionDate"),
    userAccountId: _aiUser("accountId"),
    userAgent: _aiUser("userAgent"),
    userId: _aiUser("id"),
    userStoreRegion: _aiUser("storeRegion"),
    userAuthUserId: _aiUser("authUserId"),
    userAnonymousUserAcquisitionDate: _aiUser("anonUserAcquisitionDate"),
    userAuthenticatedUserAcquisitionDate: _aiUser("authUserAcquisitionDate"),
    cloudName: _aiCloud("name"),
    cloudRole: _aiCloud("role"),
    cloudRoleVer: _aiCloud("roleVer"),
    cloudRoleInstance: _aiCloud("roleInstance"),
    cloudEnvironment: _aiCloud("environment"),
    cloudLocation: _aiCloud("location"),
    cloudDeploymentUnit: _aiCloud("deploymentUnit"),
    internalNodeName: _aiInternal("nodeName"),
    internalSdkVersion: _aiInternal("sdkVersion"),
    internalAgentVersion: _aiInternal("agentVersion"),
    internalSnippet: _aiInternal("snippet"),
    internalSdkSrc: _aiInternal("sdkSrc")
   }));
  },
  29762: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    O: () => SeverityLevel
   });
   var SeverityLevel = (0, __webpack_require__(84282).H)({
    Verbose: 0,
    Information: 1,
    Warning: 2,
    Error: 3,
    Critical: 4
   });
  },
  81575: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    F: () => Extensions,
    O: () => CtxTagKeys
   });
   var _Contracts_ContextTagKeys__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8596), Extensions = {
    UserExt: "user",
    DeviceExt: "device",
    TraceExt: "trace",
    WebExt: "web",
    AppExt: "app",
    OSExt: "os",
    SessionExt: "ses",
    SDKExt: "sdk"
   }, CtxTagKeys = new _Contracts_ContextTagKeys__WEBPACK_IMPORTED_MODULE_0__.o;
  },
  85571: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    G: () => createOfflineListener
   });
   var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(56149), _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(269), _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(24276), _DynamicConstants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(15130);
   function _disableEvents(target, evtNamespace) {
    (0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.ML)(target, null, null, evtNamespace);
   }
   function createOfflineListener(parentEvtNamespace) {
    var _document = (0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.YEm)(), _navigator = (0, 
    _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.w3n)(), _isListening = !1, listenerList = [], rState = 1;
    !_navigator || (0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.hXl)(_navigator.onLine) || _navigator.onLine || (rState = 2);
    var uState = 0, _currentState = calCurrentState(), _evtNamespace = (0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.Hm)((0, 
    _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__.Z)("OfflineListener"), parentEvtNamespace);
    try {
     if (_enableEvents((0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.zkX)()) && (_isListening = !0), 
     _document) {
      var target = _document.body || _document;
      target.ononline && _enableEvents(target) && (_isListening = !0);
     }
    } catch (e) {
     _isListening = !1;
    }
    function _enableEvents(target) {
     var enabled = !1;
     return target && (enabled = (0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.mB)(target, "online", _setOnline, _evtNamespace)) && (0, 
     _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.mB)(target, "offline", _setOffline, _evtNamespace), 
     enabled;
    }
    function calCurrentState() {
     return 2 !== uState && 2 !== rState;
    }
    function listnerNoticeCheck() {
     var newState = calCurrentState();
     _currentState !== newState && (_currentState = newState, (0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.Iuo)(listenerList, (function(callback) {
      var offlineState = {
       isOnline: _currentState,
       rState,
       uState
      };
      try {
       callback(offlineState);
      } catch (e) {}
     })));
    }
    function _setOnline() {
     rState = 1, listnerNoticeCheck();
    }
    function _setOffline() {
     rState = 2, listnerNoticeCheck();
    }
    return {
     isOnline: function() {
      return _currentState;
     },
     isListening: function() {
      return _isListening;
     },
     unload: function() {
      var win = (0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.zkX)();
      if (win && _isListening) {
       if (_disableEvents(win, _evtNamespace), _document) {
        var target = _document.body || _document;
        (0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.b07)(target.ononline) || _disableEvents(target, _evtNamespace);
       }
       _isListening = !1;
      }
     },
     addListener: function(callback) {
      return listenerList[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__.y5](callback), 
      {
       rm: function() {
        var index = listenerList.indexOf(callback);
        return index > -1 ? listenerList.splice(index, 1) : void 0;
       }
      };
     },
     setOnlineState: function(newState) {
      uState = newState, listnerNoticeCheck();
     }
    };
   }
  },
  52910: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    a: () => RequestHeaders
   });
   var RequestHeaders = (0, __webpack_require__(84282).o)({
    requestContextHeader: [ 0, "Request-Context" ],
    requestContextTargetKey: [ 1, "appId" ],
    requestContextAppIdFormat: [ 2, "appId=cid-v1:" ],
    requestIdHeader: [ 3, "Request-Id" ],
    traceParentHeader: [ 4, "traceparent" ],
    traceStateHeader: [ 5, "tracestate" ],
    sdkContextHeader: [ 6, "Sdk-Context" ],
    sdkContextHeaderAppIdRequest: [ 7, "appId" ],
    requestContextHeaderLowerCase: [ 8, "request-context" ]
   });
  },
  14658: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    AN: () => utlCanUseSessionStorage,
    BW: () => utlCanUseLocalStorage,
    Dt: () => utlSetSessionStorage,
    Nu: () => utlDisableStorage,
    Se: () => utlGetLocalStorage,
    T9: () => utlGetSessionStorageKeys,
    _M: () => utlSetLocalStorage,
    iw: () => utlEnableStorage,
    tm: () => utlRemoveStorage,
    v7: () => utlRemoveSessionStorage,
    vH: () => utlGetSessionStorage,
    vh: () => utlSetStoragePrefix
   });
   var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(269), _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(23775), _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(13673), _Enums__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7374), _DynamicConstants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(15130), _canUseLocalStorage = void 0, _canUseSessionStorage = void 0, _storagePrefix = "";
   function _getLocalStorageObject() {
    return utlCanUseLocalStorage() ? _getVerifiedStorageObject(_Enums__WEBPACK_IMPORTED_MODULE_0__.eL.LocalStorage) : null;
   }
   function _getVerifiedStorageObject(storageType) {
    try {
     if ((0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.hXl)((0, 
     _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.mS$)())) return null;
     var uid = (new Date)[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__.xE](), storage = (0, 
     _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.zS2)(storageType === _Enums__WEBPACK_IMPORTED_MODULE_0__.eL.LocalStorage ? "localStorage" : "sessionStorage"), name_1 = _storagePrefix + uid;
     storage.setItem(name_1, uid);
     var fail = storage.getItem(name_1) !== uid;
     if (storage[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__.AZ](name_1), !fail) return storage;
    } catch (exception) {}
    return null;
   }
   function _getSessionStorageObject() {
    return utlCanUseSessionStorage() ? _getVerifiedStorageObject(_Enums__WEBPACK_IMPORTED_MODULE_0__.eL.SessionStorage) : null;
   }
   function utlDisableStorage() {
    _canUseLocalStorage = !1, _canUseSessionStorage = !1;
   }
   function utlSetStoragePrefix(storagePrefix) {
    _storagePrefix = storagePrefix || "";
   }
   function utlEnableStorage() {
    _canUseLocalStorage = utlCanUseLocalStorage(!0), _canUseSessionStorage = utlCanUseSessionStorage(!0);
   }
   function utlCanUseLocalStorage(reset) {
    return (reset || void 0 === _canUseLocalStorage) && (_canUseLocalStorage = !!_getVerifiedStorageObject(_Enums__WEBPACK_IMPORTED_MODULE_0__.eL.LocalStorage)), 
    _canUseLocalStorage;
   }
   function utlGetLocalStorage(logger, name) {
    var storage = _getLocalStorageObject();
    if (null !== storage) try {
     return storage.getItem(name);
    } catch (e) {
     _canUseLocalStorage = !1, (0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_3__.ZP)(logger, 2, 1, "Browser failed read of local storage. " + (0, 
     _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_4__.lL)(e), {
      exception: (0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.mmD)(e)
     });
    }
    return null;
   }
   function utlSetLocalStorage(logger, name, data) {
    var storage = _getLocalStorageObject();
    if (null !== storage) try {
     return storage.setItem(name, data), !0;
    } catch (e) {
     _canUseLocalStorage = !1, (0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_3__.ZP)(logger, 2, 3, "Browser failed write to local storage. " + (0, 
     _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_4__.lL)(e), {
      exception: (0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.mmD)(e)
     });
    }
    return !1;
   }
   function utlRemoveStorage(logger, name) {
    var storage = _getLocalStorageObject();
    if (null !== storage) try {
     return storage[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__.AZ](name), !0;
    } catch (e) {
     _canUseLocalStorage = !1, (0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_3__.ZP)(logger, 2, 5, "Browser failed removal of local storage item. " + (0, 
     _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_4__.lL)(e), {
      exception: (0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.mmD)(e)
     });
    }
    return !1;
   }
   function utlCanUseSessionStorage(reset) {
    return (reset || void 0 === _canUseSessionStorage) && (_canUseSessionStorage = !!_getVerifiedStorageObject(_Enums__WEBPACK_IMPORTED_MODULE_0__.eL.SessionStorage)), 
    _canUseSessionStorage;
   }
   function utlGetSessionStorageKeys() {
    var keys = [];
    return utlCanUseSessionStorage() && (0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.zav)((0, 
    _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.zS2)("sessionStorage"), (function(key) {
     keys[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__.y5](key);
    })), keys;
   }
   function utlGetSessionStorage(logger, name) {
    var storage = _getSessionStorageObject();
    if (null !== storage) try {
     return storage.getItem(name);
    } catch (e) {
     _canUseSessionStorage = !1, (0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_3__.ZP)(logger, 2, 2, "Browser failed read of session storage. " + (0, 
     _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_4__.lL)(e), {
      exception: (0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.mmD)(e)
     });
    }
    return null;
   }
   function utlSetSessionStorage(logger, name, data) {
    var storage = _getSessionStorageObject();
    if (null !== storage) try {
     return storage.setItem(name, data), !0;
    } catch (e) {
     _canUseSessionStorage = !1, (0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_3__.ZP)(logger, 2, 4, "Browser failed write to session storage. " + (0, 
     _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_4__.lL)(e), {
      exception: (0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.mmD)(e)
     });
    }
    return !1;
   }
   function utlRemoveSessionStorage(logger, name) {
    var storage = _getSessionStorageObject();
    if (null !== storage) try {
     return storage[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__.AZ](name), !0;
    } catch (e) {
     _canUseSessionStorage = !1, (0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_3__.ZP)(logger, 2, 6, "Browser failed removal of session storage item. " + (0, 
     _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_4__.lL)(e), {
      exception: (0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.mmD)(e)
     });
    }
    return !1;
   }
  },
  27358: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    B: () => Data
   });
   var Data = function(baseType, data) {
    this.aiDataContract = {
     baseType: 1,
     baseData: 1
    }, this.baseType = baseType, this.baseData = data;
   };
  },
  67975: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    HQ: () => dataSanitizeId,
    Rr: () => dataSanitizeString,
    Vj: () => dataSanitizeMeasurements,
    Vk: () => dataSanitizeMessage,
    Vt: () => dataSanitizeException,
    _T: () => dataSanitizeInput,
    lq: () => dataSanitizeKey,
    pJ: () => dataSanitizeUrl,
    qW: () => dsPadNumber,
    xP: () => dataSanitizeProperties,
    zx: () => dataSanitizeKeyAndAddUniqueness
   });
   var _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(269), _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(23775), _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(7292), _DynamicConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15130);
   function dataSanitizeKeyAndAddUniqueness(logger, key, map) {
    var origLength = key[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.oI], field = dataSanitizeKey(logger, key);
    if (field[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.oI] !== origLength) {
     for (var i = 0, uniqueField = field; void 0 !== map[uniqueField]; ) i++, uniqueField = (0, 
     _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.P0f)(field, 0, 147) + dsPadNumber(i);
     field = uniqueField;
    }
    return field;
   }
   function dataSanitizeKey(logger, name) {
    var nameTrunc;
    return name && (name = (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.EHq)((0, 
    _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.oJg)(name)))[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.oI] > 150 && (nameTrunc = (0, 
    _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.P0f)(name, 0, 150), (0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__.ZP)(logger, 2, 57, "name is too long.  It has been truncated to 150 characters.", {
     name
    }, !0)), nameTrunc || name;
   }
   function dataSanitizeString(logger, value, maxLength) {
    var valueTrunc;
    return void 0 === maxLength && (maxLength = 1024), value && (maxLength = maxLength || 1024, 
    (value = (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.EHq)((0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.oJg)(value)))[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.oI] > maxLength && (valueTrunc = (0, 
    _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.P0f)(value, 0, maxLength), (0, 
    _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__.ZP)(logger, 2, 61, "string value is too long. It has been truncated to " + maxLength + " characters.", {
     value
    }, !0))), valueTrunc || value;
   }
   function dataSanitizeUrl(logger, url) {
    return dataSanitizeInput(logger, url, 2048, 66);
   }
   function dataSanitizeMessage(logger, message) {
    var messageTrunc;
    return message && message[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.oI] > 32768 && (messageTrunc = (0, 
    _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.P0f)(message, 0, 32768), (0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__.ZP)(logger, 2, 56, "message is too long, it has been truncated to 32768 characters.", {
     message
    }, !0)), messageTrunc || message;
   }
   function dataSanitizeException(logger, exception) {
    var exceptionTrunc;
    if (exception) {
     var value = "" + exception;
     value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.oI] > 32768 && (exceptionTrunc = (0, 
     _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.P0f)(value, 0, 32768), (0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__.ZP)(logger, 2, 52, "exception is too long, it has been truncated to 32768 characters.", {
      exception
     }, !0));
    }
    return exceptionTrunc || exception;
   }
   function dataSanitizeProperties(logger, properties) {
    if (properties) {
     var tempProps_1 = {};
     (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.zav)(properties, (function(prop, value) {
      if ((0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.Gvm)(value) && (0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_3__.Z)()) try {
       value = (0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_3__.hm)()[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.Jj](value);
      } catch (e) {
       (0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__.ZP)(logger, 2, 49, "custom property is not valid", {
        exception: e
       }, !0);
      }
      value = dataSanitizeString(logger, value, 8192), prop = dataSanitizeKeyAndAddUniqueness(logger, prop, tempProps_1), 
      tempProps_1[prop] = value;
     })), properties = tempProps_1;
    }
    return properties;
   }
   function dataSanitizeMeasurements(logger, measurements) {
    if (measurements) {
     var tempMeasurements_1 = {};
     (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.zav)(measurements, (function(measure, value) {
      measure = dataSanitizeKeyAndAddUniqueness(logger, measure, tempMeasurements_1), 
      tempMeasurements_1[measure] = value;
     })), measurements = tempMeasurements_1;
    }
    return measurements;
   }
   function dataSanitizeId(logger, id) {
    return id ? dataSanitizeInput(logger, id, 128, 69)[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.xE]() : id;
   }
   function dataSanitizeInput(logger, input, maxLength, _msgId) {
    var inputTrunc;
    return input && (input = (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.EHq)((0, 
    _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.oJg)(input)))[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.oI] > maxLength && (inputTrunc = (0, 
    _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.P0f)(input, 0, maxLength), (0, 
    _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__.ZP)(logger, 2, _msgId, "input is too long, it has been truncated to " + maxLength + " characters.", {
     data: input
    }, !0)), inputTrunc || input;
   }
   function dsPadNumber(num) {
    var s = "00" + num;
    return (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.hKY)(s, s[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.oI] - 3);
   }
  },
  21062: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    L: () => Envelope
   });
   var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(13673), _Constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(55025), _DynamicConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15130), _DataSanitizer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(67975), Envelope = function(logger, data, name) {
    var _this = this;
    this.ver = 1, this.sampleRate = 100, this.tags = {}, this[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.RS] = (0, 
    _DataSanitizer__WEBPACK_IMPORTED_MODULE_1__.Rr)(logger, name) || _Constants__WEBPACK_IMPORTED_MODULE_2__.R2, 
    this.data = data, this.time = (0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_3__._u)(new Date), 
    this.aiDataContract = {
     time: 1,
     iKey: 1,
     name: 1,
     sampleRate: function() {
      return 100 === _this.sampleRate ? 4 : 1;
     },
     tags: 1,
     data: 1
    };
   };
  },
  43072: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    J: () => Event
   });
   var _Constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(55025), _DynamicConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15130), _Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(67975), Event = function() {
    function Event(logger, name, properties, measurements) {
     this.aiDataContract = {
      ver: 1,
      name: 1,
      properties: 0,
      measurements: 0
     };
     this.ver = 2, this[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.RS] = (0, _Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_1__.Rr)(logger, name) || _Constants__WEBPACK_IMPORTED_MODULE_2__.R2, 
     this[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.$y] = (0, _Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_1__.xP)(logger, properties), 
     this[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.XA] = (0, _Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_1__.Vj)(logger, measurements);
    }
    return Event.envelopeType = "Microsoft.ApplicationInsights.{0}.Event", Event.dataType = "EventData", 
    Event;
   }();
  },
  65397: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    WJ: () => Exception
   });
   var _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(10659), _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(269), _Constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(55025), _DynamicConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(15130), _Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(67975);
   function _stringify(value, convertToString) {
    var result = value;
    return result && !(0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.KgX)(result) && (JSON && JSON[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.Jj] ? (result = JSON[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.Jj](value), 
    !convertToString || result && "{}" !== result || (result = (0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.Tnt)(value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.xE]) ? value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.xE]() : "" + value)) : result = value + " - (Missing JSON.stringify)"), 
    result || "";
   }
   function _formatMessage(theEvent, errorType) {
    var evtMessage = theEvent;
    return theEvent && (evtMessage && !(0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.KgX)(evtMessage) && (evtMessage = theEvent.message || theEvent.description || evtMessage), 
    evtMessage && !(0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.KgX)(evtMessage) && (evtMessage = _stringify(evtMessage, !0)), 
    theEvent.filename && (evtMessage = evtMessage + " @" + (theEvent.filename || "") + ":" + (theEvent.lineno || "?") + ":" + (theEvent.colno || "?"))), 
    errorType && "String" !== errorType && "Object" !== errorType && "Error" !== errorType && -1 === (0, 
    _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.HzD)(evtMessage || "", errorType) && (evtMessage = errorType + ": " + evtMessage), 
    evtMessage || "";
   }
   function _isStackDetails(details) {
    return details && details.src && (0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.KgX)(details.src) && details.obj && (0, 
    _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.cyL)(details.obj);
   }
   function _convertStackObj(errorStack) {
    var src = errorStack || "";
    (0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.KgX)(src) || (src = (0, 
    _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.KgX)(src.stack) ? src.stack : "" + src);
    var items = src[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.sY]("\n");
    return {
     src,
     obj: items
    };
   }
   function _getStackFromErrorObj(errorObj) {
    var details = null;
    if (errorObj) try {
     if (errorObj.stack) details = _convertStackObj(errorObj.stack); else if (errorObj.error && errorObj.error.stack) details = _convertStackObj(errorObj.error.stack); else if (errorObj.exception && errorObj.exception.stack) details = _convertStackObj(errorObj.exception.stack); else if (_isStackDetails(errorObj)) details = errorObj; else if (_isStackDetails(errorObj.stackDetails)) details = errorObj.stackDetails; else if ((0, 
     _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.zkX)() && (0, 
     _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.zkX)().opera && errorObj.message) details = function(errorMessage) {
      for (var stack = [], lines = errorMessage[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.sY]("\n"), lp = 0; lp < lines[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.oI]; lp++) {
       var entry = lines[lp];
       lines[lp + 1] && (entry += "@" + lines[lp + 1], lp++), stack[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.y5](entry);
      }
      return {
       src: errorMessage,
       obj: stack
      };
     }(errorObj[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.pM]); else if (errorObj.reason && errorObj.reason.stack) details = _convertStackObj(errorObj.reason.stack); else if ((0, 
     _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.KgX)(errorObj)) details = _convertStackObj(errorObj); else {
      var evtMessage = errorObj.message || errorObj.description || "";
      (0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.KgX)(errorObj.errorSrc) && (evtMessage && (evtMessage += "\n"), 
      evtMessage += " from " + errorObj.errorSrc), evtMessage && (details = _convertStackObj(evtMessage));
     }
    } catch (e) {
     details = _convertStackObj(e);
    }
    return details || {
     src: "",
     obj: null
    };
   }
   function _getErrorType(errorType) {
    var typeName = "";
    if (errorType && !(typeName = errorType.typeName || errorType[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.RS] || "")) try {
     var results = /function (.{1,200})\(/.exec(errorType.constructor[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.xE]());
     typeName = results && results[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.oI] > 1 ? results[1] : "";
    } catch (e) {}
    return typeName;
   }
   function _formatErrorCode(errorObj) {
    if (errorObj) try {
     if (!(0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.KgX)(errorObj)) {
      var errorType = _getErrorType(errorObj), result = _stringify(errorObj, !1);
      return result && "{}" !== result || (errorObj.error && (errorType = _getErrorType(errorObj = errorObj.error)), 
      result = _stringify(errorObj, !0)), 0 !== (0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.HzD)(result, errorType) && "String" !== errorType ? errorType + ":" + result : result;
     }
    } catch (e) {}
    return "" + (errorObj || "");
   }
   var Exception = function() {
    function Exception(logger, exception, properties, measurements, severityLevel, id) {
     this.aiDataContract = {
      ver: 1,
      exceptions: 1,
      severityLevel: 0,
      properties: 0,
      measurements: 0
     };
     this.ver = 2, !function(value) {
      try {
       if ((0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.Gvm)(value)) return "ver" in value && "exceptions" in value && "properties" in value;
      } catch (e) {}
      return !1;
     }(exception) ? (properties || (properties = {}), id && (properties.id = id), this[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.OK] = [ new _ExceptionDetails(logger, exception, properties) ], 
     this[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.$y] = (0, _Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_2__.xP)(logger, properties), 
     this[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.XA] = (0, _Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_2__.Vj)(logger, measurements), 
     severityLevel && (this[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.Ur] = severityLevel), 
     id && (this.id = id)) : (this[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.OK] = exception[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.OK] || [], 
     this[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.$y] = exception[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.$y], 
     this[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.XA] = exception[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.XA], 
     exception[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.Ur] && (this[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.Ur] = exception[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.Ur]), 
     exception.id && (this.id = exception.id, exception[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.$y].id = exception.id), 
     exception[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.Fq] && (this[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.Fq] = exception[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.Fq]), 
     (0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.hXl)(exception[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.r1]) || (this[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.r1] = exception[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.r1]));
    }
    return Exception.CreateAutoException = function(message, url, lineNumber, columnNumber, error, evt, stack, errorSrc) {
     var _a, errorType = _getErrorType(error || evt || message);
     return (_a = {})[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.pM] = _formatMessage(message, errorType), 
     _a.url = url, _a.lineNumber = lineNumber, _a.columnNumber = columnNumber, _a.error = _formatErrorCode(error || evt || message), 
     _a.evt = _formatErrorCode(evt || message), _a[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.qg] = errorType, 
     _a.stackDetails = _getStackFromErrorObj(stack || error || evt), _a.errorSrc = errorSrc, 
     _a;
    }, Exception.CreateFromInterface = function(logger, exception, properties, measurements) {
     var exceptions = exception[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.OK] && (0, 
     _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.W$7)(exception[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.OK], (function(ex) {
      return _ExceptionDetails[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.vu](logger, ex);
     }));
     return new Exception(logger, (0, _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_3__.Im)((0, 
     _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_3__.Im)({}, exception), {
      exceptions
     }), properties, measurements);
    }, Exception.prototype.toInterface = function() {
     var _a, _b = this, exceptions = _b.exceptions, properties = _b.properties, measurements = _b.measurements, severityLevel = _b.severityLevel, problemGroup = _b.problemGroup, id = _b.id, isManual = _b.isManual, exceptionDetailsInterface = exceptions instanceof Array && (0, 
     _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.W$7)(exceptions, (function(exception) {
      return exception.toInterface();
     })) || void 0;
     return (_a = {
      ver: "4.0"
     })[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.OK] = exceptionDetailsInterface, 
     _a.severityLevel = severityLevel, _a.properties = properties, _a.measurements = measurements, 
     _a.problemGroup = problemGroup, _a.id = id, _a.isManual = isManual, _a;
    }, Exception.CreateSimpleException = function(message, typeName, assembly, fileName, details, line) {
     var _a;
     return {
      exceptions: [ (_a = {}, _a[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.lW] = !0, 
      _a.message = message, _a.stack = details, _a.typeName = typeName, _a) ]
     };
    }, Exception.envelopeType = "Microsoft.ApplicationInsights.{0}.Exception", Exception.dataType = "ExceptionData", 
    Exception.formatError = _formatErrorCode, Exception;
   }(), _ExceptionDetails = function() {
    function _ExceptionDetails(logger, exception, properties) {
     this.aiDataContract = {
      id: 0,
      outerId: 0,
      typeName: 1,
      message: 1,
      hasFullStack: 0,
      stack: 0,
      parsedStack: 2
     };
     if (function(value) {
      try {
       if ((0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.Gvm)(value)) return "hasFullStack" in value && "typeName" in value;
      } catch (e) {}
      return !1;
     }(exception)) this[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.qg] = exception[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.qg], 
     this[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.pM] = exception[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.pM], 
     this.stack = exception.stack, this[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.on] = exception[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.on] || [], 
     this[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.lW] = exception[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.lW]; else {
      var error = exception, evt = error && error.evt;
      (0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.bJ7)(error) || (error = error.error || evt || error), 
      this[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.qg] = (0, _Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_2__.Rr)(logger, _getErrorType(error)) || _Constants__WEBPACK_IMPORTED_MODULE_4__.R2, 
      this[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.pM] = (0, _Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_2__.Vk)(logger, _formatMessage(exception || error, this[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.qg])) || _Constants__WEBPACK_IMPORTED_MODULE_4__.R2;
      var stack = exception.stackDetails || _getStackFromErrorObj(exception);
      this[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.on] = function(stack) {
       var parsedStack, frames = stack.obj;
       if (frames && frames[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.oI] > 0) {
        parsedStack = [];
        var level_1 = 0, totalSizeInBytes_1 = 0;
        if ((0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.Iuo)(frames, (function(frame) {
         var theFrame = frame[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.xE]();
         if (_StackFrame.regex.test(theFrame)) {
          var parsedFrame = new _StackFrame(theFrame, level_1++);
          totalSizeInBytes_1 += parsedFrame[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.J$], 
          parsedStack[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.y5](parsedFrame);
         }
        })), totalSizeInBytes_1 > 32768) for (var left = 0, right = parsedStack[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.oI] - 1, size = 0, acceptedLeft = left, acceptedRight = right; left < right; ) {
         if ((size += parsedStack[left][_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.J$] + parsedStack[right][_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.J$]) > 32768) {
          var howMany = acceptedRight - acceptedLeft + 1;
          parsedStack.splice(acceptedLeft, howMany);
          break;
         }
         acceptedLeft = left, acceptedRight = right, left++, right--;
        }
       }
       return parsedStack;
      }(stack), (0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.cyL)(this[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.on]) && (0, 
      _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.W$7)(this[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.on], (function(frame) {
       frame[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.QE] = (0, _Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_2__.Rr)(logger, frame[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.QE]), 
       frame[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.IE] = (0, _Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_2__.Rr)(logger, frame[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.IE]);
      })), this.stack = (0, _Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_2__.Vt)(logger, function(stackDetails) {
       var stack = "";
       return stackDetails && (stackDetails.obj ? (0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.Iuo)(stackDetails.obj, (function(entry) {
        stack += entry + "\n";
       })) : stack = stackDetails.src || ""), stack;
      }(stack)), this.hasFullStack = (0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.cyL)(this.parsedStack) && this.parsedStack[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.oI] > 0, 
      properties && (properties[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.qg] = properties[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.qg] || this[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.qg]);
     }
    }
    return _ExceptionDetails.prototype.toInterface = function() {
     var _a, parsedStack = this[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.on] instanceof Array && (0, 
     _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.W$7)(this[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.on], (function(frame) {
      return frame.toInterface();
     }));
     return (_a = {
      id: this.id,
      outerId: this.outerId,
      typeName: this[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.qg],
      message: this[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.pM],
      hasFullStack: this[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.lW],
      stack: this.stack
     })[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.on] = parsedStack || void 0, _a;
    }, _ExceptionDetails.CreateFromInterface = function(logger, exception) {
     var parsedStack = exception[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.on] instanceof Array && (0, 
     _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.W$7)(exception[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.on], (function(frame) {
      return _StackFrame[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.vu](frame);
     })) || exception[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.on];
     return new _ExceptionDetails(logger, (0, _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_3__.Im)((0, 
     _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_3__.Im)({}, exception), {
      parsedStack
     }));
    }, _ExceptionDetails;
   }(), _StackFrame = function() {
    function _StackFrame(sourceFrame, level) {
     this.aiDataContract = {
      level: 1,
      method: 1,
      assembly: 0,
      fileName: 0,
      line: 0
     };
     if (this[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.J$] = 0, "string" == typeof sourceFrame) {
      var frame = sourceFrame;
      this[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.Av] = level, this[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.lx] = "<no_method>", 
      this[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.QE] = (0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.EHq)(frame), 
      this[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.IE] = "", this[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.h_] = 0;
      var matches = frame.match(_StackFrame.regex);
      matches && matches[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.oI] >= 5 && (this[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.lx] = (0, 
      _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.EHq)(matches[2]) || this[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.lx], 
      this[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.IE] = (0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.EHq)(matches[4]), 
      this[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.h_] = parseInt(matches[5]) || 0);
     } else this[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.Av] = sourceFrame[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.Av], 
     this[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.lx] = sourceFrame[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.lx], 
     this[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.QE] = sourceFrame[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.QE], 
     this[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.IE] = sourceFrame[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.IE], 
     this[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.h_] = sourceFrame[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.h_], 
     this[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.J$] = 0;
     this.sizeInBytes += this.method[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.oI], 
     this.sizeInBytes += this.fileName[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.oI], 
     this.sizeInBytes += this.assembly[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.oI], 
     this[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.J$] += _StackFrame.baseSize, 
     this.sizeInBytes += this.level.toString()[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.oI], 
     this.sizeInBytes += this.line.toString()[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.oI];
    }
    return _StackFrame.CreateFromInterface = function(frame) {
     return new _StackFrame(frame, null);
    }, _StackFrame.prototype.toInterface = function() {
     return {
      level: this[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.Av],
      method: this[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.lx],
      assembly: this[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.QE],
      fileName: this[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.IE],
      line: this[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.h_]
     };
    }, _StackFrame.regex = /^([\s]+at)?[\s]{0,50}([^\@\()]+?)[\s]{0,50}(\@|\()([^\(\n]+):([0-9]+):([0-9]+)(\)?)$/, 
    _StackFrame.baseSize = 58, _StackFrame;
   }();
  },
  45014: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    J: () => Metric
   });
   var Constants = __webpack_require__(55025), _DynamicConstants = __webpack_require__(15130), DataPoint = function() {
    this.aiDataContract = {
     name: 1,
     kind: 0,
     value: 1,
     count: 0,
     min: 0,
     max: 0,
     stdDev: 0
    }, this.kind = 0;
   }, DataSanitizer = __webpack_require__(67975), Metric = function() {
    function Metric(logger, name, value, count, min, max, stdDev, properties, measurements) {
     this.aiDataContract = {
      ver: 1,
      metrics: 1,
      properties: 0
     };
     this.ver = 2;
     var dataPoint = new DataPoint;
     dataPoint[_DynamicConstants.F2] = count > 0 ? count : void 0, dataPoint.max = isNaN(max) || null === max ? void 0 : max, 
     dataPoint.min = isNaN(min) || null === min ? void 0 : min, dataPoint[_DynamicConstants.RS] = (0, 
     DataSanitizer.Rr)(logger, name) || Constants.R2, dataPoint.value = value, dataPoint.stdDev = isNaN(stdDev) || null === stdDev ? void 0 : stdDev, 
     this.metrics = [ dataPoint ], this[_DynamicConstants.$y] = (0, DataSanitizer.xP)(logger, properties), 
     this[_DynamicConstants.XA] = (0, DataSanitizer.Vj)(logger, measurements);
    }
    return Metric.envelopeType = "Microsoft.ApplicationInsights.{0}.Metric", Metric.dataType = "MetricData", 
    Metric;
   }();
  },
  51448: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    h: () => PageView
   });
   var _Constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(55025), _HelperFuncs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(60087), _DynamicConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(15130), _Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(67975), PageView = function() {
    function PageView(logger, name, url, durationMs, properties, measurements, id) {
     this.aiDataContract = {
      ver: 1,
      name: 0,
      url: 0,
      duration: 0,
      properties: 0,
      measurements: 0,
      id: 0
     };
     this.ver = 2, this.id = (0, _Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_0__.HQ)(logger, id), 
     this.url = (0, _Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_0__.pJ)(logger, url), 
     this[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.RS] = (0, _Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_0__.Rr)(logger, name) || _Constants__WEBPACK_IMPORTED_MODULE_2__.R2, 
     isNaN(durationMs) || (this[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.qd] = (0, 
     _HelperFuncs__WEBPACK_IMPORTED_MODULE_3__.bb)(durationMs)), this[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.$y] = (0, 
     _Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_0__.xP)(logger, properties), this[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.XA] = (0, 
     _Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_0__.Vj)(logger, measurements);
    }
    return PageView.envelopeType = "Microsoft.ApplicationInsights.{0}.Pageview", PageView.dataType = "PageviewData", 
    PageView;
   }();
  },
  64164: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    H: () => PageViewPerformance
   });
   var _Constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(55025), _DynamicConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(15130), _Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(67975), PageViewPerformance = function() {
    function PageViewPerformance(logger, name, url, unused, properties, measurements, cs4BaseData) {
     this.aiDataContract = {
      ver: 1,
      name: 0,
      url: 0,
      duration: 0,
      perfTotal: 0,
      networkConnect: 0,
      sentRequest: 0,
      receivedResponse: 0,
      domProcessing: 0,
      properties: 0,
      measurements: 0
     };
     this.ver = 2, this.url = (0, _Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_0__.pJ)(logger, url), 
     this[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.RS] = (0, _Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_0__.Rr)(logger, name) || _Constants__WEBPACK_IMPORTED_MODULE_2__.R2, 
     this[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.$y] = (0, _Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_0__.xP)(logger, properties), 
     this[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.XA] = (0, _Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_0__.Vj)(logger, measurements), 
     cs4BaseData && (this.domProcessing = cs4BaseData.domProcessing, this[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.qd] = cs4BaseData[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.qd], 
     this.networkConnect = cs4BaseData.networkConnect, this.perfTotal = cs4BaseData.perfTotal, 
     this[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.fd] = cs4BaseData[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.fd], 
     this.sentRequest = cs4BaseData.sentRequest);
    }
    return PageViewPerformance.envelopeType = "Microsoft.ApplicationInsights.{0}.PageviewPerformance", 
    PageViewPerformance.dataType = "PageviewPerformanceData", PageViewPerformance;
   }();
  },
  1365: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    A: () => RemoteDependencyData
   });
   var _HelperFuncs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(60087), _Util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(42318), _DynamicConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15130), _Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(67975), RemoteDependencyData = function() {
    function RemoteDependencyData(logger, id, absoluteUrl, commandName, value, success, resultCode, method, requestAPI, correlationContext, properties, measurements) {
     void 0 === requestAPI && (requestAPI = "Ajax"), this.aiDataContract = {
      id: 1,
      ver: 1,
      name: 0,
      resultCode: 0,
      duration: 0,
      success: 0,
      data: 0,
      target: 0,
      type: 0,
      properties: 0,
      measurements: 0,
      kind: 0,
      value: 0,
      count: 0,
      min: 0,
      max: 0,
      stdDev: 0,
      dependencyKind: 0,
      dependencySource: 0,
      commandName: 0,
      dependencyTypeName: 0
     };
     this.ver = 2, this.id = id, this[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.qd] = (0, 
     _HelperFuncs__WEBPACK_IMPORTED_MODULE_1__.bb)(value), this.success = success, this.resultCode = resultCode + "", 
     this.type = (0, _Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_2__.Rr)(logger, requestAPI);
     var dependencyFields = (0, _Util__WEBPACK_IMPORTED_MODULE_3__._U)(logger, absoluteUrl, method, commandName);
     this.data = (0, _Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_2__.pJ)(logger, commandName) || dependencyFields.data, 
     this.target = (0, _Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_2__.Rr)(logger, dependencyFields.target), 
     correlationContext && (this.target = "".concat(this.target, " | ").concat(correlationContext)), 
     this[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.RS] = (0, _Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_2__.Rr)(logger, dependencyFields[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.RS]), 
     this[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.$y] = (0, _Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_2__.xP)(logger, properties), 
     this[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.XA] = (0, _Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_2__.Vj)(logger, measurements);
    }
    return RemoteDependencyData.envelopeType = "Microsoft.ApplicationInsights.{0}.RemoteDependency", 
    RemoteDependencyData.dataType = "RemoteDependencyData", RemoteDependencyData;
   }();
  },
  82445: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    C: () => Trace
   });
   var _Constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(55025), _DynamicConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(15130), _Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(67975), Trace = function() {
    function Trace(logger, message, severityLevel, properties, measurements) {
     this.aiDataContract = {
      ver: 1,
      message: 1,
      severityLevel: 0,
      properties: 0
     };
     this.ver = 2, message = message || _Constants__WEBPACK_IMPORTED_MODULE_0__.R2, this[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.pM] = (0, 
     _Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_2__.Vk)(logger, message), this[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.$y] = (0, 
     _Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_2__.xP)(logger, properties), this[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.XA] = (0, 
     _Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_2__.Vj)(logger, measurements), severityLevel && (this[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.Ur] = severityLevel);
    }
    return Trace.envelopeType = "Microsoft.ApplicationInsights.{0}.Message", Trace.dataType = "MessageData", 
    Trace;
   }();
  },
  59354: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    Gz: () => urlGetPathName,
    M0: () => urlParseFullHost,
    PS: () => urlParseHost,
    cM: () => urlParseUrl,
    k6: () => urlGetCompleteUrl,
    wX: () => urlGetAbsoluteUrl
   });
   var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(269), _DynamicConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(15130), _document = (0, 
   _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.YEm)() || {}, _htmlAnchorIdx = 0, _htmlAnchorElement = [ null, null, null, null, null ];
   function urlParseUrl(url) {
    var anchorIdx = _htmlAnchorIdx, anchorCache = _htmlAnchorElement, tempAnchor = anchorCache[anchorIdx];
    return _document.createElement ? anchorCache[anchorIdx] || (tempAnchor = anchorCache[anchorIdx] = _document.createElement("a")) : tempAnchor = {
     host: urlParseHost(url, !0)
    }, tempAnchor.href = url, ++anchorIdx >= anchorCache[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.oI] && (anchorIdx = 0), 
    _htmlAnchorIdx = anchorIdx, tempAnchor;
   }
   function urlGetAbsoluteUrl(url) {
    var result, a = urlParseUrl(url);
    return a && (result = a.href), result;
   }
   function urlGetPathName(url) {
    var result, a = urlParseUrl(url);
    return a && (result = a[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.Ue]), result;
   }
   function urlGetCompleteUrl(method, absoluteUrl) {
    return method ? method.toUpperCase() + " " + absoluteUrl : absoluteUrl;
   }
   function urlParseHost(url, inclPort) {
    var fullHost = urlParseFullHost(url, inclPort) || "";
    if (fullHost) {
     var match = fullHost.match(/(www\d{0,5}\.)?([^\/:]{1,256})(:\d{1,20})?/i);
     if (null != match && match[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.oI] > 3 && (0, 
     _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.KgX)(match[2]) && match[2][_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.oI] > 0) return match[2] + (match[3] || "");
    }
    return fullHost;
   }
   function urlParseFullHost(url, inclPort) {
    var result = null;
    if (url) {
     var match = url.match(/(\w{1,150}):\/\/([^\/:]{1,256})(:\d{1,20})?/i);
     if (null != match && match[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.oI] > 2 && (0, 
     _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.KgX)(match[2]) && match[2][_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.oI] > 0 && (result = match[2] || "", 
     inclPort && match[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.oI] > 2)) {
      var protocol = (match[1] || "")[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.OL](), port = match[3] || "";
      ("http" === protocol && ":80" === port || "https" === protocol && ":443" === port) && (port = ""), 
      result += port;
     }
    }
    return result;
   }
  },
  42318: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    Ft: () => createDistributedTraceContextFromTrace,
    Qu: () => isInternalApplicationInsightsEndpoint,
    Rs: () => correlationIdCanIncludeCorrelationHeader,
    Wt: () => correlationIdSetPrefix,
    _U: () => AjaxHelperParseDependencyPath,
    jj: () => dateTimeUtilsDuration,
    lt: () => dateTimeUtilsNow,
    mD: () => correlationIdGetCorrelationContextValue,
    mp: () => correlationIdGetPrefix,
    pg: () => correlationIdGetCorrelationContext
   });
   var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(269), _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(91864), _Constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(55025), _RequestResponseHeaders__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(52910), _Telemetry_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(67975), _UrlHelperFuncs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(59354), _DynamicConstants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(15130), _internalEndpoints = [ _Constants__WEBPACK_IMPORTED_MODULE_0__._G + _Constants__WEBPACK_IMPORTED_MODULE_0__.wc, "https://breeze.aimon.applicationinsights.io" + _Constants__WEBPACK_IMPORTED_MODULE_0__.wc, "https://dc-int.services.visualstudio.com" + _Constants__WEBPACK_IMPORTED_MODULE_0__.wc ], _correlationIdPrefix = "cid-v1:";
   function isInternalApplicationInsightsEndpoint(endpointUrl) {
    return -1 !== (0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.rDm)(_internalEndpoints, endpointUrl[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__.OL]());
   }
   function correlationIdSetPrefix(prefix) {
    _correlationIdPrefix = prefix;
   }
   function correlationIdGetPrefix() {
    return _correlationIdPrefix;
   }
   function correlationIdCanIncludeCorrelationHeader(config, requestUrl, currentHost) {
    if (!requestUrl || config && config.disableCorrelationHeaders) return !1;
    if (config && config[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__.Ol]) for (var i = 0; i < config.correlationHeaderExcludePatterns[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__.oI]; i++) if (config[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__.Ol][i].test(requestUrl)) return !1;
    var requestHost = (0, _UrlHelperFuncs__WEBPACK_IMPORTED_MODULE_3__.cM)(requestUrl).host[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__.OL]();
    if (!requestHost || -1 === (0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.HzD)(requestHost, ":443") && -1 === (0, 
    _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.HzD)(requestHost, ":80") || (requestHost = ((0, 
    _UrlHelperFuncs__WEBPACK_IMPORTED_MODULE_3__.M0)(requestUrl, !0) || "")[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__.OL]()), 
    (!config || !config.enableCorsCorrelation) && requestHost && requestHost !== currentHost) return !1;
    var matchExists_1, includedDomains = config && config.correlationHeaderDomains;
    if (includedDomains && ((0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.Iuo)(includedDomains, (function(domain) {
     var regex = new RegExp(domain.toLowerCase().replace(/\\/g, "\\\\").replace(/\./g, "\\.").replace(/\*/g, ".*"));
     matchExists_1 = matchExists_1 || regex.test(requestHost);
    })), !matchExists_1)) return !1;
    var excludedDomains = config && config.correlationHeaderExcludedDomains;
    if (!excludedDomains || 0 === excludedDomains[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__.oI]) return !0;
    for (i = 0; i < excludedDomains[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__.oI]; i++) {
     if (new RegExp(excludedDomains[i].toLowerCase().replace(/\\/g, "\\\\").replace(/\./g, "\\.").replace(/\*/g, ".*")).test(requestHost)) return !1;
    }
    return requestHost && requestHost[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__.oI] > 0;
   }
   function correlationIdGetCorrelationContext(responseHeader) {
    if (responseHeader) {
     var correlationId = correlationIdGetCorrelationContextValue(responseHeader, _RequestResponseHeaders__WEBPACK_IMPORTED_MODULE_4__.a[1]);
     if (correlationId && correlationId !== _correlationIdPrefix) return correlationId;
    }
   }
   function correlationIdGetCorrelationContextValue(responseHeader, key) {
    if (responseHeader) for (var keyValues = responseHeader[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__.sY](","), i = 0; i < keyValues[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__.oI]; ++i) {
     var keyValue = keyValues[i][_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__.sY]("=");
     if (2 === keyValue[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__.oI] && keyValue[0] === key) return keyValue[1];
    }
   }
   function AjaxHelperParseDependencyPath(logger, absoluteUrl, method, commandName) {
    var target, name = commandName, data = commandName;
    if (absoluteUrl && absoluteUrl[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__.oI] > 0) {
     var parsedUrl = (0, _UrlHelperFuncs__WEBPACK_IMPORTED_MODULE_3__.cM)(absoluteUrl);
     if (target = parsedUrl.host, !name) if (null != parsedUrl[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__.Ue]) {
      var pathName = 0 === parsedUrl.pathname[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__.oI] ? "/" : parsedUrl[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__.Ue];
      "/" !== pathName.charAt(0) && (pathName = "/" + pathName), data = parsedUrl[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__.Ue], 
      name = (0, _Telemetry_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_5__.Rr)(logger, method ? method + " " + pathName : pathName);
     } else name = (0, _Telemetry_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_5__.Rr)(logger, absoluteUrl);
    } else target = commandName, name = commandName;
    return {
     target,
     name,
     data
    };
   }
   function dateTimeUtilsNow() {
    var perf = (0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.FJj)();
    if (perf && perf.now && perf.timing) {
     var now = perf.now() + perf.timing.navigationStart;
     if (now > 0) return now;
    }
    return (0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.f0d)();
   }
   function dateTimeUtilsDuration(start, end) {
    var result = null;
    return 0 === start || 0 === end || (0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.hXl)(start) || (0, 
    _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.hXl)(end) || (result = end - start), 
    result;
   }
   function createDistributedTraceContextFromTrace(telemetryTrace, parentCtx) {
    var trace = telemetryTrace || {};
    return {
     getName: function() {
      return trace[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__.RS];
     },
     setName: function(newValue) {
      parentCtx && parentCtx.setName(newValue), trace[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__.RS] = newValue;
     },
     getTraceId: function() {
      return trace.traceID;
     },
     setTraceId: function(newValue) {
      parentCtx && parentCtx.setTraceId(newValue), (0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_6__.hX)(newValue) && (trace.traceID = newValue);
     },
     getSpanId: function() {
      return trace.parentID;
     },
     setSpanId: function(newValue) {
      parentCtx && parentCtx.setSpanId(newValue), (0, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_6__.wN)(newValue) && (trace.parentID = newValue);
     },
     getTraceFlags: function() {
      return trace.traceFlags;
     },
     setTraceFlags: function(newTraceFlags) {
      parentCtx && parentCtx.setTraceFlags(newTraceFlags), trace.traceFlags = newTraceFlags;
     }
    };
   }
  },
  15130: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    $e: () => _DYN_GET_UTCDATE,
    $y: () => _DYN_PROPERTIES,
    AZ: () => _DYN_REMOVE_ITEM,
    Av: () => _DYN_LEVEL,
    C9: () => _DYN_DATE,
    Cx: () => _DYN_DISABLED,
    F2: () => _DYN_COUNT,
    Fq: () => _DYN_PROBLEM_GROUP,
    IE: () => _DYN_FILE_NAME,
    J$: () => _DYN_SIZE_IN_BYTES,
    Jj: () => _DYN_STRINGIFY,
    Jm: () => _DYN_PRE_TRIGGER_DATE,
    OK: () => _DYN_EXCEPTIONS,
    OL: () => _DYN_TO_LOWER_CASE,
    Ol: () => _DYN_CORRELATION_HEADER_E0,
    QE: () => _DYN_ASSEMBLY,
    RS: () => _DYN_NAME,
    Ue: () => _DYN_PATHNAME,
    Ur: () => _DYN_SEVERITY_LEVEL,
    XA: () => _DYN_MEASUREMENTS,
    fd: () => _DYN_RECEIVED_RESPONSE,
    h_: () => _DYN_LINE,
    i9: () => _DYN_DAYS_OF_MONTH,
    lW: () => _DYN_HAS_FULL_STACK,
    lx: () => _DYN_METHOD,
    oI: () => _DYN_LENGTH,
    on: () => _DYN_PARSED_STACK,
    pM: () => _DYN_MESSAGE,
    qd: () => _DYN_DURATION,
    qg: () => _DYN_TYPE_NAME,
    r1: () => _DYN_IS_MANUAL,
    sY: () => _DYN_SPLIT,
    up: () => _DYN_EXTENSION_CONFIG,
    vu: () => _DYN__CREATE_FROM_INTERFA1,
    xE: () => _DYN_TO_STRING,
    y5: () => _DYN_PUSH,
    zV: () => _DYN_INGESTIONENDPOINT,
    zw: () => _DYN_INTERVAL
   });
   var _DYN_SPLIT = "split", _DYN_LENGTH = "length", _DYN_TO_LOWER_CASE = "toLowerCase", _DYN_INGESTIONENDPOINT = "ingestionendpoint", _DYN_TO_STRING = "toString", _DYN_PUSH = "push", _DYN_REMOVE_ITEM = "removeItem", _DYN_NAME = "name", _DYN_MESSAGE = "message", _DYN_COUNT = "count", _DYN_PRE_TRIGGER_DATE = "preTriggerDate", _DYN_DISABLED = "disabled", _DYN_INTERVAL = "interval", _DYN_DAYS_OF_MONTH = "daysOfMonth", _DYN_DATE = "date", _DYN_GET_UTCDATE = "getUTCDate", _DYN_STRINGIFY = "stringify", _DYN_PATHNAME = "pathname", _DYN_CORRELATION_HEADER_E0 = "correlationHeaderExcludePatterns", _DYN_EXTENSION_CONFIG = "extensionConfig", _DYN_EXCEPTIONS = "exceptions", _DYN_PARSED_STACK = "parsedStack", _DYN_PROPERTIES = "properties", _DYN_MEASUREMENTS = "measurements", _DYN_SIZE_IN_BYTES = "sizeInBytes", _DYN_TYPE_NAME = "typeName", _DYN_SEVERITY_LEVEL = "severityLevel", _DYN_PROBLEM_GROUP = "problemGroup", _DYN_IS_MANUAL = "isManual", _DYN__CREATE_FROM_INTERFA1 = "CreateFromInterface", _DYN_ASSEMBLY = "assembly", _DYN_FILE_NAME = "fileName", _DYN_HAS_FULL_STACK = "hasFullStack", _DYN_LEVEL = "level", _DYN_METHOD = "method", _DYN_LINE = "line", _DYN_DURATION = "duration", _DYN_RECEIVED_RESPONSE = "receivedResponse";
  },
  90740: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.r(__webpack_exports__), __webpack_require__.d(__webpack_exports__, {
    AnalyticsPluginIdentifier: () => AnalyticsPluginIdentifier,
    BreezeChannelIdentifier: () => BreezeChannelIdentifier,
    ConfigurationManager: () => ConfigurationManager,
    ConnectionStringParser: () => ConnectionStringParser.F,
    ContextTagKeys: () => ContextTagKeys.o,
    CtxTagKeys: () => PartAExtensions.O,
    DEFAULT_BREEZE_ENDPOINT: () => Constants._G,
    DEFAULT_BREEZE_PATH: () => Constants.wc,
    Data: () => Data.B,
    DisabledPropertyName: () => Constants.xF,
    DistributedTracingModes: () => Enums.uG,
    Envelope: () => Envelope.L,
    Event: () => Telemetry_Event.J,
    EventPersistence: () => Enums.iD,
    Exception: () => Exception.WJ,
    Extensions: () => PartAExtensions.F,
    HttpMethod: () => Constants.ym,
    Metric: () => Metric.J,
    PageView: () => PageView.h,
    PageViewPerformance: () => PageViewPerformance.H,
    ProcessLegacy: () => Constants.jp,
    PropertiesPluginIdentifier: () => PropertiesPluginIdentifier,
    RemoteDependencyData: () => RemoteDependencyData.A,
    RequestHeaders: () => RequestResponseHeaders.a,
    SampleRate: () => Constants.tU,
    SeverityLevel: () => SeverityLevel.O,
    TelemetryItemCreator: () => TelemetryItemCreator,
    ThrottleMgr: () => ThrottleMgr,
    Trace: () => Trace.C,
    correlationIdCanIncludeCorrelationHeader: () => Util.Rs,
    correlationIdGetCorrelationContext: () => Util.pg,
    correlationIdGetCorrelationContextValue: () => Util.mD,
    correlationIdGetPrefix: () => Util.mp,
    correlationIdSetPrefix: () => Util.Wt,
    createDistributedTraceContextFromTrace: () => Util.Ft,
    createDomEvent: () => createDomEvent,
    createOfflineListener: () => Offline.G,
    createTelemetryItem: () => createTelemetryItem,
    createTraceParent: () => W3cTraceParent.wk,
    dataSanitizeException: () => DataSanitizer.Vt,
    dataSanitizeId: () => DataSanitizer.HQ,
    dataSanitizeInput: () => DataSanitizer._T,
    dataSanitizeKey: () => DataSanitizer.lq,
    dataSanitizeKeyAndAddUniqueness: () => DataSanitizer.zx,
    dataSanitizeMeasurements: () => DataSanitizer.Vj,
    dataSanitizeMessage: () => DataSanitizer.Vk,
    dataSanitizeProperties: () => DataSanitizer.xP,
    dataSanitizeString: () => DataSanitizer.Rr,
    dataSanitizeUrl: () => DataSanitizer.pJ,
    dateTimeUtilsDuration: () => Util.jj,
    dateTimeUtilsNow: () => Util.lt,
    dsPadNumber: () => DataSanitizer.qW,
    findAllScripts: () => W3cTraceParent.V5,
    findW3cTraceParent: () => W3cTraceParent.ef,
    formatTraceParent: () => W3cTraceParent.L0,
    getExtensionByName: () => dist_es5_HelperFuncs.Y8,
    isBeaconApiSupported: () => EnvUtils.Uf,
    isCrossOriginError: () => dist_es5_HelperFuncs.vv,
    isInternalApplicationInsightsEndpoint: () => Util.Qu,
    isSampledFlag: () => W3cTraceParent.N7,
    isValidSpanId: () => W3cTraceParent.wN,
    isValidTraceId: () => W3cTraceParent.hX,
    isValidTraceParent: () => W3cTraceParent.mJ,
    msToTimeSpan: () => dist_es5_HelperFuncs.bb,
    parseConnectionString: () => ConnectionStringParser.H,
    parseTraceParent: () => W3cTraceParent.ZI,
    strNotSpecified: () => Constants.R2,
    stringToBoolOrDefault: () => dist_es5_HelperFuncs.Dt,
    urlGetAbsoluteUrl: () => UrlHelperFuncs.wX,
    urlGetCompleteUrl: () => UrlHelperFuncs.k6,
    urlGetPathName: () => UrlHelperFuncs.Gz,
    urlParseFullHost: () => UrlHelperFuncs.M0,
    urlParseHost: () => UrlHelperFuncs.PS,
    urlParseUrl: () => UrlHelperFuncs.cM,
    utlCanUseLocalStorage: () => StorageHelperFuncs.BW,
    utlCanUseSessionStorage: () => StorageHelperFuncs.AN,
    utlDisableStorage: () => StorageHelperFuncs.Nu,
    utlEnableStorage: () => StorageHelperFuncs.iw,
    utlGetLocalStorage: () => StorageHelperFuncs.Se,
    utlGetSessionStorage: () => StorageHelperFuncs.vH,
    utlGetSessionStorageKeys: () => StorageHelperFuncs.T9,
    utlRemoveSessionStorage: () => StorageHelperFuncs.v7,
    utlRemoveStorage: () => StorageHelperFuncs.tm,
    utlSetLocalStorage: () => StorageHelperFuncs._M,
    utlSetSessionStorage: () => StorageHelperFuncs.Dt,
    utlSetStoragePrefix: () => StorageHelperFuncs.vh
   });
   var Util = __webpack_require__(42318), ts_utils = __webpack_require__(269), DiagnosticLogger = __webpack_require__(23775), HelperFuncs = __webpack_require__(13673), DynamicConfig = __webpack_require__(19749), RandomHelper = __webpack_require__(76535), StorageHelperFuncs = __webpack_require__(14658), _DynamicConstants = __webpack_require__(15130), ThrottleMgr = function(core, namePrefix) {
    var _canUseLocalStorage, _logger, _config, _localStorageObj, _isTriggered, _namePrefix, _queue, _self = this, _isReady = !1, _isSpecificDaysGiven = !1;
    function _flushMessage(msgID, message, severity, saveUnsentMsg) {
     if (_isReady) {
      var isSampledIn = function(msgID) {
       try {
        var cfg = _getCfgByKey(msgID);
        return (0, RandomHelper.Z1)(1e6) <= cfg.limit.samplingRate;
       } catch (e) {}
       return !1;
      }(msgID);
      if (!isSampledIn) return;
      var cfg = _getCfgByKey(msgID), localStorageObj = _getLocalStorageObjByKey(msgID), canThrottle = _canThrottle(cfg, _canUseLocalStorage, localStorageObj), throttled = !1, number = 0, isTriggered = _isTrigger(msgID);
      try {
       canThrottle && !isTriggered ? (number = Math.min(cfg.limit.maxSendNumber, localStorageObj[_DynamicConstants.F2] + 1), 
       localStorageObj[_DynamicConstants.F2] = 0, throttled = !0, _isTriggered[msgID] = !0, 
       localStorageObj[_DynamicConstants.Jm] = new Date) : (_isTriggered[msgID] = canThrottle, 
       localStorageObj[_DynamicConstants.F2] += 1);
       var localStorageName = _getLocalStorageName(msgID);
       _resetLocalStorage(_logger, localStorageName, localStorageObj);
       for (var i = 0; i < number; i++) _sendMessage(msgID, _logger, message, severity);
      } catch (e) {}
      return {
       isThrottled: throttled,
       throttleNum: number
      };
     }
     return saveUnsentMsg && _getQueueByKey(msgID)[_DynamicConstants.y5]({
      msgID,
      message,
      severity
     }), null;
    }
    function _getCfgByKey(msgID) {
     return _config[msgID] || _config[109];
    }
    function _setCfgByKey(msgID, config) {
     var _a, _b, interval, monthInterval, dayInterval;
     try {
      var cfg = config || {}, curCfg = {};
      curCfg[_DynamicConstants.Cx] = !!cfg[_DynamicConstants.Cx];
      var configInterval = cfg[_DynamicConstants.zw] || {};
      _isSpecificDaysGiven = (null == configInterval ? void 0 : configInterval.daysOfMonth) && (null == configInterval ? void 0 : configInterval.daysOfMonth[_DynamicConstants.oI]) > 0, 
      curCfg[_DynamicConstants.zw] = (monthInterval = null === (interval = (interval = configInterval) || {}) || void 0 === interval ? void 0 : interval.monthInterval, 
      dayInterval = null == interval ? void 0 : interval.dayInterval, (0, ts_utils.hXl)(monthInterval) && (0, 
      ts_utils.hXl)(dayInterval) && (interval.monthInterval = 3, _isSpecificDaysGiven || (interval[_DynamicConstants.i9] = [ 28 ], 
      _isSpecificDaysGiven = !0)), interval = {
       monthInterval: null == interval ? void 0 : interval.monthInterval,
       dayInterval: null == interval ? void 0 : interval.dayInterval,
       daysOfMonth: null == interval ? void 0 : interval.daysOfMonth
      });
      var limit = {
       samplingRate: (null === (_a = cfg.limit) || void 0 === _a ? void 0 : _a.samplingRate) || 100,
       maxSendNumber: (null === (_b = cfg.limit) || void 0 === _b ? void 0 : _b.maxSendNumber) || 1
      };
      curCfg.limit = limit, _config[msgID] = curCfg;
     } catch (e) {}
    }
    function _canThrottle(config, canUseLocalStorage, localStorageObj) {
     if (config && !config[_DynamicConstants.Cx] && canUseLocalStorage && (0, HelperFuncs.Gh)(localStorageObj)) {
      var curDate = _getThrottleDate(), date = localStorageObj[_DynamicConstants.C9], interval = config[_DynamicConstants.zw], monthCheck = 1;
      if (null == interval ? void 0 : interval.monthInterval) {
       var monthExpand = 12 * (curDate.getUTCFullYear() - date.getUTCFullYear()) + curDate.getUTCMonth() - date.getUTCMonth();
       monthCheck = _checkInterval(interval.monthInterval, 0, monthExpand);
      }
      var dayCheck = 1;
      if (_isSpecificDaysGiven) dayCheck = (0, ts_utils.rDm)(interval[_DynamicConstants.i9], curDate[_DynamicConstants.$e]()); else if (null == interval ? void 0 : interval.dayInterval) {
       var daySpan = Math.floor((curDate.getTime() - date.getTime()) / 864e5);
       dayCheck = _checkInterval(interval.dayInterval, 0, daySpan);
      }
      return monthCheck >= 0 && dayCheck >= 0;
     }
     return !1;
    }
    function _getLocalStorageName(msgKey, prefix) {
     var fix = (0, HelperFuncs.Gh)(prefix) ? prefix : "";
     return msgKey ? "appInsightsThrottle" + fix + "-" + msgKey : null;
    }
    function _getThrottleDate(dateStr) {
     try {
      if (!dateStr) return new Date;
      var date = new Date(dateStr);
      if (!isNaN(date.getDate())) return date;
     } catch (e) {}
     return null;
    }
    function _resetLocalStorage(logger, storageName, obj) {
     try {
      return (0, StorageHelperFuncs._M)(logger, storageName, (0, ts_utils.EHq)(JSON[_DynamicConstants.Jj](obj)));
     } catch (e) {}
     return !1;
    }
    function _checkInterval(interval, start, current) {
     return interval <= 0 ? 1 : current >= start && (current - start) % interval == 0 ? Math.floor((current - start) / interval) + 1 : -1;
    }
    function _sendMessage(msgID, logger, message, severity) {
     (0, DiagnosticLogger.ZP)(logger, severity || 1, msgID, message);
    }
    function _getLocalStorageObjByKey(key) {
     try {
      var curObj = _localStorageObj[key];
      if (!curObj) {
       var localStorageName = _getLocalStorageName(key, _namePrefix);
       curObj = function(value, logger, storageName) {
        try {
         var storageObj = {
          date: _getThrottleDate(),
          count: 0
         };
         if (value) {
          var obj = JSON.parse(value);
          return {
           date: _getThrottleDate(obj[_DynamicConstants.C9]) || storageObj[_DynamicConstants.C9],
           count: obj[_DynamicConstants.F2] || storageObj[_DynamicConstants.F2],
           preTriggerDate: obj.preTriggerDate ? _getThrottleDate(obj[_DynamicConstants.Jm]) : void 0
          };
         }
         return _resetLocalStorage(logger, storageName, storageObj), storageObj;
        } catch (e) {}
        return null;
       }((0, StorageHelperFuncs.Se)(_logger, localStorageName), _logger, localStorageName), 
       _localStorageObj[key] = curObj;
      }
      return _localStorageObj[key];
     } catch (e) {}
     return null;
    }
    function _isTrigger(key) {
     var isTrigger = _isTriggered[key];
     if ((0, ts_utils.hXl)(isTrigger)) {
      isTrigger = !1;
      var localStorageObj = _getLocalStorageObjByKey(key);
      localStorageObj && (isTrigger = function(preTriggerDate) {
       try {
        if (preTriggerDate) {
         var curDate = new Date;
         return preTriggerDate.getUTCFullYear() === curDate.getUTCFullYear() && preTriggerDate.getUTCMonth() === curDate.getUTCMonth() && preTriggerDate[_DynamicConstants.$e]() === curDate[_DynamicConstants.$e]();
        }
       } catch (e) {}
       return !1;
      }(localStorageObj[_DynamicConstants.Jm])), _isTriggered[key] = isTrigger;
     }
     return _isTriggered[key];
    }
    function _getQueueByKey(key) {
     return _queue = _queue || {}, (0, ts_utils.hXl)(_queue[key]) && (_queue[key] = []), 
     _queue[key];
    }
    _logger = (0, DiagnosticLogger.y0)(core), _isTriggered = {}, _localStorageObj = {}, 
    _queue = {}, _config = {}, _setCfgByKey(109), _namePrefix = (0, HelperFuncs.Gh)(namePrefix) ? namePrefix : "", 
    core.addUnloadHook((0, DynamicConfig.a)(core.config, (function(details) {
     var coreConfig = details.cfg;
     _canUseLocalStorage = (0, StorageHelperFuncs.BW)();
     var configMgr = coreConfig.throttleMgrCfg || {};
     (0, ts_utils.zav)(configMgr, (function(key, cfg) {
      _setCfgByKey(parseInt(key), cfg);
     }));
    }))), _self._getDbgPlgTargets = function() {
     return [ _queue ];
    }, _self.getConfig = function() {
     return _config;
    }, _self.canThrottle = function(msgId) {
     var localObj = _getLocalStorageObjByKey(msgId);
     return _canThrottle(_getCfgByKey(msgId), _canUseLocalStorage, localObj);
    }, _self.isTriggered = function(msgId) {
     return _isTrigger(msgId);
    }, _self.isReady = function() {
     return _isReady;
    }, _self.flush = function(msgId) {
     try {
      var queue = _getQueueByKey(msgId);
      if (queue && queue[_DynamicConstants.oI] > 0) {
       var items = queue.slice(0);
       return _queue[msgId] = [], (0, ts_utils.Iuo)(items, (function(item) {
        _flushMessage(item.msgID, item[_DynamicConstants.pM], item.severity, !1);
       })), !0;
      }
     } catch (err) {}
     return !1;
    }, _self.flushAll = function() {
     try {
      if (_queue) {
       var result_1 = !0;
       return (0, ts_utils.zav)(_queue, (function(key) {
        var isFlushed = _self.flush(parseInt(key));
        result_1 = result_1 && isFlushed;
       })), result_1;
      }
     } catch (err) {}
     return !1;
    }, _self.onReadyState = function(isReady, flushAll) {
     return void 0 === flushAll && (flushAll = !0), (_isReady = !!(0, ts_utils.hXl)(isReady) || isReady) && flushAll ? _self.flushAll() : null;
    }, _self.sendMessage = function(msgID, message, severity) {
     return _flushMessage(msgID, message, severity, !0);
    };
   }, ConnectionStringParser = __webpack_require__(74484), RequestResponseHeaders = __webpack_require__(52910), Constants = __webpack_require__(55025), Envelope = __webpack_require__(21062), Telemetry_Event = __webpack_require__(43072), Exception = __webpack_require__(65397), Metric = __webpack_require__(45014), PageView = __webpack_require__(51448), RemoteDependencyData = __webpack_require__(1365), Trace = __webpack_require__(82445), PageViewPerformance = __webpack_require__(64164), Data = __webpack_require__(27358), SeverityLevel = __webpack_require__(29762), ConfigurationManager = function() {
    function ConfigurationManager() {}
    return ConfigurationManager.getConfig = function(config, field, identifier, defaultValue) {
     var configValue;
     return void 0 === defaultValue && (defaultValue = !1), configValue = identifier && config[_DynamicConstants.up] && config[_DynamicConstants.up][identifier] && !(0, 
     ts_utils.hXl)(config[_DynamicConstants.up][identifier][field]) ? config[_DynamicConstants.up][identifier][field] : config[field], 
     (0, ts_utils.hXl)(configValue) ? defaultValue : configValue;
    }, ConfigurationManager;
   }(), ContextTagKeys = __webpack_require__(8596), DataSanitizer = __webpack_require__(67975);
   function createTelemetryItem(item, baseType, envelopeName, logger, customProperties, systemProperties) {
    var _a;
    envelopeName = (0, DataSanitizer.Rr)(logger, envelopeName) || Constants.R2, ((0, 
    ts_utils.hXl)(item) || (0, ts_utils.hXl)(baseType) || (0, ts_utils.hXl)(envelopeName)) && (0, 
    ts_utils.$8)("Input doesn't contain all required fields");
    var iKey = "";
    item[Constants.ks] && (iKey = item[Constants.ks], delete item[Constants.ks]);
    var telemetryItem = ((_a = {})[_DynamicConstants.RS] = envelopeName, _a.time = (0, 
    HelperFuncs._u)(new Date), _a.iKey = iKey, _a.ext = systemProperties || {}, _a.tags = [], 
    _a.data = {}, _a.baseType = baseType, _a.baseData = item, _a);
    return (0, ts_utils.hXl)(customProperties) || (0, ts_utils.zav)(customProperties, (function(prop, value) {
     telemetryItem.data[prop] = value;
    })), telemetryItem;
   }
   var TelemetryItemCreator = function() {
    function TelemetryItemCreator() {}
    return TelemetryItemCreator.create = createTelemetryItem, TelemetryItemCreator;
   }(), PartAExtensions = __webpack_require__(81575), Enums = __webpack_require__(7374), dist_es5_HelperFuncs = __webpack_require__(60087), EnvUtils = __webpack_require__(7292), W3cTraceParent = __webpack_require__(91864);
   function createDomEvent(eventName) {
    var event = null;
    if ((0, ts_utils.Tnt)(Event)) event = new Event(eventName); else {
     var doc = (0, ts_utils.YEm)();
     doc && doc.createEvent && (event = doc.createEvent("Event")).initEvent(eventName, !0, !0);
    }
    return event;
   }
   var UrlHelperFuncs = __webpack_require__(59354), Offline = __webpack_require__(85571), PropertiesPluginIdentifier = "AppInsightsPropertiesPlugin", BreezeChannelIdentifier = "AppInsightsChannelPlugin", AnalyticsPluginIdentifier = "ApplicationInsightsAnalytics";
  },
  52475: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    DD: () => cfgDfBoolean,
    Lx: () => cfgDfValidate,
    NU: () => cfgDfMerge
   });
   var _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(269), _DynamicConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6182);
   function _stringToBoolOrDefault(theValue, defaultValue, theConfig) {
    return !theValue && (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.hXl)(theValue) ? defaultValue : (0, 
    _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.Lmq)(theValue) ? theValue : "true" === (0, 
    _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.oJg)(theValue)[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.OL]();
   }
   function cfgDfMerge(defaultValue) {
    return {
     mrg: !0,
     v: defaultValue
    };
   }
   function cfgDfValidate(validator, defaultValue, fallBackName) {
    return {
     fb: fallBackName,
     isVal: validator,
     v: defaultValue
    };
   }
   function cfgDfBoolean(defaultValue, fallBackName) {
    return {
     fb: fallBackName,
     set: _stringToBoolOrDefault,
     v: !!defaultValue
    };
   }
  },
  60991: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    q: () => _applyDefaultValue
   });
   var _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(269), _DynamicConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6182);
   function _isConfigDefaults(value) {
    return value && (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.Gvm)(value) && (value.isVal || value.fb || (0, 
    _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.KhI)(value, "v") || (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.KhI)(value, "mrg") || (0, 
    _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.KhI)(value, "ref") || value.set);
   }
   function _getDefault(dynamicHandler, theConfig, cfgDefaults) {
    var defValue, isDefaultValid = cfgDefaults.dfVal || _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.O9V;
    if (theConfig && cfgDefaults.fb) {
     var fallbacks = cfgDefaults.fb;
     (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.cyL)(fallbacks) || (fallbacks = [ fallbacks ]);
     for (var lp = 0; lp < fallbacks[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.oI]; lp++) {
      var fallback = fallbacks[lp], fbValue = theConfig[fallback];
      if (isDefaultValid(fbValue) ? defValue = fbValue : dynamicHandler && (isDefaultValid(fbValue = dynamicHandler.cfg[fallback]) && (defValue = fbValue), 
      dynamicHandler.set(dynamicHandler.cfg, (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.oJg)(fallback), fbValue)), 
      isDefaultValid(defValue)) break;
     }
    }
    return !isDefaultValid(defValue) && isDefaultValid(cfgDefaults.v) && (defValue = cfgDefaults.v), 
    defValue;
   }
   function _resolveDefaultValue(dynamicHandler, theConfig, cfgDefaults) {
    var newValue_1, theValue = cfgDefaults;
    (cfgDefaults && _isConfigDefaults(cfgDefaults) && (theValue = _getDefault(dynamicHandler, theConfig, cfgDefaults)), 
    theValue) && (_isConfigDefaults(theValue) && (theValue = _resolveDefaultValue(dynamicHandler, theConfig, theValue)), 
    (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.cyL)(theValue) ? (newValue_1 = [])[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.oI] = theValue[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.oI] : (0, 
    _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.QdQ)(theValue) && (newValue_1 = {}), 
    newValue_1 && ((0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.zav)(theValue, (function(key, value) {
     value && _isConfigDefaults(value) && (value = _resolveDefaultValue(dynamicHandler, theConfig, value)), 
     newValue_1[key] = value;
    })), theValue = newValue_1));
    return theValue;
   }
   function _applyDefaultValue(dynamicHandler, theConfig, name, defaultValue) {
    var isValid, setFn, defValue, mergeDf, reference, readOnly, blkDynamicValue, theValue, cfgDefaults = defaultValue;
    _isConfigDefaults(cfgDefaults) ? (isValid = cfgDefaults.isVal, setFn = cfgDefaults.set, 
    readOnly = cfgDefaults[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.XW], blkDynamicValue = cfgDefaults[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.JQ], 
    mergeDf = cfgDefaults.mrg, !(reference = cfgDefaults.ref) && (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.b07)(reference) && (reference = !!mergeDf), 
    defValue = _getDefault(dynamicHandler, theConfig, cfgDefaults)) : defValue = defaultValue, 
    blkDynamicValue && dynamicHandler[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.JQ](theConfig, name);
    var usingDefault = !0, cfgValue = theConfig[name];
    !cfgValue && (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.hXl)(cfgValue) || (theValue = cfgValue, 
    usingDefault = !1, isValid && theValue !== defValue && !isValid(theValue) && (theValue = defValue, 
    usingDefault = !0), setFn && (usingDefault = (theValue = setFn(theValue, defValue, theConfig)) === defValue)), 
    usingDefault ? theValue = defValue ? _resolveDefaultValue(dynamicHandler, theConfig, defValue) : defValue : ((0, 
    _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.QdQ)(theValue) || (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.cyL)(defValue)) && mergeDf && defValue && ((0, 
    _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.QdQ)(defValue) || (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.cyL)(defValue)) && (0, 
    _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.zav)(defValue, (function(dfName, dfValue) {
     _applyDefaultValue(dynamicHandler, theValue, dfName, dfValue);
    })), dynamicHandler.set(theConfig, name, theValue), reference && dynamicHandler.ref(theConfig, name), 
    readOnly && dynamicHandler[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.XW](theConfig, name);
   }
  },
  19749: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    e: () => createDynamicConfig,
    a: () => onConfigChange
   });
   var aggregationErrorType, ts_utils = __webpack_require__(269), DataCacheHelper = __webpack_require__(24276), InternalConstants = __webpack_require__(96492), _DynamicConstants = __webpack_require__(6182), ConfigDefaults = __webpack_require__(60991), DynamicSupport = __webpack_require__(99147), arrayMethodsToPatch = [ "push", "pop", "shift", "unshift", "splice" ], _throwDynamicError = function(logger, name, desc, e) {
    logger && logger[_DynamicConstants.ih](3, 108, "".concat(desc, " [").concat(name, "] failed - ") + (0, 
    ts_utils.mmD)(e));
   };
   function _getOwnPropGetter(target, name) {
    var propDesc = (0, ts_utils.kgX)(target, name);
    return propDesc && propDesc.get;
   }
   function _setDynamicProperty(state, target, name, value) {
    if (target) {
     var getter = _getOwnPropGetter(target, name);
     getter && !!getter[state.prop] ? target[name] = value : function(state, theConfig, name, value) {
      var detail = {
       n: name,
       h: [],
       trk: function(handler) {
        handler && handler.fn && (-1 === (0, ts_utils.rDm)(detail.h, handler) && detail.h[_DynamicConstants.y5](handler), 
        state.trk(handler, detail));
       },
       clr: function(handler) {
        var idx = (0, ts_utils.rDm)(detail.h, handler);
        -1 !== idx && detail.h[_DynamicConstants.Ic](idx, 1);
       }
      }, checkDynamic = !0, isObjectOrArray = !1;
      function _getProperty() {
       checkDynamic && (isObjectOrArray = isObjectOrArray || (0, DynamicSupport.hF)(_getProperty, state, value), 
       value && !value[DynamicSupport.nM] && isObjectOrArray && (value = _makeDynamicObject(state, value, name, "Converting")), 
       checkDynamic = !1);
       var activeHandler = state.act;
       return activeHandler && detail.trk(activeHandler), value;
      }
      _getProperty[state.prop] = {
       chng: function() {
        state.add(detail);
       }
      }, (0, ts_utils.vF1)(theConfig, detail.n, {
       g: _getProperty,
       s: function(newValue) {
        if (value !== newValue) {
         _getProperty[state.ro] && !state.upd && (0, DynamicSupport.If)("[" + name + "] is read-only:" + (0, 
         ts_utils.mmD)(theConfig)), checkDynamic && (isObjectOrArray = isObjectOrArray || (0, 
         DynamicSupport.hF)(_getProperty, state, value), checkDynamic = !1);
         var isReferenced = isObjectOrArray && _getProperty[state.rf];
         if (isObjectOrArray) if (isReferenced) {
          (0, ts_utils.zav)(value, (function(key) {
           value[key] = newValue ? newValue[key] : InternalConstants.HP;
          }));
          try {
           (0, ts_utils.zav)(newValue, (function(key, theValue) {
            _setDynamicProperty(state, value, key, theValue);
           })), newValue = value;
          } catch (e) {
           _throwDynamicError((state.hdlr || {})[_DynamicConstants.Uw], name, "Assigning", e), 
           isObjectOrArray = !1;
          }
         } else value && value[DynamicSupport.nM] && (0, ts_utils.zav)(value, (function(key) {
          var getter = _getOwnPropGetter(value, key);
          if (getter) {
           var valueState = getter[state.prop];
           valueState && valueState.chng();
          }
         }));
         if (newValue !== value) {
          var newIsObjectOrArray = newValue && (0, DynamicSupport.hF)(_getProperty, state, newValue);
          !isReferenced && newIsObjectOrArray && (newValue = _makeDynamicObject(state, newValue, name, "Converting")), 
          value = newValue, isObjectOrArray = newIsObjectOrArray;
         }
         state.add(detail);
        }
       }
      });
     }(state, target, name, value);
    }
    return target;
   }
   function _setDynamicPropertyState(state, target, name, flags) {
    if (target) {
     var getter = _getOwnPropGetter(target, name), isDynamic = getter && !!getter[state.prop], inPlace = flags && flags[0], rdOnly = flags && flags[1], blkProp = flags && flags[2];
     if (!isDynamic) {
      if (blkProp) try {
       (0, DynamicSupport.V9)(target);
      } catch (e) {
       _throwDynamicError((state.hdlr || {})[_DynamicConstants.Uw], name, "Blocking", e);
      }
      try {
       _setDynamicProperty(state, target, name, target[name]), getter = _getOwnPropGetter(target, name);
      } catch (e) {
       _throwDynamicError((state.hdlr || {})[_DynamicConstants.Uw], name, "State", e);
      }
     }
     inPlace && (getter[state.rf] = inPlace), rdOnly && (getter[state.ro] = rdOnly), 
     blkProp && (getter[state.blkVal] = !0);
    }
    return target;
   }
   function _makeDynamicObject(state, target, name, desc) {
    try {
     (0, ts_utils.zav)(target, (function(key, value) {
      _setDynamicProperty(state, target, key, value);
     })), target[DynamicSupport.nM] || ((0, ts_utils.UxO)(target, DynamicSupport.nM, {
      get: function() {
       return state[_DynamicConstants.K0];
      }
     }), function(state, target, name) {
      (0, ts_utils.cyL)(target) && (0, ts_utils.Iuo)(arrayMethodsToPatch, (function(method) {
       var orgMethod = target[method];
       target[method] = function() {
        for (var args = [], _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
        var result = orgMethod[_DynamicConstants.y9](this, args);
        return _makeDynamicObject(state, target, name, "Patching"), result;
       };
      }));
     }(state, target, name));
    } catch (e) {
     _throwDynamicError((state.hdlr || {})[_DynamicConstants.Uw], name, desc, e);
    }
    return target;
   }
   var symPrefix = "[[ai_", symPostfix = "]]";
   function _createState(cfgHandler) {
    var _a, theState, dynamicPropertySymbol = (0, ts_utils.jjc)(symPrefix + "get" + cfgHandler.uid + symPostfix), dynamicPropertyReadOnly = (0, 
    ts_utils.jjc)(symPrefix + "ro" + cfgHandler.uid + symPostfix), dynamicPropertyReferenced = (0, 
    ts_utils.jjc)(symPrefix + "rf" + cfgHandler.uid + symPostfix), dynamicPropertyBlockValue = (0, 
    ts_utils.jjc)(symPrefix + "blkVal" + cfgHandler.uid + symPostfix), dynamicPropertyDetail = (0, 
    ts_utils.jjc)(symPrefix + "dtl" + cfgHandler.uid + symPostfix), _waitingHandlers = null, _watcherTimer = null;
    function _useHandler(activeHandler, callback) {
     var prevWatcher = theState.act;
     try {
      theState.act = activeHandler, activeHandler && activeHandler[dynamicPropertyDetail] && ((0, 
      ts_utils.Iuo)(activeHandler[dynamicPropertyDetail], (function(detail) {
       detail.clr(activeHandler);
      })), activeHandler[dynamicPropertyDetail] = []), callback({
       cfg: cfgHandler.cfg,
       set: cfgHandler.set.bind(cfgHandler),
       setDf: cfgHandler[_DynamicConstants.h0].bind(cfgHandler),
       ref: cfgHandler.ref.bind(cfgHandler),
       rdOnly: cfgHandler[_DynamicConstants.XW].bind(cfgHandler)
      });
     } catch (e) {
      var logger = cfgHandler[_DynamicConstants.Uw];
      throw logger && logger[_DynamicConstants.ih](1, 107, (0, ts_utils.mmD)(e)), e;
     } finally {
      theState.act = prevWatcher || null;
     }
    }
    function _notifyWatchers() {
     if (_waitingHandlers) {
      var notifyHandlers = _waitingHandlers;
      _waitingHandlers = null, _watcherTimer && _watcherTimer[_DynamicConstants._w](), 
      _watcherTimer = null;
      var watcherFailures_1 = [];
      if ((0, ts_utils.Iuo)(notifyHandlers, (function(handler) {
       if (handler && (handler[dynamicPropertyDetail] && ((0, ts_utils.Iuo)(handler[dynamicPropertyDetail], (function(detail) {
        detail.clr(handler);
       })), handler[dynamicPropertyDetail] = null), handler.fn)) try {
        _useHandler(handler, handler.fn);
       } catch (e) {
        watcherFailures_1[_DynamicConstants.y5](e);
       }
      })), _waitingHandlers) try {
       _notifyWatchers();
      } catch (e) {
       watcherFailures_1[_DynamicConstants.y5](e);
      }
      watcherFailures_1[_DynamicConstants.oI] > 0 && function(message, sourceErrors) {
       aggregationErrorType || (aggregationErrorType = (0, ts_utils.aqQ)("AggregationError", (function(self, args) {
        args[_DynamicConstants.oI] > 1 && (self.errors = args[1]);
       })));
       var theMessage = message || "One or more errors occurred.";
       throw (0, ts_utils.Iuo)(sourceErrors, (function(srcError, idx) {
        theMessage += "\n".concat(idx, " > ").concat((0, ts_utils.mmD)(srcError));
       })), new aggregationErrorType(theMessage, sourceErrors || []);
      }("Watcher error(s): ", watcherFailures_1);
     }
    }
    return (_a = {
     prop: dynamicPropertySymbol,
     ro: dynamicPropertyReadOnly,
     rf: dynamicPropertyReferenced
    })[_DynamicConstants.JQ] = dynamicPropertyBlockValue, _a[_DynamicConstants.K0] = cfgHandler, 
    _a.add = function(detail) {
     if (detail && detail.h[_DynamicConstants.oI] > 0) {
      _waitingHandlers || (_waitingHandlers = []), _watcherTimer || (_watcherTimer = (0, 
      ts_utils.dRz)((function() {
       _watcherTimer = null, _notifyWatchers();
      }), 0));
      for (var idx = 0; idx < detail.h[_DynamicConstants.oI]; idx++) {
       var handler = detail.h[idx];
       handler && -1 === (0, ts_utils.rDm)(_waitingHandlers, handler) && _waitingHandlers[_DynamicConstants.y5](handler);
      }
     }
    }, _a[_DynamicConstants.zs] = _notifyWatchers, _a.use = _useHandler, _a.trk = function(handler, detail) {
     if (handler) {
      var details = handler[dynamicPropertyDetail] = handler[dynamicPropertyDetail] || [];
      -1 === (0, ts_utils.rDm)(details, detail) && details[_DynamicConstants.y5](detail);
     }
    }, theState = _a;
   }
   function _createDynamicHandler(logger, target, inPlace) {
    var _a, dynamicHandler = (0, DynamicSupport.QA)(target);
    if (dynamicHandler) return dynamicHandler;
    var theState, uid = (0, DataCacheHelper.Z)("dyncfg", !0), newTarget = target && !1 !== inPlace ? target : (0, 
    DynamicSupport.Dy)(target);
    var cfgHandler = ((_a = {
     uid: null,
     cfg: newTarget
    })[_DynamicConstants.Uw] = logger, _a[_DynamicConstants.zs] = function() {
     theState[_DynamicConstants.zs]();
    }, _a.set = function(target, name, value) {
     try {
      target = _setDynamicProperty(theState, target, name, value);
     } catch (e) {
      _throwDynamicError(logger, name, "Setting value", e);
     }
     return target[name];
    }, _a[_DynamicConstants.h0] = function(theConfig, defaultValues) {
     return defaultValues && (0, ts_utils.zav)(defaultValues, (function(name, value) {
      (0, ConfigDefaults.q)(cfgHandler, theConfig, name, value);
     })), theConfig;
    }, _a[_DynamicConstants.x6] = function(configHandler) {
     return function(state, configHandler) {
      var handler = {
       fn: configHandler,
       rm: function() {
        handler.fn = null, state = null, configHandler = null;
       }
      };
      return (0, ts_utils.vF1)(handler, "toJSON", {
       v: function() {
        return "WatcherHandler" + (handler.fn ? "" : "[X]");
       }
      }), state.use(handler, configHandler), handler;
     }(theState, configHandler);
    }, _a.ref = function(target, name) {
     var _a;
     return _setDynamicPropertyState(theState, target, name, (_a = {}, _a[0] = !0, _a))[name];
    }, _a[_DynamicConstants.XW] = function(target, name) {
     var _a;
     return _setDynamicPropertyState(theState, target, name, (_a = {}, _a[1] = !0, _a))[name];
    }, _a[_DynamicConstants.JQ] = function(target, name) {
     var _a;
     return _setDynamicPropertyState(theState, target, name, (_a = {}, _a[2] = !0, _a))[name];
    }, _a._block = function(configHandler, allowUpdate) {
     theState.use(null, (function(details) {
      var prevUpd = theState.upd;
      try {
       (0, ts_utils.b07)(allowUpdate) || (theState.upd = allowUpdate), configHandler(details);
      } finally {
       theState.upd = prevUpd;
      }
     }));
    }, _a);
    return (0, ts_utils.vF1)(cfgHandler, "uid", {
     c: !1,
     e: !1,
     w: !1,
     v: uid
    }), _makeDynamicObject(theState = _createState(cfgHandler), newTarget, "config", "Creating"), 
    cfgHandler;
   }
   function createDynamicConfig(config, defaultConfig, logger, inPlace) {
    var dynamicHandler = _createDynamicHandler(logger, config || {}, inPlace);
    return defaultConfig && dynamicHandler[_DynamicConstants.h0](dynamicHandler.cfg, defaultConfig), 
    dynamicHandler;
   }
   function onConfigChange(config, configHandler, logger) {
    var handler = config[DynamicSupport.nM] || config;
    return !handler.cfg || handler.cfg !== config && handler.cfg[DynamicSupport.nM] !== handler ? (function(logger, message) {
     logger ? (logger[_DynamicConstants.on](message), logger[_DynamicConstants.ih](2, 108, message)) : (0, 
     DynamicSupport.If)(message);
    }(logger, InternalConstants.xW + (0, ts_utils.mmD)(config)), createDynamicConfig(config, null, logger)[_DynamicConstants.x6](configHandler)) : handler[_DynamicConstants.x6](configHandler);
   }
  },
  99147: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    Dy: () => _cfgDeepCopy,
    Hf: () => forceDynamicConversion,
    If: () => throwInvalidAccess,
    QA: () => getDynamicConfigHandler,
    V9: () => blockDynamicConversion,
    hF: () => _canMakeDynamic,
    nM: () => CFG_HANDLER_LINK
   });
   var _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(269), _DynamicConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6182), CFG_HANDLER_LINK = (0, 
   _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.eCG)("[[ai_dynCfg_1]]"), BLOCK_DYNAMIC = (0, 
   _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.eCG)("[[ai_blkDynCfg_1]]"), FORCE_DYNAMIC = (0, 
   _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.eCG)("[[ai_frcDynCfg_1]]");
   function _cfgDeepCopy(source) {
    var target_1;
    if (source && ((0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.cyL)(source) ? (target_1 = [])[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.oI] = source[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.oI] : (0, 
    _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.QdQ)(source) && (target_1 = {}), 
    target_1)) return (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.zav)(source, (function(key, value) {
     target_1[key] = _cfgDeepCopy(value);
    })), target_1;
    return source;
   }
   function getDynamicConfigHandler(value) {
    if (value) {
     var handler = value[CFG_HANDLER_LINK] || value;
     if (handler.cfg && (handler.cfg === value || handler.cfg[CFG_HANDLER_LINK] === handler)) return handler;
    }
    return null;
   }
   function blockDynamicConversion(value) {
    if (value && ((0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.QdQ)(value) || (0, 
    _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.cyL)(value))) try {
     value[BLOCK_DYNAMIC] = !0;
    } catch (e) {}
    return value;
   }
   function forceDynamicConversion(value) {
    if (value) try {
     value[FORCE_DYNAMIC] = !0;
    } catch (e) {}
    return value;
   }
   function _canMakeDynamic(getFunc, state, value) {
    var result = !1;
    return value && !getFunc[state.blkVal] && ((result = value[FORCE_DYNAMIC]) || value[BLOCK_DYNAMIC] || (result = (0, 
    _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.QdQ)(value) || (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.cyL)(value))), 
    result;
   }
   function throwInvalidAccess(message) {
    (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.zkd)("InvalidAccess:" + message);
   }
  },
  84282: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    H: () => createEnumStyle,
    o: () => createValueMap
   });
   var _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(269), createEnumStyle = _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.WSA, createValueMap = _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.fn0;
  },
  13662: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    x: () => EventsDiscardedReason
   });
   var _JavaScriptSDK_Enums_EnumHelperFuncs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(84282), EventsDiscardedReason = (0, 
   _JavaScriptSDK_Enums_EnumHelperFuncs__WEBPACK_IMPORTED_MODULE_0__.H)({
    Unknown: 0,
    NonRetryableStatus: 1,
    InvalidEvent: 2,
    SizeLimitExceeded: 3,
    KillSwitch: 4,
    QueueFull: 5
   });
   (0, _JavaScriptSDK_Enums_EnumHelperFuncs__WEBPACK_IMPORTED_MODULE_0__.H)({
    Unknown: 0,
    NonRetryableStatus: 1,
    CleanStorage: 2,
    MaxInStorageTimeExceeded: 3
   });
  },
  54875: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    f: () => ActiveStatus
   });
   var ActiveStatus = (0, __webpack_require__(84282).H)({
    NONE: 0,
    PENDING: 3,
    INACTIVE: 1,
    ACTIVE: 2
   });
  },
  82774: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    _: () => AppInsightsCore
   });
   var TsLibShims = __webpack_require__(10659), DynamicProto = __webpack_require__(68279), ts_async = __webpack_require__(8205), ts_utils = __webpack_require__(269), DynamicConfig = __webpack_require__(19749), InitActiveStatusEnum = __webpack_require__(54875), _DynamicConstants = __webpack_require__(6182), AsyncUtils = __webpack_require__(34013), Constants = __webpack_require__(27847), CookieMgr = __webpack_require__(25034), DataCacheHelper = __webpack_require__(24276), DbgExtensionUtils = __webpack_require__(27867), DiagnosticLogger = __webpack_require__(23775), HelperFuncs = __webpack_require__(13673), InternalConstants = __webpack_require__(96492), NotificationManager = __webpack_require__(51356), PerfManager = __webpack_require__(28156), ProcessTelemetryContext = __webpack_require__(72317), TelemetryHelpers = __webpack_require__(90380);
   var _a, TelemetryInitializerPlugin = function(_super) {
    function TelemetryInitializerPlugin() {
     var _id, _initializers, _this = _super.call(this) || this;
     function _initDefaults() {
      _id = 0, _initializers = [];
     }
     return _this.identifier = "TelemetryInitializerPlugin", _this.priority = 199, _initDefaults(), 
     (0, DynamicProto.A)(TelemetryInitializerPlugin, _this, (function(_self, _base) {
      _self.addTelemetryInitializer = function(telemetryInitializer) {
       return function(_initializers, id, telemetryInitializer) {
        var theInitializer = {
         id,
         fn: telemetryInitializer
        };
        return (0, ts_utils.Yny)(_initializers, theInitializer), {
         remove: function() {
          (0, ts_utils.Iuo)(_initializers, (function(initializer, idx) {
           if (initializer.id === theInitializer.id) return _initializers[_DynamicConstants.Ic](idx, 1), 
           -1;
          }));
         }
        };
       }(_initializers, _id++, telemetryInitializer);
      }, _self[InternalConstants.qT] = function(item, itemCtx) {
       (function(_initializers, item, logger) {
        for (var doNotSendItem = !1, telemetryInitializersCount = _initializers[_DynamicConstants.oI], i = 0; i < telemetryInitializersCount; ++i) {
         var telemetryInitializer = _initializers[i];
         if (telemetryInitializer) try {
          if (!1 === telemetryInitializer.fn[_DynamicConstants.y9](null, [ item ])) {
           doNotSendItem = !0;
           break;
          }
         } catch (e) {
          (0, DiagnosticLogger.ZP)(logger, 2, 64, "Telemetry initializer failed: " + (0, HelperFuncs.lL)(e), {
           exception: (0, ts_utils.mmD)(e)
          }, !0);
         }
        }
        return !doNotSendItem;
       })(_initializers, item, itemCtx ? itemCtx[_DynamicConstants.e4]() : _self[_DynamicConstants.e4]()) && _self[_DynamicConstants.$5](item, itemCtx);
      }, _self[_DynamicConstants.tn] = function() {
       _initDefaults();
      };
     })), _this;
    }
    return (0, TsLibShims.qU)(TelemetryInitializerPlugin, _super), TelemetryInitializerPlugin.__ieDyn = 1, 
    TelemetryInitializerPlugin;
   }(__webpack_require__(98257).s), UnloadHandlerContainer = __webpack_require__(60836), UnloadHookContainer = __webpack_require__(98969), defaultConfig = (0, 
   ts_utils.ZHX)(((_a = {
    cookieCfg: {}
   })[InternalConstants.jy] = {
    rdOnly: !0,
    ref: !0,
    v: []
   }, _a[InternalConstants.LZ] = {
    rdOnly: !0,
    ref: !0,
    v: []
   }, _a[InternalConstants.Bw] = {
    ref: !0,
    v: {}
   }, _a[InternalConstants.Yd] = InternalConstants.HP, _a.loggingLevelConsole = 0, 
   _a.diagnosticLogInterval = InternalConstants.HP, _a));
   function _createPerfManager(core, notificationMgr) {
    return new PerfManager.NS(notificationMgr);
   }
   function _isPluginPresent(thePlugin, plugins) {
    var exists = !1;
    return (0, ts_utils.Iuo)(plugins, (function(plugin) {
     if (plugin === thePlugin) return exists = !0, -1;
    })), exists;
   }
   function _deepMergeConfig(details, target, newValues, merge) {
    newValues && (0, ts_utils.zav)(newValues, (function(key, value) {
     merge && (0, ts_utils.QdQ)(value) && (0, ts_utils.QdQ)(target[key]) && _deepMergeConfig(details, target[key], value, merge), 
     merge && (0, ts_utils.QdQ)(value) && (0, ts_utils.QdQ)(target[key]) ? _deepMergeConfig(details, target[key], value, merge) : details.set(target, key, value);
    }));
   }
   function _findWatcher(listeners, newWatcher) {
    var theListener = null, idx = -1;
    return (0, ts_utils.Iuo)(listeners, (function(listener, lp) {
     if (listener.w === newWatcher) return theListener = listener, idx = lp, -1;
    })), {
     i: idx,
     l: theListener
    };
   }
   var AppInsightsCore = function() {
    function AppInsightsCore() {
     var _configHandler, _isInitialized, _logger, _eventQueue, _notificationManager, _perfManager, _cfgPerfManager, _cookieManager, _pluginChain, _configExtensions, _channelConfig, _channels, _isUnloading, _telemetryInitializerPlugin, _internalLogsEventName, _evtNamespace, _unloadHandlers, _hookContainer, _debugListener, _traceCtx, _instrumentationKey, _cfgListeners, _extensions, _pluginVersionStringArr, _pluginVersionString, _activeStatus, _endpoint, _initInMemoMaxSize, _isStatusSet, _internalLogPoller, _internalLogPollerListening, _forceStopInternalLogPoller;
     (0, DynamicProto.A)(AppInsightsCore, this, (function(_self) {
      function _setStatus() {
       _isStatusSet = !0, (0, ts_utils.hXl)(_instrumentationKey) ? (_activeStatus = InitActiveStatusEnum.f[_DynamicConstants.Yq], 
       (0, DiagnosticLogger.ZP)(_logger, 1, 112, "ikey can't be resolved from promises")) : _activeStatus = InitActiveStatusEnum.f.ACTIVE, 
       _releaseQueues();
      }
      function _releaseQueues() {
       _isInitialized && (_self.releaseQueue(), _self[_DynamicConstants.h4]());
      }
      function _startLogPoller(alwaysStart) {
       _internalLogPoller && _internalLogPoller[_DynamicConstants.XM] || _forceStopInternalLogPoller || (alwaysStart || _logger && _logger.queue[_DynamicConstants.oI] > 0) && (_internalLogPollerListening || (_internalLogPollerListening = !0, 
       _addUnloadHook(_configHandler[_DynamicConstants.x6]((function(details) {
        var interval = details.cfg.diagnosticLogInterval;
        interval && interval > 0 || (interval = 1e4);
        var isRunning = !1;
        _internalLogPoller && (isRunning = _internalLogPoller[_DynamicConstants.XM], _internalLogPoller[_DynamicConstants._w]()), 
        (_internalLogPoller = (0, ts_utils.AHH)(_flushInternalLogs, interval)).unref(), 
        _internalLogPoller[_DynamicConstants.XM] = isRunning;
       })))), _internalLogPoller[_DynamicConstants.XM] = !0);
       return _internalLogPoller;
      }
      function _setPluginVersions() {
       var thePlugins = {};
       _pluginVersionStringArr = [];
       var _addPluginVersions = function(plugins) {
        plugins && (0, ts_utils.Iuo)(plugins, (function(plugin) {
         if (plugin[_DynamicConstants.Ju] && plugin[_DynamicConstants.s] && !thePlugins[plugin.identifier]) {
          var ver = plugin[_DynamicConstants.Ju] + "=" + plugin[_DynamicConstants.s];
          _pluginVersionStringArr[_DynamicConstants.y5](ver), thePlugins[plugin.identifier] = plugin;
         }
        }));
       };
       _addPluginVersions(_channels), _channelConfig && (0, ts_utils.Iuo)(_channelConfig, (function(channels) {
        _addPluginVersions(channels);
       })), _addPluginVersions(_configExtensions);
      }
      function _initDefaults() {
       _isInitialized = !1, (_configHandler = (0, DynamicConfig.e)({}, defaultConfig, _self[_DynamicConstants.Uw])).cfg[_DynamicConstants.Bl] = 1, 
       (0, ts_utils.vF1)(_self, "config", {
        g: function() {
         return _configHandler.cfg;
        },
        s: function(newValue) {
         _self.updateCfg(newValue, !1);
        }
       }), (0, ts_utils.vF1)(_self, "pluginVersionStringArr", {
        g: function() {
         return _pluginVersionStringArr || _setPluginVersions(), _pluginVersionStringArr;
        }
       }), (0, ts_utils.vF1)(_self, "pluginVersionString", {
        g: function() {
         return _pluginVersionString || (_pluginVersionStringArr || _setPluginVersions(), 
         _pluginVersionString = _pluginVersionStringArr.join(";")), _pluginVersionString || InternalConstants.m5;
        }
       }), (0, ts_utils.vF1)(_self, "logger", {
        g: function() {
         return _logger || (_logger = new DiagnosticLogger.wq(_configHandler.cfg), _configHandler[_DynamicConstants.Uw] = _logger), 
         _logger;
        },
        s: function(newLogger) {
         _configHandler[_DynamicConstants.Uw] = newLogger, _logger !== newLogger && ((0, 
         AsyncUtils.K)(_logger, !1), _logger = newLogger);
        }
       }), _self[_DynamicConstants.Uw] = new DiagnosticLogger.wq(_configHandler.cfg), _extensions = [];
       var cfgExtensions = _self.config[InternalConstants.jy] || [];
       cfgExtensions.splice(0, cfgExtensions[_DynamicConstants.oI]), (0, ts_utils.Yny)(cfgExtensions, _extensions), 
       _telemetryInitializerPlugin = new TelemetryInitializerPlugin, _eventQueue = [], 
       (0, AsyncUtils.K)(_notificationManager, !1), _notificationManager = null, _perfManager = null, 
       _cfgPerfManager = null, (0, AsyncUtils.K)(_cookieManager, !1), _cookieManager = null, 
       _pluginChain = null, _configExtensions = [], _channelConfig = null, _channels = null, 
       _isUnloading = !1, _internalLogsEventName = null, _evtNamespace = (0, DataCacheHelper.Z)("AIBaseCore", !0), 
       _unloadHandlers = (0, UnloadHandlerContainer.P)(), _traceCtx = null, _instrumentationKey = null, 
       _hookContainer = (0, UnloadHookContainer.w)(), _cfgListeners = [], _pluginVersionString = null, 
       _pluginVersionStringArr = null, _forceStopInternalLogPoller = !1, _internalLogPoller = null, 
       _internalLogPollerListening = !1, _activeStatus = 0, _endpoint = null, _initInMemoMaxSize = null, 
       _isStatusSet = !1;
      }
      function _createTelCtx() {
       var theCtx = (0, ProcessTelemetryContext.i8)(_getPluginChain(), _configHandler.cfg, _self);
       return theCtx[_DynamicConstants.by](_startLogPoller), theCtx;
      }
      function _initPluginChain(updateState) {
       var theExtensions = function(logger, channelPriority, allExtensions) {
        var _a, coreExtensions = [], channels = [], extPriorities = {};
        return (0, ts_utils.Iuo)(allExtensions, (function(ext) {
         ((0, ts_utils.hXl)(ext) || (0, ts_utils.hXl)(ext[_DynamicConstants.mE])) && (0, 
         ts_utils.$8)("Plugins must provide initialize method");
         var extPriority = ext[InternalConstants.Vo], identifier = ext[_DynamicConstants.Ju];
         ext && extPriority && ((0, ts_utils.hXl)(extPriorities[extPriority]) ? extPriorities[extPriority] = identifier : (0, 
         DiagnosticLogger.OG)(logger, "Two extensions have same priority #" + extPriority + " - " + extPriorities[extPriority] + ", " + identifier)), 
         !extPriority || extPriority < channelPriority ? coreExtensions[_DynamicConstants.y5](ext) : channels[_DynamicConstants.y5](ext);
        })), (_a = {})[InternalConstants.eT] = coreExtensions, _a[InternalConstants.LZ] = channels, 
        _a;
       }(_self[_DynamicConstants.Uw], Constants.i, _configExtensions);
       _pluginChain = null, _pluginVersionString = null, _pluginVersionStringArr = null, 
       _channels = (_channelConfig || [])[0] || [], _channels = (0, TelemetryHelpers.Xc)((0, 
       ts_utils.Yny)(_channels, theExtensions[InternalConstants.LZ]));
       var allExtensions = (0, ts_utils.Yny)((0, TelemetryHelpers.Xc)(theExtensions[InternalConstants.eT]), _channels);
       _extensions = (0, ts_utils.N6t)(allExtensions);
       var cfgExtensions = _self.config[InternalConstants.jy] || [];
       cfgExtensions.splice(0, cfgExtensions[_DynamicConstants.oI]), (0, ts_utils.Yny)(cfgExtensions, _extensions);
       var rootCtx = _createTelCtx();
       _channels && _channels[_DynamicConstants.oI] > 0 && (0, TelemetryHelpers.pI)(rootCtx[_DynamicConstants.$o](_channels), allExtensions), 
       (0, TelemetryHelpers.pI)(rootCtx, allExtensions), updateState && _doUpdate(updateState);
      }
      function _getPlugin(pluginIdentifier) {
       var theExt = null, thePlugin = null, channelHosts = [];
       return (0, ts_utils.Iuo)(_extensions, (function(ext) {
        if (ext[_DynamicConstants.Ju] === pluginIdentifier && ext !== _telemetryInitializerPlugin) return thePlugin = ext, 
        -1;
        ext.getChannel && channelHosts[_DynamicConstants.y5](ext);
       })), !thePlugin && channelHosts[_DynamicConstants.oI] > 0 && (0, ts_utils.Iuo)(channelHosts, (function(host) {
        if (!(thePlugin = host.getChannel(pluginIdentifier))) return -1;
       })), thePlugin && (theExt = {
        plugin: thePlugin,
        setEnabled: function(enabled) {
         (0, TelemetryHelpers.Cr)(thePlugin)[InternalConstants.Hr] = !enabled;
        },
        isEnabled: function() {
         var pluginState = (0, TelemetryHelpers.Cr)(thePlugin);
         return !pluginState[_DynamicConstants.Ik] && !pluginState[InternalConstants.Hr];
        },
        remove: function(isAsync, removeCb) {
         var _a;
         void 0 === isAsync && (isAsync = !0);
         var pluginsToRemove = [ thePlugin ], unloadState = ((_a = {
          reason: 1
         })[_DynamicConstants.tI] = isAsync, _a);
         _removePlugins(pluginsToRemove, unloadState, (function(removed) {
          removed && _initPluginChain({
           reason: 32,
           removed: pluginsToRemove
          }), removeCb && removeCb(removed);
         }));
        }
       }), theExt;
      }
      function _getPluginChain() {
       if (!_pluginChain) {
        var extensions = (_extensions || []).slice();
        -1 === (0, ts_utils.rDm)(extensions, _telemetryInitializerPlugin) && extensions[_DynamicConstants.y5](_telemetryInitializerPlugin), 
        _pluginChain = (0, ProcessTelemetryContext.PV)((0, TelemetryHelpers.Xc)(extensions), _configHandler.cfg, _self);
       }
       return _pluginChain;
      }
      function _removePlugins(thePlugins, unloadState, removeComplete) {
       if (thePlugins && thePlugins[_DynamicConstants.oI] > 0) {
        var unloadChain = (0, ProcessTelemetryContext.PV)(thePlugins, _configHandler.cfg, _self), unloadCtx = (0, 
        ProcessTelemetryContext.tS)(unloadChain, _self);
        unloadCtx[_DynamicConstants.by]((function() {
         var removed = !1, newConfigExtensions = [];
         (0, ts_utils.Iuo)(_configExtensions, (function(plugin, idx) {
          _isPluginPresent(plugin, thePlugins) ? removed = !0 : newConfigExtensions[_DynamicConstants.y5](plugin);
         })), _configExtensions = newConfigExtensions, _pluginVersionString = null, _pluginVersionStringArr = null;
         var newChannelConfig = [];
         _channelConfig && ((0, ts_utils.Iuo)(_channelConfig, (function(queue, idx) {
          var newQueue = [];
          (0, ts_utils.Iuo)(queue, (function(channel) {
           _isPluginPresent(channel, thePlugins) ? removed = !0 : newQueue[_DynamicConstants.y5](channel);
          })), newChannelConfig[_DynamicConstants.y5](newQueue);
         })), _channelConfig = newChannelConfig), removeComplete && removeComplete(removed), 
         _startLogPoller();
        })), unloadCtx[_DynamicConstants.$5](unloadState);
       } else removeComplete(!1);
      }
      function _flushInternalLogs() {
       if (_logger && _logger.queue) {
        var queue = _logger.queue.slice(0);
        _logger.queue[_DynamicConstants.oI] = 0, (0, ts_utils.Iuo)(queue, (function(logMessage) {
         var _a, item = ((_a = {})[_DynamicConstants.RS] = _internalLogsEventName || "InternalMessageId: " + logMessage[_DynamicConstants.JR], 
         _a[_DynamicConstants.FI] = _instrumentationKey, _a[_DynamicConstants.fA] = (0, HelperFuncs._u)(new Date), 
         _a.baseType = DiagnosticLogger.WD.dataType, _a.baseData = {
          message: logMessage[_DynamicConstants.pM]
         }, _a);
         _self.track(item);
        }));
       }
      }
      function _flushChannels(isAsync, callBack, sendReason, cbTimeout) {
       var waiting = 1, doneIterating = !1, cbTimer = null;
       function doCallback() {
        waiting--, doneIterating && 0 === waiting && (cbTimer && cbTimer[_DynamicConstants._w](), 
        cbTimer = null, callBack && callBack(doneIterating), callBack = null);
       }
       (cbTimeout = cbTimeout || 5e3, _channels && _channels[_DynamicConstants.oI] > 0) && _createTelCtx()[_DynamicConstants.$o](_channels).iterate((function(plugin) {
        if (plugin.flush) {
         waiting++;
         var handled_1 = !1;
         plugin.flush(isAsync, (function() {
          handled_1 = !0, doCallback();
         }), sendReason) || handled_1 || (isAsync && null == cbTimer ? cbTimer = (0, ts_utils.dRz)((function() {
          cbTimer = null, doCallback();
         }), cbTimeout) : doCallback());
        }
       }));
       return doneIterating = !0, doCallback(), !0;
      }
      function _doUpdate(updateState) {
       var updateCtx = (0, ProcessTelemetryContext.nU)(_getPluginChain(), _self);
       updateCtx[_DynamicConstants.by](_startLogPoller), _self._updateHook && !0 === _self._updateHook(updateCtx, updateState) || updateCtx[_DynamicConstants.$5](updateState);
      }
      function _logOrThrowError(message) {
       var logger = _self[_DynamicConstants.Uw];
       logger ? ((0, DiagnosticLogger.ZP)(logger, 2, 73, message), _startLogPoller()) : (0, 
       ts_utils.$8)(message);
      }
      function _notifyInvalidEvent(telemetryItem) {
       var manager = _self[_DynamicConstants.RF]();
       manager && manager[InternalConstants.Yp]([ telemetryItem ], 2);
      }
      function _addUnloadHook(hooks) {
       _hookContainer.add(hooks);
      }
      _initDefaults(), _self._getDbgPlgTargets = function() {
       return [ _extensions, _eventQueue ];
      }, _self[_DynamicConstants.tZ] = function() {
       return _isInitialized;
      }, _self.activeStatus = function() {
       return _activeStatus;
      }, _self._setPendingStatus = function() {
       _activeStatus = 3;
      }, _self[_DynamicConstants.mE] = function(config, extensions, logger, notificationManager) {
       var prevCfgPerfMgr;
       _isUnloading && (0, ts_utils.$8)("SDK is still unloading..."), _self[_DynamicConstants.tZ]() && (0, 
       ts_utils.$8)("Core cannot be initialized more than once"), _configHandler = (0, 
       DynamicConfig.e)(config, defaultConfig, logger || _self[_DynamicConstants.Uw], !1), 
       config = _configHandler.cfg, _addUnloadHook(_configHandler[_DynamicConstants.x6]((function(details) {
        var rootCfg = details.cfg;
        if (!(3 === _activeStatus)) {
         _initInMemoMaxSize = rootCfg.initInMemoMaxSize || 100;
         var ikey = rootCfg[_DynamicConstants.sl], endpointUrl = rootCfg.endpointUrl;
         if ((0, ts_utils.hXl)(ikey)) {
          _instrumentationKey = null, _activeStatus = InitActiveStatusEnum.f[_DynamicConstants.Yq];
          var msg = "Please provide instrumentation key";
          _isInitialized ? ((0, DiagnosticLogger.ZP)(_logger, 1, 100, msg), _releaseQueues()) : (0, 
          ts_utils.$8)(msg);
         } else {
          var promises = [];
          if ((0, ts_utils.$XS)(ikey) ? (promises[_DynamicConstants.y5](ikey), _instrumentationKey = null) : _instrumentationKey = ikey, 
          (0, ts_utils.$XS)(endpointUrl) ? (promises[_DynamicConstants.y5](endpointUrl), _endpoint = null) : _endpoint = endpointUrl, 
          promises[_DynamicConstants.oI]) {
           _isStatusSet = !1, _activeStatus = 3;
           var initTimeout = (0, HelperFuncs.Gh)(rootCfg.initTimeOut) ? rootCfg.initTimeOut : 5e4, allPromises = (0, 
           ts_async.lh)(promises);
           (0, ts_utils.dRz)((function() {
            _isStatusSet || _setStatus();
           }), initTimeout), (0, ts_async.Dv)(allPromises, (function(response) {
            try {
             if (_isStatusSet) return;
             if (!response.rejected) {
              var values = response[_DynamicConstants.pF];
              if (values && values[_DynamicConstants.oI]) {
               var ikeyRes = values[0];
               if (_instrumentationKey = ikeyRes && ikeyRes[_DynamicConstants.pF], values[_DynamicConstants.oI] > 1) {
                var endpointRes = values[1];
                _endpoint = endpointRes && endpointRes[_DynamicConstants.pF];
               }
              }
              _instrumentationKey && (config[_DynamicConstants.sl] = _instrumentationKey, config.endpointUrl = _endpoint);
             }
             _setStatus();
            } catch (e) {
             _isStatusSet || _setStatus();
            }
           }));
          } else _setStatus();
          var extCfg = details.ref(details.cfg, InternalConstants.Bw);
          (0, ts_utils.zav)(extCfg, (function(key) {
           details.ref(extCfg, key);
          }));
         }
        }
       }))), _debugListener = function(configHandler, unloadContainer, notificationManager, debugListener) {
        return unloadContainer.add(configHandler[_DynamicConstants.x6]((function(details) {
         var disableDbgExt = details.cfg.disableDbgExt;
         !0 === disableDbgExt && debugListener && (notificationManager[_DynamicConstants.h3](debugListener), 
         debugListener = null), notificationManager && !debugListener && !0 !== disableDbgExt && (debugListener = (0, 
         DbgExtensionUtils.M)(details.cfg), notificationManager[_DynamicConstants.vR](debugListener));
        }))), debugListener;
       }(_configHandler, _hookContainer, (_notificationManager = notificationManager) && _self[_DynamicConstants.RF](), _debugListener), 
       _addUnloadHook(_configHandler[_DynamicConstants.x6]((function(details) {
        if (details.cfg.enablePerfMgr) {
         var createPerfMgr = details.cfg[InternalConstants.Yd];
         prevCfgPerfMgr !== createPerfMgr && (createPerfMgr || (createPerfMgr = _createPerfManager), 
         (0, HelperFuncs.c2)(details.cfg, InternalConstants.Yd, createPerfMgr), prevCfgPerfMgr = createPerfMgr, 
         _cfgPerfManager = null), _perfManager || _cfgPerfManager || !(0, ts_utils.Tnt)(createPerfMgr) || (_cfgPerfManager = createPerfMgr(_self, _self[_DynamicConstants.RF]()));
        } else _cfgPerfManager = null, prevCfgPerfMgr = null;
       }))), _self[_DynamicConstants.Uw] = logger;
       var cfgExtensions = config[InternalConstants.jy];
       if ((_configExtensions = [])[_DynamicConstants.y5].apply(_configExtensions, (0, 
       TsLibShims.vz)((0, TsLibShims.vz)([], extensions, !1), cfgExtensions, !1)), _channelConfig = config[InternalConstants.LZ], 
       _initPluginChain(null), _channels && 0 !== _channels[_DynamicConstants.oI] || (0, 
       ts_utils.$8)("No " + InternalConstants.LZ + " available"), _channelConfig && _channelConfig[_DynamicConstants.oI] > 1) {
        var teeController = _self[_DynamicConstants.AP]("TeeChannelController");
        teeController && teeController.plugin || (0, DiagnosticLogger.ZP)(_logger, 1, 28, "TeeChannel required");
       }
       !function(config, listeners, logger) {
        (0, ts_utils.Iuo)(listeners, (function(listener) {
         var unloadHdl = (0, DynamicConfig.a)(config, listener.w, logger);
         delete listener.w, listener.rm = function() {
          unloadHdl.rm();
         };
        }));
       }(config, _cfgListeners, _logger), _cfgListeners = null, _isInitialized = !0, _activeStatus === InitActiveStatusEnum.f.ACTIVE && _releaseQueues();
      }, _self.getChannels = function() {
       var controls = [];
       return _channels && (0, ts_utils.Iuo)(_channels, (function(channel) {
        controls[_DynamicConstants.y5](channel);
       })), (0, ts_utils.N6t)(controls);
      }, _self.track = function(telemetryItem) {
       (0, PerfManager.r2)(_self[InternalConstants.kI](), (function() {
        return "AppInsightsCore:track";
       }), (function() {
        null === telemetryItem && (_notifyInvalidEvent(telemetryItem), (0, ts_utils.$8)("Invalid telemetry item")), 
        !telemetryItem[_DynamicConstants.RS] && (0, ts_utils.hXl)(telemetryItem[_DynamicConstants.RS]) && (_notifyInvalidEvent(telemetryItem), 
        (0, ts_utils.$8)("telemetry name required")), telemetryItem[_DynamicConstants.FI] = telemetryItem[_DynamicConstants.FI] || _instrumentationKey, 
        telemetryItem[_DynamicConstants.fA] = telemetryItem[_DynamicConstants.fA] || (0, 
        HelperFuncs._u)(new Date), telemetryItem.ver = telemetryItem.ver || "4.0", !_isUnloading && _self[_DynamicConstants.tZ]() && _activeStatus === InitActiveStatusEnum.f.ACTIVE ? _createTelCtx()[_DynamicConstants.$5](telemetryItem) : _activeStatus !== InitActiveStatusEnum.f[_DynamicConstants.Yq] && _eventQueue[_DynamicConstants.oI] <= _initInMemoMaxSize && _eventQueue[_DynamicConstants.y5](telemetryItem);
       }), (function() {
        return {
         item: telemetryItem
        };
       }), !telemetryItem.sync);
      }, _self[_DynamicConstants.DI] = _createTelCtx, _self[_DynamicConstants.RF] = function() {
       return _notificationManager || (_notificationManager = new NotificationManager.h(_configHandler.cfg), 
       _self._notificationManager = _notificationManager), _notificationManager;
      }, _self[_DynamicConstants.vR] = function(listener) {
       _self.getNotifyMgr()[_DynamicConstants.vR](listener);
      }, _self[_DynamicConstants.h3] = function(listener) {
       _notificationManager && _notificationManager[_DynamicConstants.h3](listener);
      }, _self.getCookieMgr = function() {
       return _cookieManager || (_cookieManager = (0, CookieMgr.xN)(_configHandler.cfg, _self[_DynamicConstants.Uw])), 
       _cookieManager;
      }, _self.setCookieMgr = function(cookieMgr) {
       _cookieManager !== cookieMgr && ((0, AsyncUtils.K)(_cookieManager, !1), _cookieManager = cookieMgr);
      }, _self[InternalConstants.kI] = function() {
       return _perfManager || _cfgPerfManager || (0, PerfManager.Z4)();
      }, _self.setPerfMgr = function(perfMgr) {
       _perfManager = perfMgr;
      }, _self.eventCnt = function() {
       return _eventQueue[_DynamicConstants.oI];
      }, _self.releaseQueue = function() {
       if (_isInitialized && _eventQueue[_DynamicConstants.oI] > 0) {
        var eventQueue = _eventQueue;
        _eventQueue = [], 2 === _activeStatus ? (0, ts_utils.Iuo)(eventQueue, (function(event) {
         event[_DynamicConstants.FI] = event[_DynamicConstants.FI] || _instrumentationKey, 
         _createTelCtx()[_DynamicConstants.$5](event);
        })) : (0, DiagnosticLogger.ZP)(_logger, 2, 20, "core init status is not active");
       }
      }, _self[_DynamicConstants.h4] = function(eventName) {
       return _internalLogsEventName = eventName || null, _forceStopInternalLogPoller = !1, 
       _internalLogPoller && _internalLogPoller[_DynamicConstants._w](), _startLogPoller(!0);
      }, _self[_DynamicConstants.Di] = function() {
       _forceStopInternalLogPoller = !0, _internalLogPoller && _internalLogPoller[_DynamicConstants._w](), 
       _flushInternalLogs();
      }, (0, HelperFuncs.o$)(_self, (function() {
       return _telemetryInitializerPlugin;
      }), [ "addTelemetryInitializer" ]), _self[_DynamicConstants.M5] = function(isAsync, unloadComplete, cbTimeout) {
       var _a;
       void 0 === isAsync && (isAsync = !0), _isInitialized || (0, ts_utils.$8)("SDK is not initialized"), 
       _isUnloading && (0, ts_utils.$8)("SDK is still unloading...");
       var result, unloadState = ((_a = {
        reason: 50
       })[_DynamicConstants.tI] = isAsync, _a.flushComplete = !1, _a);
       isAsync && !unloadComplete && (result = (0, ts_async.Qo)((function(resolve) {
        unloadComplete = resolve;
       })));
       var processUnloadCtx = (0, ProcessTelemetryContext.tS)(_getPluginChain(), _self);
       function _doUnload(flushComplete) {
        unloadState.flushComplete = flushComplete, _isUnloading = !0, _unloadHandlers.run(processUnloadCtx, unloadState), 
        _self[_DynamicConstants.Di](), processUnloadCtx[_DynamicConstants.$5](unloadState);
       }
       return processUnloadCtx[_DynamicConstants.by]((function() {
        _hookContainer.run(_self[_DynamicConstants.Uw]), (0, AsyncUtils.k)([ _cookieManager, _notificationManager, _logger ], isAsync, (function() {
         _initDefaults(), unloadComplete && unloadComplete(unloadState);
        }));
       }), _self), _flushInternalLogs(), _flushChannels(isAsync, _doUnload, 6, cbTimeout) || _doUnload(!1), 
       result;
      }, _self[_DynamicConstants.AP] = _getPlugin, _self.addPlugin = function(plugin, replaceExisting, isAsync, addCb) {
       if (!plugin) return addCb && addCb(!1), void _logOrThrowError("Plugins must provide initialize method");
       var existingPlugin = _getPlugin(plugin[_DynamicConstants.Ju]);
       if (existingPlugin && !replaceExisting) return addCb && addCb(!1), void _logOrThrowError("Plugin [" + plugin[_DynamicConstants.Ju] + "] is already loaded!");
       var updateState = {
        reason: 16
       };
       function _addPlugin(removed) {
        _configExtensions[_DynamicConstants.y5](plugin), updateState.added = [ plugin ], 
        _initPluginChain(updateState), addCb && addCb(!0);
       }
       if (existingPlugin) {
        var removedPlugins_1 = [ existingPlugin.plugin ];
        _removePlugins(removedPlugins_1, {
         reason: 2,
         isAsync: !!isAsync
        }, (function(removed) {
         removed ? (updateState.removed = removedPlugins_1, updateState.reason |= 32, _addPlugin()) : addCb && addCb(!1);
        }));
       } else _addPlugin();
      }, _self.updateCfg = function(newConfig, mergeExisting) {
       var updateState;
       if (void 0 === mergeExisting && (mergeExisting = !0), _self[_DynamicConstants.tZ]()) {
        updateState = {
         reason: 1,
         cfg: _configHandler.cfg,
         oldCfg: (0, ts_utils.zwS)({}, _configHandler.cfg),
         newConfig: (0, ts_utils.zwS)({}, newConfig),
         merge: mergeExisting
        }, newConfig = updateState.newConfig;
        var cfg = _configHandler.cfg;
        newConfig[InternalConstants.jy] = cfg[InternalConstants.jy], newConfig[InternalConstants.LZ] = cfg[InternalConstants.LZ];
       }
       _configHandler._block((function(details) {
        var theConfig = details.cfg;
        _deepMergeConfig(details, theConfig, newConfig, mergeExisting), mergeExisting || (0, 
        ts_utils.zav)(theConfig, (function(key) {
         (0, ts_utils.KhI)(newConfig, key) || details.set(theConfig, key, InternalConstants.HP);
        })), details[_DynamicConstants.h0](theConfig, defaultConfig);
       }), !0), _configHandler[_DynamicConstants.zs](), updateState && _doUpdate(updateState);
      }, _self.evtNamespace = function() {
       return _evtNamespace;
      }, _self.flush = _flushChannels, _self.getTraceCtx = function(createNew) {
       return _traceCtx || (_traceCtx = (0, TelemetryHelpers.u7)()), _traceCtx;
      }, _self.setTraceCtx = function(traceCtx) {
       _traceCtx = traceCtx || null;
      }, _self.addUnloadHook = _addUnloadHook, (0, HelperFuncs.RF)(_self, "addUnloadCb", (function() {
       return _unloadHandlers;
      }), "add"), _self.onCfgChange = function(handler) {
       var unloadHook, listeners, newWatcher, theListener;
       return _isInitialized ? unloadHook = (0, DynamicConfig.a)(_configHandler.cfg, handler, _self[_DynamicConstants.Uw]) : ((theListener = _findWatcher(listeners = _cfgListeners, newWatcher = handler).l) || (theListener = {
        w: newWatcher,
        rm: function() {
         var fnd = _findWatcher(listeners, newWatcher);
         -1 !== fnd.i && listeners[_DynamicConstants.Ic](fnd.i, 1);
        }
       }, listeners[_DynamicConstants.y5](theListener)), unloadHook = theListener), function(unloadHook) {
        return (0, ts_utils.vF1)({
         rm: function() {
          unloadHook.rm();
         }
        }, "toJSON", {
         v: function() {
          return "aicore::onCfgChange<" + JSON.stringify(unloadHook) + ">";
         }
        });
       }(unloadHook);
      }, _self.getWParam = function() {
       return (0, ts_utils.Wtk)() || _configHandler.cfg.enableWParam ? 0 : -1;
      };
     }));
    }
    return AppInsightsCore.__ieDyn = 1, AppInsightsCore;
   }();
  },
  34013: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    K: () => runTargetUnload,
    k: () => doUnloadAll
   });
   var _nevware21_ts_async__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8205), _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(269), _DynamicConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6182);
   function runTargetUnload(target, isAsync) {
    if (target && target[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.M5]) return target[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.M5](isAsync);
   }
   function doUnloadAll(targets, isAsync, done) {
    var result;
    return done || (result = (0, _nevware21_ts_async__WEBPACK_IMPORTED_MODULE_1__.Qo)((function(resolved) {
     done = resolved;
    }))), targets && (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_2__.R3R)(targets) > 0 ? (0, 
    _nevware21_ts_async__WEBPACK_IMPORTED_MODULE_1__.Dv)(runTargetUnload(targets[0], isAsync), (function() {
     doUnloadAll((0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_2__.KVm)(targets, 1), isAsync, done);
    })) : done(), result;
   }
  },
  98257: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    s: () => BaseTelemetryPlugin
   });
   var _a, _microsoft_dynamicproto_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(68279), _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(269), _Config_DynamicConfig__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(19749), _DynamicConstants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(6182), _DiagnosticLogger__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(23775), _HelperFuncs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(13673), _InternalConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96492), _ProcessTelemetryContext__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(72317), _UnloadHandlerContainer__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(60836), _UnloadHookContainer__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(98969), defaultValues = ((_a = {})[_InternalConstants__WEBPACK_IMPORTED_MODULE_0__.Bw] = {
    isVal: _HelperFuncs__WEBPACK_IMPORTED_MODULE_1__.Gh,
    v: {}
   }, _a), BaseTelemetryPlugin = function() {
    function BaseTelemetryPlugin() {
     var _isinitialized, _rootCtx, _nextPlugin, _unloadHandlerContainer, _hookContainer, _self = this;
     function _getTelCtx(currentCtx) {
      void 0 === currentCtx && (currentCtx = null);
      var itemCtx = currentCtx;
      if (!itemCtx) {
       var rootCtx = _rootCtx || (0, _ProcessTelemetryContext__WEBPACK_IMPORTED_MODULE_4__.i8)(null, {}, _self[_InternalConstants__WEBPACK_IMPORTED_MODULE_0__.eT]);
       itemCtx = _nextPlugin && _nextPlugin.getPlugin ? rootCtx[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__.$o](null, _nextPlugin.getPlugin) : rootCtx[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__.$o](null, _nextPlugin);
      }
      return itemCtx;
     }
     function _setDefaults(config, core, pluginChain) {
      (0, _Config_DynamicConfig__WEBPACK_IMPORTED_MODULE_6__.e)(config, defaultValues, (0, 
      _DiagnosticLogger__WEBPACK_IMPORTED_MODULE_7__.y0)(core)), !pluginChain && core && (pluginChain = core[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__.DI]()[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__.uR]());
      var nextPlugin = _nextPlugin;
      _nextPlugin && _nextPlugin.getPlugin && (nextPlugin = _nextPlugin.getPlugin()), 
      _self[_InternalConstants__WEBPACK_IMPORTED_MODULE_0__.eT] = core, _rootCtx = (0, 
      _ProcessTelemetryContext__WEBPACK_IMPORTED_MODULE_4__.i8)(pluginChain, config, core, nextPlugin);
     }
     function _initDefaults() {
      _isinitialized = !1, _self[_InternalConstants__WEBPACK_IMPORTED_MODULE_0__.eT] = null, 
      _rootCtx = null, _nextPlugin = null, _hookContainer = (0, _UnloadHookContainer__WEBPACK_IMPORTED_MODULE_8__.w)(), 
      _unloadHandlerContainer = (0, _UnloadHandlerContainer__WEBPACK_IMPORTED_MODULE_9__.P)();
     }
     _initDefaults(), (0, _microsoft_dynamicproto_js__WEBPACK_IMPORTED_MODULE_2__.A)(BaseTelemetryPlugin, _self, (function(_self) {
      _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__.mE] = function(config, core, extensions, pluginChain) {
       _setDefaults(config, core, pluginChain), _isinitialized = !0;
      }, _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__.Ik] = function(unloadCtx, unloadState) {
       var _a, core = _self[_InternalConstants__WEBPACK_IMPORTED_MODULE_0__.eT];
       if (core && (!unloadCtx || core === unloadCtx[_InternalConstants__WEBPACK_IMPORTED_MODULE_0__.eT]())) {
        var result, unloadDone = !1, theUnloadCtx = unloadCtx || (0, _ProcessTelemetryContext__WEBPACK_IMPORTED_MODULE_4__.tS)(null, core, _nextPlugin && _nextPlugin.getPlugin ? _nextPlugin.getPlugin() : _nextPlugin), theUnloadState = unloadState || ((_a = {
         reason: 0
        })[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__.tI] = !1, _a);
        return _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__.tn] && !0 === _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__.tn](theUnloadCtx, theUnloadState, _unloadCallback) ? result = !0 : _unloadCallback(), 
        result;
       }
       function _unloadCallback() {
        unloadDone || (unloadDone = !0, _unloadHandlerContainer.run(theUnloadCtx, unloadState), 
        _hookContainer.run(theUnloadCtx[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__.e4]()), 
        !0 === result && theUnloadCtx[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__.$5](theUnloadState), 
        _initDefaults());
       }
      }, _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__.HC] = function(updateCtx, updateState) {
       var core = _self[_InternalConstants__WEBPACK_IMPORTED_MODULE_0__.eT];
       if (core && (!updateCtx || core === updateCtx[_InternalConstants__WEBPACK_IMPORTED_MODULE_0__.eT]())) {
        var result, updateDone = !1, theUpdateCtx = updateCtx || (0, _ProcessTelemetryContext__WEBPACK_IMPORTED_MODULE_4__.nU)(null, core, _nextPlugin && _nextPlugin.getPlugin ? _nextPlugin.getPlugin() : _nextPlugin), theUpdateState = updateState || {
         reason: 0
        };
        return _self._doUpdate && !0 === _self._doUpdate(theUpdateCtx, theUpdateState, _updateCallback) ? result = !0 : _updateCallback(), 
        result;
       }
       function _updateCallback() {
        updateDone || (updateDone = !0, _setDefaults(theUpdateCtx.getCfg(), theUpdateCtx.core(), theUpdateCtx[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__.uR]()));
       }
      }, (0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_1__.RF)(_self, "_addUnloadCb", (function() {
       return _unloadHandlerContainer;
      }), "add"), (0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_1__.RF)(_self, "_addHook", (function() {
       return _hookContainer;
      }), "add"), (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_5__.vF1)(_self, "_unloadHooks", {
       g: function() {
        return _hookContainer;
       }
      });
     })), _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__.e4] = function(itemCtx) {
      return _getTelCtx(itemCtx)[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__.e4]();
     }, _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__.tZ] = function() {
      return _isinitialized;
     }, _self.setInitialized = function(isInitialized) {
      _isinitialized = isInitialized;
     }, _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__.YH] = function(next) {
      _nextPlugin = next;
     }, _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__.$5] = function(env, itemCtx) {
      itemCtx ? itemCtx[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__.$5](env) : _nextPlugin && (0, 
      _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_5__.Tnt)(_nextPlugin[_InternalConstants__WEBPACK_IMPORTED_MODULE_0__.qT]) && _nextPlugin[_InternalConstants__WEBPACK_IMPORTED_MODULE_0__.qT](env, null);
     }, _self._getTelCtx = _getTelCtx;
    }
    return BaseTelemetryPlugin.__ieDyn = 1, BaseTelemetryPlugin;
   }();
  },
  27847: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    i: () => ChannelControllerPriority,
    x: () => DisabledPropertyName
   });
   var ChannelControllerPriority = 500, DisabledPropertyName = "Microsoft_ApplicationInsights_BypassAjaxInstrumentation";
  },
  25034: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    It: () => uaDisallowsSameSiteNone,
    gi: () => areCookiesSupported,
    um: () => safeGetCookieMgr,
    xN: () => createCookieMgr
   });
   var _a, _b, _doc, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(269), _Config_ConfigDefaultHelpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(52475), _Config_DynamicConfig__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(19749), _DynamicConstants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(6182), _DiagnosticLogger__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(23775), _EnvUtils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(7292), _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(13673), _InternalConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96492), strToGMTString = "toGMTString", strToUTCString = "toUTCString", strCookie = "cookie", strExpires = "expires", strIsCookieUseDisabled = "isCookieUseDisabled", strDisableCookiesUsage = "disableCookiesUsage", strConfigCookieMgr = "_ckMgr", _supportsCookies = null, _allowUaSameSite = null, _parsedCookieValue = null, _cookieCache = {}, _globalCookieConfig = {}, rootDefaultConfig = ((_a = {
    cookieCfg: (0, _Config_ConfigDefaultHelpers__WEBPACK_IMPORTED_MODULE_0__.NU)((_b = {}, 
    _b[_InternalConstants__WEBPACK_IMPORTED_MODULE_1__.Fk] = {
     fb: "cookieDomain",
     dfVal: _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.Gh
    }, _b.path = {
     fb: "cookiePath",
     dfVal: _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.Gh
    }, _b.enabled = _InternalConstants__WEBPACK_IMPORTED_MODULE_1__.HP, _b.ignoreCookies = _InternalConstants__WEBPACK_IMPORTED_MODULE_1__.HP, 
    _b.blockedCookies = _InternalConstants__WEBPACK_IMPORTED_MODULE_1__.HP, _b)),
    cookieDomain: _InternalConstants__WEBPACK_IMPORTED_MODULE_1__.HP,
    cookiePath: _InternalConstants__WEBPACK_IMPORTED_MODULE_1__.HP
   })[strDisableCookiesUsage] = _InternalConstants__WEBPACK_IMPORTED_MODULE_1__.HP, 
   _a);
   function _getDoc() {
    !_doc && (_doc = (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.nRs)((function() {
     return (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.YEm)();
    })));
   }
   function _isMgrEnabled(cookieMgr) {
    return !cookieMgr || cookieMgr.isEnabled();
   }
   function _isIgnoredCookie(cookieMgrCfg, name) {
    return !!(name && cookieMgrCfg && (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.cyL)(cookieMgrCfg.ignoreCookies)) && -1 !== (0, 
    _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.rDm)(cookieMgrCfg.ignoreCookies, name);
   }
   function _isCfgEnabled(rootConfig, cookieMgrConfig) {
    var isCfgEnabled = cookieMgrConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__.XM];
    if ((0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.hXl)(isCfgEnabled)) {
     var cookieEnabled = void 0;
     (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.b07)(rootConfig[strIsCookieUseDisabled]) || (cookieEnabled = !rootConfig[strIsCookieUseDisabled]), 
     (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.b07)(rootConfig[strDisableCookiesUsage]) || (cookieEnabled = !rootConfig[strDisableCookiesUsage]), 
     isCfgEnabled = cookieEnabled;
    }
    return isCfgEnabled;
   }
   function safeGetCookieMgr(core, config) {
    var cookieMgr;
    if (core) cookieMgr = core.getCookieMgr(); else if (config) {
     var cookieCfg = config.cookieCfg;
     cookieMgr = cookieCfg && cookieCfg[strConfigCookieMgr] ? cookieCfg[strConfigCookieMgr] : createCookieMgr(config);
    }
    return cookieMgr || (cookieMgr = function(config, logger) {
     var inst = createCookieMgr[strConfigCookieMgr] || _globalCookieConfig[strConfigCookieMgr];
     return inst || (inst = createCookieMgr[strConfigCookieMgr] = createCookieMgr(config, logger), 
     _globalCookieConfig[strConfigCookieMgr] = inst), inst;
    }(config, (core || {})[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__.Uw])), cookieMgr;
   }
   function createCookieMgr(rootConfig, logger) {
    var _a, cookieMgrConfig, _path, _domain, unloadHandler, _enabled, _getCookieFn, _setCookieFn, _delCookieFn;
    rootConfig = (0, _Config_DynamicConfig__WEBPACK_IMPORTED_MODULE_5__.e)(rootConfig || _globalCookieConfig, null, logger).cfg, 
    unloadHandler = (0, _Config_DynamicConfig__WEBPACK_IMPORTED_MODULE_5__.a)(rootConfig, (function(details) {
     details[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__.h0](details.cfg, rootDefaultConfig), 
     cookieMgrConfig = details.ref(details.cfg, "cookieCfg"), _path = cookieMgrConfig[_InternalConstants__WEBPACK_IMPORTED_MODULE_1__.QW] || "/", 
     _domain = cookieMgrConfig[_InternalConstants__WEBPACK_IMPORTED_MODULE_1__.Fk], _enabled = !1 !== _isCfgEnabled(rootConfig, cookieMgrConfig), 
     _getCookieFn = cookieMgrConfig.getCookie || _getCookieValue, _setCookieFn = cookieMgrConfig.setCookie || _setCookieValue, 
     _delCookieFn = cookieMgrConfig.delCookie || _setCookieValue;
    }), logger);
    var cookieMgr = ((_a = {
     isEnabled: function() {
      var enabled = !1 !== _isCfgEnabled(rootConfig, cookieMgrConfig) && _enabled && areCookiesSupported(logger), gblManager = _globalCookieConfig[strConfigCookieMgr];
      return enabled && gblManager && cookieMgr !== gblManager && (enabled = _isMgrEnabled(gblManager)), 
      enabled;
     },
     setEnabled: function(value) {
      _enabled = !1 !== value, cookieMgrConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__.XM] = value;
     },
     set: function(name, value, maxAgeSec, domain, path) {
      var result = !1;
      if (_isMgrEnabled(cookieMgr) && !function(cookieMgrCfg, name) {
       return !!(name && cookieMgrCfg && (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.cyL)(cookieMgrCfg.blockedCookies) && -1 !== (0, 
       _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.rDm)(cookieMgrCfg.blockedCookies, name)) || _isIgnoredCookie(cookieMgrCfg, name);
      }(cookieMgrConfig, name)) {
       var values = {}, theValue = (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.EHq)(value || _InternalConstants__WEBPACK_IMPORTED_MODULE_1__.m5), idx = (0, 
       _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.HzD)(theValue, ";");
       if (-1 !== idx && (theValue = (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.EHq)((0, 
       _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.ZWZ)(value, idx)), values = _extractParts((0, 
       _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.P0f)(value, idx + 1))), (0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.KY)(values, _InternalConstants__WEBPACK_IMPORTED_MODULE_1__.Fk, domain || _domain, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.zzB, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.b07), 
       !(0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.hXl)(maxAgeSec)) {
        var _isIE = (0, _EnvUtils__WEBPACK_IMPORTED_MODULE_6__.lT)();
        if ((0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.b07)(values[strExpires])) {
         var expireMs = (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.f0d)() + 1e3 * maxAgeSec;
         if (expireMs > 0) {
          var expiry = new Date;
          expiry.setTime(expireMs), (0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.KY)(values, strExpires, _formatDate(expiry, _isIE ? strToGMTString : strToUTCString) || _formatDate(expiry, _isIE ? strToGMTString : strToUTCString) || _InternalConstants__WEBPACK_IMPORTED_MODULE_1__.m5, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.zzB);
         }
        }
        _isIE || (0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.KY)(values, "max-age", _InternalConstants__WEBPACK_IMPORTED_MODULE_1__.m5 + maxAgeSec, null, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.b07);
       }
       var location_1 = (0, _EnvUtils__WEBPACK_IMPORTED_MODULE_6__.g$)();
       location_1 && "https:" === location_1[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__.Qg] && ((0, 
       _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.KY)(values, "secure", null, null, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.b07), 
       null === _allowUaSameSite && (_allowUaSameSite = !uaDisallowsSameSiteNone(((0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.w3n)() || {})[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__.tX])), 
       _allowUaSameSite && (0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.KY)(values, "SameSite", "None", null, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.b07)), 
       (0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.KY)(values, _InternalConstants__WEBPACK_IMPORTED_MODULE_1__.QW, path || _path, null, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.b07), 
       _setCookieFn(name, _formatCookieValue(theValue, values)), result = !0;
      }
      return result;
     },
     get: function(name) {
      var value = _InternalConstants__WEBPACK_IMPORTED_MODULE_1__.m5;
      return _isMgrEnabled(cookieMgr) && !_isIgnoredCookie(cookieMgrConfig, name) && (value = _getCookieFn(name)), 
      value;
     },
     del: function(name, path) {
      var result = !1;
      return _isMgrEnabled(cookieMgr) && (result = cookieMgr.purge(name, path)), result;
     },
     purge: function(name, path) {
      var _a, result = !1;
      if (areCookiesSupported(logger)) {
       var values = ((_a = {})[_InternalConstants__WEBPACK_IMPORTED_MODULE_1__.QW] = path || "/", 
       _a[strExpires] = "Thu, 01 Jan 1970 00:00:01 GMT", _a);
       (0, _EnvUtils__WEBPACK_IMPORTED_MODULE_6__.lT)() || (values["max-age"] = "0"), _delCookieFn(name, _formatCookieValue(_InternalConstants__WEBPACK_IMPORTED_MODULE_1__.m5, values)), 
       result = !0;
      }
      return result;
     }
    })[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__.M5] = function(isAsync) {
     unloadHandler && unloadHandler.rm(), unloadHandler = null;
    }, _a);
    return cookieMgr[strConfigCookieMgr] = cookieMgr, cookieMgr;
   }
   function areCookiesSupported(logger) {
    if (null === _supportsCookies) {
     _supportsCookies = !1, !_doc && _getDoc();
     try {
      var doc = _doc.v || {};
      _supportsCookies = void 0 !== doc[strCookie];
     } catch (e) {
      (0, _DiagnosticLogger__WEBPACK_IMPORTED_MODULE_7__.ZP)(logger, 2, 68, "Cannot access document.cookie - " + (0, 
      _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.lL)(e), {
       exception: (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.mmD)(e)
      });
     }
    }
    return _supportsCookies;
   }
   function _extractParts(theValue) {
    var values = {};
    if (theValue && theValue[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__.oI]) {
     var parts = (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.EHq)(theValue)[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__.sY](";");
     (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.Iuo)(parts, (function(thePart) {
      if (thePart = (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.EHq)(thePart || _InternalConstants__WEBPACK_IMPORTED_MODULE_1__.m5)) {
       var idx = (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.HzD)(thePart, "=");
       -1 === idx ? values[thePart] = null : values[(0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.EHq)((0, 
       _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.ZWZ)(thePart, idx))] = (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.EHq)((0, 
       _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.P0f)(thePart, idx + 1));
      }
     }));
    }
    return values;
   }
   function _formatDate(theDate, func) {
    return (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.Tnt)(theDate[func]) ? theDate[func]() : null;
   }
   function _formatCookieValue(value, values) {
    var cookieValue = value || _InternalConstants__WEBPACK_IMPORTED_MODULE_1__.m5;
    return (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.zav)(values, (function(name, theValue) {
     cookieValue += "; " + name + ((0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.hXl)(theValue) ? _InternalConstants__WEBPACK_IMPORTED_MODULE_1__.m5 : "=" + theValue);
    })), cookieValue;
   }
   function _getCookieValue(name) {
    var cookieValue = _InternalConstants__WEBPACK_IMPORTED_MODULE_1__.m5;
    if (!_doc && _getDoc(), _doc.v) {
     var theCookie = _doc.v[strCookie] || _InternalConstants__WEBPACK_IMPORTED_MODULE_1__.m5;
     _parsedCookieValue !== theCookie && (_cookieCache = _extractParts(theCookie), _parsedCookieValue = theCookie), 
     cookieValue = (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.EHq)(_cookieCache[name] || _InternalConstants__WEBPACK_IMPORTED_MODULE_1__.m5);
    }
    return cookieValue;
   }
   function _setCookieValue(name, cookieValue) {
    !_doc && _getDoc(), _doc.v && (_doc.v[strCookie] = name + "=" + cookieValue);
   }
   function uaDisallowsSameSiteNone(userAgent) {
    return !!(0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.KgX)(userAgent) && (!(!(0, 
    _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.Ju)(userAgent, "CPU iPhone OS 12") && !(0, 
    _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.Ju)(userAgent, "iPad; CPU OS 12")) || (!!((0, 
    _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.Ju)(userAgent, "Macintosh; Intel Mac OS X 10_14") && (0, 
    _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.Ju)(userAgent, "Version/") && (0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.Ju)(userAgent, "Safari")) || (!(!(0, 
    _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.Ju)(userAgent, "Macintosh; Intel Mac OS X 10_14") || !(0, 
    _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.Cv9)(userAgent, "AppleWebKit/605.1.15 (KHTML, like Gecko)")) || (!(!(0, 
    _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.Ju)(userAgent, "Chrome/5") && !(0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.Ju)(userAgent, "Chrome/6")) || (!(!(0, 
    _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.Ju)(userAgent, "UnrealEngine") || (0, 
    _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.Ju)(userAgent, "Chrome")) || !(!(0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.Ju)(userAgent, "UCBrowser/12") && !(0, 
    _HelperFuncs__WEBPACK_IMPORTED_MODULE_2__.Ju)(userAgent, "UCBrowser/11")))))));
   }
  },
  69882: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    aq: () => newGuid,
    cL: () => generateW3CId
   });
   var _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(269), _InternalConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96492), _RandomHelper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(76535);
   function newGuid() {
    var uuid = generateW3CId();
    return (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.P0f)(uuid, 0, 8) + "-" + (0, 
    _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.P0f)(uuid, 8, 12) + "-" + (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.P0f)(uuid, 12, 16) + "-" + (0, 
    _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.P0f)(uuid, 16, 20) + "-" + (0, 
    _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.P0f)(uuid, 20);
   }
   function generateW3CId() {
    for (var tmp, hexValues = [ "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f" ], oct = _InternalConstants__WEBPACK_IMPORTED_MODULE_1__.m5, a = 0; a < 4; a++) oct += hexValues[15 & (tmp = (0, 
    _RandomHelper__WEBPACK_IMPORTED_MODULE_2__.VN)())] + hexValues[tmp >> 4 & 15] + hexValues[tmp >> 8 & 15] + hexValues[tmp >> 12 & 15] + hexValues[tmp >> 16 & 15] + hexValues[tmp >> 20 & 15] + hexValues[tmp >> 24 & 15] + hexValues[tmp >> 28 & 15];
    var clockSequenceHi = hexValues[8 + (3 & (0, _RandomHelper__WEBPACK_IMPORTED_MODULE_2__.VN)()) | 0];
    return (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.hKY)(oct, 0, 8) + (0, 
    _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.hKY)(oct, 9, 4) + "4" + (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.hKY)(oct, 13, 3) + clockSequenceHi + (0, 
    _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.hKY)(oct, 16, 3) + (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.hKY)(oct, 19, 12);
   }
  },
  24276: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    T: () => createElmNodeData,
    Z: () => createUniqueNamespace
   });
   var _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(269), _DynamicConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6182), _HelperFuncs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(13673), _InternalConstants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(96492), _RandomHelper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(76535), version = "3.3.3", instanceName = "." + (0, 
   _RandomHelper__WEBPACK_IMPORTED_MODULE_0__.Si)(6), _dataUid = 0;
   function _canAcceptData(target) {
    return 1 === target[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.re] || 9 === target[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.re] || !+target[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.re];
   }
   function createUniqueNamespace(name, includeVersion) {
    return void 0 === includeVersion && (includeVersion = !1), (0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_3__.cH)(name + _dataUid++ + (includeVersion ? "." + version : _InternalConstants__WEBPACK_IMPORTED_MODULE_4__.m5) + instanceName);
   }
   function createElmNodeData(name) {
    var data = {
     id: createUniqueNamespace("_aiData-" + (name || _InternalConstants__WEBPACK_IMPORTED_MODULE_4__.m5) + "." + version),
     accept: function(target) {
      return _canAcceptData(target);
     },
     get: function(target, name, defValue, addDefault) {
      var theCache = target[data.id];
      return theCache ? theCache[(0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_3__.cH)(name)] : (addDefault && (theCache = function(data, target) {
       var theCache = target[data.id];
       if (!theCache) {
        theCache = {};
        try {
         _canAcceptData(target) && (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_2__.vF1)(target, data.id, {
          e: !1,
          v: theCache
         });
        } catch (e) {}
       }
       return theCache;
      }(data, target), theCache[(0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_3__.cH)(name)] = defValue), 
      defValue);
     },
     kill: function(target, name) {
      if (target && target[name]) try {
       delete target[name];
      } catch (e) {}
     }
    };
    return data;
   }
  },
  27867: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    $: () => getDebugExt,
    M: () => getDebugListener
   });
   var _debugListener, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(269), _DynamicConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6182), _InternalConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96492), listenerFuncs = [ _InternalConstants__WEBPACK_IMPORTED_MODULE_0__.fc, _InternalConstants__WEBPACK_IMPORTED_MODULE_0__.Yp, _InternalConstants__WEBPACK_IMPORTED_MODULE_0__.dI, _InternalConstants__WEBPACK_IMPORTED_MODULE_0__.l0 ], _aiNamespace = null;
   function _listenerProxyFunc(name, config) {
    return function() {
     var args = arguments, dbgExt = getDebugExt(config);
     if (dbgExt) {
      var listener = dbgExt.listener;
      listener && listener[name] && listener[name][_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.y9](listener, args);
     }
    };
   }
   function getDebugExt(config) {
    var target, ns = _aiNamespace;
    return ns || !0 === config.disableDbgExt || (ns = _aiNamespace || ((target = (0, 
    _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_2__.zS2)("Microsoft")) && (_aiNamespace = target.ApplicationInsights), 
    _aiNamespace)), ns ? ns.ChromeDbgExt : null;
   }
   function getDebugListener(config) {
    if (!_debugListener) {
     _debugListener = {};
     for (var lp = 0; lp < listenerFuncs[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.oI]; lp++) _debugListener[listenerFuncs[lp]] = _listenerProxyFunc(listenerFuncs[lp], config);
    }
    return _debugListener;
   }
  },
  23775: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    OG: () => _warnToConsole,
    Oc: () => _logInternalMessage,
    WD: () => _InternalLogMessage,
    ZP: () => _throwInternal,
    wq: () => DiagnosticLogger,
    y0: () => safeGetLogger
   });
   var _a, _microsoft_dynamicproto_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(68279), _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(269), _Config_DynamicConfig__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(19749), _DynamicConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6182), _DbgExtensionUtils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(27867), _EnvUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7292), _InternalConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(96492), defaultValues = {
    loggingLevelConsole: 0,
    loggingLevelTelemetry: 1,
    maxMessageLimit: 25,
    enableDebug: !1
   }, _logFuncs = ((_a = {})[0] = null, _a[1] = "errorToConsole", _a[2] = "warnToConsole", 
   _a[3] = "debugToConsole", _a);
   function _sanitizeDiagnosticText(text) {
    return text ? '"' + text[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.W7](/\"/g, _InternalConstants__WEBPACK_IMPORTED_MODULE_1__.m5) + '"' : _InternalConstants__WEBPACK_IMPORTED_MODULE_1__.m5;
   }
   function _logToConsole(func, message) {
    var theConsole = (0, _EnvUtils__WEBPACK_IMPORTED_MODULE_2__.U5)();
    if (theConsole) {
     var logFunc = "log";
     theConsole[func] && (logFunc = func), (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.Tnt)(theConsole[logFunc]) && theConsole[logFunc](message);
    }
   }
   var _InternalLogMessage = function() {
    function _InternalLogMessage(msgId, msg, isUserAct, properties) {
     void 0 === isUserAct && (isUserAct = !1);
     this[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.JR] = msgId, this[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.pM] = (isUserAct ? "AI: " : "AI (Internal): ") + msgId;
     var strProps = _InternalConstants__WEBPACK_IMPORTED_MODULE_1__.m5;
     (0, _EnvUtils__WEBPACK_IMPORTED_MODULE_2__.Z)() && (strProps = (0, _EnvUtils__WEBPACK_IMPORTED_MODULE_2__.hm)().stringify(properties));
     var diagnosticText = (msg ? " message:" + _sanitizeDiagnosticText(msg) : _InternalConstants__WEBPACK_IMPORTED_MODULE_1__.m5) + (properties ? " props:" + _sanitizeDiagnosticText(strProps) : _InternalConstants__WEBPACK_IMPORTED_MODULE_1__.m5);
     this[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.pM] += diagnosticText;
    }
    return _InternalLogMessage.dataType = "MessageData", _InternalLogMessage;
   }();
   function safeGetLogger(core, config) {
    return (core || {})[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.Uw] || new DiagnosticLogger(config);
   }
   var DiagnosticLogger = function() {
    function DiagnosticLogger(config) {
     this.identifier = "DiagnosticLogger", this.queue = [];
     var _loggingLevelConsole, _loggingLevelTelemetry, _maxInternalMessageLimit, _enableDebug, _unloadHandler, _messageCount = 0, _messageLogged = {};
     (0, _microsoft_dynamicproto_js__WEBPACK_IMPORTED_MODULE_4__.A)(DiagnosticLogger, this, (function(_self) {
      function _logInternalMessage(severity, message) {
       if (!(_messageCount >= _maxInternalMessageLimit)) {
        var logMessage = !0, messageKey = "AITR_" + message[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.JR];
        if (_messageLogged[messageKey] ? logMessage = !1 : _messageLogged[messageKey] = !0, 
        logMessage && (severity <= _loggingLevelTelemetry && (_self.queue[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.y5](message), 
        _messageCount++, _debugExtMsg(1 === severity ? "error" : "warn", message)), _messageCount === _maxInternalMessageLimit)) {
         var throttleLimitMessage = "Internal events throttle limit per PageView reached for this app.", throttleMessage = new _InternalLogMessage(23, throttleLimitMessage, !1);
         _self.queue[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.y5](throttleMessage), 
         1 === severity ? _self.errorToConsole(throttleLimitMessage) : _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.on](throttleLimitMessage);
        }
       }
      }
      function _debugExtMsg(name, data) {
       var dbgExt = (0, _DbgExtensionUtils__WEBPACK_IMPORTED_MODULE_6__.$)(config || {});
       dbgExt && dbgExt[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.e4] && dbgExt[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.e4](name, data);
      }
      _unloadHandler = function(config) {
       return (0, _Config_DynamicConfig__WEBPACK_IMPORTED_MODULE_5__.a)((0, _Config_DynamicConfig__WEBPACK_IMPORTED_MODULE_5__.e)(config, defaultValues, _self).cfg, (function(details) {
        var config = details.cfg;
        _loggingLevelConsole = config[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.Bl], 
        _loggingLevelTelemetry = config.loggingLevelTelemetry, _maxInternalMessageLimit = config.maxMessageLimit, 
        _enableDebug = config.enableDebug;
       }));
      }(config || {}), _self.consoleLoggingLevel = function() {
       return _loggingLevelConsole;
      }, _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.ih] = function(severity, msgId, msg, properties, isUserAct) {
       void 0 === isUserAct && (isUserAct = !1);
       var message = new _InternalLogMessage(msgId, msg, isUserAct, properties);
       if (_enableDebug) throw (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.mmD)(message);
       var logFunc = _logFuncs[severity] || "warnToConsole";
       if ((0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.b07)(message[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.pM])) _debugExtMsg("throw" + (1 === severity ? "Critical" : "Warning"), message); else {
        if (isUserAct) {
         var messageKey = +message[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.JR];
         !_messageLogged[messageKey] && _loggingLevelConsole >= severity && (_self[logFunc](message[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.pM]), 
         _messageLogged[messageKey] = !0);
        } else _loggingLevelConsole >= severity && _self[logFunc](message[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.pM]);
        _logInternalMessage(severity, message);
       }
      }, _self.debugToConsole = function(message) {
       _logToConsole("debug", message), _debugExtMsg("warning", message);
      }, _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.on] = function(message) {
       _logToConsole("warn", message), _debugExtMsg("warning", message);
      }, _self.errorToConsole = function(message) {
       _logToConsole("error", message), _debugExtMsg("error", message);
      }, _self.resetInternalMessageCount = function() {
       _messageCount = 0, _messageLogged = {};
      }, _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.sx] = _logInternalMessage, 
      _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.M5] = function(isAsync) {
       _unloadHandler && _unloadHandler.rm(), _unloadHandler = null;
      };
     }));
    }
    return DiagnosticLogger.__ieDyn = 1, DiagnosticLogger;
   }();
   function _getLogger(logger) {
    return logger || new DiagnosticLogger;
   }
   function _throwInternal(logger, severity, msgId, msg, properties, isUserAct) {
    void 0 === isUserAct && (isUserAct = !1), _getLogger(logger)[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.ih](severity, msgId, msg, properties, isUserAct);
   }
   function _warnToConsole(logger, message) {
    _getLogger(logger)[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.on](message);
   }
   function _logInternalMessage(logger, severity, message) {
    _getLogger(logger)[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.sx](severity, message);
   }
  },
  7292: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    $Z: () => findMetaTag,
    Iu: () => findNamedServerTiming,
    L0: () => getIEVersion,
    MY: () => getCrypto,
    PV: () => useXDomainRequest,
    R7: () => isFetchSupported,
    U5: () => getConsole,
    Uf: () => isBeaconsSupported,
    Z: () => hasJSON,
    cU: () => setEnableEnvMocks,
    g$: () => getLocation,
    hm: () => getJSON,
    iN: () => getMsCrypto,
    lT: () => isIE,
    lV: () => isReactNative,
    xk: () => isXhrSupported
   });
   var _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(45664), _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(269), _DynamicConstants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(6182), _HelperFuncs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(13673), _InternalConstants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(96492), strDocumentMode = "documentMode", strLocation = "location", strConsole = "console", strJSON = "JSON", strCrypto = "crypto", strMsCrypto = "msCrypto", strReactNative = "ReactNative", strMsie = "msie", strTrident = "trident/", strXMLHttpRequest = "XMLHttpRequest", _isTrident = null, _navUserAgentCheck = null, _enableMocks = !1, _useXDomainRequest = null, _beaconsSupported = null;
   function _hasProperty(theClass, property) {
    var supported = !1;
    if (theClass) {
     try {
      if (!(supported = property in theClass)) {
       var proto = theClass[_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__.vR];
       proto && (supported = property in proto);
      }
     } catch (e) {}
     if (!supported) try {
      var tmp = new theClass;
      supported = !(0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.b07)(tmp[property]);
     } catch (e) {}
    }
    return supported;
   }
   function setEnableEnvMocks(enabled) {
    _enableMocks = enabled;
   }
   function getLocation(checkForMock) {
    if (checkForMock && _enableMocks) {
     var mockLocation = (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.zS2)("__mockLocation");
     if (mockLocation) return mockLocation;
    }
    return typeof location === _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__._1 && location ? location : (0, 
    _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.zS2)(strLocation);
   }
   function getConsole() {
    return typeof console !== _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__.bA ? console : (0, 
    _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.zS2)(strConsole);
   }
   function hasJSON() {
    return Boolean(typeof JSON === _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__._1 && JSON || null !== (0, 
    _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.zS2)(strJSON));
   }
   function getJSON() {
    return hasJSON() ? JSON || (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.zS2)(strJSON) : null;
   }
   function getCrypto() {
    return (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.zS2)(strCrypto);
   }
   function getMsCrypto() {
    return (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.zS2)(strMsCrypto);
   }
   function isReactNative() {
    var nav = (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.w3n)();
    return !(!nav || !nav.product) && nav.product === strReactNative;
   }
   function isIE() {
    var nav = (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.w3n)();
    if (nav && (nav[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__.tX] !== _navUserAgentCheck || null === _isTrident)) {
     var userAgent = ((_navUserAgentCheck = nav[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__.tX]) || _InternalConstants__WEBPACK_IMPORTED_MODULE_3__.m5)[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__.OL]();
     _isTrident = (0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_4__.Ju)(userAgent, strMsie) || (0, 
     _HelperFuncs__WEBPACK_IMPORTED_MODULE_4__.Ju)(userAgent, strTrident);
    }
    return _isTrident;
   }
   function getIEVersion(userAgentStr) {
    if (void 0 === userAgentStr && (userAgentStr = null), !userAgentStr) {
     var navigator_1 = (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.w3n)() || {};
     userAgentStr = navigator_1 ? (navigator_1.userAgent || _InternalConstants__WEBPACK_IMPORTED_MODULE_3__.m5)[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__.OL]() : _InternalConstants__WEBPACK_IMPORTED_MODULE_3__.m5;
    }
    var ua = (userAgentStr || _InternalConstants__WEBPACK_IMPORTED_MODULE_3__.m5)[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__.OL]();
    if ((0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_4__.Ju)(ua, strMsie)) {
     var doc = (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.YEm)() || {};
     return Math.max(parseInt(ua[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__.sY](strMsie)[1]), doc[strDocumentMode] || 0);
    }
    if ((0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_4__.Ju)(ua, strTrident)) {
     var tridentVer = parseInt(ua[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__.sY](strTrident)[1]);
     if (tridentVer) return tridentVer + 4;
    }
    return null;
   }
   function isBeaconsSupported(useCached) {
    return null !== _beaconsSupported && !1 !== useCached || (_beaconsSupported = (0, 
    _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.w9M)() && Boolean((0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.w3n)().sendBeacon)), 
    _beaconsSupported;
   }
   function isFetchSupported(withKeepAlive) {
    var isSupported = !1;
    try {
     isSupported = !!(0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.zS2)("fetch");
     var request = (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.zS2)("Request");
     isSupported && withKeepAlive && request && (isSupported = _hasProperty(request, "keepalive"));
    } catch (e) {}
    return isSupported;
   }
   function useXDomainRequest() {
    return null === _useXDomainRequest && (_useXDomainRequest = typeof XDomainRequest !== _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__.bA) && isXhrSupported() && (_useXDomainRequest = _useXDomainRequest && !_hasProperty((0, 
    _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.zS2)(strXMLHttpRequest), "withCredentials")), 
    _useXDomainRequest;
   }
   function isXhrSupported() {
    var isSupported = !1;
    try {
     isSupported = !!(0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.zS2)(strXMLHttpRequest);
    } catch (e) {}
    return isSupported;
   }
   function _getNamedValue(values, name) {
    if (values) for (var i = 0; i < values[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__.oI]; i++) {
     var value = values[i];
     if (value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__.RS] && value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__.RS] === name) return value;
    }
    return {};
   }
   function findMetaTag(name) {
    var doc = (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.YEm)();
    return doc && name ? _getNamedValue(doc.querySelectorAll("meta"), name).content : null;
   }
   function findNamedServerTiming(name) {
    var value, perf = (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.FJj)();
    if (perf) {
     var navPerf = perf.getEntriesByType("navigation") || [];
     value = _getNamedValue((navPerf[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__.oI] > 0 ? navPerf[0] : {}).serverTiming, name).description;
    }
    return value;
   }
  },
  56149: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    Ds: () => removePageUnloadEventListener,
    El: () => __getRegisteredEvents,
    Fc: () => addPageHideEventListener,
    Hm: () => mergeEvtNamespace,
    ML: () => eventOff,
    Q3: () => attachEvent,
    So: () => addEventHandler,
    Wg: () => removeEventListeners,
    Ym: () => detachEvent,
    ee: () => addPageUnloadEventListener,
    lQ: () => addEventListeners,
    mB: () => eventOn,
    oS: () => addPageShowEventListener,
    sq: () => removePageHideEventListener,
    vF: () => removePageShowEventListener,
    zh: () => removeEventHandler
   });
   var _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(269), _DynamicConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6182), _DataCacheHelper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(24276), _InternalConstants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(96492), strOnPrefix = "on", strAttachEvent = "attachEvent", strAddEventHelper = "addEventListener", strDetachEvent = "detachEvent", strRemoveEventListener = "removeEventListener", strEvents = "events", strVisibilityChangeEvt = "visibilitychange", strPageHide = "pagehide", strPageShow = "pageshow", strUnload = "unload", strBeforeUnload = "beforeunload", strPageHideNamespace = (0, 
   _DataCacheHelper__WEBPACK_IMPORTED_MODULE_0__.Z)("aiEvtPageHide"), strPageShowNamespace = (0, 
   _DataCacheHelper__WEBPACK_IMPORTED_MODULE_0__.Z)("aiEvtPageShow"), rRemoveEmptyNs = /\.[\.]+/g, rRemoveTrailingEmptyNs = /[\.]+$/, _guid = 1, elmNodeData = (0, 
   _DataCacheHelper__WEBPACK_IMPORTED_MODULE_0__.T)("events"), eventNamespace = /^([^.]*)(?:\.(.+)|)/;
   function _normalizeNamespace(name) {
    return name && name[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.W7] ? name[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.W7](/^[\s\.]+|(?=[\s\.])[\.\s]+$/g, _InternalConstants__WEBPACK_IMPORTED_MODULE_2__.m5) : name;
   }
   function _getEvtNamespace(eventName, evtNamespace) {
    var _a;
    if (evtNamespace) {
     var theNamespace_1 = _InternalConstants__WEBPACK_IMPORTED_MODULE_2__.m5;
     (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.cyL)(evtNamespace) ? (theNamespace_1 = _InternalConstants__WEBPACK_IMPORTED_MODULE_2__.m5, 
     (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.Iuo)(evtNamespace, (function(name) {
      (name = _normalizeNamespace(name)) && ("." !== name[0] && (name = "." + name), theNamespace_1 += name);
     }))) : theNamespace_1 = _normalizeNamespace(evtNamespace), theNamespace_1 && ("." !== theNamespace_1[0] && (theNamespace_1 = "." + theNamespace_1), 
     eventName = (eventName || _InternalConstants__WEBPACK_IMPORTED_MODULE_2__.m5) + theNamespace_1);
    }
    var parsedEvent = eventNamespace.exec(eventName || _InternalConstants__WEBPACK_IMPORTED_MODULE_2__.m5) || [];
    return (_a = {})[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.QM] = parsedEvent[1], 
    _a.ns = (parsedEvent[2] || _InternalConstants__WEBPACK_IMPORTED_MODULE_2__.m5).replace(rRemoveEmptyNs, ".").replace(rRemoveTrailingEmptyNs, _InternalConstants__WEBPACK_IMPORTED_MODULE_2__.m5)[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.sY](".").sort().join("."), 
    _a;
   }
   function __getRegisteredEvents(target, eventName, evtNamespace) {
    var theEvents = [], eventCache = elmNodeData.get(target, strEvents, {}, !1), evtName = _getEvtNamespace(eventName, evtNamespace);
    return (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.zav)(eventCache, (function(evtType, registeredEvents) {
     (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.Iuo)(registeredEvents, (function(value) {
      var _a;
      evtName[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.QM] && evtName[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.QM] !== value.evtName[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.QM] || evtName.ns && evtName.ns != evtName.ns || theEvents[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.y5](((_a = {})[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.RS] = value.evtName[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.QM] + (value.evtName.ns ? "." + value.evtName.ns : _InternalConstants__WEBPACK_IMPORTED_MODULE_2__.m5), 
      _a.handler = value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.Yo], _a));
     }));
    })), theEvents;
   }
   function _getRegisteredEvents(target, evtName, addDefault) {
    void 0 === addDefault && (addDefault = !0);
    var aiEvts = elmNodeData.get(target, strEvents, {}, addDefault), registeredEvents = aiEvts[evtName];
    return registeredEvents || (registeredEvents = aiEvts[evtName] = []), registeredEvents;
   }
   function _doDetach(obj, evtName, handlerRef, useCapture) {
    obj && evtName && evtName[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.QM] && (obj[strRemoveEventListener] ? obj[strRemoveEventListener](evtName[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.QM], handlerRef, useCapture) : obj[strDetachEvent] && obj[strDetachEvent](strOnPrefix + evtName[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.QM], handlerRef));
   }
   function _doUnregister(target, events, evtName, unRegFn) {
    for (var idx = events[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.oI]; idx--; ) {
     var theEvent = events[idx];
     theEvent && (evtName.ns && evtName.ns !== theEvent.evtName.ns || unRegFn && !unRegFn(theEvent) || (_doDetach(target, theEvent.evtName, theEvent[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.Yo], theEvent.capture), 
     events[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.Ic](idx, 1)));
    }
   }
   function mergeEvtNamespace(theNamespace, namespaces) {
    return namespaces ? _getEvtNamespace("xx", (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.cyL)(namespaces) ? [ theNamespace ].concat(namespaces) : [ theNamespace, namespaces ]).ns[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.sY](".") : theNamespace;
   }
   function eventOn(target, eventName, handlerRef, evtNamespace, useCapture) {
    var _a;
    void 0 === useCapture && (useCapture = !1);
    var result = !1;
    if (target) try {
     var evtName = _getEvtNamespace(eventName, evtNamespace);
     if (result = function(obj, evtName, handlerRef, useCapture) {
      var result = !1;
      return obj && evtName && evtName[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.QM] && handlerRef && (obj[strAddEventHelper] ? (obj[strAddEventHelper](evtName[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.QM], handlerRef, useCapture), 
      result = !0) : obj[strAttachEvent] && (obj[strAttachEvent](strOnPrefix + evtName[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.QM], handlerRef), 
      result = !0)), result;
     }(target, evtName, handlerRef, useCapture), result && elmNodeData.accept(target)) {
      var registeredEvent = ((_a = {
       guid: _guid++,
       evtName
      })[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.Yo] = handlerRef, _a.capture = useCapture, 
      _a);
      _getRegisteredEvents(target, evtName.type)[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.y5](registeredEvent);
     }
    } catch (e) {}
    return result;
   }
   function eventOff(target, eventName, handlerRef, evtNamespace, useCapture) {
    if (void 0 === useCapture && (useCapture = !1), target) try {
     var evtName_1 = _getEvtNamespace(eventName, evtNamespace), found_1 = !1;
     !function(target, evtName, unRegFn) {
      if (evtName[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.QM]) _doUnregister(target, _getRegisteredEvents(target, evtName[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.QM]), evtName, unRegFn); else {
       var eventCache = elmNodeData.get(target, strEvents, {});
       (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.zav)(eventCache, (function(evtType, events) {
        _doUnregister(target, events, evtName, unRegFn);
       })), 0 === (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.cGk)(eventCache)[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.oI] && elmNodeData.kill(target, strEvents);
      }
     }(target, evtName_1, (function(regEvent) {
      return !((!evtName_1.ns || handlerRef) && regEvent[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.Yo] !== handlerRef) && (found_1 = !0, 
      !0);
     })), found_1 || _doDetach(target, evtName_1, handlerRef, useCapture);
    } catch (e) {}
   }
   function attachEvent(obj, eventNameWithoutOn, handlerRef, useCapture) {
    return void 0 === useCapture && (useCapture = !1), eventOn(obj, eventNameWithoutOn, handlerRef, null, useCapture);
   }
   function detachEvent(obj, eventNameWithoutOn, handlerRef, useCapture) {
    void 0 === useCapture && (useCapture = !1), eventOff(obj, eventNameWithoutOn, handlerRef, null, useCapture);
   }
   function addEventHandler(eventName, callback, evtNamespace) {
    var result = !1, w = (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.zkX)();
    w && (result = eventOn(w, eventName, callback, evtNamespace), result = eventOn(w.body, eventName, callback, evtNamespace) || result);
    var doc = (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.YEm)();
    return doc && (result = eventOn(doc, eventName, callback, evtNamespace) || result), 
    result;
   }
   function removeEventHandler(eventName, callback, evtNamespace) {
    var w = (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.zkX)();
    w && (eventOff(w, eventName, callback, evtNamespace), eventOff(w.body, eventName, callback, evtNamespace));
    var doc = (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.YEm)();
    doc && eventOff(doc, eventName, callback, evtNamespace);
   }
   function _addEventListeners(events, listener, excludeEvents, evtNamespace) {
    var added = !1;
    return listener && events && events[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.oI] > 0 && (0, 
    _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.Iuo)(events, (function(name) {
     name && (excludeEvents && -1 !== (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.rDm)(excludeEvents, name) || (added = addEventHandler(name, listener, evtNamespace) || added));
    })), added;
   }
   function addEventListeners(events, listener, excludeEvents, evtNamespace) {
    var added = !1;
    return listener && events && (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.cyL)(events) && !(added = _addEventListeners(events, listener, excludeEvents, evtNamespace)) && excludeEvents && excludeEvents[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.oI] > 0 && (added = _addEventListeners(events, listener, null, evtNamespace)), 
    added;
   }
   function removeEventListeners(events, listener, evtNamespace) {
    events && (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.cyL)(events) && (0, 
    _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.Iuo)(events, (function(name) {
     name && removeEventHandler(name, listener, evtNamespace);
    }));
   }
   function addPageUnloadEventListener(listener, excludeEvents, evtNamespace) {
    return addEventListeners([ strBeforeUnload, strUnload, strPageHide ], listener, excludeEvents, evtNamespace);
   }
   function removePageUnloadEventListener(listener, evtNamespace) {
    removeEventListeners([ strBeforeUnload, strUnload, strPageHide ], listener, evtNamespace);
   }
   function addPageHideEventListener(listener, excludeEvents, evtNamespace) {
    var newNamespaces = mergeEvtNamespace(strPageHideNamespace, evtNamespace), pageUnloadAdded = _addEventListeners([ strPageHide ], listener, excludeEvents, newNamespaces);
    return excludeEvents && -1 !== (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.rDm)(excludeEvents, strVisibilityChangeEvt) || (pageUnloadAdded = _addEventListeners([ strVisibilityChangeEvt ], (function(evt) {
     var doc = (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.YEm)();
     listener && doc && "hidden" === doc.visibilityState && listener(evt);
    }), excludeEvents, newNamespaces) || pageUnloadAdded), !pageUnloadAdded && excludeEvents && (pageUnloadAdded = addPageHideEventListener(listener, null, evtNamespace)), 
    pageUnloadAdded;
   }
   function removePageHideEventListener(listener, evtNamespace) {
    var newNamespaces = mergeEvtNamespace(strPageHideNamespace, evtNamespace);
    removeEventListeners([ strPageHide ], listener, newNamespaces), removeEventListeners([ strVisibilityChangeEvt ], null, newNamespaces);
   }
   function addPageShowEventListener(listener, excludeEvents, evtNamespace) {
    var newNamespaces = mergeEvtNamespace(strPageShowNamespace, evtNamespace), pageShowAdded = _addEventListeners([ strPageShow ], listener, excludeEvents, newNamespaces);
    return !(pageShowAdded = _addEventListeners([ strVisibilityChangeEvt ], (function(evt) {
     var doc = (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.YEm)();
     listener && doc && "visible" === doc.visibilityState && listener(evt);
    }), excludeEvents, newNamespaces) || pageShowAdded) && excludeEvents && (pageShowAdded = addPageShowEventListener(listener, null, evtNamespace)), 
    pageShowAdded;
   }
   function removePageShowEventListener(listener, evtNamespace) {
    var newNamespaces = mergeEvtNamespace(strPageShowNamespace, evtNamespace);
    removeEventListeners([ strPageShow ], listener, newNamespaces), removeEventListeners([ strVisibilityChangeEvt ], null, newNamespaces);
   }
  },
  13673: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    CP: () => objExtend,
    Gh: () => isNotNullOrUndefined,
    H$: () => openXhr,
    HU: () => formatErrorMessageXdr,
    IL: () => convertAllHeadersToMap,
    Ju: () => strContains,
    KY: () => setValue,
    LU: () => _appendHeader,
    Lo: () => getResponseText,
    RF: () => proxyFunctionAs,
    SZ: () => createClassFromInterface,
    _u: () => toISOString,
    c2: () => getSetValue,
    cH: () => normalizeJsName,
    hW: () => optimizeObject,
    jL: () => prependTransports,
    lL: () => getExceptionName,
    o$: () => proxyFunctions,
    qz: () => proxyAssign,
    r4: () => formatErrorMessageXhr,
    w3: () => _getAllResponseHeaders
   });
   var _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(269), _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(45664), _DynamicConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6182), _InternalConstants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(96492), rCamelCase = /-([a-z])/g, rNormalizeInvalid = /([^\w\d_$])/g, rLeadingNumeric = /^(\d+[\w\d_$])/;
   Object.getPrototypeOf;
   function isNotNullOrUndefined(value) {
    return !(0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.hXl)(value);
   }
   function normalizeJsName(name) {
    var value = name;
    return value && (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.KgX)(value) && (value = (value = (value = value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.W7](rCamelCase, (function(_all, letter) {
     return letter.toUpperCase();
    })))[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.W7](rNormalizeInvalid, "_"))[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.W7](rLeadingNumeric, (function(_all, match) {
     return "_" + match;
    }))), value;
   }
   function strContains(value, search) {
    return !(!value || !search) && -1 !== (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.HzD)(value, search);
   }
   function toISOString(date) {
    return date && date.toISOString() || "";
   }
   function getExceptionName(object) {
    return (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.bJ7)(object) ? object[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.RS] : _InternalConstants__WEBPACK_IMPORTED_MODULE_2__.m5;
   }
   function setValue(target, field, value, valChk, srcChk) {
    var theValue = value;
    return target && ((theValue = target[field]) === value || srcChk && !srcChk(theValue) || valChk && !valChk(value) || (theValue = value, 
    target[field] = theValue)), theValue;
   }
   function getSetValue(target, field, defValue) {
    var theValue;
    return target ? !(theValue = target[field]) && (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.hXl)(theValue) && (theValue = (0, 
    _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.b07)(defValue) ? {} : defValue, 
    target[field] = theValue) : theValue = (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.b07)(defValue) ? {} : defValue, 
    theValue;
   }
   function _createProxyFunction(source, funcName) {
    var srcFunc = null, src = null;
    return (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.Tnt)(source) ? srcFunc = source : src = source, 
    function() {
     var originalArguments = arguments;
     if (srcFunc && (src = srcFunc()), src) return src[funcName][_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.y9](src, originalArguments);
    };
   }
   function proxyAssign(target, source, chkSet) {
    if (target && source && (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.Gvm)(target) && (0, 
    _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.Gvm)(source)) {
     var _loop_1 = function(field) {
      if ((0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.KgX)(field)) {
       var value = source[field];
       (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.Tnt)(value) ? chkSet && !chkSet(field, !0, source, target) || (target[field] = _createProxyFunction(source, field)) : chkSet && !chkSet(field, !1, source, target) || ((0, 
       _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.KhI)(target, field) && delete target[field], 
       (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.vF1)(target, field, {
        g: function() {
         return source[field];
        },
        s: function(theValue) {
         source[field] = theValue;
        }
       }));
      }
     };
     for (var field in source) _loop_1(field);
    }
    return target;
   }
   function proxyFunctionAs(target, name, source, theFunc, overwriteTarget) {
    target && name && source && (!1 !== overwriteTarget || (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.b07)(target[name])) && (target[name] = _createProxyFunction(source, theFunc));
   }
   function proxyFunctions(target, source, functionsToProxy, overwriteTarget) {
    return target && source && (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.Gvm)(target) && (0, 
    _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.cyL)(functionsToProxy) && (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.Iuo)(functionsToProxy, (function(theFuncName) {
     (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.KgX)(theFuncName) && proxyFunctionAs(target, theFuncName, source, theFuncName, overwriteTarget);
    })), target;
   }
   function createClassFromInterface(defaults) {
    return function() {
     var _this = this;
     defaults && (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.zav)(defaults, (function(field, value) {
      _this[field] = value;
     }));
    };
   }
   function optimizeObject(theObject) {
    return theObject && _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.vE3 && (theObject = (0, 
    _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_3__.s6)((0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.vE3)({}, theObject))), 
    theObject;
   }
   function objExtend(obj1, obj2, obj3, obj4, obj5, obj6) {
    var theArgs = arguments, extended = theArgs[0] || {}, argLen = theArgs[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.oI], deep = !1, idx = 1;
    for (argLen > 0 && (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.Lmq)(extended) && (deep = extended, 
    extended = theArgs[idx] || {}, idx++), (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.Gvm)(extended) || (extended = {}); idx < argLen; idx++) {
     var arg = theArgs[idx], isArgArray = (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.cyL)(arg), isArgObj = (0, 
     _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.Gvm)(arg);
     for (var prop in arg) {
      if (isArgArray && prop in arg || isArgObj && (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.KhI)(arg, prop)) {
       var newValue = arg[prop], isNewArray = void 0;
       if (deep && newValue && ((isNewArray = (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.cyL)(newValue)) || (0, 
       _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.QdQ)(newValue))) {
        var clone = extended[prop];
        isNewArray ? (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.cyL)(clone) || (clone = []) : (0, 
        _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.QdQ)(clone) || (clone = {}), newValue = objExtend(deep, clone, newValue);
       }
       void 0 !== newValue && (extended[prop] = newValue);
      }
     }
    }
    return extended;
   }
   function getResponseText(xhr) {
    try {
     return xhr.responseText;
    } catch (e) {}
    return null;
   }
   function formatErrorMessageXdr(xdr, message) {
    return xdr ? "XDomainRequest,Response:" + getResponseText(xdr) || 0 : message;
   }
   function formatErrorMessageXhr(xhr, message) {
    return xhr ? "XMLHttpRequest,Status:" + xhr[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.cV] + ",Response:" + getResponseText(xhr) || 0 : message;
   }
   function prependTransports(theTransports, newTransports) {
    return newTransports && ((0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.EtT)(newTransports) ? theTransports = [ newTransports ].concat(theTransports) : (0, 
    _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.cyL)(newTransports) && (theTransports = newTransports.concat(theTransports))), 
    theTransports;
   }
   var strDisabledPropertyName = "Microsoft_ApplicationInsights_BypassAjaxInstrumentation", strWithCredentials = "withCredentials", strTimeout = "timeout";
   function openXhr(method, urlString, withCredentials, disabled, isSync, timeout) {
    function _wrapSetXhrProp(xhr, prop, value) {
     try {
      xhr[prop] = value;
     } catch (e) {}
    }
    void 0 === disabled && (disabled = !1), void 0 === isSync && (isSync = !1);
    var xhr = new XMLHttpRequest;
    return disabled && _wrapSetXhrProp(xhr, strDisabledPropertyName, disabled), withCredentials && _wrapSetXhrProp(xhr, strWithCredentials, withCredentials), 
    xhr.open(method, urlString, !isSync), withCredentials && _wrapSetXhrProp(xhr, strWithCredentials, withCredentials), 
    !isSync && timeout && _wrapSetXhrProp(xhr, strTimeout, timeout), xhr;
   }
   function convertAllHeadersToMap(headersString) {
    var headers = {};
    if ((0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.KgX)(headersString)) {
     var headersArray = (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.EHq)(headersString)[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.sY](/[\r\n]+/);
     (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.Iuo)(headersArray, (function(headerEntry) {
      if (headerEntry) {
       var idx = headerEntry.indexOf(": ");
       if (-1 !== idx) {
        var header = (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.EHq)(headerEntry.substring(0, idx))[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.OL](), value = (0, 
        _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.EHq)(headerEntry.substring(idx + 1));
        headers[header] = value;
       } else headers[(0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.EHq)(headerEntry)] = 1;
      }
     }));
    }
    return headers;
   }
   function _appendHeader(theHeaders, xhr, name) {
    if (!theHeaders[name] && xhr && xhr[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.Az]) {
     var value = xhr[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.Az](name);
     value && (theHeaders[name] = (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.EHq)(value));
    }
    return theHeaders;
   }
   var STR_KILL_DURATION_HEADER = "kill-duration", STR_KILL_DURATION_SECONDS_HEADER = "kill-duration-seconds", STR_TIME_DELTA_HEADER = "time-delta-millis";
   function _getAllResponseHeaders(xhr, isOneDs) {
    var theHeaders = {};
    return xhr[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.wJ] ? theHeaders = convertAllHeadersToMap(xhr[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.wJ]()) : isOneDs && (theHeaders = _appendHeader(theHeaders, xhr, STR_TIME_DELTA_HEADER), 
    theHeaders = _appendHeader(theHeaders, xhr, STR_KILL_DURATION_HEADER), theHeaders = _appendHeader(theHeaders, xhr, STR_KILL_DURATION_SECONDS_HEADER)), 
    theHeaders;
   }
  },
  96492: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    Bw: () => STR_EXTENSION_CONFIG,
    Ev: () => STR_OFFLINE_DROP,
    Fk: () => STR_DOMAIN,
    HP: () => UNDEFINED_VALUE,
    Hr: () => STR_DISABLED,
    LZ: () => STR_CHANNELS,
    QW: () => STR_PATH,
    Vj: () => STR_OFFLINE_SENT,
    Vo: () => STR_PRIORITY,
    Yd: () => STR_CREATE_PERF_MGR,
    Yp: () => STR_EVENTS_DISCARDED,
    dI: () => STR_EVENTS_SEND_REQUEST,
    eT: () => STR_CORE,
    fc: () => STR_EVENTS_SENT,
    jy: () => STR_EXTENSIONS,
    kI: () => STR_GET_PERF_MGR,
    l0: () => STR_PERF_EVENT,
    m5: () => STR_EMPTY,
    qT: () => STR_PROCESS_TELEMETRY,
    s4: () => STR_OFFLINE_STORE,
    xW: () => STR_NOT_DYNAMIC_ERROR
   });
   var UNDEFINED_VALUE = void 0, STR_EMPTY = "", STR_CHANNELS = "channels", STR_CORE = "core", STR_CREATE_PERF_MGR = "createPerfMgr", STR_DISABLED = "disabled", STR_EXTENSION_CONFIG = "extensionConfig", STR_EXTENSIONS = "extensions", STR_PROCESS_TELEMETRY = "processTelemetry", STR_PRIORITY = "priority", STR_EVENTS_SENT = "eventsSent", STR_EVENTS_DISCARDED = "eventsDiscarded", STR_EVENTS_SEND_REQUEST = "eventsSendRequest", STR_PERF_EVENT = "perfEvent", STR_OFFLINE_STORE = "offlineEventsStored", STR_OFFLINE_SENT = "offlineBatchSent", STR_OFFLINE_DROP = "offlineBatchDrop", STR_GET_PERF_MGR = "getPerfMgr", STR_DOMAIN = "domain", STR_PATH = "path", STR_NOT_DYNAMIC_ERROR = "Not dynamic - ";
  },
  51356: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    h: () => NotificationManager
   });
   var _microsoft_dynamicproto_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(68279), _nevware21_ts_async__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(8205), _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(269), _Config_DynamicConfig__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(19749), _DynamicConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6182), _InternalConstants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(96492), defaultValues = {
    perfEvtsSendAll: !1
   };
   function _runScheduledListeners(asyncNotifications) {
    asyncNotifications.h = null;
    var callbacks = asyncNotifications.cb;
    asyncNotifications.cb = [], (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.Iuo)(callbacks, (function(cb) {
     (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.gBW)(cb.fn, [ cb.arg ]);
    }));
   }
   function _runListeners(listeners, name, asyncNotifications, callback) {
    (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.Iuo)(listeners, (function(listener) {
     listener && listener[name] && (asyncNotifications ? (asyncNotifications.cb[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.y5]({
      fn: callback,
      arg: listener
     }), asyncNotifications.h = asyncNotifications.h || (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.dRz)(_runScheduledListeners, 0, asyncNotifications)) : (0, 
     _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.gBW)(callback, [ listener ]));
    }));
   }
   var NotificationManager = function() {
    function NotificationManager(config) {
     var perfEvtsSendAll, unloadHandler;
     this.listeners = [];
     var _listeners = [], _asyncNotifications = {
      h: null,
      cb: []
     }, cfgHandler = (0, _Config_DynamicConfig__WEBPACK_IMPORTED_MODULE_2__.e)(config, defaultValues);
     unloadHandler = cfgHandler[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.x6]((function(details) {
      perfEvtsSendAll = !!details.cfg.perfEvtsSendAll;
     })), (0, _microsoft_dynamicproto_js__WEBPACK_IMPORTED_MODULE_3__.A)(NotificationManager, this, (function(_self) {
      (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.vF1)(_self, "listeners", {
       g: function() {
        return _listeners;
       }
      }), _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.vR] = function(listener) {
       _listeners[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.y5](listener);
      }, _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.h3] = function(listener) {
       for (var index = (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.rDm)(_listeners, listener); index > -1; ) _listeners[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.Ic](index, 1), 
       index = (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.rDm)(_listeners, listener);
      }, _self[_InternalConstants__WEBPACK_IMPORTED_MODULE_4__.fc] = function(events) {
       _runListeners(_listeners, _InternalConstants__WEBPACK_IMPORTED_MODULE_4__.fc, _asyncNotifications, (function(listener) {
        listener[_InternalConstants__WEBPACK_IMPORTED_MODULE_4__.fc](events);
       }));
      }, _self[_InternalConstants__WEBPACK_IMPORTED_MODULE_4__.Yp] = function(events, reason) {
       _runListeners(_listeners, _InternalConstants__WEBPACK_IMPORTED_MODULE_4__.Yp, _asyncNotifications, (function(listener) {
        listener[_InternalConstants__WEBPACK_IMPORTED_MODULE_4__.Yp](events, reason);
       }));
      }, _self[_InternalConstants__WEBPACK_IMPORTED_MODULE_4__.dI] = function(sendReason, isAsync) {
       _runListeners(_listeners, _InternalConstants__WEBPACK_IMPORTED_MODULE_4__.dI, isAsync ? _asyncNotifications : null, (function(listener) {
        listener[_InternalConstants__WEBPACK_IMPORTED_MODULE_4__.dI](sendReason, isAsync);
       }));
      }, _self[_InternalConstants__WEBPACK_IMPORTED_MODULE_4__.l0] = function(perfEvent) {
       perfEvent && (!perfEvtsSendAll && perfEvent[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.Zu]() || _runListeners(_listeners, _InternalConstants__WEBPACK_IMPORTED_MODULE_4__.l0, null, (function(listener) {
        perfEvent[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.tI] ? (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.dRz)((function() {
         return listener[_InternalConstants__WEBPACK_IMPORTED_MODULE_4__.l0](perfEvent);
        }), 0) : listener[_InternalConstants__WEBPACK_IMPORTED_MODULE_4__.l0](perfEvent);
       })));
      }, _self[_InternalConstants__WEBPACK_IMPORTED_MODULE_4__.s4] = function(events) {
       events && events[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.oI] && _runListeners(_listeners, _InternalConstants__WEBPACK_IMPORTED_MODULE_4__.s4, _asyncNotifications, (function(listener) {
        listener[_InternalConstants__WEBPACK_IMPORTED_MODULE_4__.s4](events);
       }));
      }, _self[_InternalConstants__WEBPACK_IMPORTED_MODULE_4__.Vj] = function(batch) {
       batch && batch[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.Cd] && _runListeners(_listeners, _InternalConstants__WEBPACK_IMPORTED_MODULE_4__.Vj, _asyncNotifications, (function(listener) {
        listener[_InternalConstants__WEBPACK_IMPORTED_MODULE_4__.Vj](batch);
       }));
      }, _self[_InternalConstants__WEBPACK_IMPORTED_MODULE_4__.Ev] = function(cnt, reason) {
       if (cnt > 0) {
        var rn_1 = reason || 0;
        _runListeners(_listeners, _InternalConstants__WEBPACK_IMPORTED_MODULE_4__.Ev, _asyncNotifications, (function(listener) {
         listener[_InternalConstants__WEBPACK_IMPORTED_MODULE_4__.Ev](cnt, rn_1);
        }));
       }
      }, _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.M5] = function(isAsync) {
       var waiting, _finishUnload = function() {
        unloadHandler && unloadHandler.rm(), unloadHandler = null, _listeners = [], _asyncNotifications.h && _asyncNotifications.h[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._w](), 
        _asyncNotifications.h = null, _asyncNotifications.cb = [];
       };
       if (_runListeners(_listeners, "unload", null, (function(listener) {
        var asyncUnload = listener[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.M5](isAsync);
        asyncUnload && (waiting || (waiting = []), waiting[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.y5](asyncUnload));
       })), waiting) return (0, _nevware21_ts_async__WEBPACK_IMPORTED_MODULE_5__.Qo)((function(resolve) {
        return (0, _nevware21_ts_async__WEBPACK_IMPORTED_MODULE_5__.Dv)((0, _nevware21_ts_async__WEBPACK_IMPORTED_MODULE_5__.Xf)(waiting), (function() {
         _finishUnload(), resolve();
        }));
       }));
       _finishUnload();
      };
     }));
    }
    return NotificationManager.__ieDyn = 1, NotificationManager;
   }();
  },
  28156: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    NS: () => PerfManager,
    Q6: () => PerfEvent,
    Z4: () => getGblPerfMgr,
    r2: () => doPerf
   });
   var _microsoft_dynamicproto_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(68279), _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(269), _DynamicConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6182), _InternalConstants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(96492), strParentContextKey = "ParentContextKey", strChildrenContextKey = "ChildrenContextKey", _defaultPerfManager = null, PerfEvent = function() {
    function PerfEvent(name, payloadDetails, isAsync) {
     var theDetails_1, _self = this;
     (_self.start = (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.f0d)(), _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.RS] = name, 
     _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.tI] = isAsync, _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.Zu] = function() {
      return !1;
     }, (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.Tnt)(payloadDetails)) && (0, 
     _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.vF1)(_self, "payload", {
      g: function() {
       return !theDetails_1 && (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.Tnt)(payloadDetails) && (theDetails_1 = payloadDetails(), 
       payloadDetails = null), theDetails_1;
      }
     });
     _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.O_] = function(key) {
      return key ? key === PerfEvent[strParentContextKey] || key === PerfEvent[strChildrenContextKey] ? _self[key] : (_self.ctx || {})[key] : null;
     }, _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.e_] = function(key, value) {
      if (key) if (key === PerfEvent[strParentContextKey]) _self[key] || (_self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.Zu] = function() {
       return !0;
      }), _self[key] = value; else if (key === PerfEvent[strChildrenContextKey]) _self[key] = value; else {
       (_self.ctx = _self.ctx || {})[key] = value;
      }
     }, _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.Ru] = function() {
      var childTime = 0, childEvts = _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.O_](PerfEvent[strChildrenContextKey]);
      if ((0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.cyL)(childEvts)) for (var lp = 0; lp < childEvts[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.oI]; lp++) {
       var childEvt = childEvts[lp];
       childEvt && (childTime += childEvt[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.fA]);
      }
      _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.fA] = (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.f0d)() - _self.start, 
      _self.exTime = _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.fA] - childTime, 
      _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.Ru] = function() {};
     };
    }
    return PerfEvent.ParentContextKey = "parent", PerfEvent.ChildrenContextKey = "childEvts", 
    PerfEvent;
   }(), PerfManager = function() {
    function PerfManager(manager) {
     this.ctx = {}, (0, _microsoft_dynamicproto_js__WEBPACK_IMPORTED_MODULE_2__.A)(PerfManager, this, (function(_self) {
      _self.create = function(src, payloadDetails, isAsync) {
       return new PerfEvent(src, payloadDetails, isAsync);
      }, _self.fire = function(perfEvent) {
       perfEvent && (perfEvent[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.Ru](), manager && (0, 
       _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.Tnt)(manager[_InternalConstants__WEBPACK_IMPORTED_MODULE_3__.l0]) && manager[_InternalConstants__WEBPACK_IMPORTED_MODULE_3__.l0](perfEvent));
      }, _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.e_] = function(key, value) {
       key && ((_self.ctx = _self.ctx || {})[key] = value);
      }, _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.O_] = function(key) {
       return (_self.ctx || {})[key];
      };
     }));
    }
    return PerfManager.__ieDyn = 1, PerfManager;
   }(), doPerfActiveKey = "CoreUtils.doPerf";
   function doPerf(mgrSource, getSource, func, details, isAsync) {
    if (mgrSource) {
     var perfMgr = mgrSource;
     if (perfMgr[_InternalConstants__WEBPACK_IMPORTED_MODULE_3__.kI] && (perfMgr = perfMgr[_InternalConstants__WEBPACK_IMPORTED_MODULE_3__.kI]()), 
     perfMgr) {
      var perfEvt = void 0, currentActive = perfMgr[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.O_](doPerfActiveKey);
      try {
       if (perfEvt = perfMgr.create(getSource(), details, isAsync)) {
        if (currentActive && perfEvt[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.e_] && (perfEvt[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.e_](PerfEvent[strParentContextKey], currentActive), 
        currentActive[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.O_] && currentActive[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.e_])) {
         var children = currentActive[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.O_](PerfEvent[strChildrenContextKey]);
         children || (children = [], currentActive[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.e_](PerfEvent[strChildrenContextKey], children)), 
         children[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.y5](perfEvt);
        }
        return perfMgr[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.e_](doPerfActiveKey, perfEvt), 
        func(perfEvt);
       }
      } catch (ex) {
       perfEvt && perfEvt[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.e_] && perfEvt[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.e_]("exception", ex);
      } finally {
       perfEvt && perfMgr.fire(perfEvt), perfMgr[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.e_](doPerfActiveKey, currentActive);
      }
     }
    }
    return func();
   }
   function getGblPerfMgr() {
    return _defaultPerfManager;
   }
  },
  72317: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    PV: () => createTelemetryProxyChain,
    W0: () => ProcessTelemetryContext,
    i8: () => createProcessTelemetryContext,
    nU: () => createProcessTelemetryUpdateContext,
    tS: () => createProcessTelemetryUnloadContext
   });
   var _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(269), _Config_ConfigDefaults__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(60991), _Config_DynamicConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(19749), _DynamicConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6182), _DiagnosticLogger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(23775), _HelperFuncs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(13673), _InternalConstants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(96492), _PerfManager__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(28156), _TelemetryHelpers__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(90380), strTelemetryPluginChain = "TelemetryPluginChain", strHasRunFlags = "_hasRun", strGetTelCtx = "_getTelCtx", _chainId = 0;
   function _createInternalContext(telemetryChain, dynamicHandler, core, startAt) {
    var _nextProxy = null, _onComplete = [];
    dynamicHandler || (dynamicHandler = (0, _Config_DynamicConfig__WEBPACK_IMPORTED_MODULE_1__.e)({}, null, core[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.Uw])), 
    null !== startAt && (_nextProxy = startAt ? function(proxy, core, startAt) {
     for (;proxy; ) {
      if (proxy[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.AP]() === startAt) return proxy;
      proxy = proxy[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.uR]();
     }
     return createTelemetryProxyChain([ startAt ], core.config || {}, core);
    }(telemetryChain, core, startAt) : telemetryChain);
    var context = {
     _next: function() {
      var nextProxy = _nextProxy;
      if (_nextProxy = nextProxy ? nextProxy[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.uR]() : null, 
      !nextProxy) {
       var onComplete = _onComplete;
       onComplete && onComplete[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.oI] > 0 && ((0, 
       _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.Iuo)(onComplete, (function(completeDetails) {
        try {
         completeDetails.func.call(completeDetails.self, completeDetails.args);
        } catch (e) {
         (0, _DiagnosticLogger__WEBPACK_IMPORTED_MODULE_2__.ZP)(core[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.Uw], 2, 73, "Unexpected Exception during onComplete - " + (0, 
         _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.mmD)(e));
        }
       })), _onComplete = []);
      }
      return nextProxy;
     },
     ctx: {
      core: function() {
       return core;
      },
      diagLog: function() {
       return (0, _DiagnosticLogger__WEBPACK_IMPORTED_MODULE_2__.y0)(core, dynamicHandler.cfg);
      },
      getCfg: function() {
       return dynamicHandler.cfg;
      },
      getExtCfg: function(identifier, defaultValues) {
       var newConfig = _getExtCfg(identifier, !0);
       defaultValues && (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.zav)(defaultValues, (function(field, defaultValue) {
        if ((0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.hXl)(newConfig[field])) {
         var cfgValue = dynamicHandler.cfg[field];
         !cfgValue && (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.hXl)(cfgValue) || (newConfig[field] = cfgValue);
        }
        (0, _Config_ConfigDefaults__WEBPACK_IMPORTED_MODULE_5__.q)(dynamicHandler, newConfig, field, defaultValue);
       }));
       return dynamicHandler[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.h0](newConfig, defaultValues);
      },
      getConfig: function(identifier, field, defaultValue) {
       void 0 === defaultValue && (defaultValue = !1);
       var theValue, extConfig = _getExtCfg(identifier, !1), rootConfig = dynamicHandler.cfg;
       !extConfig || !extConfig[field] && (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.hXl)(extConfig[field]) ? !rootConfig[field] && (0, 
       _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.hXl)(rootConfig[field]) || (theValue = rootConfig[field]) : theValue = extConfig[field];
       return theValue || !(0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.hXl)(theValue) ? theValue : defaultValue;
      },
      hasNext: function() {
       return !!_nextProxy;
      },
      getNext: function() {
       return _nextProxy;
      },
      setNext: function(nextPlugin) {
       _nextProxy = nextPlugin;
      },
      iterate: function(cb) {
       var nextPlugin;
       for (;nextPlugin = context._next(); ) {
        var plugin = nextPlugin[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.AP]();
        plugin && cb(plugin);
       }
      },
      onComplete: function(onComplete, that) {
       for (var args = [], _i = 2; _i < arguments.length; _i++) args[_i - 2] = arguments[_i];
       onComplete && _onComplete[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.y5]({
        func: onComplete,
        self: (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.b07)(that) ? context.ctx : that,
        args
       });
      }
     }
    };
    function _getExtCfg(identifier, createIfMissing) {
     var idCfg = null, cfg = dynamicHandler.cfg;
     if (cfg && identifier) {
      var extCfg = cfg[_InternalConstants__WEBPACK_IMPORTED_MODULE_4__.Bw];
      !extCfg && createIfMissing && (extCfg = {}), cfg[_InternalConstants__WEBPACK_IMPORTED_MODULE_4__.Bw] = extCfg, 
      (extCfg = dynamicHandler.ref(cfg, _InternalConstants__WEBPACK_IMPORTED_MODULE_4__.Bw)) && (!(idCfg = extCfg[identifier]) && createIfMissing && (idCfg = {}), 
      extCfg[identifier] = idCfg, idCfg = dynamicHandler.ref(extCfg, identifier));
     }
     return idCfg;
    }
    return context;
   }
   function createProcessTelemetryContext(telemetryChain, cfg, core, startAt) {
    var config = (0, _Config_DynamicConfig__WEBPACK_IMPORTED_MODULE_1__.e)(cfg), internalContext = _createInternalContext(telemetryChain, config, core, startAt), context = internalContext.ctx;
    return context[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.$5] = function(env) {
     var nextPlugin = internalContext._next();
     return nextPlugin && nextPlugin[_InternalConstants__WEBPACK_IMPORTED_MODULE_4__.qT](env, context), 
     !nextPlugin;
    }, context[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.$o] = function(plugins, startAt) {
     return void 0 === plugins && (plugins = null), (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.cyL)(plugins) && (plugins = createTelemetryProxyChain(plugins, config.cfg, core, startAt)), 
     createProcessTelemetryContext(plugins || context[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.uR](), config.cfg, core, startAt);
    }, context;
   }
   function createProcessTelemetryUnloadContext(telemetryChain, core, startAt) {
    var config = (0, _Config_DynamicConfig__WEBPACK_IMPORTED_MODULE_1__.e)(core.config), internalContext = _createInternalContext(telemetryChain, config, core, startAt), context = internalContext.ctx;
    return context[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.$5] = function(unloadState) {
     var nextPlugin = internalContext._next();
     return nextPlugin && nextPlugin[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.M5](context, unloadState), 
     !nextPlugin;
    }, context[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.$o] = function(plugins, startAt) {
     return void 0 === plugins && (plugins = null), (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.cyL)(plugins) && (plugins = createTelemetryProxyChain(plugins, config.cfg, core, startAt)), 
     createProcessTelemetryUnloadContext(plugins || context[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.uR](), core, startAt);
    }, context;
   }
   function createProcessTelemetryUpdateContext(telemetryChain, core, startAt) {
    var config = (0, _Config_DynamicConfig__WEBPACK_IMPORTED_MODULE_1__.e)(core.config), context = _createInternalContext(telemetryChain, config, core, startAt).ctx;
    return context[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.$5] = function(updateState) {
     return context.iterate((function(plugin) {
      (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.Tnt)(plugin[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.HC]) && plugin[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.HC](context, updateState);
     }));
    }, context[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.$o] = function(plugins, startAt) {
     return void 0 === plugins && (plugins = null), (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.cyL)(plugins) && (plugins = createTelemetryProxyChain(plugins, config.cfg, core, startAt)), 
     createProcessTelemetryUpdateContext(plugins || context[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.uR](), core, startAt);
    }, context;
   }
   function createTelemetryProxyChain(plugins, config, core, startAt) {
    var firstProxy = null, add = !startAt;
    if ((0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.cyL)(plugins) && plugins[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.oI] > 0) {
     var lastProxy_1 = null;
     (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.Iuo)(plugins, (function(thePlugin) {
      if (add || startAt !== thePlugin || (add = !0), add && thePlugin && (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.Tnt)(thePlugin[_InternalConstants__WEBPACK_IMPORTED_MODULE_4__.qT])) {
       var newProxy = function(plugin, config, core) {
        var chainId, nextProxy = null, hasProcessTelemetry = (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.Tnt)(plugin[_InternalConstants__WEBPACK_IMPORTED_MODULE_4__.qT]), hasSetNext = (0, 
        _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.Tnt)(plugin[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.YH]);
        chainId = plugin ? plugin[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.Ju] + "-" + plugin[_InternalConstants__WEBPACK_IMPORTED_MODULE_4__.Vo] + "-" + _chainId++ : "Unknown-0-" + _chainId++;
        var proxyChain = {
         getPlugin: function() {
          return plugin;
         },
         getNext: function() {
          return nextProxy;
         },
         processTelemetry: _processTelemetry,
         unload: _unloadPlugin,
         update: _updatePlugin,
         _id: chainId,
         _setNext: function(nextPlugin) {
          nextProxy = nextPlugin;
         }
        };
        function _getTelCtx() {
         var itemCtx;
         return plugin && (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.Tnt)(plugin[strGetTelCtx]) && (itemCtx = plugin[strGetTelCtx]()), 
         itemCtx || (itemCtx = createProcessTelemetryContext(proxyChain, config, core)), 
         itemCtx;
        }
        function _processChain(itemCtx, processPluginFn, name, details, isAsync) {
         var hasRun = !1, identifier = plugin ? plugin[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.Ju] : strTelemetryPluginChain, hasRunContext = itemCtx[strHasRunFlags];
         return hasRunContext || (hasRunContext = itemCtx[strHasRunFlags] = {}), itemCtx.setNext(nextProxy), 
         plugin && (0, _PerfManager__WEBPACK_IMPORTED_MODULE_6__.r2)(itemCtx[_InternalConstants__WEBPACK_IMPORTED_MODULE_4__.eT](), (function() {
          return identifier + ":" + name;
         }), (function() {
          hasRunContext[chainId] = !0;
          try {
           var nextId = nextProxy ? nextProxy._id : _InternalConstants__WEBPACK_IMPORTED_MODULE_4__.m5;
           nextId && (hasRunContext[nextId] = !1), hasRun = processPluginFn(itemCtx);
          } catch (error) {
           var hasNextRun = !nextProxy || hasRunContext[nextProxy._id];
           hasNextRun && (hasRun = !0), nextProxy && hasNextRun || (0, _DiagnosticLogger__WEBPACK_IMPORTED_MODULE_2__.ZP)(itemCtx[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.e4](), 1, 73, "Plugin [" + identifier + "] failed during " + name + " - " + (0, 
           _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.mmD)(error) + ", run flags: " + (0, 
           _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.mmD)(hasRunContext));
          }
         }), details, isAsync), hasRun;
        }
        function _processTelemetry(env, itemCtx) {
         function _callProcessTelemetry(itemCtx) {
          if (!plugin || !hasProcessTelemetry) return !1;
          var pluginState = (0, _TelemetryHelpers__WEBPACK_IMPORTED_MODULE_7__.Cr)(plugin);
          return !pluginState[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.Ik] && !pluginState[_InternalConstants__WEBPACK_IMPORTED_MODULE_4__.Hr] && (hasSetNext && plugin[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.YH](nextProxy), 
          plugin[_InternalConstants__WEBPACK_IMPORTED_MODULE_4__.qT](env, itemCtx), !0);
         }
         _processChain(itemCtx = itemCtx || _getTelCtx(), _callProcessTelemetry, "processTelemetry", (function() {
          return {
           item: env
          };
         }), !env.sync) || itemCtx[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.$5](env);
        }
        function _unloadPlugin(unloadCtx, unloadState) {
         function _callTeardown() {
          var hasRun = !1;
          if (plugin) {
           var pluginState = (0, _TelemetryHelpers__WEBPACK_IMPORTED_MODULE_7__.Cr)(plugin), pluginCore = plugin[_InternalConstants__WEBPACK_IMPORTED_MODULE_4__.eT] || pluginState[_InternalConstants__WEBPACK_IMPORTED_MODULE_4__.eT];
           !plugin || pluginCore && pluginCore !== unloadCtx.core() || pluginState[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.Ik] || (pluginState[_InternalConstants__WEBPACK_IMPORTED_MODULE_4__.eT] = null, 
           pluginState[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.Ik] = !0, pluginState[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.tZ] = !1, 
           plugin[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.Ik] && !0 === plugin[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.Ik](unloadCtx, unloadState) && (hasRun = !0));
          }
          return hasRun;
         }
         _processChain(unloadCtx, _callTeardown, "unload", (function() {}), unloadState[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.tI]) || unloadCtx[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.$5](unloadState);
        }
        function _updatePlugin(updateCtx, updateState) {
         function _callUpdate() {
          var hasRun = !1;
          if (plugin) {
           var pluginState = (0, _TelemetryHelpers__WEBPACK_IMPORTED_MODULE_7__.Cr)(plugin), pluginCore = plugin[_InternalConstants__WEBPACK_IMPORTED_MODULE_4__.eT] || pluginState[_InternalConstants__WEBPACK_IMPORTED_MODULE_4__.eT];
           !plugin || pluginCore && pluginCore !== updateCtx.core() || pluginState[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.Ik] || plugin[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.HC] && !0 === plugin[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.HC](updateCtx, updateState) && (hasRun = !0);
          }
          return hasRun;
         }
         _processChain(updateCtx, _callUpdate, "update", (function() {}), !1) || updateCtx[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.$5](updateState);
        }
        return (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.N6t)(proxyChain);
       }(thePlugin, config, core);
       firstProxy || (firstProxy = newProxy), lastProxy_1 && lastProxy_1._setNext(newProxy), 
       lastProxy_1 = newProxy;
      }
     }));
    }
    return startAt && !firstProxy ? createTelemetryProxyChain([ startAt ], config, core) : firstProxy;
   }
   var ProcessTelemetryContext = function(pluginChain, config, core, startAt) {
    var context = createProcessTelemetryContext(pluginChain, config, core, startAt);
    (0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_8__.o$)(this, context, (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.cGk)(context));
   };
  },
  76535: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    Si: () => newId,
    VN: () => random32,
    Z1: () => randomValue
   });
   var _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(269), _DynamicConstants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(6182), _EnvUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7292), _InternalConstants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(96492), UInt32Mask = 4294967296, MaxUInt32 = 4294967295, SEED1 = 123456789, SEED2 = 987654321, _mwcSeeded = !1, _mwcW = SEED1, _mwcZ = SEED2;
   function _mwcSeed(seedValue) {
    seedValue < 0 && (seedValue >>>= 0), _mwcW = SEED1 + seedValue & MaxUInt32, _mwcZ = SEED2 - seedValue & MaxUInt32, 
    _mwcSeeded = !0;
   }
   function _autoSeedMwc() {
    try {
     var now = 2147483647 & (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.f0d)();
     _mwcSeed((Math.random() * UInt32Mask ^ now) + now);
    } catch (e) {}
   }
   function randomValue(maxValue) {
    return maxValue > 0 ? Math.floor(random32() / MaxUInt32 * (maxValue + 1)) >>> 0 : 0;
   }
   function random32(signed) {
    var value = 0, c = (0, _EnvUtils__WEBPACK_IMPORTED_MODULE_1__.MY)() || (0, _EnvUtils__WEBPACK_IMPORTED_MODULE_1__.iN)();
    return c && c.getRandomValues && (value = c.getRandomValues(new Uint32Array(1))[0] & MaxUInt32), 
    0 === value && (0, _EnvUtils__WEBPACK_IMPORTED_MODULE_1__.lT)() && (_mwcSeeded || _autoSeedMwc(), 
    value = function(signed) {
     var value = ((_mwcZ = 36969 * (65535 & _mwcZ) + (_mwcZ >> 16) & MaxUInt32) << 16) + (65535 & (_mwcW = 18e3 * (65535 & _mwcW) + (_mwcW >> 16) & MaxUInt32)) >>> 0 & MaxUInt32;
     signed || (value >>>= 0);
     return value;
    }() & MaxUInt32), 0 === value && (value = Math.floor(UInt32Mask * Math.random() | 0)), 
    signed || (value >>>= 0), value;
   }
   function newId(maxLength) {
    void 0 === maxLength && (maxLength = 22);
    for (var number = random32() >>> 0, chars = 0, result = _InternalConstants__WEBPACK_IMPORTED_MODULE_2__.m5; result[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__.oI] < maxLength; ) chars++, 
    result += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(63 & number), 
    number >>>= 6, 5 === chars && (number = (random32() << 2 & 4294967295 | 3 & number) >>> 0, 
    chars = 0);
    return result;
   }
  },
  31190: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    x: () => parseResponse
   });
   var _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(269), _DynamicConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6182), _DiagnosticLogger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(23775), _EnvUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7292);
   function parseResponse(response, diagLog) {
    try {
     if (response && "" !== response) {
      var result = (0, _EnvUtils__WEBPACK_IMPORTED_MODULE_0__.hm)().parse(response);
      if (result && result[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.cp] && result[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.cp] >= result.itemsAccepted && result.itemsReceived - result.itemsAccepted === result.errors[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.oI]) return result;
     }
    } catch (e) {
     (0, _DiagnosticLogger__WEBPACK_IMPORTED_MODULE_2__.ZP)(diagLog, 1, 43, "Cannot parse the response. " + (e[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.RS] || (0, 
     _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.mmD)(e)), {
      response
     });
    }
    return null;
   }
  },
  90856: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    v: () => SenderPostManager
   });
   var _microsoft_dynamicproto_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(68279), _nevware21_ts_async__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(8205), _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(269), _DynamicConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6182), _Constants__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(27847), _DiagnosticLogger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(23775), _EnvUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(7292), _HelperFuncs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(13673), SenderPostManager = function() {
    function SenderPostManager() {
     var _enableSendPromise, _isInitialized, _diagLog, _isOneDs, _onCompleteFuncs, _disableCredentials, _fetchCredentials, _fallbackInst, _disableXhr, _disableBeacon, _disableBeaconSync, _disableFetchKeepAlive, _addNoResponse, _timeoutWrapper, _syncFetchPayload = 0;
     (0, _microsoft_dynamicproto_js__WEBPACK_IMPORTED_MODULE_0__.A)(SenderPostManager, this, (function(_self, _base) {
      var _sendCredentials = !0;
      function _onError(message, onComplete) {
       (0, _DiagnosticLogger__WEBPACK_IMPORTED_MODULE_2__.ZP)(_diagLog, 2, 26, "Failed to send telemetry.", {
        message
       }), _doOnComplete(onComplete, 400, {});
      }
      function _onNoPayloadUrl(onComplete) {
       _onError("No endpoint url is provided for the batch", onComplete);
      }
      function _doOnComplete(oncomplete, status, headers, response) {
       try {
        oncomplete && oncomplete(status, headers, response);
       } catch (e) {}
      }
      function _doBeaconSend(payload, oncomplete) {
       var nav = (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_4__.w3n)(), url = payload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.Vq];
       if (!url) return _onNoPayloadUrl(oncomplete), !0;
       url = payload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.Vq] + (_addNoResponse ? "&NoResponseBody=true" : "");
       var data = payload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.Cd], plainTextBatch = _isOneDs ? data : new Blob([ data ], {
        type: "text/plain;charset=UTF-8"
       });
       return nav.sendBeacon(url, plainTextBatch);
      }
      function _beaconSender(payload, oncomplete, sync) {
       var data = payload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.Cd];
       try {
        if (data) if (_doBeaconSend(payload, oncomplete)) _doOnComplete(oncomplete, 200, {}, ""); else {
         var onRetry = _onCompleteFuncs && _onCompleteFuncs.beaconOnRetry;
         onRetry && (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_4__.Tnt)(onRetry) ? onRetry(payload, oncomplete, _doBeaconSend) : (_fallbackInst && _fallbackInst[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.L](payload, oncomplete, !0), 
         (0, _DiagnosticLogger__WEBPACK_IMPORTED_MODULE_2__.ZP)(_diagLog, 2, 40, ". Failed to send telemetry with Beacon API, retried with normal sender."));
        }
       } catch (e) {
        _isOneDs && (0, _DiagnosticLogger__WEBPACK_IMPORTED_MODULE_2__.OG)(_diagLog, "Failed to send telemetry using sendBeacon API. Ex:" + (0, 
        _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_4__.mmD)(e)), _doOnComplete(oncomplete, _isOneDs ? 0 : 400, {}, "");
       }
      }
      function _xhrSender(payload, oncomplete, sync) {
       var thePromise, resolveFunc, rejectFunc, headers = payload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.c1] || {};
       !sync && _enableSendPromise && (thePromise = (0, _nevware21_ts_async__WEBPACK_IMPORTED_MODULE_5__.Qo)((function(resolve, reject) {
        resolveFunc = resolve, rejectFunc = reject;
       }))), _isOneDs && sync && payload.disableXhrSync && (sync = !1);
       var endPointUrl = payload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.Vq];
       if (!endPointUrl) return _onNoPayloadUrl(oncomplete), void (resolveFunc && resolveFunc(!1));
       var xhr = (0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_6__.H$)("POST", endPointUrl, _sendCredentials, !0, sync, payload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.do]);
       function _doOnReadyFunc(xhr) {
        var onReadyFunc = _onCompleteFuncs && _onCompleteFuncs.xhrOnComplete;
        if (onReadyFunc && (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_4__.Tnt)(onReadyFunc)) onReadyFunc(xhr, oncomplete, payload); else {
         var response = (0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_6__.Lo)(xhr);
         _doOnComplete(oncomplete, xhr[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.cV], (0, 
         _HelperFuncs__WEBPACK_IMPORTED_MODULE_6__.w3)(xhr, _isOneDs), response);
        }
       }
       return _isOneDs || xhr[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.yy]("Content-type", "application/json"), 
       (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_4__.Iuo)((0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_4__.cGk)(headers), (function(headerName) {
        xhr[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.yy](headerName, headers[headerName]);
       })), xhr.onreadystatechange = function() {
        _isOneDs || (_doOnReadyFunc(xhr), 4 === xhr.readyState && resolveFunc && resolveFunc(!0));
       }, xhr.onload = function() {
        _isOneDs && _doOnReadyFunc(xhr);
       }, xhr.onerror = function(event) {
        _doOnComplete(oncomplete, _isOneDs ? xhr[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.cV] : 400, (0, 
        _HelperFuncs__WEBPACK_IMPORTED_MODULE_6__.w3)(xhr, _isOneDs), _isOneDs ? "" : (0, 
        _HelperFuncs__WEBPACK_IMPORTED_MODULE_6__.r4)(xhr)), rejectFunc && rejectFunc(event);
       }, xhr.ontimeout = function() {
        _doOnComplete(oncomplete, _isOneDs ? xhr[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.cV] : 500, (0, 
        _HelperFuncs__WEBPACK_IMPORTED_MODULE_6__.w3)(xhr, _isOneDs), _isOneDs ? "" : (0, 
        _HelperFuncs__WEBPACK_IMPORTED_MODULE_6__.r4)(xhr)), resolveFunc && resolveFunc(!1);
       }, xhr.send(payload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.Cd]), thePromise;
      }
      function _doFetchSender(payload, oncomplete, sync) {
       var _a, thePromise, resolveFunc, rejectFunc, endPointUrl = payload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.Vq], batch = payload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.Cd], plainTextBatch = _isOneDs ? batch : new Blob([ batch ], {
        type: "application/json"
       }), requestHeaders = new Headers, batchLength = batch[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.oI], ignoreResponse = !1, responseHandled = !1, headers = payload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.c1] || {}, init = ((_a = {
        method: "POST",
        body: plainTextBatch
       })[_Constants__WEBPACK_IMPORTED_MODULE_7__.x] = !0, _a);
       payload.headers && (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_4__.cGk)(payload.headers)[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.oI] > 0 && ((0, 
       _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_4__.Iuo)((0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_4__.cGk)(headers), (function(headerName) {
        requestHeaders.append(headerName, headers[headerName]);
       })), init[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.c1] = requestHeaders), 
       _fetchCredentials ? init.credentials = _fetchCredentials : _sendCredentials && _isOneDs && (init.credentials = "include"), 
       sync && (init.keepalive = !0, _syncFetchPayload += batchLength, _isOneDs ? 2 === payload._sendReason && (ignoreResponse = !0, 
       _addNoResponse && (endPointUrl += "&NoResponseBody=true")) : ignoreResponse = !0);
       var request = new Request(endPointUrl, init);
       try {
        request[_Constants__WEBPACK_IMPORTED_MODULE_7__.x] = !0;
       } catch (e) {}
       if (!sync && _enableSendPromise && (thePromise = (0, _nevware21_ts_async__WEBPACK_IMPORTED_MODULE_5__.Qo)((function(resolve, reject) {
        resolveFunc = resolve, rejectFunc = reject;
       }))), !endPointUrl) return _onNoPayloadUrl(oncomplete), void (resolveFunc && resolveFunc(!1));
       function _handleError(res) {
        _doOnComplete(oncomplete, _isOneDs ? 0 : 400, {}, _isOneDs ? "" : res);
       }
       function _onFetchComplete(response, payload, value) {
        var status = response[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.cV], onCompleteFunc = _onCompleteFuncs.fetchOnComplete;
        onCompleteFunc && (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_4__.Tnt)(onCompleteFunc) ? onCompleteFunc(response, oncomplete, value || "", payload) : _doOnComplete(oncomplete, status, {}, value || "");
       }
       try {
        (0, _nevware21_ts_async__WEBPACK_IMPORTED_MODULE_5__.Dv)(fetch(_isOneDs ? endPointUrl : request, _isOneDs ? init : null), (function(result) {
         if (sync && (_syncFetchPayload -= batchLength, batchLength = 0), !responseHandled) if (responseHandled = !0, 
         result.rejected) _handleError(result.reason && result.reason[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.pM]), 
         rejectFunc && rejectFunc(result.reason); else {
          var response_1 = result[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.pF];
          try {
           _isOneDs || response_1.ok ? _isOneDs && !response_1.body ? (_onFetchComplete(response_1, null, ""), 
           resolveFunc && resolveFunc(!0)) : (0, _nevware21_ts_async__WEBPACK_IMPORTED_MODULE_5__.Dv)(response_1.text(), (function(resp) {
            _onFetchComplete(response_1, payload, resp[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.pF]), 
            resolveFunc && resolveFunc(!0);
           })) : (_handleError(response_1.statusText), resolveFunc && resolveFunc(!1));
          } catch (e) {
           _handleError((0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_4__.mmD)(e)), rejectFunc && rejectFunc(e);
          }
         }
        }));
       } catch (e) {
        responseHandled || (_handleError((0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_4__.mmD)(e)), 
        rejectFunc && rejectFunc(e));
       }
       return ignoreResponse && !responseHandled && (responseHandled = !0, _doOnComplete(oncomplete, 200, {}), 
       resolveFunc && resolveFunc(!0)), _isOneDs && !responseHandled && payload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.do] > 0 && _timeoutWrapper && _timeoutWrapper.set((function() {
        responseHandled || (responseHandled = !0, _doOnComplete(oncomplete, 500, {}), resolveFunc && resolveFunc(!0));
       }), payload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.do]), thePromise;
      }
      function _xdrSender(payload, oncomplete, sync) {
       var _window = (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_4__.zkX)(), xdr = new XDomainRequest, data = payload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.Cd];
       xdr.onload = function() {
        var response = (0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_6__.Lo)(xdr), onloadFunc = _onCompleteFuncs && _onCompleteFuncs.xdrOnComplete;
        onloadFunc && (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_4__.Tnt)(onloadFunc) ? onloadFunc(xdr, oncomplete, payload) : _doOnComplete(oncomplete, 200, {}, response);
       }, xdr.onerror = function() {
        _doOnComplete(oncomplete, 400, {}, _isOneDs ? "" : (0, _HelperFuncs__WEBPACK_IMPORTED_MODULE_6__.HU)(xdr));
       }, xdr.ontimeout = function() {
        _doOnComplete(oncomplete, 500, {});
       }, xdr.onprogress = function() {};
       var hostingProtocol = _window && _window.location && _window.location[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.Qg] || "", endpoint = payload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.Vq];
       if (endpoint) {
        if (!_isOneDs && 0 !== endpoint.lastIndexOf(hostingProtocol, 0)) {
         var msg = "Cannot send XDomain request. The endpoint URL protocol doesn't match the hosting page protocol.";
         return (0, _DiagnosticLogger__WEBPACK_IMPORTED_MODULE_2__.ZP)(_diagLog, 2, 40, ". " + msg), 
         void _onError(msg, oncomplete);
        }
        var endpointUrl = _isOneDs ? endpoint : endpoint[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.W7](/^(https?:)/, "");
        xdr.open("POST", endpointUrl), payload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.do] && (xdr[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.do] = payload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.do]), 
        xdr.send(data), _isOneDs && sync ? _timeoutWrapper && _timeoutWrapper.set((function() {
         xdr.send(data);
        }), 0) : xdr.send(data);
       } else _onNoPayloadUrl(oncomplete);
      }
      function _initDefaults() {
       _syncFetchPayload = 0, _isInitialized = !1, _enableSendPromise = !1, _diagLog = null, 
       _isOneDs = null, _onCompleteFuncs = null, _disableCredentials = null, _fetchCredentials = null, 
       _fallbackInst = null, _disableXhr = !1, _disableBeacon = !1, _disableBeaconSync = !1, 
       _disableFetchKeepAlive = !1, _addNoResponse = !1, _timeoutWrapper = null;
      }
      _initDefaults(), _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.mE] = function(config, diagLog) {
       _diagLog = diagLog, _isInitialized && (0, _DiagnosticLogger__WEBPACK_IMPORTED_MODULE_2__.ZP)(_diagLog, 1, 28, "Sender is already initialized"), 
       _self.SetConfig(config), _isInitialized = !0;
      }, _self._getDbgPlgTargets = function() {
       return [ _isInitialized, _isOneDs, _disableCredentials, _enableSendPromise ];
      }, _self.SetConfig = function(config) {
       try {
        if (_onCompleteFuncs = config.senderOnCompleteCallBack || {}, _disableCredentials = !!config.disableCredentials, 
        _fetchCredentials = config.fetchCredentials, _isOneDs = !!config.isOneDs, _enableSendPromise = !!config.enableSendPromise, 
        _disableXhr = !!config.disableXhr, _disableBeacon = !!config.disableBeacon, _disableBeaconSync = !!config.disableBeaconSync, 
        _timeoutWrapper = config.timeWrapper, _addNoResponse = !!config.addNoResponse, _disableFetchKeepAlive = !!config.disableFetchKeepAlive, 
        _fallbackInst = {
         sendPOST: _xhrSender
        }, _isOneDs || (_sendCredentials = !1), _disableCredentials) {
         var location_1 = (0, _EnvUtils__WEBPACK_IMPORTED_MODULE_3__.g$)();
         location_1 && location_1.protocol && "file:" === location_1.protocol[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.OL]() && (_sendCredentials = !1);
        }
        return !0;
       } catch (e) {}
       return !1;
      }, _self.getSyncFetchPayload = function() {
       return _syncFetchPayload;
      }, _self.getSenderInst = function(transports, sync) {
       return transports && transports[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.oI] ? function(transports, syncSupport) {
        var _a, transportType = 0, sendPostFunc = null, lp = 0;
        for (;null == sendPostFunc && lp < transports[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.oI]; ) transportType = transports[lp], 
        _disableXhr || 1 !== transportType ? 2 !== transportType || !(0, _EnvUtils__WEBPACK_IMPORTED_MODULE_3__.R7)(syncSupport) || syncSupport && _disableFetchKeepAlive ? 3 !== transportType || !(0, 
        _EnvUtils__WEBPACK_IMPORTED_MODULE_3__.Uf)() || (syncSupport ? _disableBeaconSync : _disableBeacon) || (sendPostFunc = _beaconSender) : sendPostFunc = _doFetchSender : (0, 
        _EnvUtils__WEBPACK_IMPORTED_MODULE_3__.PV)() ? sendPostFunc = _xdrSender : (0, _EnvUtils__WEBPACK_IMPORTED_MODULE_3__.xk)() && (sendPostFunc = _xhrSender), 
        lp++;
        if (sendPostFunc) return (_a = {
         _transport: transportType,
         _isSync: syncSupport
        })[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.L] = sendPostFunc, _a;
        return null;
       }(transports, sync) : null;
      }, _self.getFallbackInst = function() {
       return _fallbackInst;
      }, _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.tn] = function(unloadCtx, unloadState) {
       _initDefaults();
      };
     }));
    }
    return SenderPostManager.__ieDyn = 1, SenderPostManager;
   }();
  },
  90380: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    Cr: () => _getPluginState,
    Xc: () => sortPlugins,
    pI: () => initializePlugins,
    u7: () => createDistributedTraceContext
   });
   var _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(269), _DynamicConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6182), _DataCacheHelper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(24276), _InternalConstants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(96492), _W3cTraceParent__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(91864), pluginStateData = (0, 
   _DataCacheHelper__WEBPACK_IMPORTED_MODULE_0__.T)("plugin");
   function _getPluginState(plugin) {
    return pluginStateData.get(plugin, "state", {}, !0);
   }
   function initializePlugins(processContext, extensions) {
    for (var pluginState, initPlugins = [], lastPlugin = null, proxy = processContext[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.uR](); proxy; ) {
     var thePlugin = proxy[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.AP]();
     if (thePlugin) {
      lastPlugin && lastPlugin[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.YH] && thePlugin[_InternalConstants__WEBPACK_IMPORTED_MODULE_2__.qT] && lastPlugin[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.YH](thePlugin);
      var isInitialized = !!(pluginState = _getPluginState(thePlugin))[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.tZ];
      thePlugin[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.tZ] && (isInitialized = thePlugin[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.tZ]()), 
      isInitialized || initPlugins[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.y5](thePlugin), 
      lastPlugin = thePlugin, proxy = proxy[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.uR]();
     }
    }
    (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.Iuo)(initPlugins, (function(thePlugin) {
     var core = processContext[_InternalConstants__WEBPACK_IMPORTED_MODULE_2__.eT]();
     thePlugin[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.mE](processContext.getCfg(), core, extensions, processContext[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.uR]()), 
     pluginState = _getPluginState(thePlugin), thePlugin[_InternalConstants__WEBPACK_IMPORTED_MODULE_2__.eT] || pluginState[_InternalConstants__WEBPACK_IMPORTED_MODULE_2__.eT] || (pluginState[_InternalConstants__WEBPACK_IMPORTED_MODULE_2__.eT] = core), 
     pluginState[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.tZ] = !0, delete pluginState[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.Ik];
    }));
   }
   function sortPlugins(plugins) {
    return plugins.sort((function(extA, extB) {
     var result = 0;
     if (extB) {
      var bHasProcess = extB[_InternalConstants__WEBPACK_IMPORTED_MODULE_2__.qT];
      extA[_InternalConstants__WEBPACK_IMPORTED_MODULE_2__.qT] ? result = bHasProcess ? extA[_InternalConstants__WEBPACK_IMPORTED_MODULE_2__.Vo] - extB[_InternalConstants__WEBPACK_IMPORTED_MODULE_2__.Vo] : 1 : bHasProcess && (result = -1);
     } else result = extA ? 1 : -1;
     return result;
    }));
   }
   function createDistributedTraceContext(parentCtx) {
    var trace = {};
    return {
     getName: function() {
      return trace[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.RS];
     },
     setName: function(newValue) {
      parentCtx && parentCtx.setName(newValue), trace[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.RS] = newValue;
     },
     getTraceId: function() {
      return trace[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.P5];
     },
     setTraceId: function(newValue) {
      parentCtx && parentCtx.setTraceId(newValue), (0, _W3cTraceParent__WEBPACK_IMPORTED_MODULE_4__.hX)(newValue) && (trace[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.P5] = newValue);
     },
     getSpanId: function() {
      return trace[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.wi];
     },
     setSpanId: function(newValue) {
      parentCtx && parentCtx.setSpanId(newValue), (0, _W3cTraceParent__WEBPACK_IMPORTED_MODULE_4__.wN)(newValue) && (trace[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.wi] = newValue);
     },
     getTraceFlags: function() {
      return trace[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.Rr];
     },
     setTraceFlags: function(newTraceFlags) {
      parentCtx && parentCtx.setTraceFlags(newTraceFlags), trace[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__.Rr] = newTraceFlags;
     }
    };
   }
  },
  60836: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    P: () => createUnloadHandlerContainer
   });
   var _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(269), _DynamicConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6182), _DiagnosticLogger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(23775);
   function createUnloadHandlerContainer() {
    var handlers = [];
    return {
     add: function(handler) {
      handler && handlers[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.y5](handler);
     },
     run: function(unloadCtx, unloadState) {
      (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.Iuo)(handlers, (function(handler) {
       try {
        handler(unloadCtx, unloadState);
       } catch (e) {
        (0, _DiagnosticLogger__WEBPACK_IMPORTED_MODULE_2__.ZP)(unloadCtx[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.e4](), 2, 73, "Unexpected error calling unload handler - " + (0, 
        _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.mmD)(e));
       }
      })), handlers = [];
     }
    };
   }
  },
  98969: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    d: () => _testHookMaxUnloadHooksCb,
    w: () => createUnloadHookContainer
   });
   var _maxHooks, _hookAddMonitor, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(269), _DynamicConstants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(6182), _DiagnosticLogger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(23775);
   function _testHookMaxUnloadHooksCb(maxHooks, addMonitor) {
    _maxHooks = maxHooks, _hookAddMonitor = addMonitor;
   }
   function createUnloadHookContainer() {
    var _hooks = [];
    return {
     run: function(logger) {
      var oldHooks = _hooks;
      _hooks = [], (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.Iuo)(oldHooks, (function(fn) {
       try {
        (fn.rm || fn.remove).call(fn);
       } catch (e) {
        (0, _DiagnosticLogger__WEBPACK_IMPORTED_MODULE_1__.ZP)(logger, 2, 73, "Unloading:" + (0, 
        _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.mmD)(e));
       }
      })), _maxHooks && oldHooks[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__.oI] > _maxHooks && (_hookAddMonitor ? _hookAddMonitor("doUnload", oldHooks) : (0, 
      _DiagnosticLogger__WEBPACK_IMPORTED_MODULE_1__.ZP)(null, 1, 48, "Max unload hooks exceeded. An excessive number of unload hooks has been detected."));
     },
     add: function(hooks) {
      hooks && ((0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.Yny)(_hooks, hooks), 
      _maxHooks && _hooks[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__.oI] > _maxHooks && (_hookAddMonitor ? _hookAddMonitor("Add", _hooks) : (0, 
      _DiagnosticLogger__WEBPACK_IMPORTED_MODULE_1__.ZP)(null, 1, 48, "Max unload hooks exceeded. An excessive number of unload hooks has been detected.")));
     }
    };
   }
  },
  91864: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    L0: () => formatTraceParent,
    N7: () => isSampledFlag,
    V5: () => findAllScripts,
    ZI: () => parseTraceParent,
    ef: () => findW3cTraceParent,
    hX: () => isValidTraceId,
    mJ: () => isValidTraceParent,
    wN: () => isValidSpanId,
    wk: () => createTraceParent
   });
   var _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(269), _DynamicConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6182), _CoreUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(69882), _EnvUtils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(7292), _InternalConstants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(96492), TRACE_PARENT_REGEX = /^([\da-f]{2})-([\da-f]{32})-([\da-f]{16})-([\da-f]{2})(-[^\s]{1,64})?$/i, DEFAULT_VERSION = "00", INVALID_VERSION = "ff", INVALID_TRACE_ID = "00000000000000000000000000000000", INVALID_SPAN_ID = "0000000000000000", SAMPLED_FLAG = 1;
   function _isValid(value, len, invalidValue) {
    return !(!value || value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.oI] !== len || value === invalidValue) && !!value.match(/^[\da-f]*$/i);
   }
   function _formatValue(value, len, defValue) {
    return _isValid(value, len) ? value : defValue;
   }
   function _formatFlags(value) {
    (isNaN(value) || value < 0 || value > 255) && (value = 1);
    for (var result = value.toString(16); result[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.oI] < 2; ) result = "0" + result;
    return result;
   }
   function createTraceParent(traceId, spanId, flags, version) {
    var _a;
    return (_a = {})[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.s] = _isValid(version, 2, INVALID_VERSION) ? version : DEFAULT_VERSION, 
    _a[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.P5] = isValidTraceId(traceId) ? traceId : (0, 
    _CoreUtils__WEBPACK_IMPORTED_MODULE_1__.cL)(), _a[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.wi] = isValidSpanId(spanId) ? spanId : (0, 
    _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_2__.ZWZ)((0, _CoreUtils__WEBPACK_IMPORTED_MODULE_1__.cL)(), 16), 
    _a.traceFlags = flags >= 0 && flags <= 255 ? flags : 1, _a;
   }
   function parseTraceParent(value, selectIdx) {
    var _a;
    if (!value) return null;
    if ((0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_2__.cyL)(value) && (value = value[0] || ""), 
    !value || !(0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_2__.KgX)(value) || value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.oI] > 8192) return null;
    if (-1 !== value.indexOf(",")) {
     var values = value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.sY](",");
     value = values[selectIdx > 0 && values[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.oI] > selectIdx ? selectIdx : 0];
    }
    var match = TRACE_PARENT_REGEX.exec((0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_2__.EHq)(value));
    return match && match[1] !== INVALID_VERSION && match[2] !== INVALID_TRACE_ID && match[3] !== INVALID_SPAN_ID ? ((_a = {
     version: (match[1] || _InternalConstants__WEBPACK_IMPORTED_MODULE_3__.m5)[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.OL](),
     traceId: (match[2] || _InternalConstants__WEBPACK_IMPORTED_MODULE_3__.m5)[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.OL](),
     spanId: (match[3] || _InternalConstants__WEBPACK_IMPORTED_MODULE_3__.m5)[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.OL]()
    })[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.Rr] = parseInt(match[4], 16), 
    _a) : null;
   }
   function isValidTraceId(value) {
    return _isValid(value, 32, INVALID_TRACE_ID);
   }
   function isValidSpanId(value) {
    return _isValid(value, 16, INVALID_SPAN_ID);
   }
   function isValidTraceParent(value) {
    return !!(value && _isValid(value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.s], 2, INVALID_VERSION) && _isValid(value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.P5], 32, INVALID_TRACE_ID) && _isValid(value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.wi], 16, INVALID_SPAN_ID) && _isValid(_formatFlags(value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.Rr]), 2));
   }
   function isSampledFlag(value) {
    return !!isValidTraceParent(value) && (value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.Rr] & SAMPLED_FLAG) === SAMPLED_FLAG;
   }
   function formatTraceParent(value) {
    if (value) {
     var flags = _formatFlags(value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.Rr]);
     _isValid(flags, 2) || (flags = "01");
     var version = value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.s] || DEFAULT_VERSION;
     return "00" !== version && "ff" !== version && (version = DEFAULT_VERSION), "".concat(version.toLowerCase(), "-").concat(_formatValue(value.traceId, 32, INVALID_TRACE_ID).toLowerCase(), "-").concat(_formatValue(value.spanId, 16, INVALID_SPAN_ID).toLowerCase(), "-").concat(flags.toLowerCase());
    }
    return "";
   }
   function findW3cTraceParent(selectIdx) {
    var traceParent = parseTraceParent((0, _EnvUtils__WEBPACK_IMPORTED_MODULE_4__.$Z)("traceparent"), selectIdx);
    return traceParent || (traceParent = parseTraceParent((0, _EnvUtils__WEBPACK_IMPORTED_MODULE_4__.Iu)("traceparent"), selectIdx)), 
    traceParent;
   }
   function findAllScripts(doc) {
    var scripts = doc.getElementsByTagName("script"), result = [];
    return (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_2__.Iuo)(scripts, (function(script) {
     var src = script[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.NA]("src");
     if (src) {
      var crossOrigin = script[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.NA]("crossorigin"), async = !0 === script.hasAttribute("async"), defer = !0 === script.hasAttribute("defer"), referrerPolicy = script[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.NA]("referrerpolicy"), info = {
       url: src
      };
      crossOrigin && (info.crossOrigin = crossOrigin), async && (info.async = async), 
      defer && (info.defer = defer), referrerPolicy && (info.referrerPolicy = referrerPolicy), 
      result[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__.y5](info);
     }
    })), result;
   }
  },
  6182: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    $5: () => _DYN_PROCESS_NEXT,
    $o: () => _DYN_CREATE_NEW,
    AP: () => _DYN_GET_PLUGIN,
    Az: () => _DYN_GET_RESPONSE_HEADER,
    Bl: () => _DYN_LOGGING_LEVEL_CONSOL4,
    Cd: () => _DYN_DATA,
    DI: () => _DYN_GET_PROCESS_TEL_CONT2,
    Di: () => _DYN_STOP_POLLING_INTERNA3,
    FI: () => _DYN_I_KEY,
    HC: () => _DYN_UPDATE,
    Ic: () => _DYN_SPLICE,
    Ik: () => _DYN_TEARDOWN,
    JQ: () => _DYN_BLK_VAL,
    JR: () => _DYN_MESSAGE_ID,
    Ju: () => _DYN_IDENTIFIER,
    K0: () => _DYN_HDLR,
    L: () => _DYN_SEND_POST,
    M5: () => _DYN_UNLOAD,
    NA: () => _DYN_GET_ATTRIBUTE,
    OL: () => _DYN_TO_LOWER_CASE,
    O_: () => _DYN_GET_CTX,
    P5: () => _DYN_TRACE_ID,
    QM: () => _DYN_TYPE,
    Qg: () => _DYN_PROTOCOL,
    RF: () => _DYN_GET_NOTIFY_MGR,
    RS: () => _DYN_NAME,
    Rr: () => _DYN_TRACE_FLAGS,
    Ru: () => _DYN_COMPLETE,
    Uw: () => _DYN_LOGGER,
    Vq: () => _DYN_URL_STRING,
    W7: () => _DYN_REPLACE,
    XM: () => _DYN_ENABLED,
    XW: () => _DYN_RD_ONLY,
    YH: () => _DYN_SET_NEXT_PLUGIN,
    Yo: () => _DYN_HANDLER,
    Yq: () => _DYN__INACTIVE,
    Zu: () => _DYN_IS_CHILD_EVT,
    _w: () => _DYN_CANCEL,
    by: () => _DYN_ON_COMPLETE,
    c1: () => _DYN_HEADERS,
    cV: () => _DYN_STATUS,
    cp: () => _DYN_ITEMS_RECEIVED,
    do: () => _DYN_TIMEOUT,
    e4: () => _DYN_DIAG_LOG,
    e_: () => _DYN_SET_CTX,
    fA: () => _DYN_TIME,
    h0: () => _DYN_SET_DF,
    h3: () => _DYN_REMOVE_NOTIFICATION_0,
    h4: () => _DYN_POLL_INTERNAL_LOGS,
    ih: () => _DYN_THROW_INTERNAL,
    mE: () => _DYN_INITIALIZE,
    oI: () => _DYN_LENGTH,
    on: () => _DYN_WARN_TO_CONSOLE,
    pF: () => _DYN_VALUE,
    pM: () => _DYN_MESSAGE,
    re: () => _DYN_NODE_TYPE,
    s: () => _DYN_VERSION,
    sY: () => _DYN_SPLIT,
    sl: () => _DYN_INSTRUMENTATION_KEY,
    sx: () => _DYN_LOG_INTERNAL_MESSAGE,
    tI: () => _DYN_IS_ASYNC,
    tX: () => _DYN_USER_AGENT,
    tZ: () => _DYN_IS_INITIALIZED,
    tn: () => _DYN__DO_TEARDOWN,
    uR: () => _DYN_GET_NEXT,
    vR: () => _DYN_ADD_NOTIFICATION_LIS1,
    wJ: () => _DYN_GET_ALL_RESPONSE_HEA5,
    wi: () => _DYN_SPAN_ID,
    x6: () => _DYN_WATCH,
    y5: () => _DYN_PUSH,
    y9: () => _DYN_APPLY,
    yy: () => _DYN_SET_REQUEST_HEADER,
    zs: () => _DYN_NOTIFY
   });
   var _DYN_TO_LOWER_CASE = "toLowerCase", _DYN_BLK_VAL = "blkVal", _DYN_LENGTH = "length", _DYN_RD_ONLY = "rdOnly", _DYN_NOTIFY = "notify", _DYN_WARN_TO_CONSOLE = "warnToConsole", _DYN_THROW_INTERNAL = "throwInternal", _DYN_SET_DF = "setDf", _DYN_WATCH = "watch", _DYN_LOGGER = "logger", _DYN_APPLY = "apply", _DYN_PUSH = "push", _DYN_SPLICE = "splice", _DYN_HDLR = "hdlr", _DYN_CANCEL = "cancel", _DYN_INITIALIZE = "initialize", _DYN_IDENTIFIER = "identifier", _DYN_REMOVE_NOTIFICATION_0 = "removeNotificationListener", _DYN_ADD_NOTIFICATION_LIS1 = "addNotificationListener", _DYN_IS_INITIALIZED = "isInitialized", _DYN_INSTRUMENTATION_KEY = "instrumentationKey", _DYN__INACTIVE = "INACTIVE", _DYN_VALUE = "value", _DYN_GET_NOTIFY_MGR = "getNotifyMgr", _DYN_GET_PLUGIN = "getPlugin", _DYN_NAME = "name", _DYN_I_KEY = "iKey", _DYN_TIME = "time", _DYN_PROCESS_NEXT = "processNext", _DYN_GET_PROCESS_TEL_CONT2 = "getProcessTelContext", _DYN_POLL_INTERNAL_LOGS = "pollInternalLogs", _DYN_ENABLED = "enabled", _DYN_STOP_POLLING_INTERNA3 = "stopPollingInternalLogs", _DYN_UNLOAD = "unload", _DYN_ON_COMPLETE = "onComplete", _DYN_VERSION = "version", _DYN_LOGGING_LEVEL_CONSOL4 = "loggingLevelConsole", _DYN_CREATE_NEW = "createNew", _DYN_TEARDOWN = "teardown", _DYN_MESSAGE_ID = "messageId", _DYN_MESSAGE = "message", _DYN_IS_ASYNC = "isAsync", _DYN_DIAG_LOG = "diagLog", _DYN__DO_TEARDOWN = "_doTeardown", _DYN_UPDATE = "update", _DYN_GET_NEXT = "getNext", _DYN_SET_NEXT_PLUGIN = "setNextPlugin", _DYN_PROTOCOL = "protocol", _DYN_USER_AGENT = "userAgent", _DYN_SPLIT = "split", _DYN_NODE_TYPE = "nodeType", _DYN_REPLACE = "replace", _DYN_LOG_INTERNAL_MESSAGE = "logInternalMessage", _DYN_TYPE = "type", _DYN_HANDLER = "handler", _DYN_STATUS = "status", _DYN_GET_RESPONSE_HEADER = "getResponseHeader", _DYN_GET_ALL_RESPONSE_HEA5 = "getAllResponseHeaders", _DYN_IS_CHILD_EVT = "isChildEvt", _DYN_DATA = "data", _DYN_GET_CTX = "getCtx", _DYN_SET_CTX = "setCtx", _DYN_COMPLETE = "complete", _DYN_ITEMS_RECEIVED = "itemsReceived", _DYN_URL_STRING = "urlString", _DYN_SEND_POST = "sendPOST", _DYN_HEADERS = "headers", _DYN_TIMEOUT = "timeout", _DYN_SET_REQUEST_HEADER = "setRequestHeader", _DYN_TRACE_ID = "traceId", _DYN_SPAN_ID = "spanId", _DYN_TRACE_FLAGS = "traceFlags", _DYN_GET_ATTRIBUTE = "getAttribute";
  },
  45664: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    Wy: () => ObjProto,
    _1: () => strShimObject,
    bA: () => strShimUndefined,
    hW: () => strShimFunction,
    s6: () => ObjClass,
    vR: () => strShimPrototype
   });
   var strShimFunction = "function", strShimObject = "object", strShimUndefined = "undefined", strShimPrototype = "prototype", ObjClass = Object, ObjProto = ObjClass[strShimPrototype];
  },
  10659: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    Im: () => __assignFn,
    qU: () => __extendsFn,
    vz: () => __spreadArrayFn
   });
   var _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(269), _Constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(45664), __assignFn = (((0, 
   _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.mS$)() || {}).Symbol, ((0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.mS$)() || {}).Reflect, 
   _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.vE3 || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) for (var p in s = arguments[i]) _Constants__WEBPACK_IMPORTED_MODULE_1__.Wy.hasOwnProperty.call(s, p) && (t[p] = s[p]);
    return t;
   }), extendStaticsFn = function(d, b) {
    return extendStaticsFn = _Constants__WEBPACK_IMPORTED_MODULE_1__.s6.setPrototypeOf || {
     __proto__: []
    } instanceof Array && function(d, b) {
     d.__proto__ = b;
    } || function(d, b) {
     for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
    }, extendStaticsFn(d, b);
   };
   function __extendsFn(d, b) {
    function __() {
     this.constructor = d;
    }
    typeof b !== _Constants__WEBPACK_IMPORTED_MODULE_1__.hW && null !== b && (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.zkd)("Class extends value " + String(b) + " is not a constructor or null"), 
    extendStaticsFn(d, b), d[_Constants__WEBPACK_IMPORTED_MODULE_1__.vR] = null === b ? (0, 
    _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.sSX)(b) : (__[_Constants__WEBPACK_IMPORTED_MODULE_1__.vR] = b[_Constants__WEBPACK_IMPORTED_MODULE_1__.vR], 
    new __);
   }
   function __spreadArrayFn(to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];
    return to;
   }
  },
  5927: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.r(__webpack_exports__), __webpack_require__.d(__webpack_exports__, {
    AppInsightsCore: () => AppInsightsCore._,
    ApplicationInsights: () => ApplicationInsights,
    Sender: () => Sender,
    SeverityLevel: () => SeverityLevel.O,
    arrForEach: () => ts_utils.Iuo,
    isNullOrUndefined: () => ts_utils.hXl,
    proxyFunctions: () => HelperFuncs.o$,
    throwError: () => ts_utils.$8
   });
   var DynamicProto = __webpack_require__(68279), TsLibShims = __webpack_require__(10659), Constants = __webpack_require__(55025), Event = __webpack_require__(43072), Trace = __webpack_require__(82445), PageView = __webpack_require__(51448), PageViewPerformance = __webpack_require__(64164), Exception = __webpack_require__(65397), Metric = __webpack_require__(45014), RemoteDependencyData = __webpack_require__(1365), applicationinsights_common = __webpack_require__(90740), Offline = __webpack_require__(85571), StorageHelperFuncs = __webpack_require__(14658), Util = __webpack_require__(42318), RequestResponseHeaders = __webpack_require__(52910), ConfigDefaultHelpers = __webpack_require__(52475), DiagnosticLogger = __webpack_require__(23775), HelperFuncs = __webpack_require__(13673), ts_utils = __webpack_require__(269), EventHelpers = __webpack_require__(56149), DataCacheHelper = __webpack_require__(24276), DynamicConfig = __webpack_require__(19749), ProcessTelemetryContext = __webpack_require__(72317), InitActiveStatusEnum = __webpack_require__(54875), EnvUtils = __webpack_require__(7292), SenderPostManager = __webpack_require__(90856), AsyncUtils = __webpack_require__(34013), ResponseHelpers = __webpack_require__(31190), BaseTelemetryPlugin = __webpack_require__(98257), PartAExtensions = __webpack_require__(81575), DataSanitizer = __webpack_require__(67975), Envelope = __webpack_require__(21062), Data = __webpack_require__(27358);
   function _setValueIf(target, field, value) {
    return (0, HelperFuncs.KY)(target, field, value, ts_utils.zzB);
   }
   function _extractPropsAndMeasurements(data, properties, measurements) {
    (0, ts_utils.hXl)(data) || (0, ts_utils.zav)(data, (function(key, value) {
     (0, ts_utils.EtT)(value) ? measurements[key] = value : (0, ts_utils.KgX)(value) ? properties[key] = value : (0, 
     EnvUtils.Z)() && (properties[key] = (0, EnvUtils.hm)().stringify(value));
    }));
   }
   function _convertPropsUndefinedToCustomDefinedValue(properties, customUndefinedValue) {
    (0, ts_utils.hXl)(properties) || (0, ts_utils.zav)(properties, (function(key, value) {
     properties[key] = value || customUndefinedValue;
    }));
   }
   function _createEnvelope(logger, envelopeType, telemetryItem, data) {
    var envelope = new Envelope.L(logger, data, envelopeType);
    _setValueIf(envelope, "sampleRate", telemetryItem[Constants.tU]), (telemetryItem.baseData || {}).startTime && (envelope.time = (0, 
    HelperFuncs._u)(telemetryItem.baseData.startTime)), envelope.iKey = telemetryItem.iKey;
    var iKeyNoDashes = telemetryItem.iKey.replace(/-/g, "");
    return envelope.name = envelope.name.replace("{0}", iKeyNoDashes), function(logger, item, env) {
     var envTags = env.tags = env.tags || {}, itmExt = item.ext = item.ext || {}, itmTags = item.tags = item.tags || [], extUser = itmExt.user;
     extUser && (_setValueIf(envTags, PartAExtensions.O.userAuthUserId, extUser.authId), 
     _setValueIf(envTags, PartAExtensions.O.userId, extUser.id || extUser.localId));
     var extApp = itmExt.app;
     extApp && _setValueIf(envTags, PartAExtensions.O.sessionId, extApp.sesId);
     var extDevice = itmExt.device;
     extDevice && (_setValueIf(envTags, PartAExtensions.O.deviceId, extDevice.id || extDevice.localId), 
     _setValueIf(envTags, PartAExtensions.O.deviceType, extDevice.deviceClass), _setValueIf(envTags, PartAExtensions.O.deviceIp, extDevice.ip), 
     _setValueIf(envTags, PartAExtensions.O.deviceModel, extDevice.model), _setValueIf(envTags, PartAExtensions.O.deviceType, extDevice.deviceType));
     var web = item.ext.web;
     if (web) {
      _setValueIf(envTags, PartAExtensions.O.deviceLanguage, web.browserLang), _setValueIf(envTags, PartAExtensions.O.deviceBrowserVersion, web.browserVer), 
      _setValueIf(envTags, PartAExtensions.O.deviceBrowser, web.browser);
      var envData = env.data = env.data || {}, envBaseData = envData.baseData = envData.baseData || {}, envProps = envBaseData.properties = envBaseData.properties || {};
      _setValueIf(envProps, "domain", web.domain), _setValueIf(envProps, "isManual", web.isManual ? "true" : null), 
      _setValueIf(envProps, "screenRes", web.screenRes), _setValueIf(envProps, "userConsent", web.userConsent ? "true" : null);
     }
     var extOs = itmExt.os;
     extOs && (_setValueIf(envTags, PartAExtensions.O.deviceOS, extOs.name), _setValueIf(envTags, PartAExtensions.O.deviceOSVersion, extOs.osVer));
     var extTrace = itmExt.trace;
     extTrace && (_setValueIf(envTags, PartAExtensions.O.operationParentId, extTrace.parentID), 
     _setValueIf(envTags, PartAExtensions.O.operationName, (0, DataSanitizer.Rr)(logger, extTrace.name)), 
     _setValueIf(envTags, PartAExtensions.O.operationId, extTrace.traceID));
     for (var tgs = {}, i = itmTags.length - 1; i >= 0; i--) {
      var tg = itmTags[i];
      (0, ts_utils.zav)(tg, (function(key, value) {
       tgs[key] = value;
      })), itmTags.splice(i, 1);
     }
     (0, ts_utils.zav)(itmTags, (function(tg, value) {
      tgs[tg] = value;
     }));
     var theTags = (0, TsLibShims.Im)((0, TsLibShims.Im)({}, envTags), tgs);
     theTags[PartAExtensions.O.internalSdkVersion] || (theTags[PartAExtensions.O.internalSdkVersion] = (0, 
     DataSanitizer.Rr)(logger, "javascript:".concat(EnvelopeCreator.Version), 64)), env.tags = (0, 
     HelperFuncs.hW)(theTags);
    }(logger, telemetryItem, envelope), telemetryItem.tags = telemetryItem.tags || [], 
    (0, HelperFuncs.hW)(envelope);
   }
   function EnvelopeCreatorInit(logger, telemetryItem) {
    (0, ts_utils.hXl)(telemetryItem.baseData) && (0, DiagnosticLogger.ZP)(logger, 1, 46, "telemetryItem.baseData cannot be null.");
   }
   var EnvelopeCreator = {
    Version: "3.3.3"
   };
   function EventEnvelopeCreator(logger, telemetryItem, customUndefinedValue) {
    EnvelopeCreatorInit(logger, telemetryItem);
    var customProperties = {}, customMeasurements = {};
    telemetryItem.baseType !== Event.J.dataType && (customProperties.baseTypeSource = telemetryItem.baseType), 
    telemetryItem.baseType === Event.J.dataType ? (customProperties = telemetryItem.baseData.properties || {}, 
    customMeasurements = telemetryItem.baseData.measurements || {}) : telemetryItem.baseData && _extractPropsAndMeasurements(telemetryItem.baseData, customProperties, customMeasurements), 
    _extractPropsAndMeasurements(telemetryItem.data, customProperties, customMeasurements), 
    (0, ts_utils.hXl)(customUndefinedValue) || _convertPropsUndefinedToCustomDefinedValue(customProperties, customUndefinedValue);
    var eventName = telemetryItem.baseData.name, eventData = new Event.J(logger, eventName, customProperties, customMeasurements), data = new Data.B(Event.J.dataType, eventData);
    return _createEnvelope(logger, Event.J.envelopeType, telemetryItem, data);
   }
   var _a, _b, BaseSendBuffer = function() {
    function BaseSendBuffer(logger, config) {
     var _buffer = [], _bufferFullMessageSent = !1, _maxRetryCnt = config.maxRetryCnt;
     this._get = function() {
      return _buffer;
     }, this._set = function(buffer) {
      return _buffer = buffer;
     }, (0, DynamicProto.A)(BaseSendBuffer, this, (function(_self) {
      _self.enqueue = function(payload) {
       _self.count() >= config.eventsLimitInMem ? _bufferFullMessageSent || ((0, DiagnosticLogger.ZP)(logger, 2, 105, "Maximum in-memory buffer size reached: " + _self.count(), !0), 
       _bufferFullMessageSent = !0) : (payload.cnt = payload.cnt || 0, !(0, ts_utils.hXl)(_maxRetryCnt) && payload.cnt > _maxRetryCnt || _buffer.push(payload));
      }, _self.count = function() {
       return _buffer.length;
      }, _self.size = function() {
       for (var size = _buffer.length, lp = 0; lp < _buffer.length; lp++) size += _buffer[lp].item.length;
       return config.emitLineDelimitedJson || (size += 2), size;
      }, _self.clear = function() {
       _buffer = [], _bufferFullMessageSent = !1;
      }, _self.getItems = function() {
       return _buffer.slice(0);
      }, _self.batchPayloads = function(payloads) {
       if (payloads && payloads.length > 0) {
        var payloadStr_1 = [];
        return (0, ts_utils.Iuo)(payloads, (function(payload) {
         payloadStr_1.push(payload.item);
        })), config.emitLineDelimitedJson ? payloadStr_1.join("\n") : "[" + payloadStr_1.join(",") + "]";
       }
       return null;
      }, _self.createNew = function(newLogger, newConfig, canUseSessionStorage) {
       var items = _buffer.slice(0);
       newLogger = newLogger || logger, newConfig = newConfig || {};
       var newBuffer = canUseSessionStorage ? new SessionStorageSendBuffer(newLogger, newConfig) : new ArraySendBuffer(newLogger, newConfig);
       return (0, ts_utils.Iuo)(items, (function(payload) {
        newBuffer.enqueue(payload);
       })), newBuffer;
      };
     }));
    }
    return BaseSendBuffer.__ieDyn = 1, BaseSendBuffer;
   }(), ArraySendBuffer = function(_super) {
    function ArraySendBuffer(logger, config) {
     var _this = _super.call(this, logger, config) || this;
     return (0, DynamicProto.A)(ArraySendBuffer, _this, (function(_self, _base) {
      _self.markAsSent = function(payload) {
       _base.clear();
      }, _self.clearSent = function(payload) {};
     })), _this;
    }
    return (0, TsLibShims.qU)(ArraySendBuffer, _super), ArraySendBuffer.__ieDyn = 1, 
    ArraySendBuffer;
   }(BaseSendBuffer), PREVIOUS_KEYS = [ "AI_buffer", "AI_sentBuffer" ], SessionStorageSendBuffer = function(_super) {
    function SessionStorageSendBuffer(logger, config) {
     var _this = _super.call(this, logger, config) || this, _bufferFullMessageSent = !1, _namePrefix = null == config ? void 0 : config.namePrefix, _b = config.bufferOverride || {
      getItem: StorageHelperFuncs.vH,
      setItem: StorageHelperFuncs.Dt
     }, getItem = _b.getItem, setItem = _b.setItem, _maxRetryCnt = config.maxRetryCnt;
     return (0, DynamicProto.A)(SessionStorageSendBuffer, _this, (function(_self, _base) {
      var bufferItems = _getBuffer(SessionStorageSendBuffer.BUFFER_KEY), itemsInSentBuffer = _getBuffer(SessionStorageSendBuffer.SENT_BUFFER_KEY), previousItems = function() {
       var items = [];
       try {
        return (0, ts_utils.Iuo)(PREVIOUS_KEYS, (function(key) {
         var events = _getItemsFromPreviousKey(key);
         if (items = items.concat(events), _namePrefix) {
          var prefixEvents = _getItemsFromPreviousKey(_namePrefix + "_" + key);
          items = items.concat(prefixEvents);
         }
        })), items;
       } catch (e) {
        (0, DiagnosticLogger.ZP)(logger, 2, 41, "Transfer events from previous buffers: " + (0, 
        HelperFuncs.lL)(e) + ". previous Buffer items can not be removed", {
         exception: (0, ts_utils.mmD)(e)
        });
       }
       return [];
      }(), notDeliveredItems = itemsInSentBuffer.concat(previousItems), buffer = _self._set(bufferItems.concat(notDeliveredItems));
      function _removePayloadsFromBuffer(payloads, buffer) {
       var remaining = [], payloadStr = [];
       return (0, ts_utils.Iuo)(payloads, (function(payload) {
        payloadStr.push(payload.item);
       })), (0, ts_utils.Iuo)(buffer, (function(value) {
        (0, ts_utils.Tnt)(value) || -1 !== (0, ts_utils.rDm)(payloadStr, value.item) || remaining.push(value);
       })), remaining;
      }
      function _getBuffer(key) {
       var prefixedKey = key;
       return _getBufferBase(prefixedKey = _namePrefix ? _namePrefix + "_" + prefixedKey : prefixedKey);
      }
      function _getBufferBase(key) {
       try {
        var bufferJson = getItem(logger, key);
        if (bufferJson) {
         var buffer_1 = (0, EnvUtils.hm)().parse(bufferJson);
         if ((0, ts_utils.KgX)(buffer_1) && (buffer_1 = (0, EnvUtils.hm)().parse(buffer_1)), 
         buffer_1 && (0, ts_utils.cyL)(buffer_1)) return buffer_1;
        }
       } catch (e) {
        (0, DiagnosticLogger.ZP)(logger, 1, 42, " storage key: " + key + ", " + (0, HelperFuncs.lL)(e), {
         exception: (0, ts_utils.mmD)(e)
        });
       }
       return [];
      }
      function _setBuffer(key, buffer) {
       var prefixedKey = key;
       try {
        prefixedKey = _namePrefix ? _namePrefix + "_" + prefixedKey : prefixedKey;
        var bufferJson = JSON.stringify(buffer);
        setItem(logger, prefixedKey, bufferJson);
       } catch (e) {
        setItem(logger, prefixedKey, JSON.stringify([])), (0, DiagnosticLogger.ZP)(logger, 2, 41, " storage key: " + prefixedKey + ", " + (0, 
        HelperFuncs.lL)(e) + ". Buffer cleared", {
         exception: (0, ts_utils.mmD)(e)
        });
       }
      }
      function _getItemsFromPreviousKey(key) {
       try {
        var items = _getBufferBase(key), transFormedItems_1 = [];
        return (0, ts_utils.Iuo)(items, (function(item) {
         var internalItem = {
          item,
          cnt: 0
         };
         transFormedItems_1.push(internalItem);
        })), (0, StorageHelperFuncs.v7)(logger, key), transFormedItems_1;
       } catch (e) {}
       return [];
      }
      buffer.length > SessionStorageSendBuffer.MAX_BUFFER_SIZE && (buffer.length = SessionStorageSendBuffer.MAX_BUFFER_SIZE), 
      _setBuffer(SessionStorageSendBuffer.SENT_BUFFER_KEY, []), _setBuffer(SessionStorageSendBuffer.BUFFER_KEY, buffer), 
      _self.enqueue = function(payload) {
       _self.count() >= SessionStorageSendBuffer.MAX_BUFFER_SIZE ? _bufferFullMessageSent || ((0, 
       DiagnosticLogger.ZP)(logger, 2, 67, "Maximum buffer size reached: " + _self.count(), !0), 
       _bufferFullMessageSent = !0) : (payload.cnt = payload.cnt || 0, !(0, ts_utils.hXl)(_maxRetryCnt) && payload.cnt > _maxRetryCnt || (_base.enqueue(payload), 
       _setBuffer(SessionStorageSendBuffer.BUFFER_KEY, _self._get())));
      }, _self.clear = function() {
       _base.clear(), _setBuffer(SessionStorageSendBuffer.BUFFER_KEY, _self._get()), _setBuffer(SessionStorageSendBuffer.SENT_BUFFER_KEY, []), 
       _bufferFullMessageSent = !1;
      }, _self.markAsSent = function(payload) {
       _setBuffer(SessionStorageSendBuffer.BUFFER_KEY, _self._set(_removePayloadsFromBuffer(payload, _self._get())));
       var sentElements = _getBuffer(SessionStorageSendBuffer.SENT_BUFFER_KEY);
       sentElements instanceof Array && payload instanceof Array && ((sentElements = sentElements.concat(payload)).length > SessionStorageSendBuffer.MAX_BUFFER_SIZE && ((0, 
       DiagnosticLogger.ZP)(logger, 1, 67, "Sent buffer reached its maximum size: " + sentElements.length, !0), 
       sentElements.length = SessionStorageSendBuffer.MAX_BUFFER_SIZE), _setBuffer(SessionStorageSendBuffer.SENT_BUFFER_KEY, sentElements));
      }, _self.clearSent = function(payload) {
       var sentElements = _getBuffer(SessionStorageSendBuffer.SENT_BUFFER_KEY);
       sentElements = _removePayloadsFromBuffer(payload, sentElements), _setBuffer(SessionStorageSendBuffer.SENT_BUFFER_KEY, sentElements);
      }, _self.createNew = function(newLogger, newConfig, canUseSessionStorage) {
       canUseSessionStorage = !!canUseSessionStorage;
       var unsentItems = _self._get().slice(0), sentItems = _getBuffer(SessionStorageSendBuffer.SENT_BUFFER_KEY).slice(0);
       newLogger = newLogger || logger, newConfig = newConfig || {}, _self.clear();
       var newBuffer = canUseSessionStorage ? new SessionStorageSendBuffer(newLogger, newConfig) : new ArraySendBuffer(newLogger, newConfig);
       return (0, ts_utils.Iuo)(unsentItems, (function(payload) {
        newBuffer.enqueue(payload);
       })), canUseSessionStorage && newBuffer.markAsSent(sentItems), newBuffer;
      };
     })), _this;
    }
    var _a;
    return (0, TsLibShims.qU)(SessionStorageSendBuffer, _super), _a = SessionStorageSendBuffer, 
    SessionStorageSendBuffer.VERSION = "_1", SessionStorageSendBuffer.BUFFER_KEY = "AI_buffer" + _a.VERSION, 
    SessionStorageSendBuffer.SENT_BUFFER_KEY = "AI_sentBuffer" + _a.VERSION, SessionStorageSendBuffer.MAX_BUFFER_SIZE = 2e3, 
    SessionStorageSendBuffer;
   }(BaseSendBuffer), Serializer = function() {
    function Serializer(logger) {
     (0, DynamicProto.A)(Serializer, this, (function(_self) {
      function _serializeObject(source, name) {
       var output = {};
       if (!source) return (0, DiagnosticLogger.ZP)(logger, 1, 48, "cannot serialize object because it is null or undefined", {
        name
       }, !0), output;
       if (source.__aiCircularRefCheck) return (0, DiagnosticLogger.ZP)(logger, 2, 50, "Circular reference detected while serializing object", {
        name
       }, !0), output;
       if (!source.aiDataContract) {
        if ("measurements" === name) output = _serializeStringMap(source, "number", name); else if ("properties" === name) output = _serializeStringMap(source, "string", name); else if ("tags" === name) output = _serializeStringMap(source, "string", name); else if ((0, 
        ts_utils.cyL)(source)) output = _serializeArray(source, name); else {
         (0, DiagnosticLogger.ZP)(logger, 2, 49, "Attempting to serialize an object which does not implement ISerializable", {
          name
         }, !0);
         try {
          (0, EnvUtils.hm)().stringify(source), output = source;
         } catch (e) {
          (0, DiagnosticLogger.ZP)(logger, 1, 48, e && (0, ts_utils.Tnt)(e.toString) ? e.toString() : "Error serializing object", null, !0);
         }
        }
        return output;
       }
       return source.__aiCircularRefCheck = !0, (0, ts_utils.zav)(source.aiDataContract, (function(field, contract) {
        var isRequired = (0, ts_utils.Tnt)(contract) ? 1 & contract() : 1 & contract, isHidden = (0, 
        ts_utils.Tnt)(contract) ? 4 & contract() : 4 & contract, isArray = 2 & contract, isPresent = void 0 !== source[field], isObj = (0, 
        ts_utils.Gvm)(source[field]) && null !== source[field];
        if (!isRequired || isPresent || isArray) {
         if (!isHidden) {
          var value = void 0;
          void 0 !== (value = isObj ? isArray ? _serializeArray(source[field], field) : _serializeObject(source[field], field) : source[field]) && (output[field] = value);
         }
        } else (0, DiagnosticLogger.ZP)(logger, 1, 24, "Missing required field specification. The field is required but not present on source", {
         field,
         name
        });
       })), delete source.__aiCircularRefCheck, output;
      }
      function _serializeArray(sources, name) {
       var output;
       if (sources) if ((0, ts_utils.cyL)(sources)) {
        output = [];
        for (var i = 0; i < sources.length; i++) {
         var item = _serializeObject(sources[i], name + "[" + i + "]");
         output.push(item);
        }
       } else (0, DiagnosticLogger.ZP)(logger, 1, 54, "This field was specified as an array in the contract but the item is not an array.\r\n", {
        name
       }, !0);
       return output;
      }
      function _serializeStringMap(map, expectedType, name) {
       var output;
       return map && (output = {}, (0, ts_utils.zav)(map, (function(field, value) {
        if ("string" === expectedType) void 0 === value ? output[field] = "undefined" : null === value ? output[field] = "null" : value.toString ? output[field] = value.toString() : output[field] = "invalid field: toString() is not defined."; else if ("number" === expectedType) if (void 0 === value) output[field] = "undefined"; else if (null === value) output[field] = "null"; else {
         var num = parseFloat(value);
         output[field] = num;
        } else output[field] = "invalid field: " + name + " is of unknown type.", (0, DiagnosticLogger.ZP)(logger, 1, output[field], null, !0);
       }))), output;
      }
      _self.serialize = function(input) {
       var output = _serializeObject(input, "root");
       try {
        return (0, EnvUtils.hm)().stringify(output);
       } catch (e) {
        (0, DiagnosticLogger.ZP)(logger, 1, 48, e && (0, ts_utils.Tnt)(e.toString) ? e.toString() : "Error serializing object", null, !0);
       }
      };
     }));
    }
    return Serializer.__ieDyn = 1, Serializer;
   }(), ContextTagKeys = __webpack_require__(8596), HashCodeScoreGenerator = function() {
    function HashCodeScoreGenerator() {}
    return HashCodeScoreGenerator.prototype.getHashCodeScore = function(key) {
     return 100 * (this.getHashCode(key) / HashCodeScoreGenerator.INT_MAX_VALUE);
    }, HashCodeScoreGenerator.prototype.getHashCode = function(input) {
     if ("" === input) return 0;
     for (;input.length < 8; ) input = input.concat(input);
     for (var hash = 5381, i = 0; i < input.length; ++i) hash = (hash << 5) + hash + input.charCodeAt(i), 
     hash |= 0;
     return Math.abs(hash);
    }, HashCodeScoreGenerator.INT_MAX_VALUE = 2147483647, HashCodeScoreGenerator;
   }(), SamplingScoreGenerator = function() {
    var hashCodeGenerator = new HashCodeScoreGenerator, keys = new ContextTagKeys.o;
    this.getSamplingScore = function(item) {
     return item.tags && item.tags[keys.userId] ? hashCodeGenerator.getHashCodeScore(item.tags[keys.userId]) : item.ext && item.ext.user && item.ext.user.id ? hashCodeGenerator.getHashCodeScore(item.ext.user.id) : item.tags && item.tags[keys.operationId] ? hashCodeGenerator.getHashCodeScore(item.tags[keys.operationId]) : item.ext && item.ext.telemetryTrace && item.ext.telemetryTrace.traceID ? hashCodeGenerator.getHashCodeScore(item.ext.telemetryTrace.traceID) : 100 * Math.random();
    };
   }, Sample = function() {
    function Sample(sampleRate, logger) {
     this.INT_MAX_VALUE = 2147483647;
     var _logger = logger || (0, DiagnosticLogger.y0)(null);
     (sampleRate > 100 || sampleRate < 0) && (_logger.throwInternal(2, 58, "Sampling rate is out of range (0..100). Sampling will be disabled, you may be sending too much data which may affect your AI service level.", {
      samplingRate: sampleRate
     }, !0), sampleRate = 100), this.sampleRate = sampleRate, this.samplingScoreGenerator = new SamplingScoreGenerator;
    }
    return Sample.prototype.isSampledIn = function(envelope) {
     var samplingPercentage = this.sampleRate;
     return null == samplingPercentage || samplingPercentage >= 100 || (envelope.baseType === Metric.J.dataType || this.samplingScoreGenerator.getSamplingScore(envelope) < samplingPercentage);
    }, Sample;
   }();
   function _getResponseText(xhr) {
    try {
     return xhr.responseText;
    } catch (e) {}
    return null;
   }
   var defaultAppInsightsChannelConfig = (0, ts_utils.ZHX)(((_a = {
    endpointUrl: (0, ConfigDefaultHelpers.Lx)(ts_utils.zzB, Constants._G + Constants.wc)
   }).emitLineDelimitedJson = (0, ConfigDefaultHelpers.DD)(), _a.maxBatchInterval = 15e3, 
   _a.maxBatchSizeInBytes = 102400, _a.disableTelemetry = (0, ConfigDefaultHelpers.DD)(), 
   _a.enableSessionStorageBuffer = (0, ConfigDefaultHelpers.DD)(!0), _a.isRetryDisabled = (0, 
   ConfigDefaultHelpers.DD)(), _a.isBeaconApiDisabled = (0, ConfigDefaultHelpers.DD)(!0), 
   _a.disableSendBeaconSplit = (0, ConfigDefaultHelpers.DD)(!0), _a.disableXhr = (0, 
   ConfigDefaultHelpers.DD)(), _a.onunloadDisableFetch = (0, ConfigDefaultHelpers.DD)(), 
   _a.onunloadDisableBeacon = (0, ConfigDefaultHelpers.DD)(), _a.instrumentationKey = undefined, 
   _a.namePrefix = undefined, _a.samplingPercentage = (0, ConfigDefaultHelpers.Lx)((function(value) {
    return !isNaN(value) && value > 0 && value <= 100;
   }), 100), _a.customHeaders = undefined, _a.convertUndefined = undefined, _a.eventsLimitInMem = 1e4, 
   _a.bufferOverride = !1, _a.httpXHROverride = {
    isVal: function(httpXHROverride) {
     return httpXHROverride && httpXHROverride.sendPOST;
    },
    v: undefined
   }, _a.alwaysUseXhrOverride = (0, ConfigDefaultHelpers.DD)(), _a.transports = undefined, 
   _a.retryCodes = undefined, _a.maxRetryCnt = {
    isVal: ts_utils.EtT,
    v: 10
   }, _a));
   var dist_es5_a, EnvelopeTypeCreator = ((_b = {})[Event.J.dataType] = EventEnvelopeCreator, 
   _b[Trace.C.dataType] = function(logger, telemetryItem, customUndefinedValue) {
    EnvelopeCreatorInit(logger, telemetryItem);
    var message = telemetryItem.baseData.message, severityLevel = telemetryItem.baseData.severityLevel, props = telemetryItem.baseData.properties || {}, measurements = telemetryItem.baseData.measurements || {};
    _extractPropsAndMeasurements(telemetryItem.data, props, measurements), (0, ts_utils.hXl)(customUndefinedValue) || _convertPropsUndefinedToCustomDefinedValue(props, customUndefinedValue);
    var baseData = new Trace.C(logger, message, severityLevel, props, measurements), data = new Data.B(Trace.C.dataType, baseData);
    return _createEnvelope(logger, Trace.C.envelopeType, telemetryItem, data);
   }, _b[PageView.h.dataType] = function(logger, telemetryItem, customUndefinedValue) {
    var duration;
    EnvelopeCreatorInit(logger, telemetryItem);
    var baseData = telemetryItem.baseData;
    (0, ts_utils.hXl)(baseData) || (0, ts_utils.hXl)(baseData.properties) || (0, ts_utils.hXl)(baseData.properties.duration) ? (0, 
    ts_utils.hXl)(telemetryItem.data) || (0, ts_utils.hXl)(telemetryItem.data.duration) || (duration = telemetryItem.data.duration, 
    delete telemetryItem.data.duration) : (duration = baseData.properties.duration, 
    delete baseData.properties.duration);
    var currentContextId, bd = telemetryItem.baseData;
    ((telemetryItem.ext || {}).trace || {}).traceID && (currentContextId = telemetryItem.ext.trace.traceID);
    var id = bd.id || currentContextId, name = bd.name, url = bd.uri, properties = bd.properties || {}, measurements = bd.measurements || {};
    if ((0, ts_utils.hXl)(bd.refUri) || (properties.refUri = bd.refUri), (0, ts_utils.hXl)(bd.pageType) || (properties.pageType = bd.pageType), 
    (0, ts_utils.hXl)(bd.isLoggedIn) || (properties.isLoggedIn = bd.isLoggedIn.toString()), 
    !(0, ts_utils.hXl)(bd.properties)) {
     var pageTags = bd.properties;
     (0, ts_utils.zav)(pageTags, (function(key, value) {
      properties[key] = value;
     }));
    }
    _extractPropsAndMeasurements(telemetryItem.data, properties, measurements), (0, 
    ts_utils.hXl)(customUndefinedValue) || _convertPropsUndefinedToCustomDefinedValue(properties, customUndefinedValue);
    var pageViewData = new PageView.h(logger, name, url, duration, properties, measurements, id), data = new Data.B(PageView.h.dataType, pageViewData);
    return _createEnvelope(logger, PageView.h.envelopeType, telemetryItem, data);
   }, _b[PageViewPerformance.H.dataType] = function(logger, telemetryItem, customUndefinedValue) {
    EnvelopeCreatorInit(logger, telemetryItem);
    var bd = telemetryItem.baseData, name = bd.name, url = bd.uri || bd.url, properties = bd.properties || {}, measurements = bd.measurements || {};
    _extractPropsAndMeasurements(telemetryItem.data, properties, measurements), (0, 
    ts_utils.hXl)(customUndefinedValue) || _convertPropsUndefinedToCustomDefinedValue(properties, customUndefinedValue);
    var baseData = new PageViewPerformance.H(logger, name, url, void 0, properties, measurements, bd), data = new Data.B(PageViewPerformance.H.dataType, baseData);
    return _createEnvelope(logger, PageViewPerformance.H.envelopeType, telemetryItem, data);
   }, _b[Exception.WJ.dataType] = function(logger, telemetryItem, customUndefinedValue) {
    EnvelopeCreatorInit(logger, telemetryItem);
    var customMeasurements = telemetryItem.baseData.measurements || {}, customProperties = telemetryItem.baseData.properties || {};
    _extractPropsAndMeasurements(telemetryItem.data, customProperties, customMeasurements), 
    (0, ts_utils.hXl)(customUndefinedValue) || _convertPropsUndefinedToCustomDefinedValue(customProperties, customUndefinedValue);
    var bd = telemetryItem.baseData, exData = Exception.WJ.CreateFromInterface(logger, bd, customProperties, customMeasurements), data = new Data.B(Exception.WJ.dataType, exData);
    return _createEnvelope(logger, Exception.WJ.envelopeType, telemetryItem, data);
   }, _b[Metric.J.dataType] = function(logger, telemetryItem, customUndefinedValue) {
    EnvelopeCreatorInit(logger, telemetryItem);
    var baseData = telemetryItem.baseData, props = baseData.properties || {}, measurements = baseData.measurements || {};
    _extractPropsAndMeasurements(telemetryItem.data, props, measurements), (0, ts_utils.hXl)(customUndefinedValue) || _convertPropsUndefinedToCustomDefinedValue(props, customUndefinedValue);
    var baseMetricData = new Metric.J(logger, baseData.name, baseData.average, baseData.sampleCount, baseData.min, baseData.max, baseData.stdDev, props, measurements), data = new Data.B(Metric.J.dataType, baseMetricData);
    return _createEnvelope(logger, Metric.J.envelopeType, telemetryItem, data);
   }, _b[RemoteDependencyData.A.dataType] = function(logger, telemetryItem, customUndefinedValue) {
    EnvelopeCreatorInit(logger, telemetryItem);
    var customMeasurements = telemetryItem.baseData.measurements || {}, customProperties = telemetryItem.baseData.properties || {};
    _extractPropsAndMeasurements(telemetryItem.data, customProperties, customMeasurements), 
    (0, ts_utils.hXl)(customUndefinedValue) || _convertPropsUndefinedToCustomDefinedValue(customProperties, customUndefinedValue);
    var bd = telemetryItem.baseData;
    if ((0, ts_utils.hXl)(bd)) return (0, DiagnosticLogger.OG)(logger, "Invalid input for dependency data"), 
    null;
    var method = bd.properties && bd.properties[Constants.ym] ? bd.properties[Constants.ym] : "GET", remoteDepData = new RemoteDependencyData.A(logger, bd.id, bd.target, bd.name, bd.duration, bd.success, bd.responseCode, method, bd.type, bd.correlationContext, customProperties, customMeasurements), data = new Data.B(RemoteDependencyData.A.dataType, remoteDepData);
    return _createEnvelope(logger, RemoteDependencyData.A.envelopeType, telemetryItem, data);
   }, _b), Sender = function(_super) {
    function Sender() {
     var _consecutiveErrors, _retryAt, _paused, _timeoutHandle, _serializer, _stamp_specific_redirects, _headers, _this = _super.call(this) || this;
     _this.priority = 1001, _this.identifier = applicationinsights_common.BreezeChannelIdentifier;
     var _syncUnloadSender, _offlineListener, _evtNamespace, _endpointUrl, _orgEndpointUrl, _maxBatchSizeInBytes, _beaconSupported, _beaconOnUnloadSupported, _beaconNormalSupported, _customHeaders, _disableTelemetry, _instrumentationKey, _convertUndefined, _isRetryDisabled, _maxBatchInterval, _sessionStorageUsed, _bufferOverrideUsed, _namePrefix, _enableSendPromise, _alwaysUseCustomSend, _disableXhr, _fetchKeepAlive, _xhrSend, _fallbackSend, _disableBeaconSplit, _sendPostMgr, _retryCodes, _syncFetchPayload = 0;
     return (0, DynamicProto.A)(Sender, _this, (function(_self, _base) {
      function _xdrOnLoad(xdr, payload) {
       var responseText = _getResponseText(xdr);
       if (!xdr || responseText + "" != "200" && "" !== responseText) {
        var results = (0, ResponseHelpers.x)(responseText);
        results && results.itemsReceived && results.itemsReceived > results.itemsAccepted && !_isRetryDisabled ? _self._onPartialSuccess(payload, results) : _self._onError(payload, (0, 
        HelperFuncs.HU)(xdr));
       } else _consecutiveErrors = 0, _self._onSuccess(payload, 0);
      }
      function _xhrReadyStateChange(xhr, payload, countOfItemsInPayload) {
       4 === xhr.readyState && _checkResponsStatus(xhr.status, payload, xhr.responseURL, countOfItemsInPayload, (0, 
       HelperFuncs.r4)(xhr), _getResponseText(xhr) || xhr.response);
      }
      function _getPayloadArr(payload) {
       try {
        if (payload) {
         var arr = payload.oriPayload;
         return arr && arr.length ? arr : null;
        }
       } catch (e) {}
       return null;
      }
      function _validate(telemetryItem, diagLogger) {
       return !_disableTelemetry && (telemetryItem ? telemetryItem.baseData && !telemetryItem.baseType ? (diagLogger && (0, 
       DiagnosticLogger.ZP)(diagLogger, 1, 70, "Cannot send telemetry without baseData and baseType"), 
       !1) : (telemetryItem.baseType || (telemetryItem.baseType = "EventData"), _self._sender ? (envelope = telemetryItem, 
       _self._sample.isSampledIn(envelope) ? (telemetryItem[Constants.tU] = _self._sample.sampleRate, 
       !0) : (diagLogger && (0, DiagnosticLogger.ZP)(diagLogger, 2, 33, "Telemetry item was sampled out and not sent", {
        SampleRate: _self._sample.sampleRate
       }), !1)) : (diagLogger && (0, DiagnosticLogger.ZP)(diagLogger, 1, 28, "Sender was not initialized"), 
       !1)) : (diagLogger && (0, DiagnosticLogger.ZP)(diagLogger, 1, 7, "Cannot send empty telemetry"), 
       !1));
       var envelope;
      }
      function _getEnvelope(telemetryItem, diagLogger) {
       var defaultEnvelopeIkey = telemetryItem.iKey || _instrumentationKey, aiEnvelope = Sender.constructEnvelope(telemetryItem, defaultEnvelopeIkey, diagLogger, _convertUndefined);
       if (aiEnvelope) {
        var doNotSendItem = !1;
        if (telemetryItem.tags && telemetryItem.tags[Constants.jp] && ((0, ts_utils.Iuo)(telemetryItem.tags[Constants.jp], (function(callBack) {
         try {
          callBack && !1 === callBack(aiEnvelope) && (doNotSendItem = !0, (0, DiagnosticLogger.OG)(diagLogger, "Telemetry processor check returns false"));
         } catch (e) {
          (0, DiagnosticLogger.ZP)(diagLogger, 1, 64, "One of telemetry initializers failed, telemetry item will not be sent: " + (0, 
          HelperFuncs.lL)(e), {
           exception: (0, ts_utils.mmD)(e)
          }, !0);
         }
        })), delete telemetryItem.tags[Constants.jp]), !doNotSendItem) return aiEnvelope;
       } else (0, DiagnosticLogger.ZP)(diagLogger, 1, 47, "Unable to create an AppInsights envelope");
      }
      function _serialize(item) {
       var rlt = "", diagLogger = _self.diagLog();
       try {
        var valid = _validate(item, diagLogger), envelope = null;
        valid && (envelope = _getEnvelope(item, diagLogger)), envelope && (rlt = _serializer.serialize(envelope));
       } catch (e) {}
       return rlt;
      }
      function _batch(arr) {
       var rlt = "";
       return arr && arr.length && (rlt = "[" + arr.join(",") + "]"), rlt;
      }
      function _createPayload(data) {
       var _a, headers = _getHeaders();
       return (_a = {
        urlString: _endpointUrl
       }).data = data, _a.headers = headers, _a;
      }
      function _doSend(sendInterface, payload, isAsync, markAsSent) {
       void 0 === markAsSent && (markAsSent = !0);
       var payloadData = _getPayload(payload), sendPostFunc = sendInterface && sendInterface.sendPOST;
       return sendPostFunc && payloadData ? (markAsSent && _self._buffer.markAsSent(payload), 
       sendPostFunc(payloadData, (function(status, headers, response) {
        return function(payload, status, headers, response) {
         200 === status && payload ? _self._onSuccess(payload, payload.length) : response && _self._onError(payload, response);
        }(payload, status, 0, response);
       }), !isAsync)) : null;
      }
      function _getPayload(payload) {
       var _a;
       if ((0, ts_utils.cyL)(payload) && payload.length > 0) {
        var batch = _self._buffer.batchPayloads(payload), headers = _getHeaders();
        return (_a = {}).data = batch, _a.urlString = _endpointUrl, _a.headers = headers, 
        _a.disableXhrSync = _disableXhr, _a.disableFetchKeepAlive = !_fetchKeepAlive, _a.oriPayload = payload, 
        _a;
       }
       return null;
      }
      function _getHeaders() {
       try {
        var headers = _headers || {};
        return (0, Util.Qu)(_endpointUrl) && (headers[RequestResponseHeaders.a[6]] = RequestResponseHeaders.a[7]), 
        headers;
       } catch (e) {}
       return null;
      }
      function _checkMaxSize(incomingPayload) {
       var incomingSize = incomingPayload ? incomingPayload.length : 0;
       return _self._buffer.size() + incomingSize > _maxBatchSizeInBytes && (_offlineListener && !_offlineListener.isOnline() || _self.triggerSend(!0, null, 10), 
       !0);
      }
      function _checkResponsStatus(status, payload, responseUrl, countOfItemsInPayload, errorMessage, res) {
       var response = null;
       if (_self._appId || (response = (0, ResponseHelpers.x)(res)) && response.appId && (_self._appId = response.appId), 
       (status < 200 || status >= 300) && 0 !== status) {
        if ((301 === status || 307 === status || 308 === status) && !_checkAndUpdateEndPointUrl(responseUrl)) return void _self._onError(payload, errorMessage);
        if (_offlineListener && !_offlineListener.isOnline()) {
         if (!_isRetryDisabled) {
          _resendPayload(payload, 10), (0, DiagnosticLogger.ZP)(_self.diagLog(), 2, 40, ". Offline - Response Code: ".concat(status, ". Offline status: ").concat(!_offlineListener.isOnline(), ". Will retry to send ").concat(payload.length, " items."));
         }
         return;
        }
        !_isRetryDisabled && _isRetriable(status) ? (_resendPayload(payload), (0, DiagnosticLogger.ZP)(_self.diagLog(), 2, 40, ". Response code " + status + ". Will retry to send " + payload.length + " items.")) : _self._onError(payload, errorMessage);
       } else _checkAndUpdateEndPointUrl(responseUrl), 206 === status ? (response || (response = (0, 
       ResponseHelpers.x)(res)), response && !_isRetryDisabled ? _self._onPartialSuccess(payload, response) : _self._onError(payload, errorMessage)) : (_consecutiveErrors = 0, 
       _self._onSuccess(payload, countOfItemsInPayload));
      }
      function _checkAndUpdateEndPointUrl(responseUrl) {
       return !(_stamp_specific_redirects >= 10) && (!(0, ts_utils.hXl)(responseUrl) && "" !== responseUrl && responseUrl !== _endpointUrl && (_endpointUrl = responseUrl, 
       ++_stamp_specific_redirects, !0));
      }
      function _doUnloadSend(payload, isAsync) {
       if (!_syncUnloadSender) return _doSend(_sendPostMgr && _sendPostMgr.getSenderInst([ 3 ], !0), payload, isAsync);
       _syncUnloadSender(payload, !1);
      }
      function _isStringArr(arr) {
       try {
        if (arr && arr.length) return (0, ts_utils.KgX)(arr[0]);
       } catch (e) {}
       return null;
      }
      function _fetchKeepAliveSender(payload, isAsync) {
       var transport = null;
       if ((0, ts_utils.cyL)(payload)) {
        for (var payloadSize = payload.length, lp = 0; lp < payload.length; lp++) payloadSize += payload[lp].item.length;
        return _sendPostMgr.getSyncFetchPayload() + payloadSize <= 65e3 ? transport = 2 : (0, 
        EnvUtils.Uf)() ? transport = 3 : (transport = 1, (0, DiagnosticLogger.ZP)(_self.diagLog(), 2, 40, ". Failed to send telemetry with Beacon API, retried with xhrSender.")), 
        _doSend(_sendPostMgr && _sendPostMgr.getSenderInst([ transport ], !0), payload, isAsync);
       }
       return null;
      }
      function _resendPayload(payload, linearFactor) {
       if (void 0 === linearFactor && (linearFactor = 1), payload && 0 !== payload.length) {
        var buffer = _self._buffer;
        buffer.clearSent(payload), _consecutiveErrors++;
        for (var _i = 0, payload_1 = payload; _i < payload_1.length; _i++) {
         var item = payload_1[_i];
         item.cnt = item.cnt || 0, item.cnt++, buffer.enqueue(item);
        }
        !function(linearFactor) {
         var delayInSeconds, SlotDelayInSeconds = 10;
         if (_consecutiveErrors <= 1) delayInSeconds = SlotDelayInSeconds; else {
          var backOffSlot = (Math.pow(2, _consecutiveErrors) - 1) / 2, backOffDelay = Math.floor(Math.random() * backOffSlot * SlotDelayInSeconds) + 1;
          backOffDelay *= linearFactor, delayInSeconds = Math.max(Math.min(backOffDelay, 3600), SlotDelayInSeconds);
         }
         var retryAfterTimeSpan = (0, ts_utils.f0d)() + 1e3 * delayInSeconds;
         _retryAt = retryAfterTimeSpan;
        }(linearFactor), _setupTimer();
       }
      }
      function _setupTimer() {
       if (!_timeoutHandle && !_paused) {
        var retryInterval = _retryAt ? Math.max(0, _retryAt - (0, ts_utils.f0d)()) : 0, timerValue = Math.max(_maxBatchInterval, retryInterval);
        _timeoutHandle = (0, ts_utils.dRz)((function() {
         _timeoutHandle = null, _self.triggerSend(!0, null, 1);
        }), timerValue);
       }
      }
      function _clearScheduledTimer() {
       _timeoutHandle && _timeoutHandle.cancel(), _timeoutHandle = null, _retryAt = null;
      }
      function _isRetriable(statusCode) {
       return (0, ts_utils.hXl)(_retryCodes) ? 401 === statusCode || 408 === statusCode || 429 === statusCode || 500 === statusCode || 502 === statusCode || 503 === statusCode || 504 === statusCode : _retryCodes.length && _retryCodes.indexOf(statusCode) > -1;
      }
      function _initDefaults() {
       _self._sender = null, _self._buffer = null, _self._appId = null, _self._sample = null, 
       _headers = {}, _offlineListener = null, _consecutiveErrors = 0, _retryAt = null, 
       _paused = !1, _timeoutHandle = null, _serializer = null, _stamp_specific_redirects = 0, 
       _syncFetchPayload = 0, _syncUnloadSender = null, _evtNamespace = null, _endpointUrl = null, 
       _orgEndpointUrl = null, _maxBatchSizeInBytes = 0, _beaconSupported = !1, _customHeaders = null, 
       _disableTelemetry = !1, _instrumentationKey = null, _convertUndefined = undefined, 
       _isRetryDisabled = !1, _sessionStorageUsed = null, _namePrefix = undefined, _disableXhr = !1, 
       _fetchKeepAlive = !1, _disableBeaconSplit = !1, _xhrSend = null, _fallbackSend = null, 
       _sendPostMgr = null, (0, ts_utils.vF1)(_self, "_senderConfig", {
        g: function() {
         return (0, HelperFuncs.CP)({}, defaultAppInsightsChannelConfig);
        }
       });
      }
      _initDefaults(), _self.pause = function() {
       _clearScheduledTimer(), _paused = !0;
      }, _self.resume = function() {
       _paused && (_paused = !1, _retryAt = null, _checkMaxSize(), _setupTimer());
      }, _self.flush = function(isAsync, callBack, sendReason) {
       if (void 0 === isAsync && (isAsync = !0), !_paused) {
        _clearScheduledTimer();
        try {
         return _self.triggerSend(isAsync, null, sendReason || 1);
        } catch (e) {
         (0, DiagnosticLogger.ZP)(_self.diagLog(), 1, 22, "flush failed, telemetry will not be collected: " + (0, 
         HelperFuncs.lL)(e), {
          exception: (0, ts_utils.mmD)(e)
         });
        }
       }
      }, _self.onunloadFlush = function() {
       if (!_paused) if (_beaconSupported || _alwaysUseCustomSend) try {
        return _self.triggerSend(!0, _doUnloadSend, 2);
       } catch (e) {
        (0, DiagnosticLogger.ZP)(_self.diagLog(), 1, 20, "failed to flush with beacon sender on page unload, telemetry will not be collected: " + (0, 
        HelperFuncs.lL)(e), {
         exception: (0, ts_utils.mmD)(e)
        });
       } else _self.flush(!1);
      }, _self.addHeader = function(name, value) {
       _headers[name] = value;
      }, _self.initialize = function(config, core, extensions, pluginChain) {
       _self.isInitialized() && (0, DiagnosticLogger.ZP)(_self.diagLog(), 1, 28, "Sender is already initialized"), 
       _base.initialize(config, core, extensions, pluginChain);
       var identifier = _self.identifier;
       _serializer = new Serializer(core.logger), _consecutiveErrors = 0, _retryAt = null, 
       _self._sender = null, _stamp_specific_redirects = 0;
       var diagLog = _self.diagLog();
       _evtNamespace = (0, EventHelpers.Hm)((0, DataCacheHelper.Z)("Sender"), core.evtNamespace && core.evtNamespace()), 
       _offlineListener = (0, Offline.G)(_evtNamespace), _self._addHook((0, DynamicConfig.a)(config, (function(details) {
        var config = details.cfg;
        config.storagePrefix && (0, StorageHelperFuncs.vh)(config.storagePrefix);
        var senderConfig = (0, ProcessTelemetryContext.i8)(null, config, core).getExtCfg(identifier, defaultAppInsightsChannelConfig);
        (0, ts_utils.$XS)(senderConfig.endpointUrl) && (senderConfig.endpointUrl = config.endpointUrl), 
        (0, ts_utils.$XS)(senderConfig.instrumentationKey) && (senderConfig.instrumentationKey = config.instrumentationKey), 
        (0, ts_utils.vF1)(_self, "_senderConfig", {
         g: function() {
          return senderConfig;
         }
        }), _orgEndpointUrl !== senderConfig.endpointUrl && (_endpointUrl = _orgEndpointUrl = senderConfig.endpointUrl), 
        core.activeStatus() === InitActiveStatusEnum.f.PENDING ? _self.pause() : core.activeStatus() === InitActiveStatusEnum.f.ACTIVE && _self.resume(), 
        _customHeaders && _customHeaders !== senderConfig.customHeaders && (0, ts_utils.Iuo)(_customHeaders, (function(customHeader) {
         delete _headers[customHeader.header];
        })), _maxBatchSizeInBytes = senderConfig.maxBatchSizeInBytes, _beaconSupported = (!1 === senderConfig.onunloadDisableBeacon || !1 === senderConfig.isBeaconApiDisabled) && (0, 
        EnvUtils.Uf)(), _beaconOnUnloadSupported = !1 === senderConfig.onunloadDisableBeacon && (0, 
        EnvUtils.Uf)(), _beaconNormalSupported = !1 === senderConfig.isBeaconApiDisabled && (0, 
        EnvUtils.Uf)(), _alwaysUseCustomSend = senderConfig.alwaysUseXhrOverride, _disableXhr = !!senderConfig.disableXhr, 
        _retryCodes = senderConfig.retryCodes;
        var bufferOverride = senderConfig.bufferOverride, canUseSessionStorage = !!senderConfig.enableSessionStorageBuffer && (!!bufferOverride || (0, 
        StorageHelperFuncs.AN)()), namePrefix = senderConfig.namePrefix, shouldUpdate = canUseSessionStorage !== _sessionStorageUsed || canUseSessionStorage && _namePrefix !== namePrefix || canUseSessionStorage && _bufferOverrideUsed !== bufferOverride;
        if (_self._buffer) {
         if (shouldUpdate) try {
          _self._buffer = _self._buffer.createNew(diagLog, senderConfig, canUseSessionStorage);
         } catch (e) {
          (0, DiagnosticLogger.ZP)(_self.diagLog(), 1, 12, "failed to transfer telemetry to different buffer storage, telemetry will be lost: " + (0, 
          HelperFuncs.lL)(e), {
           exception: (0, ts_utils.mmD)(e)
          });
         }
         _checkMaxSize();
        } else _self._buffer = canUseSessionStorage ? new SessionStorageSendBuffer(diagLog, senderConfig) : new ArraySendBuffer(diagLog, senderConfig);
        _namePrefix = namePrefix, _sessionStorageUsed = canUseSessionStorage, _bufferOverrideUsed = bufferOverride, 
        _fetchKeepAlive = !senderConfig.onunloadDisableFetch && (0, EnvUtils.R7)(!0), _disableBeaconSplit = !!senderConfig.disableSendBeaconSplit, 
        _self._sample = new Sample(senderConfig.samplingPercentage, diagLog), _instrumentationKey = senderConfig.instrumentationKey, 
        (0, ts_utils.$XS)(_instrumentationKey) || function(instrumentationKey, config) {
         var disableValidation = config.disableInstrumentationKeyValidation;
         if (!(0, ts_utils.hXl)(disableValidation) && disableValidation) return !0;
         return new RegExp("^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$").test(instrumentationKey);
        }(_instrumentationKey, config) || (0, DiagnosticLogger.ZP)(diagLog, 1, 100, "Invalid Instrumentation key " + _instrumentationKey), 
        _customHeaders = senderConfig.customHeaders, (0, ts_utils.KgX)(_endpointUrl) && !(0, 
        Util.Qu)(_endpointUrl) && _customHeaders && _customHeaders.length > 0 ? (0, ts_utils.Iuo)(_customHeaders, (function(customHeader) {
         _this.addHeader(customHeader.header, customHeader.value);
        })) : _customHeaders = null, _enableSendPromise = senderConfig.enableSendPromise;
        var sendPostConfig = function() {
         var _a;
         try {
          var onCompleteFuncs = {
           xdrOnComplete: function(xdr, oncomplete, payload) {
            var data = _getPayloadArr(payload);
            if (data) return _xdrOnLoad(xdr, data);
           },
           fetchOnComplete: function(response, onComplete, resValue, payload) {
            var data = _getPayloadArr(payload);
            if (data) return _checkResponsStatus(response.status, data, response.url, data.length, response.statusText, resValue || "");
           },
           xhrOnComplete: function(request, oncomplete, payload) {
            var data = _getPayloadArr(payload);
            if (data) return _xhrReadyStateChange(request, data, data.length);
           },
           beaconOnRetry: function(data, onComplete, canSend) {
            return function(payload, onComplete, canSend) {
             var internalPayload = payload, data = internalPayload && internalPayload.oriPayload;
             if (_disableBeaconSplit) _fallbackSend && _fallbackSend(data, !0), (0, DiagnosticLogger.ZP)(_self.diagLog(), 2, 40, ". Failed to send telemetry with Beacon API, retried with normal sender."); else {
              for (var droppedPayload = [], lp = 0; lp < data.length; lp++) {
               var thePayload = data[lp], arr = [ thePayload ];
               canSend(_getPayload(arr), onComplete) ? _self._onSuccess(arr, arr.length) : droppedPayload.push(thePayload);
              }
              droppedPayload.length > 0 && (_fallbackSend && _fallbackSend(droppedPayload, !0), 
              (0, DiagnosticLogger.ZP)(_self.diagLog(), 2, 40, ". Failed to send telemetry with Beacon API, retried with normal sender."));
             }
            }(data, onComplete, canSend);
           }
          };
          return (_a = {}).enableSendPromise = _enableSendPromise, _a.isOneDs = !1, _a.disableCredentials = !1, 
          _a.disableXhr = _disableXhr, _a.disableBeacon = !_beaconNormalSupported, _a.disableBeaconSync = !_beaconOnUnloadSupported, 
          _a.senderOnCompleteCallBack = onCompleteFuncs, _a;
         } catch (e) {}
         return null;
        }();
        _sendPostMgr ? _sendPostMgr.SetConfig(sendPostConfig) : (_sendPostMgr = new SenderPostManager.v).initialize(sendPostConfig, diagLog);
        var customInterface = senderConfig.httpXHROverride, httpInterface = null, syncInterface = null, theTransports = (0, 
        HelperFuncs.jL)([ 3, 1, 2 ], senderConfig.transports);
        httpInterface = _sendPostMgr && _sendPostMgr.getSenderInst(theTransports, !1);
        var xhrInterface = _sendPostMgr && _sendPostMgr.getFallbackInst();
        _xhrSend = function(payload, isAsync) {
         return _doSend(xhrInterface, payload, isAsync);
        }, _fallbackSend = function(payload, isAsync) {
         return _doSend(xhrInterface, payload, isAsync, !1);
        }, httpInterface = _alwaysUseCustomSend ? customInterface : httpInterface || customInterface || xhrInterface, 
        _self._sender = function(payload, isAsync) {
         return _doSend(httpInterface, payload, isAsync);
        }, _fetchKeepAlive && (_syncUnloadSender = _fetchKeepAliveSender);
        var syncTransports = (0, HelperFuncs.jL)([ 3, 1 ], senderConfig.unloadTransports);
        _fetchKeepAlive || (syncTransports = syncTransports.filter((function(transport) {
         return 2 !== transport;
        }))), syncInterface = _sendPostMgr && _sendPostMgr.getSenderInst(syncTransports, !0), 
        syncInterface = _alwaysUseCustomSend ? customInterface : syncInterface || customInterface, 
        (_alwaysUseCustomSend || senderConfig.unloadTransports || !_syncUnloadSender) && syncInterface && (_syncUnloadSender = function(payload, isAsync) {
         return _doSend(syncInterface, payload, isAsync);
        }), _syncUnloadSender || (_syncUnloadSender = _xhrSend), _disableTelemetry = senderConfig.disableTelemetry, 
        _convertUndefined = senderConfig.convertUndefined || undefined, _isRetryDisabled = senderConfig.isRetryDisabled, 
        _maxBatchInterval = senderConfig.maxBatchInterval;
       })));
      }, _self.processTelemetry = function(telemetryItem, itemCtx) {
       var _a, diagLogger = (itemCtx = _self._getTelCtx(itemCtx)).diagLog();
       try {
        if (!_validate(telemetryItem, diagLogger)) return;
        var aiEnvelope = _getEnvelope(telemetryItem, diagLogger);
        if (!aiEnvelope) return;
        var payload = _serializer.serialize(aiEnvelope), buffer = _self._buffer;
        _checkMaxSize(payload);
        var payloadItem = ((_a = {}).item = payload, _a.cnt = 0, _a);
        buffer.enqueue(payloadItem), _setupTimer();
       } catch (e) {
        (0, DiagnosticLogger.ZP)(diagLogger, 2, 12, "Failed adding telemetry to the sender's buffer, some telemetry will be lost: " + (0, 
        HelperFuncs.lL)(e), {
         exception: (0, ts_utils.mmD)(e)
        });
       }
       _self.processNext(telemetryItem, itemCtx);
      }, _self.isCompletelyIdle = function() {
       return !_paused && 0 === _syncFetchPayload && 0 === _self._buffer.count();
      }, _self._xhrReadyStateChange = function(xhr, payload, countOfItemsInPayload) {
       if (!_isStringArr(payload)) return _xhrReadyStateChange(xhr, payload, countOfItemsInPayload);
      }, _self.triggerSend = function(async, forcedSender, sendReason) {
       var result;
       if (void 0 === async && (async = !0), !_paused) try {
        var buffer = _self._buffer;
        if (_disableTelemetry) buffer.clear(); else {
         if (buffer.count() > 0) {
          var payload = buffer.getItems();
          !function(sendRequest, isAsync) {
           var manager = function() {
            var func = "getNotifyMgr";
            if (_self.core[func]) return _self.core[func]();
            return _self.core._notificationManager;
           }();
           if (manager && manager.eventsSendRequest) try {
            manager.eventsSendRequest(sendRequest, isAsync);
           } catch (e) {
            (0, DiagnosticLogger.ZP)(_self.diagLog(), 1, 74, "send request notification failed: " + (0, 
            HelperFuncs.lL)(e), {
             exception: (0, ts_utils.mmD)(e)
            });
           }
          }(sendReason || 0, async), result = forcedSender ? forcedSender.call(_self, payload, async) : _self._sender(payload, async);
         }
         +new Date;
        }
        _clearScheduledTimer();
       } catch (e) {
        var ieVer = (0, EnvUtils.L0)();
        (!ieVer || ieVer > 9) && (0, DiagnosticLogger.ZP)(_self.diagLog(), 1, 40, "Telemetry transmission failed, some telemetry will be lost: " + (0, 
        HelperFuncs.lL)(e), {
         exception: (0, ts_utils.mmD)(e)
        });
       }
       return result;
      }, _self.getOfflineSupport = function() {
       var _a;
       return (_a = {
        getUrl: function() {
         return _endpointUrl;
        },
        createPayload: _createPayload
       }).serialize = _serialize, _a.batch = _batch, _a.shouldProcess = function(evt) {
        return !!_validate(evt);
       }, _a;
      }, _self._doTeardown = function(unloadCtx, unloadState) {
       _self.onunloadFlush(), (0, AsyncUtils.K)(_offlineListener, !1), _initDefaults();
      }, _self._onError = function(payload, message, event) {
       if (!_isStringArr(payload)) return function(payload, message) {
        (0, DiagnosticLogger.ZP)(_self.diagLog(), 2, 26, "Failed to send telemetry.", {
         message
        }), _self._buffer && _self._buffer.clearSent(payload);
       }(payload, message);
      }, _self._onPartialSuccess = function(payload, results) {
       if (!_isStringArr(payload)) return function(payload, results) {
        for (var failed = [], retry = [], errors = results.errors.reverse(), _i = 0, errors_1 = errors; _i < errors_1.length; _i++) {
         var error = errors_1[_i], extracted = payload.splice(error.index, 1)[0];
         _isRetriable(error.statusCode) ? retry.push(extracted) : failed.push(extracted);
        }
        payload.length > 0 && _self._onSuccess(payload, results.itemsAccepted);
        failed.length > 0 && _self._onError(failed, (0, HelperFuncs.r4)(null, [ "partial success", results.itemsAccepted, "of", results.itemsReceived ].join(" ")));
        retry.length > 0 && (_resendPayload(retry), (0, DiagnosticLogger.ZP)(_self.diagLog(), 2, 40, "Partial success. Delivered: " + payload.length + ", Failed: " + failed.length + ". Will retry to send " + retry.length + " our of " + results.itemsReceived + " items"));
       }(payload, results);
      }, _self._onSuccess = function(payload, countOfItemsInPayload) {
       if (!_isStringArr(payload)) return function(payload) {
        _self._buffer && _self._buffer.clearSent(payload);
       }(payload);
      }, _self._xdrOnLoad = function(xdr, payload) {
       if (!_isStringArr(payload)) return _xdrOnLoad(xdr, payload);
      };
     })), _this;
    }
    return (0, TsLibShims.qU)(Sender, _super), Sender.constructEnvelope = function(orig, iKey, logger, convertUndefined) {
     var envelope;
     return envelope = iKey === orig.iKey || (0, ts_utils.hXl)(iKey) ? orig : (0, TsLibShims.Im)((0, 
     TsLibShims.Im)({}, orig), {
      iKey
     }), (EnvelopeTypeCreator[envelope.baseType] || EventEnvelopeCreator)(logger, envelope, convertUndefined);
    }, Sender;
   }(BaseTelemetryPlugin.s), ConnectionStringParser = __webpack_require__(74484), AppInsightsCore = __webpack_require__(82774), ts_async = __webpack_require__(8205), SeverityLevel = __webpack_require__(29762), defaultConfigValues = ((dist_es5_a = {
    diagnosticLogInterval: (0, ConfigDefaultHelpers.Lx)((function(value) {
     return value && value > 0;
    }), 1e4)
   }).connectionString = undefined, dist_es5_a.endpointUrl = undefined, dist_es5_a.instrumentationKey = undefined, 
   dist_es5_a.extensionConfig = {}, dist_es5_a);
   var ApplicationInsights = function() {
    function ApplicationInsights(config) {
     var _config, core = new AppInsightsCore._;
     function _track(item) {
      item && (item.baseData = item.baseData || {}, item.baseType = item.baseType || "EventData"), 
      core.track(item);
     }
     ((0, ts_utils.hXl)(config) || (0, ts_utils.hXl)(config.instrumentationKey) && (0, 
     ts_utils.hXl)(config.connectionString)) && (0, ts_utils.$8)("Invalid input configuration"), 
     (0, DynamicProto.A)(ApplicationInsights, this, (function(_self) {
      function _initialize() {
       var cfgHandler = (0, DynamicConfig.e)(config || {}, defaultConfigValues);
       _config = cfgHandler.cfg, core.addUnloadHook((0, DynamicConfig.a)(cfgHandler, (function() {
        var configCs = _config.connectionString;
        if ((0, ts_utils.$XS)(configCs)) {
         var ikeyPromise = (0, ts_async.Rf)((function(resolve, reject) {
          (0, ts_async.Dv)(configCs, (function(res) {
           var curCs = res.value, ikey = _config.instrumentationKey;
           !res.rejected && curCs && (_config.connectionString = curCs, ikey = (0, ConnectionStringParser.H)(curCs).instrumentationkey || ikey);
           resolve(ikey);
          }));
         })), urlPromise = (0, ts_async.Rf)((function(resolve, reject) {
          (0, ts_async.Dv)(configCs, (function(res) {
           var curCs = res.value, url = _config.endpointUrl;
           if (!res.rejected && curCs) {
            var ingest = (0, ConnectionStringParser.H)(curCs).ingestionendpoint;
            url = ingest ? ingest + Constants.wc : url;
           }
           resolve(url);
          }));
         }));
         _config.instrumentationKey = ikeyPromise, _config.endpointUrl = _config.userOverrideEndpointUrl || urlPromise;
        }
        if ((0, ts_utils.KgX)(configCs)) {
         var cs = (0, ConnectionStringParser.H)(configCs), ingest = cs.ingestionendpoint;
         _config.endpointUrl = _config.userOverrideEndpointUrl ? _config.userOverrideEndpointUrl : ingest + Constants.wc, 
         _config.instrumentationKey = cs.instrumentationkey || _config.instrumentationKey;
        }
        _config.endpointUrl = _config.userOverrideEndpointUrl ? _config.userOverrideEndpointUrl : _config.endpointUrl;
       }))), core.initialize(_config, [ new Sender ]);
      }
      (0, ts_utils.vF1)(_self, "config", {
       g: function() {
        return _config;
       }
      }), _initialize(), _self.initialize = _initialize, _self.track = _track, (0, HelperFuncs.o$)(_self, core, [ "flush", "pollInternalLogs", "stopPollingInternalLogs", "unload", "getPlugin", "addPlugin", "evtNamespace", "addUnloadCb", "onCfgChange", "getTraceCtx", "updateCfg", "addTelemetryInitializer" ]);
     }));
    }
    return ApplicationInsights.__ieDyn = 1, ApplicationInsights;
   }();
  },
  68279: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    A: () => dynamicProto
   });
   var _a, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(269), Constructor = "constructor", Prototype = "prototype", strFunction = "function", DynInstFuncTable = "_dynInstFuncs", DynProxyTag = "_isDynProxy", DynClassName = "_dynClass", DynClassNamePrefix = "_dynCls$", DynInstChkTag = "_dynInstChk", DynAllowInstChkTag = DynInstChkTag, DynProtoDefaultOptions = "_dfOpts", UnknownValue = "_unknown_", str__Proto = "__proto__", DynProtoBaseProto = "_dyn" + str__Proto, DynProtoCurrent = "_dynInstProto", strUseBaseInst = "useBaseInst", strSetInstFuncs = "setInstFuncs", Obj = Object, _objGetPrototypeOf = Obj.getPrototypeOf, _objGetOwnProps = Obj.getOwnPropertyNames, _gbl = (0, 
   _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.mS$)(), _gblInst = _gbl.__dynProto$Gbl || (_gbl.__dynProto$Gbl = {
    o: (_a = {}, _a[strSetInstFuncs] = !0, _a[strUseBaseInst] = !0, _a),
    n: 1e3
   });
   function _isObjectOrArrayPrototype(target) {
    return target && (target === Obj[Prototype] || target === Array[Prototype]);
   }
   function _isObjectArrayOrFunctionPrototype(target) {
    return _isObjectOrArrayPrototype(target) || target === Function[Prototype];
   }
   function _getObjProto(target) {
    var newProto;
    if (target) {
     if (_objGetPrototypeOf) return _objGetPrototypeOf(target);
     var curProto = target[str__Proto] || target[Prototype] || (target[Constructor] ? target[Constructor][Prototype] : null);
     newProto = target[DynProtoBaseProto] || curProto, (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.v0u)(target, DynProtoBaseProto) || (delete target[DynProtoCurrent], 
     newProto = target[DynProtoBaseProto] = target[DynProtoCurrent] || target[DynProtoBaseProto], 
     target[DynProtoCurrent] = curProto);
    }
    return newProto;
   }
   function _forEachProp(target, func) {
    var props = [];
    if (_objGetOwnProps) props = _objGetOwnProps(target); else for (var name_1 in target) "string" == typeof name_1 && (0, 
    _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.v0u)(target, name_1) && props.push(name_1);
    if (props && props.length > 0) for (var lp = 0; lp < props.length; lp++) func(props[lp]);
   }
   function _isDynamicCandidate(target, funcName, skipOwn) {
    return funcName !== Constructor && typeof target[funcName] === strFunction && (skipOwn || (0, 
    _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.v0u)(target, funcName)) && funcName !== str__Proto && funcName !== Prototype;
   }
   function _throwTypeError(message) {
    (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.zkd)("DynamicProto: " + message);
   }
   function _hasVisited(values, value) {
    for (var lp = values.length - 1; lp >= 0; lp--) if (values[lp] === value) return !0;
    return !1;
   }
   function _populatePrototype(proto, className, target, baseInstFuncs, setInstanceFunc) {
    function _createDynamicPrototype(proto, funcName) {
     var dynProtoProxy = function() {
      var instFunc = function(target, funcName, proto, currentDynProtoProxy) {
       var instFunc = null;
       if (target && (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.v0u)(proto, DynClassName)) {
        var instFuncTable = target[DynInstFuncTable] || (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.sSX)(null);
        if ((instFunc = (instFuncTable[proto[DynClassName]] || (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.sSX)(null))[funcName]) || _throwTypeError("Missing [" + funcName + "] " + strFunction), 
        !instFunc[DynInstChkTag] && !1 !== instFuncTable[DynAllowInstChkTag]) {
         for (var canAddInst = !(0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.v0u)(target, funcName), objProto = _getObjProto(target), visited = []; canAddInst && objProto && !_isObjectArrayOrFunctionPrototype(objProto) && !_hasVisited(visited, objProto); ) {
          var protoFunc = objProto[funcName];
          if (protoFunc) {
           canAddInst = protoFunc === currentDynProtoProxy;
           break;
          }
          visited.push(objProto), objProto = _getObjProto(objProto);
         }
         try {
          canAddInst && (target[funcName] = instFunc), instFunc[DynInstChkTag] = 1;
         } catch (e) {
          instFuncTable[DynAllowInstChkTag] = !1;
         }
        }
       }
       return instFunc;
      }(this, funcName, proto, dynProtoProxy) || function(funcName, proto, currentDynProtoProxy) {
       var protoFunc = proto[funcName];
       return protoFunc === currentDynProtoProxy && (protoFunc = _getObjProto(proto)[funcName]), 
       typeof protoFunc !== strFunction && _throwTypeError("[" + funcName + "] is not a " + strFunction), 
       protoFunc;
      }(funcName, proto, dynProtoProxy);
      return instFunc.apply(this, arguments);
     };
     return dynProtoProxy[DynProxyTag] = 1, dynProtoProxy;
    }
    if (!_isObjectOrArrayPrototype(proto)) {
     var instFuncTable = target[DynInstFuncTable] = target[DynInstFuncTable] || (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.sSX)(null);
     if (!_isObjectOrArrayPrototype(instFuncTable)) {
      var instFuncs_1 = instFuncTable[className] = instFuncTable[className] || (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.sSX)(null);
      !1 !== instFuncTable[DynAllowInstChkTag] && (instFuncTable[DynAllowInstChkTag] = !!setInstanceFunc), 
      _isObjectOrArrayPrototype(instFuncs_1) || _forEachProp(target, (function(name) {
       _isDynamicCandidate(target, name, !1) && target[name] !== baseInstFuncs[name] && (instFuncs_1[name] = target[name], 
       delete target[name], (!(0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.v0u)(proto, name) || proto[name] && !proto[name][DynProxyTag]) && (proto[name] = _createDynamicPrototype(proto, name)));
      }));
     }
    }
   }
   function _getObjName(target, unknownValue) {
    return (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.v0u)(target, Prototype) ? target.name || unknownValue || UnknownValue : ((target || {})[Constructor] || {}).name || unknownValue || UnknownValue;
   }
   function dynamicProto(theClass, target, delegateFunc, options) {
    (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.v0u)(theClass, Prototype) || _throwTypeError("theClass is an invalid class definition.");
    var classProto = theClass[Prototype];
    (function(classProto, thisTarget) {
     if (_objGetPrototypeOf) {
      for (var visited = [], thisProto = _getObjProto(thisTarget); thisProto && !_isObjectArrayOrFunctionPrototype(thisProto) && !_hasVisited(visited, thisProto); ) {
       if (thisProto === classProto) return !0;
       visited.push(thisProto), thisProto = _getObjProto(thisProto);
      }
      return !1;
     }
     return !0;
    })(classProto, target) || _throwTypeError("[" + _getObjName(theClass) + "] not in hierarchy of [" + _getObjName(target) + "]");
    var className = null;
    (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.v0u)(classProto, DynClassName) ? className = classProto[DynClassName] : (className = DynClassNamePrefix + _getObjName(theClass, "_") + "$" + _gblInst.n, 
    _gblInst.n++, classProto[DynClassName] = className);
    var perfOptions = dynamicProto[DynProtoDefaultOptions], useBaseInst = !!perfOptions[strUseBaseInst];
    useBaseInst && options && void 0 !== options[strUseBaseInst] && (useBaseInst = !!options[strUseBaseInst]);
    var instFuncs = function(thisTarget) {
     var instFuncs = (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.sSX)(null);
     return _forEachProp(thisTarget, (function(name) {
      !instFuncs[name] && _isDynamicCandidate(thisTarget, name, !1) && (instFuncs[name] = thisTarget[name]);
     })), instFuncs;
    }(target), baseFuncs = function(classProto, thisTarget, instFuncs, useBaseInst) {
     function _instFuncProxy(target, funcHost, funcName) {
      var theFunc = funcHost[funcName];
      if (theFunc[DynProxyTag] && useBaseInst) {
       var instFuncTable = target[DynInstFuncTable] || {};
       !1 !== instFuncTable[DynAllowInstChkTag] && (theFunc = (instFuncTable[funcHost[DynClassName]] || {})[funcName] || theFunc);
      }
      return function() {
       return theFunc.apply(target, arguments);
      };
     }
     var baseFuncs = (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.sSX)(null);
     _forEachProp(instFuncs, (function(name) {
      baseFuncs[name] = _instFuncProxy(thisTarget, instFuncs, name);
     }));
     for (var baseProto = _getObjProto(classProto), visited = []; baseProto && !_isObjectArrayOrFunctionPrototype(baseProto) && !_hasVisited(visited, baseProto); ) _forEachProp(baseProto, (function(name) {
      !baseFuncs[name] && _isDynamicCandidate(baseProto, name, !_objGetPrototypeOf) && (baseFuncs[name] = _instFuncProxy(thisTarget, baseProto, name));
     })), visited.push(baseProto), baseProto = _getObjProto(baseProto);
     return baseFuncs;
    }(classProto, target, instFuncs, useBaseInst);
    delegateFunc(target, baseFuncs);
    var setInstanceFunc = !!_objGetPrototypeOf && !!perfOptions[strSetInstFuncs];
    setInstanceFunc && options && (setInstanceFunc = !!options[strSetInstFuncs]), _populatePrototype(classProto, className, target, instFuncs, !1 !== setInstanceFunc);
   }
   dynamicProto[DynProtoDefaultOptions] = _gblInst.o;
  },
  8205: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    Dv: () => doAwaitResponse,
    Qo: () => createPromise,
    Rf: () => createSyncPromise,
    Xf: () => createAllPromise,
    lh: () => createSyncAllSettledPromise
   });
   var _debugState, _debugResult, _debugHandled, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(269), STR_PROMISE = "Promise", REJECTED = "rejected";
   function doAwaitResponse(value, cb) {
    return doAwait(value, (function(value) {
     return cb ? cb({
      status: "fulfilled",
      rejected: !1,
      value
     }) : value;
    }), (function(reason) {
     return cb ? cb({
      status: REJECTED,
      rejected: !0,
      reason
     }) : reason;
    }));
   }
   function doAwait(value, resolveFn, rejectFn, finallyFn) {
    var result = value;
    try {
     if ((0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.$XS)(value)) (resolveFn || rejectFn) && (result = value.then(resolveFn, rejectFn)); else try {
      resolveFn && (result = resolveFn(value));
     } catch (err) {
      if (!rejectFn) throw err;
      result = rejectFn(err);
     }
    } finally {
     finallyFn && doFinally(result, finallyFn);
    }
    return result;
   }
   function doFinally(value, finallyFn) {
    var result = value;
    return finallyFn && ((0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.$XS)(value) ? result = value.finally ? value.finally(finallyFn) : value.then((function(value) {
     return finallyFn(), value;
    }), (function(reason) {
     throw finallyFn(), reason;
    })) : finallyFn()), result;
   }
   var _promiseDebugEnabled = !1;
   var _hasInitEvent, STRING_STATES = [ "pending", "resolving", "resolved", REJECTED ], DISPATCH_EVENT = "dispatchEvent";
   function _hasInitEventFn(doc) {
    var evt;
    return doc && doc.createEvent && (evt = doc.createEvent("Event")), !!evt && evt.initEvent;
   }
   var _hasPromiseRejectionEvent, NODE_UNHANDLED_REJECTION = "unhandledRejection", UNHANDLED_REJECTION = NODE_UNHANDLED_REJECTION.toLowerCase(), _currentPromiseId = [], _uniquePromiseId = 0, _unhandledRejectionTimeout = 10;
   function dumpFnObj(value) {
    return (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.Tnt)(value) ? value.toString() : (0, 
    _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.mmD)(value);
   }
   function _createPromise(newPromise, processor, executor) {
    var _settledValue, _thePromise, additionalArgs = (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.KVm)(arguments, 3), _state = 0, _hasResolved = !1, _queue = [], _id = _uniquePromiseId++, _parentId = _currentPromiseId.length > 0 ? _currentPromiseId[_currentPromiseId.length - 1] : void 0, _handled = !1, _unHandledRejectionHandler = null;
    function _then(onResolved, onRejected) {
     try {
      return _currentPromiseId.push(_id), _handled = !0, _unHandledRejectionHandler && _unHandledRejectionHandler.cancel(), 
      _unHandledRejectionHandler = null, newPromise((function(resolve, reject) {
       _queue.push((function() {
        try {
         var handler = 2 === _state ? onResolved : onRejected, value = (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.b07)(handler) ? _settledValue : (0, 
         _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.Tnt)(handler) ? handler(_settledValue) : handler;
         (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.$XS)(value) ? value.then(resolve, reject) : handler ? resolve(value) : 3 === _state ? reject(value) : resolve(value);
        } catch (e) {
         reject(e);
        }
       })), _hasResolved && _processQueue();
      }), additionalArgs);
     } finally {
      _currentPromiseId.pop();
     }
    }
    function _strState() {
     return STRING_STATES[_state];
    }
    function _processQueue() {
     if (_queue.length > 0) {
      var pending = _queue.slice();
      _queue = [], _handled = !0, _unHandledRejectionHandler && _unHandledRejectionHandler.cancel(), 
      _unHandledRejectionHandler = null, processor(pending);
     }
    }
    function _createSettleIfFn(newState, allowState) {
     return function(theValue) {
      if (_state === allowState) {
       if (2 === newState && (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.$XS)(theValue)) return _state = 1, 
       void theValue.then(_createSettleIfFn(2, 1), _createSettleIfFn(3, 1));
       _state = newState, _hasResolved = !0, _settledValue = theValue, _processQueue(), 
       _handled || 3 !== newState || _unHandledRejectionHandler || (_unHandledRejectionHandler = (0, 
       _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.dRz)(_notifyUnhandledRejection, _unhandledRejectionTimeout));
      }
     };
    }
    function _notifyUnhandledRejection() {
     if (!_handled) if (_handled = !0, (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.Lln)()) process.emit(NODE_UNHANDLED_REJECTION, _settledValue, _thePromise); else {
      var gbl = (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.zkX)() || (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.mS$)();
      !_hasPromiseRejectionEvent && (_hasPromiseRejectionEvent = (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.GuU)((0, 
      _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.gBW)(_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.zS2, [ STR_PROMISE + "RejectionEvent" ]).v)), 
      function(target, evtName, populateEvent, useNewEvent) {
       var doc = (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.YEm)();
       !_hasInitEvent && (_hasInitEvent = (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.GuU)(!!(0, 
       _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.gBW)(_hasInitEventFn, [ doc ]).v));
       var theEvt = _hasInitEvent.v ? doc.createEvent("Event") : useNewEvent ? new Event(evtName) : {};
       if (populateEvent && populateEvent(theEvt), _hasInitEvent.v && theEvt.initEvent(evtName, !1, !0), 
       theEvt && target[DISPATCH_EVENT]) target[DISPATCH_EVENT](theEvt); else {
        var handler = target["on" + evtName];
        if (handler) handler(theEvt); else {
         var theConsole = (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.zS2)("console");
         theConsole && (theConsole.error || theConsole.log)(evtName, (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.mmD)(theEvt));
        }
       }
      }(gbl, UNHANDLED_REJECTION, (function(theEvt) {
       return (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.vF1)(theEvt, "promise", {
        g: function() {
         return _thePromise;
        }
       }), theEvt.reason = _settledValue, theEvt;
      }), !!_hasPromiseRejectionEvent.v);
     }
    }
    return _thePromise = {
     then: _then,
     catch: function(onRejected) {
      return _then(void 0, onRejected);
     },
     finally: function(onFinally) {
      var thenFinally = onFinally, catchFinally = onFinally;
      return (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.Tnt)(onFinally) && (thenFinally = function(value) {
       return onFinally && onFinally(), value;
      }, catchFinally = function(reason) {
       throw onFinally && onFinally(), reason;
      }), _then(thenFinally, catchFinally);
     }
    }, (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.UxO)(_thePromise, "state", {
     get: _strState
    }), _promiseDebugEnabled && function(thePromise, stateFn, resultFn, handledFn) {
     _debugResult = _debugResult || {
      toString: function() {
       return "[[PromiseResult]]";
      }
     }, _debugHandled = _debugHandled || {
      toString: function() {
       return "[[PromiseIsHandled]]";
      }
     };
     var props = {};
     props[_debugState = _debugState || {
      toString: function() {
       return "[[PromiseState]]";
      }
     }] = {
      get: stateFn
     }, props[_debugResult] = {
      get: resultFn
     }, props[_debugHandled] = {
      get: handledFn
     }, (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isD)(thePromise, props);
    }(_thePromise, _strState, (function() {
     return (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.SZ2)(_settledValue);
    }), (function() {
     return _handled;
    })), (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.Lok)() && (_thePromise[(0, 
    _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.Y0g)(11)] = "IPromise"), _thePromise.toString = function() {
     return "IPromise" + (_promiseDebugEnabled ? "[" + _id + ((0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.b07)(_parentId) ? "" : ":" + _parentId) + "]" : "") + " " + _strState() + (_hasResolved ? " - " + dumpFnObj(_settledValue) : "");
    }, function() {
     (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.Tnt)(executor) || (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.zkd)(STR_PROMISE + ": executor is not a function - " + dumpFnObj(executor));
     var _rejectFn = _createSettleIfFn(3, 0);
     try {
      executor.call(_thePromise, _createSettleIfFn(2, 0), _rejectFn);
     } catch (e) {
      _rejectFn(e);
     }
    }(), _thePromise;
   }
   function _createAllPromise(newPromise) {
    return function(input) {
     var additionalArgs = (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.KVm)(arguments, 1);
     return newPromise((function(resolve, reject) {
      try {
       var values_1 = [], pending_1 = 1;
       (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.DA8)(input, (function(item, idx) {
        item && (pending_1++, doAwait(item, (function(value) {
         values_1[idx] = value, 0 == --pending_1 && resolve(values_1);
        }), reject));
       })), 0 === --pending_1 && resolve(values_1);
      } catch (e) {
       reject(e);
      }
     }), additionalArgs);
    };
   }
   function _createAllSettledPromise(newPromise) {
    return (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.GuU)((function(input) {
     var additionalArgs = (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.KVm)(arguments, 1);
     return newPromise((function(resolve, reject) {
      var values = [], pending = 1;
      function processItem(item, idx) {
       pending++, doAwaitResponse(item, (function(value) {
        value.rejected ? values[idx] = {
         status: REJECTED,
         reason: value.reason
        } : values[idx] = {
         status: "fulfilled",
         value: value.value
        }, 0 == --pending && resolve(values);
       }));
      }
      try {
       (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.cyL)(input) ? (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.Iuo)(input, processItem) : (0, 
       _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.xZI)(input) ? (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.DA8)(input, processItem) : (0, 
       _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.zkd)("Input is not an iterable"), 
       0 === --pending && resolve(values);
      } catch (e) {
       reject(e);
      }
     }), additionalArgs);
    }));
   }
   function syncItemProcessor(pending) {
    (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.Iuo)(pending, (function(fn) {
     try {
      fn();
     } catch (e) {}
    }));
   }
   function createAsyncPromise(executor, timeout) {
    return _createPromise(createAsyncPromise, function(timeout) {
     var callbackTimeout = (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.EtT)(timeout) ? timeout : 0;
     return function(pending) {
      (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.dRz)((function() {
       syncItemProcessor(pending);
      }), callbackTimeout);
     };
    }(timeout), executor, timeout);
   }
   var _promiseCls;
   function createNativePromise(executor, timeout) {
    !_promiseCls && (_promiseCls = (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.GuU)((0, 
    _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.gBW)(_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.zS2, [ STR_PROMISE ]).v || null));
    var PrmCls = _promiseCls.v;
    if (!PrmCls) return createAsyncPromise(executor);
    (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.Tnt)(executor) || (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.zkd)(STR_PROMISE + ": executor is not a function - " + (0, 
    _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.mmD)(executor));
    var _state = 0;
    var thePromise = new PrmCls((function(resolve, reject) {
     executor((function(value) {
      _state = 2, resolve(value);
     }), (function(reason) {
      _state = 3, reject(reason);
     }));
    }));
    return (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.UxO)(thePromise, "state", {
     get: function() {
      return STRING_STATES[_state];
     }
    }), thePromise;
   }
   var _allSyncSettledCreator;
   function createSyncPromise(executor) {
    return _createPromise(createSyncPromise, syncItemProcessor, executor);
   }
   function createSyncAllSettledPromise(input, timeout) {
    return !_allSyncSettledCreator && (_allSyncSettledCreator = _createAllSettledPromise(createSyncPromise)), 
    _allSyncSettledCreator.v(input, timeout);
   }
   var _promiseCreator;
   function createPromise(executor, timeout) {
    return !_promiseCreator && (_promiseCreator = (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.GuU)(createNativePromise)), 
    _promiseCreator.v.call(this, executor, timeout);
   }
   var createAllPromise = _createAllPromise(createPromise);
   (0, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.Y0g)(11);
  },
  269: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   function _pureAssign(func1, func2) {
    return func1 || func2;
   }
   function _pureRef(value, name) {
    return value[name];
   }
   __webpack_require__.d(__webpack_exports__, {
    $8: () => throwError,
    $PY: () => isDate,
    $XS: () => isPromiseLike,
    AHH: () => createTimeout,
    Cv9: () => strEndsWith,
    DA8: () => iterForOf,
    EHq: () => strTrim,
    Edw: () => isTypeof,
    EtT: () => isNumber,
    FJj: () => getPerformance,
    GuU: () => createCachedValue,
    Gvm: () => isObject,
    HzD: () => strIndexOf,
    Iuo: () => arrForEach,
    JKf: () => getHistory,
    KTd: () => arrReduce,
    KVm: () => arrSlice,
    KgX: () => isString,
    KhI: () => objHasOwn,
    Lln: () => isNode,
    Lmq: () => isBoolean,
    Lok: () => hasSymbol,
    N6t: () => objFreeze,
    Nq2: () => arrIncludes,
    O9V: () => isDefined,
    P0f: () => strSubstring,
    QdQ: () => isPlainObject,
    R3R: () => getLength,
    SZ2: () => objToString,
    Tnt: () => isFunction,
    UUD: () => perfNow,
    UxO: () => objDefineProp,
    Vdv: () => hasWindow,
    W$7: () => arrMap,
    WSA: () => createEnum,
    Wtk: () => hasDocument,
    Y0g: () => getKnownSymbol,
    YEm: () => getDocument,
    Yny: () => arrAppend,
    ZHX: () => objDeepFreeze,
    ZWZ: () => strLeft,
    aqQ: () => createCustomError,
    b07: () => isUndefined,
    bJ7: () => isError,
    cGk: () => objKeys,
    cyL: () => isArray,
    dRz: () => scheduleTimeout,
    eCG: () => symbolFor,
    f0d: () => utcNow,
    fn0: () => createTypeMap,
    gBW: () => safe,
    hKY: () => strSubstr,
    hXl: () => isNullOrUndefined,
    isD: () => objDefineProperties,
    jjc: () => newSymbol,
    jsL: () => objSeal,
    kgX: () => objGetOwnPropertyDescriptor,
    mS$: () => getGlobal,
    mmD: () => dumpObj,
    nRs: () => getLazy,
    oJg: () => asString,
    rDm: () => arrIndexOf,
    raO: () => objDefineAccessors,
    sSX: () => objCreate,
    tGl: () => strStartsWith,
    twz: () => hasHistory,
    v0u: () => objHasOwnProperty,
    vE3: () => objAssign,
    vF1: () => objDefine,
    vKV: () => scheduleTimeoutWith,
    w3n: () => getNavigator,
    w9M: () => hasNavigator,
    woc: () => isNotTruthy,
    xZI: () => isIterable,
    zS2: () => getInst,
    zav: () => objForEachKey,
    zkX: () => getWindow,
    zkd: () => throwTypeError,
    zwS: () => deepExtend,
    zzB: () => isTruthy
   });
   var _primitiveTypes, UNDEF_VALUE = void 0, NULL_VALUE = null, EMPTY = "", FUNCTION = "function", OBJECT = "object", PROTOTYPE = "prototype", __PROTO__ = "__proto__", UNDEFINED = "undefined", CONSTRUCTOR = "constructor", SYMBOL = "Symbol", POLYFILL_TAG = "_polyfill", LENGTH = "length", NAME = "name", CALL = "call", TO_STRING = "toString", ObjClass = _pureAssign(Object), ObjProto = _pureRef(ObjClass, PROTOTYPE), StrCls = _pureAssign(String), StrProto = _pureRef(StrCls, PROTOTYPE), MathCls = _pureAssign(Math), ArrCls = _pureAssign(Array), ArrProto = _pureRef(ArrCls, PROTOTYPE), ArrSlice = _pureRef(ArrProto, "slice");
   function safe(func, argArray) {
    try {
     return {
      v: func.apply(this, argArray)
     };
    } catch (e) {
     return {
      e
     };
    }
   }
   function _createIs(theType) {
    return function(value) {
     return typeof value === theType;
    };
   }
   function _createObjIs(theName) {
    var theType = "[object " + theName + "]";
    return function(value) {
     return !(!value || objToString(value) !== theType);
    };
   }
   function objToString(value) {
    return ObjProto[TO_STRING].call(value);
   }
   function isTypeof(value, theType) {
    return typeof value === theType;
   }
   function isUndefined(value) {
    return typeof value === UNDEFINED || value === UNDEFINED;
   }
   function isNullOrUndefined(value) {
    return value === NULL_VALUE || isUndefined(value);
   }
   function isDefined(arg) {
    return !!arg || arg !== UNDEF_VALUE;
   }
   function isPrimitiveType(theType) {
    return !_primitiveTypes && (_primitiveTypes = [ "string", "number", "boolean", UNDEFINED, "symbol", "bigint" ]), 
    !(theType === OBJECT || -1 === _primitiveTypes.indexOf(theType));
   }
   var isString = _createIs("string"), isFunction = _createIs(FUNCTION);
   function isObject(value) {
    return !(!value && isNullOrUndefined(value)) && (!!value && typeof value === OBJECT);
   }
   var isArray = _pureRef(ArrCls, "isArray"), isDate = _createObjIs("Date"), isNumber = _createIs("number"), isBoolean = _createIs("boolean"), isError = _createObjIs("Error");
   function isPromiseLike(value) {
    return !!(value && value.then && isFunction(value.then));
   }
   function isNotTruthy(value) {
    return !value || !isTruthy(value);
   }
   function isTruthy(value) {
    return !(!value || (cb = function() {
     return !(value && 0 + value);
    }, defValue = !value, result = safe(cb), result.e ? defValue : result.v));
    var cb, defValue, result;
   }
   var objGetOwnPropertyDescriptor = _pureRef(ObjClass, "getOwnPropertyDescriptor");
   function objHasOwnProperty(obj, prop) {
    return !!obj && ObjProto.hasOwnProperty[CALL](obj, prop);
   }
   var objHasOwn = _pureAssign(_pureRef(ObjClass, "hasOwn"), polyObjHasOwn);
   function polyObjHasOwn(obj, prop) {
    return objHasOwnProperty(obj, prop) || !!objGetOwnPropertyDescriptor(obj, prop);
   }
   function objForEachKey(theObject, callbackfn, thisArg) {
    if (theObject && isObject(theObject)) for (var prop in theObject) if (objHasOwn(theObject, prop) && -1 === callbackfn[CALL](thisArg || theObject, prop, theObject[prop])) break;
   }
   var propMap = {
    e: "enumerable",
    c: "configurable",
    v: "value",
    w: "writable",
    g: "get",
    s: "set"
   };
   function _createProp(value) {
    var prop = {};
    if (prop[propMap.c] = !0, prop[propMap.e] = !0, value.l) {
     prop.get = function() {
      return value.l.v;
     };
     var desc = objGetOwnPropertyDescriptor(value.l, "v");
     desc && desc.set && (prop.set = function(newValue) {
      value.l.v = newValue;
     });
    }
    return objForEachKey(value, (function(key, value) {
     prop[propMap[key]] = isDefined(value) ? value : prop[propMap[key]];
    })), prop;
   }
   var objDefineProp = _pureRef(ObjClass, "defineProperty"), objDefineProperties = _pureRef(ObjClass, "defineProperties");
   function objDefineAccessors(target, prop, getProp, setProp, configurable, enumerable) {
    var desc = {
     e: enumerable,
     c: configurable
    };
    return getProp && (desc.g = getProp), setProp && (desc.s = setProp), objDefineProp(target, prop, _createProp(desc));
   }
   function objDefine(target, key, propDesc) {
    return objDefineProp(target, key, _createProp(propDesc));
   }
   function _createKeyValueMap(values, keyType, valueType, completeFn, writable) {
    var theMap = {};
    return objForEachKey(values, (function(key, value) {
     _assignMapValue(theMap, key, keyType ? value : key, writable), _assignMapValue(theMap, value, valueType ? value : key, writable);
    })), completeFn ? completeFn(theMap) : theMap;
   }
   function _assignMapValue(theMap, key, value, writable) {
    objDefineProp(theMap, key, {
     value,
     enumerable: !0,
     writable: !!writable
    });
   }
   var asString = _pureAssign(StrCls), ERROR_TYPE = "[object Error]";
   function dumpObj(object, format) {
    var propertyValueDump = EMPTY, objType = ObjProto[TO_STRING][CALL](object);
    objType === ERROR_TYPE && (object = {
     stack: asString(object.stack),
     message: asString(object.message),
     name: asString(object.name)
    });
    try {
     propertyValueDump = ((propertyValueDump = JSON.stringify(object, NULL_VALUE, format ? "number" == typeof format ? format : 4 : UNDEF_VALUE)) ? propertyValueDump.replace(/"(\w+)"\s*:\s{0,1}/g, "$1: ") : NULL_VALUE) || asString(object);
    } catch (e) {
     propertyValueDump = " - " + dumpObj(e, format);
    }
    return objType + ": " + propertyValueDump;
   }
   function throwError(message) {
    throw new Error(message);
   }
   function throwTypeError(message) {
    throw new TypeError(message);
   }
   var _objFreeze = _pureRef(ObjClass, "freeze");
   function _doNothing(value) {
    return value;
   }
   function _getProto(value) {
    return value[__PROTO__] || NULL_VALUE;
   }
   var objAssign = _pureRef(ObjClass, "assign"), objKeys = _pureRef(ObjClass, "keys");
   function objDeepFreeze(value) {
    return _objFreeze && objForEachKey(value, (function(key, value) {
     (isArray(value) || isObject(value)) && objDeepFreeze(value);
    })), objFreeze(value);
   }
   var objFreeze = _pureAssign(_objFreeze, _doNothing), objSeal = _pureAssign(_pureRef(ObjClass, "seal"), _doNothing), objGetPrototypeOf = _pureAssign(_pureRef(ObjClass, "getPrototypeOf"), _getProto);
   function createEnum(values) {
    return _createKeyValueMap(values, 1, 0, objFreeze);
   }
   function createEnumKeyMap(values) {
    return _createKeyValueMap(values, 0, 0, objFreeze);
   }
   function createTypeMap(values) {
    return function(values) {
     var mapClass = {};
     return objForEachKey(values, (function(key, value) {
      _assignMapValue(mapClass, key, value[1]), _assignMapValue(mapClass, value[0], value[1]);
     })), objFreeze(mapClass);
    }(values);
   }
   var _globalCfg, _wellKnownSymbolMap = createEnumKeyMap({
    asyncIterator: 0,
    hasInstance: 1,
    isConcatSpreadable: 2,
    iterator: 3,
    match: 4,
    matchAll: 5,
    replace: 6,
    search: 7,
    species: 8,
    split: 9,
    toPrimitive: 10,
    toStringTag: 11,
    unscopables: 12
   }), GLOBAL_CONFIG_KEY = "__tsUtils$gblCfg";
   function _getGlobalValue() {
    var result;
    return typeof globalThis !== UNDEFINED && (result = globalThis), result || typeof self === UNDEFINED || (result = self), 
    result || typeof window === UNDEFINED || (result = window), result || typeof global === UNDEFINED || (result = global), 
    result;
   }
   function _getGlobalConfig() {
    if (!_globalCfg) {
     var gbl = safe(_getGlobalValue).v || {};
     _globalCfg = gbl[GLOBAL_CONFIG_KEY] = gbl[GLOBAL_CONFIG_KEY] || {};
    }
    return _globalCfg;
   }
   var _unwrapFunction = _unwrapFunctionWithPoly;
   function _unwrapFunctionWithPoly(funcName, clsProto, polyFunc) {
    var clsFn = clsProto ? clsProto[funcName] : NULL_VALUE;
    return function(thisArg) {
     var theFunc = (thisArg ? thisArg[funcName] : NULL_VALUE) || clsFn;
     if (theFunc || polyFunc) {
      var theArgs = arguments;
      return (theFunc || polyFunc).apply(thisArg, theFunc ? ArrSlice[CALL](theArgs, 1) : theArgs);
     }
     throwTypeError('"' + asString(funcName) + '" not defined for ' + dumpObj(thisArg));
    };
   }
   function _unwrapProp(propName) {
    return function(thisArg) {
     return thisArg[propName];
    };
   }
   var mathMax = _pureRef(MathCls, "max"), strSlice = _unwrapFunction("slice", StrProto), strSubstring = _unwrapFunction("substring", StrProto), strSubstr = _unwrapFunctionWithPoly("substr", StrProto, polyStrSubstr);
   function polyStrSubstr(value, start, length) {
    return isNullOrUndefined(value) && throwTypeError("Invalid " + dumpObj(value)), 
    length < 0 ? EMPTY : ((start = start || 0) < 0 && (start = mathMax(start + value[LENGTH], 0)), 
    isUndefined(length) ? strSlice(value, start) : strSlice(value, start, start + length));
   }
   function strLeft(value, count) {
    return strSubstring(value, 0, count);
   }
   var _polySymbols, _wellKnownSymbolCache, _globalLazyTestHooks, UNIQUE_REGISTRY_ID = "_urid";
   function _globalSymbolRegistry() {
    if (!_polySymbols) {
     var gblCfg = _getGlobalConfig();
     _polySymbols = gblCfg.gblSym = gblCfg.gblSym || {
      k: {},
      s: {}
     };
    }
    return _polySymbols;
   }
   function polyNewSymbol(description) {
    var theSymbol = {
     description: asString(description),
     toString: function() {
      return SYMBOL + "(" + description + ")";
     }
    };
    return theSymbol[POLYFILL_TAG] = !0, theSymbol;
   }
   function polySymbolFor(key) {
    var registry = _globalSymbolRegistry();
    if (!objHasOwn(registry.k, key)) {
     var newSymbol_1 = polyNewSymbol(key), regId_1 = objKeys(registry.s).length;
     newSymbol_1[UNIQUE_REGISTRY_ID] = function() {
      return regId_1 + "_" + newSymbol_1[TO_STRING]();
     }, registry.k[key] = newSymbol_1, registry.s[newSymbol_1[UNIQUE_REGISTRY_ID]()] = asString(key);
    }
    return registry.k[key];
   }
   function _initTestHooks() {
    _globalLazyTestHooks = _getGlobalConfig();
   }
   function getLazy(cb) {
    var lazyValue = {};
    return !_globalLazyTestHooks && _initTestHooks(), lazyValue.b = _globalLazyTestHooks.lzy, 
    objDefineProp(lazyValue, "v", {
     configurable: !0,
     get: function() {
      var result = cb();
      return _globalLazyTestHooks.lzy || objDefineProp(lazyValue, "v", {
       value: result
      }), lazyValue.b = _globalLazyTestHooks.lzy, result;
     }
    }), lazyValue;
   }
   function createCachedValue(value) {
    return objDefineProp({
     toJSON: function() {
      return value;
     }
    }, "v", {
     value
    });
   }
   var _cachedGlobal, WINDOW = "window";
   function _getGlobalInstFn(getFn, theArgs) {
    var cachedValue;
    return function() {
     return !_globalLazyTestHooks && _initTestHooks(), cachedValue && !_globalLazyTestHooks.lzy || (cachedValue = createCachedValue(safe(getFn, theArgs).v)), 
     cachedValue.v;
    };
   }
   function getGlobal(useCached) {
    return !_globalLazyTestHooks && _initTestHooks(), _cachedGlobal && !1 !== useCached && !_globalLazyTestHooks.lzy || (_cachedGlobal = createCachedValue(safe(_getGlobalValue).v || NULL_VALUE)), 
    _cachedGlobal.v;
   }
   function getInst(name, useCached) {
    var gbl;
    if ((gbl = _cachedGlobal && !1 !== useCached ? _cachedGlobal.v : getGlobal(useCached)) && gbl[name]) return gbl[name];
    if (name === WINDOW) try {
     return window;
    } catch (e) {}
    return NULL_VALUE;
   }
   function hasDocument() {
    return !!getDocument();
   }
   var getDocument = _getGlobalInstFn(getInst, [ "document" ]);
   function hasWindow() {
    return !!getWindow();
   }
   var getWindow = _getGlobalInstFn(getInst, [ WINDOW ]);
   function hasNavigator() {
    return !!getNavigator();
   }
   var getNavigator = _getGlobalInstFn(getInst, [ "navigator" ]);
   function hasHistory() {
    return !!getHistory();
   }
   var _symbol, _symbolFor, getHistory = _getGlobalInstFn(getInst, [ "history" ]), isNode = _getGlobalInstFn((function() {
    return !!safe((function() {
     return process && (process.versions || {}).node;
    })).v;
   }));
   function _initSymbol() {
    return _symbol = createCachedValue(safe(getInst, [ SYMBOL ]).v);
   }
   function _getSymbolKey(key) {
    var gblSym = (_globalLazyTestHooks.lzy ? 0 : _symbol) || _initSymbol();
    return gblSym.v ? gblSym.v[key] : UNDEF_VALUE;
   }
   var _iterSymbol$1;
   function hasSymbol() {
    return !!getSymbol();
   }
   function getSymbol() {
    return !_globalLazyTestHooks && _initTestHooks(), ((_globalLazyTestHooks.lzy ? 0 : _symbol) || _initSymbol()).v;
   }
   function getKnownSymbol(name, noPoly) {
    var knownName = _wellKnownSymbolMap[name];
    !_globalLazyTestHooks && _initTestHooks();
    var sym = (_globalLazyTestHooks.lzy ? 0 : _symbol) || _initSymbol();
    return sym.v ? sym.v[knownName || name] : noPoly ? UNDEF_VALUE : function(name) {
     var result;
     !_wellKnownSymbolCache && (_wellKnownSymbolCache = {});
     var knownName = _wellKnownSymbolMap[name];
     return knownName && (result = _wellKnownSymbolCache[knownName] = _wellKnownSymbolCache[knownName] || polyNewSymbol(SYMBOL + "." + knownName)), 
     result;
    }(name);
   }
   function newSymbol(description, noPoly) {
    !_globalLazyTestHooks && _initTestHooks();
    var sym = (_globalLazyTestHooks.lzy ? 0 : _symbol) || _initSymbol();
    return sym.v ? sym.v(description) : noPoly ? NULL_VALUE : polyNewSymbol(description);
   }
   function symbolFor(key) {
    return !_globalLazyTestHooks && _initTestHooks(), ((_symbolFor = (_globalLazyTestHooks.lzy ? 0 : _symbolFor) || createCachedValue(safe(_getSymbolKey, [ "for" ]).v)).v || polySymbolFor)(key);
   }
   function isIterator(value) {
    return !!value && isFunction(value.next);
   }
   function isIterable(value) {
    return !function(value) {
     return value === NULL_VALUE || !isDefined(value);
    }(value) && isFunction(value[getKnownSymbol(3)]);
   }
   function iterForOf(iter, callbackfn, thisArg) {
    if (iter && (isIterator(iter) || (!_iterSymbol$1 && (_iterSymbol$1 = createCachedValue(getKnownSymbol(3))), 
    iter = iter[_iterSymbol$1.v] ? iter[_iterSymbol$1.v]() : NULL_VALUE), isIterator(iter))) {
     var err = UNDEF_VALUE, iterResult = UNDEF_VALUE;
     try {
      for (var count = 0; !(iterResult = iter.next()).done && -1 !== callbackfn[CALL](thisArg || iter, iterResult.value, count, iter); ) count++;
     } catch (failed) {
      err = {
       e: failed
      }, iter.throw && (iterResult = NULL_VALUE, iter.throw(err));
     } finally {
      try {
       iterResult && !iterResult.done && iter.return && iter.return(iterResult);
      } finally {
       if (err) throw err.e;
      }
     }
    }
   }
   function fnApply(fn, thisArg, argArray) {
    return fn.apply(thisArg, argArray);
   }
   function arrAppend(target, elms) {
    return !isUndefined(elms) && target && (isArray(elms) ? fnApply(target.push, target, elms) : isIterator(elms) || isIterable(elms) ? iterForOf(elms, (function(elm) {
     target.push(elm);
    })) : target.push(elms)), target;
   }
   function arrForEach(theArray, callbackfn, thisArg) {
    if (theArray) for (var len = theArray[LENGTH] >>> 0, idx = 0; idx < len && (!(idx in theArray) || -1 !== callbackfn[CALL](thisArg || theArray, theArray[idx], idx, theArray)); idx++) ;
   }
   var arrIndexOf = _unwrapFunction("indexOf", ArrProto), arrMap = _unwrapFunction("map", ArrProto);
   function arrSlice(theArray, start, end) {
    return ((theArray ? theArray.slice : NULL_VALUE) || ArrSlice).apply(theArray, ArrSlice[CALL](arguments, 1));
   }
   function polyArrIncludes(theArray, searchElement, fromIndex) {
    return -1 !== arrIndexOf(theArray, searchElement, fromIndex);
   }
   var arrIncludes = _unwrapFunctionWithPoly("includes", ArrProto, polyArrIncludes), arrReduce = _unwrapFunction("reduce", ArrProto);
   var _isProtoArray, objCreate = _pureAssign(_pureRef(ObjClass, "create"), polyObjCreate);
   function polyObjCreate(obj) {
    if (!obj) return {};
    var type = typeof obj;
    function tempFunc() {}
    return type !== OBJECT && type !== FUNCTION && throwTypeError("Prototype must be an Object or function: " + dumpObj(obj)), 
    tempFunc[PROTOTYPE] = obj, new tempFunc;
   }
   function objSetPrototypeOf(obj, proto) {
    return (ObjClass.setPrototypeOf || function(d, b) {
     var _a;
     !_isProtoArray && (_isProtoArray = createCachedValue(((_a = {})[__PROTO__] = [], 
     _a instanceof Array))), _isProtoArray.v ? d[__PROTO__] = b : objForEachKey(b, (function(key, value) {
      return d[key] = value;
     }));
    })(obj, proto);
   }
   function _setName(baseClass, name) {
    name && (baseClass[NAME] = name);
   }
   function createCustomError(name, constructCb, errorBase) {
    var theBaseClass = errorBase || Error, orgName = theBaseClass[PROTOTYPE][NAME], captureFn = Error.captureStackTrace;
    return function(name, d, b) {
     function __() {
      this[CONSTRUCTOR] = d, safe(objDefine, [ this, NAME, {
       v: name,
       c: !0,
       e: !1
      } ]);
     }
     return safe(objDefine, [ d, NAME, {
      v: name,
      c: !0,
      e: !1
     } ]), (d = objSetPrototypeOf(d, b))[PROTOTYPE] = b === NULL_VALUE ? objCreate(b) : (__[PROTOTYPE] = b[PROTOTYPE], 
     new __), d;
    }(name, (function() {
     var theArgs = arguments;
     try {
      safe(_setName, [ theBaseClass, name ]);
      var _self = fnApply(theBaseClass, this, ArrSlice[CALL](theArgs)) || this;
      if (_self !== this) {
       var orgProto = objGetPrototypeOf(this);
       orgProto !== objGetPrototypeOf(_self) && objSetPrototypeOf(_self, orgProto);
      }
      return captureFn && captureFn(_self, this[CONSTRUCTOR]), constructCb && constructCb(_self, theArgs), 
      _self;
     } finally {
      safe(_setName, [ theBaseClass, orgName ]);
     }
    }), theBaseClass);
   }
   function utcNow() {
    return (Date.now || polyUtcNow)();
   }
   function polyUtcNow() {
    return (new Date).getTime();
   }
   function _createTrimFn(exp) {
    return function(value) {
     return isNullOrUndefined(value) && throwTypeError("strTrim called [" + dumpObj(value) + "]"), 
     value && value.replace && (value = value.replace(exp, EMPTY)), value;
    };
   }
   var strTrim = _unwrapFunctionWithPoly("trim", StrProto, _createTrimFn(/^\s+|(?=\s)\s+$/g));
   var _fnToString, _objCtrFnString, _gblWindow;
   function isPlainObject(value) {
    if (!value || typeof value !== OBJECT) return !1;
    _gblWindow || (_gblWindow = !hasWindow() || getWindow());
    var result = !1;
    if (value !== _gblWindow) {
     _objCtrFnString || (_fnToString = Function[PROTOTYPE][TO_STRING], _objCtrFnString = _fnToString[CALL](ObjClass));
     try {
      var proto = objGetPrototypeOf(value);
      (result = !proto) || (objHasOwnProperty(proto, CONSTRUCTOR) && (proto = proto[CONSTRUCTOR]), 
      result = !(!proto || typeof proto !== FUNCTION || _fnToString[CALL](proto) !== _objCtrFnString));
     } catch (ex) {}
    }
    return result;
   }
   function _defaultDeepCopyHandler(details) {
    return details.value && plainObjDeepCopyHandler(details), !0;
   }
   var defaultDeepCopyHandlers = [ function(details) {
    var value = details.value;
    if (isArray(value)) {
     var target = details.result = [];
     return target.length = value.length, details.copyTo(target, value), !0;
    }
    return !1;
   }, plainObjDeepCopyHandler, function(details) {
    if (details.type === FUNCTION) return !0;
    return !1;
   }, function(details) {
    var value = details.value;
    if (isDate(value)) return details.result = new Date(value.getTime()), !0;
    return !1;
   } ];
   function _deepCopy(visitMap, value, ctx, key) {
    var userHandler = ctx.handler, newPath = ctx.path ? key ? ctx.path.concat(key) : ctx.path : [], newCtx = {
     handler: ctx.handler,
     src: ctx.src,
     path: newPath
    }, theType = typeof value, isPlain = !1, isPrim = value === NULL_VALUE;
    isPrim || (value && theType === OBJECT ? isPlain = isPlainObject(value) : isPrim = isPrimitiveType(theType));
    var details = {
     type: theType,
     isPrim,
     isPlain,
     value,
     result: value,
     path: newPath,
     origin: ctx.src,
     copy: function(source, newKey) {
      return _deepCopy(visitMap, source, newKey ? newCtx : ctx, newKey);
     },
     copyTo: function(target, source) {
      return _copyProps(visitMap, target, source, newCtx);
     }
    };
    return details.isPrim ? userHandler && userHandler[CALL](ctx, details) ? details.result : value : function(visitMap, source, newPath, cb) {
     var theEntry;
     return arrForEach(visitMap, (function(entry) {
      if (entry.k === source) return theEntry = entry, -1;
     })), theEntry || (theEntry = {
      k: source,
      v: source
     }, visitMap.push(theEntry), cb(theEntry)), theEntry.v;
    }(visitMap, value, 0, (function(newEntry) {
     objDefine(details, "result", {
      g: function() {
       return newEntry.v;
      },
      s: function(newValue) {
       newEntry.v = newValue;
      }
     });
     for (var idx = 0, handler = userHandler; !(handler || (idx < defaultDeepCopyHandlers.length ? defaultDeepCopyHandlers[idx++] : _defaultDeepCopyHandler))[CALL](ctx, details); ) handler = NULL_VALUE;
    }));
   }
   function _copyProps(visitMap, target, source, ctx) {
    if (!isNullOrUndefined(source)) for (var key in source) target[key] = _deepCopy(visitMap, source[key], ctx, key);
    return target;
   }
   function plainObjDeepCopyHandler(details) {
    var value = details.value;
    if (value && details.isPlain) {
     var target = details.result = {};
     return details.copyTo(target, value), !0;
    }
    return !1;
   }
   function _doExtend(target, theArgs) {
    return arrForEach(theArgs, (function(theArg) {
     !function(target, source, handler) {
      _copyProps([], target, source, {
       handler,
       src: source,
       path: []
      });
     }(target, theArg);
    })), target;
   }
   function deepExtend(target, obj1, obj2, obj3, obj4, obj5, obj6) {
    return _doExtend(_deepCopy([], source = target, {
     handler,
     src: source
    }) || {}, ArrSlice[CALL](arguments));
    var source, handler;
   }
   var _perf, getLength = _unwrapProp(LENGTH);
   function getPerformance() {
    return !_globalLazyTestHooks && _initTestHooks(), _perf && !_globalLazyTestHooks.lzy || (_perf = createCachedValue(safe(getInst, [ "performance" ]).v)), 
    _perf.v;
   }
   function perfNow() {
    var perf = getPerformance();
    return perf && perf.now ? perf.now() : utcNow();
   }
   hasSymbol();
   var strEndsWith = _unwrapFunctionWithPoly("endsWith", StrProto, polyStrEndsWith);
   function polyStrEndsWith(value, searchString, length) {
    isString(value) || throwTypeError("'" + dumpObj(value) + "' is not a string");
    var searchValue = isString(searchString) ? searchString : asString(searchString), end = !isUndefined(length) && length < value[LENGTH] ? length : value[LENGTH];
    return strSubstring(value, end - searchValue[LENGTH], end) === searchValue;
   }
   var strIndexOf = _unwrapFunction("indexOf", StrProto);
   var strStartsWith = _unwrapFunctionWithPoly("startsWith", StrProto, polyStrStartsWith);
   function polyStrStartsWith(value, searchString, position) {
    isString(value) || throwTypeError("'" + dumpObj(value) + "' is not a string");
    var searchValue = isString(searchString) ? searchString : asString(searchString), pos = position > 0 ? position : 0;
    return strSubstring(value, pos, pos + searchValue[LENGTH]) === searchValue;
   }
   var REF = "ref", UNREF = "unref", HAS_REF = "hasRef", ENABLED = "enabled";
   function _createTimerHandler(startTimer, refreshFn, cancelFn) {
    var theTimerHandler, ref = !0, timerId = startTimer ? refreshFn(NULL_VALUE) : NULL_VALUE;
    function _unref() {
     return ref = !1, timerId && timerId[UNREF] && timerId[UNREF](), theTimerHandler;
    }
    function _cancel() {
     timerId && cancelFn(timerId), timerId = NULL_VALUE;
    }
    function _refresh() {
     return timerId = refreshFn(timerId), ref || _unref(), theTimerHandler;
    }
    return (theTimerHandler = {
     cancel: _cancel,
     refresh: _refresh
    })[HAS_REF] = function() {
     return timerId && timerId[HAS_REF] ? timerId[HAS_REF]() : ref;
    }, theTimerHandler[REF] = function() {
     return ref = !0, timerId && timerId[REF] && timerId[REF](), theTimerHandler;
    }, theTimerHandler[UNREF] = _unref, {
     h: theTimerHandler = objDefineProp(theTimerHandler, ENABLED, {
      get: function() {
       return !!timerId;
      },
      set: function(value) {
       !value && timerId && _cancel(), value && !timerId && _refresh();
      }
     }),
     dn: function() {
      timerId = NULL_VALUE;
     }
    };
   }
   function _createTimeoutWith(startTimer, overrideFn, theArgs) {
    var isArr = isArray(overrideFn), len = isArr ? overrideFn.length : 0, setFn = (len > 0 ? overrideFn[0] : isArr ? UNDEF_VALUE : overrideFn) || setTimeout, clearFn = (len > 1 ? overrideFn[1] : UNDEF_VALUE) || clearTimeout, timerFn = theArgs[0];
    theArgs[0] = function() {
     handler.dn(), fnApply(timerFn, UNDEF_VALUE, ArrSlice[CALL](arguments));
    };
    var handler = _createTimerHandler(startTimer, (function(timerId) {
     if (timerId) {
      if (timerId.refresh) return timerId.refresh(), timerId;
      fnApply(clearFn, UNDEF_VALUE, [ timerId ]);
     }
     return fnApply(setFn, UNDEF_VALUE, theArgs);
    }), (function(timerId) {
     fnApply(clearFn, UNDEF_VALUE, [ timerId ]);
    }));
    return handler.h;
   }
   function scheduleTimeout(callback, timeout) {
    return _createTimeoutWith(!0, UNDEF_VALUE, ArrSlice[CALL](arguments));
   }
   function scheduleTimeoutWith(overrideFn, callback, timeout) {
    return _createTimeoutWith(!0, overrideFn, ArrSlice[CALL](arguments, 1));
   }
   function createTimeout(callback, timeout) {
    return _createTimeoutWith(!1, UNDEF_VALUE, ArrSlice[CALL](arguments));
   }
  },
  78697: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.encode = exports.decode = void 0;
   const crypt = __webpack_require__(76982);
   function toJSON(value) {
    return JSON.parse(value.toString());
   }
   function initializeMessage(_message) {
    return Object.assign({}, {
     header: {},
     parent_header: {},
     metadata: {},
     content: {},
     idents: [],
     buffers: []
    }, _message);
   }
   function identifyHMACScheme(_scheme) {
    let scheme = _scheme;
    if ("hmac-sha256" === _scheme) scheme = "sha256";
    return scheme;
   }
   exports.decode = function(messageFrames, key, _scheme = "sha256") {
    var i = 0;
    const idents = [];
    for (i = 0; i < messageFrames.length; i++) {
     var frame = messageFrames[i];
     if ("<IDS|MSG>" === frame.toString()) break;
     idents.push(frame);
    }
    if (messageFrames.length - i < 5) throw new Error("Message Decoding: Not enough message frames");
    if ("<IDS|MSG>" !== messageFrames[i].toString()) throw new Error("Message Decoding: Missing delimiter");
    if (key) {
     const scheme = identifyHMACScheme(_scheme);
     var obtainedSignature = messageFrames[i + 1].toString(), hmac = crypt.createHmac(scheme, key);
     hmac.update(messageFrames[i + 2]), hmac.update(messageFrames[i + 3]), hmac.update(messageFrames[i + 4]), 
     hmac.update(messageFrames[i + 5]);
     var expectedSignature = hmac.digest("hex");
     if (expectedSignature !== obtainedSignature) throw new Error(`Message Decoding: Incorrect;\nObtained "${obtainedSignature}"\nExpected "${expectedSignature}"`);
    }
    return initializeMessage({
     idents,
     header: toJSON(messageFrames[i + 2]),
     parent_header: toJSON(messageFrames[i + 3]),
     content: toJSON(messageFrames[i + 5]),
     metadata: toJSON(messageFrames[i + 4]),
     buffers: Array.prototype.slice.apply(messageFrames, [ i + 6 ])
    });
   }, exports.encode = function(_message, key, _scheme = "sha256") {
    const message = initializeMessage(_message), scheme = identifyHMACScheme(_scheme), idents = message.idents, header = Buffer.from(JSON.stringify(message.header), "utf-8"), parent_header = Buffer.from(JSON.stringify(message.parent_header), "utf-8"), metadata = Buffer.from(JSON.stringify(message.metadata), "utf-8"), content = Buffer.from(JSON.stringify(message.content), "utf-8");
    let signature = "";
    if (key) {
     const hmac = crypt.createHmac(scheme, key);
     hmac.update(header), hmac.update(parent_header), hmac.update(metadata), hmac.update(content), 
     signature = hmac.digest("hex");
    }
    return idents.concat([ Buffer.from("<IDS|MSG>"), Buffer.from(signature), header, parent_header, metadata, content ]).concat(message.buffers);
   };
  },
  25396: function(__unused_webpack_module, exports, __webpack_require__) {
   "use strict";
   var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    void 0 === k2 && (k2 = k);
    var desc = Object.getOwnPropertyDescriptor(m, k);
    desc && !("get" in desc ? !m.__esModule : desc.writable || desc.configurable) || (desc = {
     enumerable: !0,
     get: function() {
      return m[k];
     }
    }), Object.defineProperty(o, k2, desc);
   } : function(o, m, k, k2) {
    void 0 === k2 && (k2 = k), o[k2] = m[k];
   }), __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
     enumerable: !0,
     value: v
    });
   } : function(o, v) {
    o.default = v;
   }), __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (null != mod) for (var k in mod) "default" !== k && Object.prototype.hasOwnProperty.call(mod, k) && __createBinding(result, mod, k);
    return __setModuleDefault(result, mod), result;
   };
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.oneDataSystemClientFactory = void 0;
   exports.oneDataSystemClientFactory = async (key, vscodeAPI, xhrOverride) => {
    let appInsightsCore = await (async (key, vscodeAPI, xhrOverride) => {
     const oneDs = await Promise.resolve().then((() => __importStar(__webpack_require__(80956)))), postPlugin = await Promise.resolve().then((() => __importStar(__webpack_require__(78916)))), appInsightsCore = new oneDs.AppInsightsCore, collectorChannelPlugin = new postPlugin.PostChannel, coreConfig = {
      instrumentationKey: key,
      endpointUrl: "https://mobile.events.data.microsoft.com/OneCollector/1.0",
      loggingLevelTelemetry: 0,
      loggingLevelConsole: 0,
      disableCookiesUsage: !0,
      disableDbgExt: !0,
      disableInstrumentationKeyValidation: !0,
      channels: [ [ collectorChannelPlugin ] ]
     };
     if (xhrOverride) {
      coreConfig.extensionConfig = {};
      const channelConfig = {
       alwaysUseXhrOverride: !0,
       httpXHROverride: xhrOverride
      };
      coreConfig.extensionConfig[collectorChannelPlugin.identifier] = channelConfig;
     }
     const internalTesting = vscodeAPI.workspace.getConfiguration("telemetry").get("internalTesting");
     return appInsightsCore.initialize(coreConfig, []), appInsightsCore.addTelemetryInitializer((envelope => {
      envelope.ext = envelope.ext ?? {}, envelope.ext.web = envelope.ext.web ?? {}, envelope.ext.web.consentDetails = '{"GPC_DataSharingOptIn":false}', 
      internalTesting && (envelope.ext.utc = envelope.ext.utc ?? {}, envelope.ext.utc.flags = 8462029);
     })), appInsightsCore;
    })(key, vscodeAPI, xhrOverride);
    return {
     logEvent: (eventName, data) => {
      try {
       appInsightsCore?.track({
        name: eventName,
        baseData: {
         name: eventName,
         properties: data?.properties,
         measurements: data?.measurements
        }
       });
      } catch (e) {
       throw new Error("Failed to log event to app insights!\n" + e.message);
      }
     },
     flush: async () => {
      try {
       return new Promise(((resolve, reject) => {
        appInsightsCore ? appInsightsCore.flush(!0, (completedFlush => {
         completedFlush || reject("Failed to flush app 1DS!");
        })) : resolve();
       }));
      } catch (e) {
       throw new Error("Failed to flush 1DS!\n" + e.message);
      }
     },
     dispose: async () => new Promise((resolve => {
      appInsightsCore ? appInsightsCore.unload(!1, (() => {
       resolve(), appInsightsCore = void 0;
      }), 1e3) : resolve();
     }))
    };
   };
  },
  72468: function(__unused_webpack_module, exports, __webpack_require__) {
   "use strict";
   var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    void 0 === k2 && (k2 = k);
    var desc = Object.getOwnPropertyDescriptor(m, k);
    desc && !("get" in desc ? !m.__esModule : desc.writable || desc.configurable) || (desc = {
     enumerable: !0,
     get: function() {
      return m[k];
     }
    }), Object.defineProperty(o, k2, desc);
   } : function(o, m, k, k2) {
    void 0 === k2 && (k2 = k), o[k2] = m[k];
   }), __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
     enumerable: !0,
     value: v
    });
   } : function(o, v) {
    o.default = v;
   }), __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (null != mod) for (var k in mod) "default" !== k && Object.prototype.hasOwnProperty.call(mod, k) && __createBinding(result, mod, k);
    return __setModuleDefault(result, mod), result;
   };
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.appInsightsClientFactory = void 0;
   const applicationinsights_common_1 = __webpack_require__(90740), util_1 = __webpack_require__(38393);
   exports.appInsightsClientFactory = async (key, xhrOverride, replacementOptions) => {
    let appInsightsClient;
    try {
     const basicAISDK = await Promise.resolve().then((() => __importStar(__webpack_require__(5927)))), extensionConfig = {};
     if (xhrOverride) {
      const channelConfig = {
       alwaysUseXhrOverride: !0,
       httpXHROverride: xhrOverride
      };
      extensionConfig[applicationinsights_common_1.BreezeChannelIdentifier] = channelConfig;
     }
     appInsightsClient = new basicAISDK.ApplicationInsights({
      instrumentationKey: key,
      disableAjaxTracking: !0,
      disableExceptionTracking: !0,
      disableFetchTracking: !0,
      disableCorrelationHeaders: !0,
      disableCookiesUsage: !0,
      autoTrackPageVisitTime: !1,
      emitLineDelimitedJson: !1,
      disableInstrumentationKeyValidation: !0,
      extensionConfig
     });
    } catch (e) {
     return Promise.reject(e);
    }
    return {
     logEvent: (eventName, data) => {
      const properties = {
       ...data?.properties,
       ...data?.measurements
      };
      replacementOptions?.length && util_1.TelemetryUtil.applyReplacements(properties, replacementOptions), 
      appInsightsClient?.track({
       name: eventName,
       data: properties,
       baseType: "EventData",
       baseData: {
        name: eventName,
        properties: data?.properties,
        measurements: data?.measurements
       }
      });
     },
     flush: async () => {
      appInsightsClient?.flush(!1);
     },
     dispose: async () => new Promise((resolve => {
      appInsightsClient?.unload(!0, (() => {
       resolve(), appInsightsClient = void 0;
      }), 1e3);
     }))
    };
   };
  },
  86548: (__unused_webpack_module, exports) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.BaseTelemetryReporter = void 0;
   exports.BaseTelemetryReporter = class {
    constructor(telemetrySender, vscodeAPI, initializationOptions) {
     this.telemetrySender = telemetrySender, this.vscodeAPI = vscodeAPI, this.userOptIn = !1, 
     this.errorOptIn = !1, this.disposables = [], this._onDidChangeTelemetryLevel = new this.vscodeAPI.EventEmitter, 
     this.onDidChangeTelemetryLevel = this._onDidChangeTelemetryLevel.event, this.telemetryLogger = this.vscodeAPI.env.createTelemetryLogger(this.telemetrySender, initializationOptions), 
     this.updateUserOptIn(), this.telemetryLogger.onDidChangeEnableStates((() => {
      this.updateUserOptIn();
     }));
    }
    updateUserOptIn() {
     this.errorOptIn = this.telemetryLogger.isErrorsEnabled, this.userOptIn = this.telemetryLogger.isUsageEnabled, 
     (this.telemetryLogger.isErrorsEnabled || this.telemetryLogger.isUsageEnabled) && this.telemetrySender.instantiateSender(), 
     this._onDidChangeTelemetryLevel.fire(this.telemetryLevel);
    }
    get telemetryLevel() {
     return this.errorOptIn && this.userOptIn ? "all" : this.errorOptIn ? "error" : "off";
    }
    internalSendTelemetryEvent(eventName, properties, measurements, dangerous) {
     dangerous ? this.telemetrySender.sendEventData(eventName, {
      properties,
      measurements
     }) : this.telemetryLogger.logUsage(eventName, {
      properties,
      measurements
     });
    }
    sendTelemetryEvent(eventName, properties, measurements) {
     this.internalSendTelemetryEvent(eventName, properties, measurements, !1);
    }
    sendRawTelemetryEvent(eventName, properties, measurements) {
     const modifiedProperties = {
      ...properties
     };
     for (const propertyKey of Object.keys(modifiedProperties ?? {})) {
      const propertyValue = modifiedProperties[propertyKey];
      "string" == typeof propertyKey && void 0 !== propertyValue && (modifiedProperties[propertyKey] = new this.vscodeAPI.TelemetryTrustedValue("string" == typeof propertyValue ? propertyValue : propertyValue.value));
     }
     this.sendTelemetryEvent(eventName, modifiedProperties, measurements);
    }
    sendDangerousTelemetryEvent(eventName, properties, measurements) {
     this.telemetrySender.instantiateSender(), this.internalSendTelemetryEvent(eventName, properties, measurements, !0);
    }
    internalSendTelemetryErrorEvent(eventName, properties, measurements, dangerous) {
     dangerous ? this.telemetrySender.sendEventData(eventName, {
      properties,
      measurements
     }) : this.telemetryLogger.logError(eventName, {
      properties,
      measurements
     });
    }
    sendTelemetryErrorEvent(eventName, properties, measurements) {
     this.internalSendTelemetryErrorEvent(eventName, properties, measurements, !1);
    }
    sendDangerousTelemetryErrorEvent(eventName, properties, measurements) {
     this.telemetrySender.instantiateSender(), this.internalSendTelemetryErrorEvent(eventName, properties, measurements, !0);
    }
    async dispose() {
     return await this.telemetrySender.dispose(), this.telemetryLogger.dispose(), Promise.all(this.disposables.map((d => d.dispose())));
    }
   };
  },
  52396: (__unused_webpack_module, exports) => {
   "use strict";
   var InstantiationStatus;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.BaseTelemetrySender = void 0, function(InstantiationStatus) {
    InstantiationStatus[InstantiationStatus.NOT_INSTANTIATED = 0] = "NOT_INSTANTIATED", 
    InstantiationStatus[InstantiationStatus.INSTANTIATING = 1] = "INSTANTIATING", InstantiationStatus[InstantiationStatus.INSTANTIATED = 2] = "INSTANTIATED";
   }(InstantiationStatus || (InstantiationStatus = {}));
   exports.BaseTelemetrySender = class {
    constructor(key, clientFactory) {
     this._instantiationStatus = InstantiationStatus.NOT_INSTANTIATED, this._eventQueue = [], 
     this._exceptionQueue = [], this._clientFactory = clientFactory, this._key = key;
    }
    sendEventData(eventName, data) {
     this._telemetryClient ? this._telemetryClient.logEvent(eventName, data) : this._instantiationStatus !== InstantiationStatus.INSTANTIATED && this._eventQueue.push({
      eventName,
      data
     });
    }
    sendErrorData(exception, data) {
     if (!this._telemetryClient) return void (this._instantiationStatus !== InstantiationStatus.INSTANTIATED && this._exceptionQueue.push({
      exception,
      data
     }));
     const errorData = {
      stack: exception.stack,
      message: exception.message,
      name: exception.name
     };
     if (data) {
      const errorProperties = data.properties || data;
      data.properties = {
       ...errorProperties,
       ...errorData
      };
     } else data = {
      properties: errorData
     };
     this._telemetryClient.logEvent("unhandlederror", data);
    }
    async flush() {
     return this._telemetryClient?.flush();
    }
    async dispose() {
     this._telemetryClient && (await this._telemetryClient.dispose(), this._telemetryClient = void 0);
    }
    _flushQueues() {
     this._eventQueue.forEach((({eventName, data}) => this.sendEventData(eventName, data))), 
     this._eventQueue = [], this._exceptionQueue.forEach((({exception, data}) => this.sendErrorData(exception, data))), 
     this._exceptionQueue = [];
    }
    instantiateSender() {
     this._instantiationStatus === InstantiationStatus.NOT_INSTANTIATED && (this._instantiationStatus = InstantiationStatus.INSTANTIATING, 
     this._clientFactory(this._key).then((client => {
      this._telemetryClient = client, this._instantiationStatus = InstantiationStatus.INSTANTIATED, 
      this._flushQueues();
     })).catch((err => {
      console.error(err), this._instantiationStatus = InstantiationStatus.INSTANTIATED;
     })));
    }
   };
  },
  38393: (__unused_webpack_module, exports) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.TelemetryUtil = void 0;
   class TelemetryUtil {
    static applyReplacements(data, replacementOptions) {
     for (const key of Object.keys(data)) for (const option of replacementOptions) option.lookup.test(key) && (void 0 !== option.replacementString ? data[key] = option.replacementString : delete data[key]);
    }
    static shouldUseOneDataSystemSDK(key) {
     return 74 === key.length && "-" === key[32] && "-" === key[41] && "-" === key[46] && "-" === key[51] && "-" === key[56] && "-" === key[69];
    }
    static getAdditionalCommonProperties(osShim) {
     return {
      "common.os": osShim.platform,
      "common.nodeArch": osShim.architecture,
      "common.platformversion": (osShim.release || "").replace(/^(\d+)(\.\d+)?(\.\d+)?(.*)/, "$1$2$3"),
      "common.telemetryclientversion": "0.9.6"
     };
    }
    static getInstance() {
     return TelemetryUtil._instance || (TelemetryUtil._instance = new TelemetryUtil), 
     TelemetryUtil._instance;
    }
   }
   exports.TelemetryUtil = TelemetryUtil;
  },
  81170: function(__unused_webpack_module, exports, __webpack_require__) {
   "use strict";
   var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    void 0 === k2 && (k2 = k);
    var desc = Object.getOwnPropertyDescriptor(m, k);
    desc && !("get" in desc ? !m.__esModule : desc.writable || desc.configurable) || (desc = {
     enumerable: !0,
     get: function() {
      return m[k];
     }
    }), Object.defineProperty(o, k2, desc);
   } : function(o, m, k, k2) {
    void 0 === k2 && (k2 = k), o[k2] = m[k];
   }), __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
     enumerable: !0,
     value: v
    });
   } : function(o, v) {
    o.default = v;
   }), __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (null != mod) for (var k in mod) "default" !== k && Object.prototype.hasOwnProperty.call(mod, k) && __createBinding(result, mod, k);
    return __setModuleDefault(result, mod), result;
   };
   Object.defineProperty(exports, "__esModule", {
    value: !0
   });
   const os = __importStar(__webpack_require__(70857)), vscode = __importStar(__webpack_require__(54980)), https = __importStar(__webpack_require__(65692)), baseTelemetryReporter_1 = __webpack_require__(86548), baseTelemetrySender_1 = __webpack_require__(52396), util_1 = __webpack_require__(38393), _1dsClientFactory_1 = __webpack_require__(25396), appInsightsClientFactory_1 = __webpack_require__(72468);
   function getXHROverride() {
    return {
     sendPOST: (payload, oncomplete) => {
      const options = {
       method: "POST",
       headers: {
        ...payload.headers,
        "Content-Type": "application/json",
        "Content-Length": Buffer.byteLength(payload.data)
       }
      };
      try {
       const req = https.request(payload.urlString, options, (res => {
        res.on("data", (function(responseData) {
         oncomplete(res.statusCode ?? 200, res.headers, responseData.toString());
        })), res.on("error", (function() {
         oncomplete(0, {});
        }));
       }));
       req.write(payload.data, (err => {
        err && oncomplete(0, {});
       })), req.end();
      } catch {
       oncomplete(0, {});
      }
     }
    };
   }
   class TelemetryReporter extends baseTelemetryReporter_1.BaseTelemetryReporter {
    constructor(key, replacementOptions) {
     let clientFactory = key => (0, appInsightsClientFactory_1.appInsightsClientFactory)(key, getXHROverride(), replacementOptions);
     util_1.TelemetryUtil.shouldUseOneDataSystemSDK(key) && (clientFactory = key => (0, 
     _1dsClientFactory_1.oneDataSystemClientFactory)(key, vscode, getXHROverride()));
     const osShim = {
      release: os.release(),
      platform: os.platform(),
      architecture: os.arch()
     }, sender = new baseTelemetrySender_1.BaseTelemetrySender(key, clientFactory);
     if (key && 0 === key.indexOf("AIF-")) throw new Error("AIF keys are no longer supported. Please switch to 1DS keys for 1st party extensions");
     super(sender, vscode, {
      additionalCommonProperties: util_1.TelemetryUtil.getAdditionalCommonProperties(osShim)
     });
    }
   }
   exports.default = TelemetryReporter;
  },
  7988: module => {
   "use strict";
   module.exports = function(Promise) {
    var SomePromiseArray = Promise._SomePromiseArray;
    function any(promises) {
     var ret = new SomePromiseArray(promises), promise = ret.promise();
     return ret.setHowMany(1), ret.setUnwrap(), ret.init(), promise;
    }
    Promise.any = function(promises) {
     return any(promises);
    }, Promise.prototype.any = function() {
     return any(this);
    };
   };
  },
  28210: (module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   var firstLineError;
   try {
    throw new Error;
   } catch (e) {
    firstLineError = e;
   }
   var schedule = __webpack_require__(71065), Queue = __webpack_require__(49937);
   function Async() {
    this._customScheduler = !1, this._isTickUsed = !1, this._lateQueue = new Queue(16), 
    this._normalQueue = new Queue(16), this._haveDrainedQueues = !1;
    var self = this;
    this.drainQueues = function() {
     self._drainQueues();
    }, this._schedule = schedule;
   }
   function _drainQueue(queue) {
    for (;queue.length() > 0; ) _drainQueueStep(queue);
   }
   function _drainQueueStep(queue) {
    var fn = queue.shift();
    if ("function" != typeof fn) fn._settlePromises(); else {
     var receiver = queue.shift(), arg = queue.shift();
     fn.call(receiver, arg);
    }
   }
   Async.prototype.setScheduler = function(fn) {
    var prev = this._schedule;
    return this._schedule = fn, this._customScheduler = !0, prev;
   }, Async.prototype.hasCustomScheduler = function() {
    return this._customScheduler;
   }, Async.prototype.haveItemsQueued = function() {
    return this._isTickUsed || this._haveDrainedQueues;
   }, Async.prototype.fatalError = function(e, isNode) {
    isNode ? (process.stderr.write("Fatal " + (e instanceof Error ? e.stack : e) + "\n"), 
    process.exit(2)) : this.throwLater(e);
   }, Async.prototype.throwLater = function(fn, arg) {
    if (1 === arguments.length && (arg = fn, fn = function() {
     throw arg;
    }), "undefined" != typeof setTimeout) setTimeout((function() {
     fn(arg);
    }), 0); else try {
     this._schedule((function() {
      fn(arg);
     }));
    } catch (e) {
     throw new Error("No async scheduler available\n\n    See http://goo.gl/MqrFmX\n");
    }
   }, Async.prototype.invokeLater = function(fn, receiver, arg) {
    this._lateQueue.push(fn, receiver, arg), this._queueTick();
   }, Async.prototype.invoke = function(fn, receiver, arg) {
    this._normalQueue.push(fn, receiver, arg), this._queueTick();
   }, Async.prototype.settlePromises = function(promise) {
    this._normalQueue._pushOne(promise), this._queueTick();
   }, Async.prototype._drainQueues = function() {
    _drainQueue(this._normalQueue), this._reset(), this._haveDrainedQueues = !0, _drainQueue(this._lateQueue);
   }, Async.prototype._queueTick = function() {
    this._isTickUsed || (this._isTickUsed = !0, this._schedule(this.drainQueues));
   }, Async.prototype._reset = function() {
    this._isTickUsed = !1;
   }, module.exports = Async, module.exports.firstLineError = firstLineError;
  },
  54271: module => {
   "use strict";
   module.exports = function(Promise, INTERNAL, tryConvertToPromise, debug) {
    var calledBind = !1, rejectThis = function(_, e) {
     this._reject(e);
    }, targetRejected = function(e, context) {
     context.promiseRejectionQueued = !0, context.bindingPromise._then(rejectThis, rejectThis, null, this, e);
    }, bindingResolved = function(thisArg, context) {
     50397184 & this._bitField || this._resolveCallback(context.target);
    }, bindingRejected = function(e, context) {
     context.promiseRejectionQueued || this._reject(e);
    };
    Promise.prototype.bind = function(thisArg) {
     calledBind || (calledBind = !0, Promise.prototype._propagateFrom = debug.propagateFromFunction(), 
     Promise.prototype._boundValue = debug.boundValueFunction());
     var maybePromise = tryConvertToPromise(thisArg), ret = new Promise(INTERNAL);
     ret._propagateFrom(this, 1);
     var target = this._target();
     if (ret._setBoundTo(maybePromise), maybePromise instanceof Promise) {
      var context = {
       promiseRejectionQueued: !1,
       promise: ret,
       target,
       bindingPromise: maybePromise
      };
      target._then(INTERNAL, targetRejected, void 0, ret, context), maybePromise._then(bindingResolved, bindingRejected, void 0, ret, context), 
      ret._setOnCancel(maybePromise);
     } else ret._resolveCallback(target);
     return ret;
    }, Promise.prototype._setBoundTo = function(obj) {
     void 0 !== obj ? (this._bitField = 2097152 | this._bitField, this._boundTo = obj) : this._bitField = -2097153 & this._bitField;
    }, Promise.prototype._isBound = function() {
     return !(2097152 & ~this._bitField);
    }, Promise.bind = function(thisArg, value) {
     return Promise.resolve(value).bind(thisArg);
    };
   };
  },
  51007: (module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   var old;
   "undefined" != typeof Promise && (old = Promise);
   var bluebird = __webpack_require__(39979)();
   bluebird.noConflict = function() {
    try {
     Promise === bluebird && (Promise = old);
    } catch (e) {}
    return bluebird;
   }, module.exports = bluebird;
  },
  31675: (module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   var cr = Object.create;
   if (cr) {
    var callerCache = cr(null), getterCache = cr(null);
    callerCache[" size"] = getterCache[" size"] = 0;
   }
   module.exports = function(Promise) {
    var getMethodCaller, getGetter, util = __webpack_require__(92208), canEvaluate = util.canEvaluate, isIdentifier = util.isIdentifier, makeMethodCaller = function(methodName) {
     return new Function("ensureMethod", "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ".replace(/methodName/g, methodName))(ensureMethod);
    }, makeGetter = function(propertyName) {
     return new Function("obj", "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ".replace("propertyName", propertyName));
    }, getCompiled = function(name, compiler, cache) {
     var ret = cache[name];
     if ("function" != typeof ret) {
      if (!isIdentifier(name)) return null;
      if (ret = compiler(name), cache[name] = ret, cache[" size"]++, cache[" size"] > 512) {
       for (var keys = Object.keys(cache), i = 0; i < 256; ++i) delete cache[keys[i]];
       cache[" size"] = keys.length - 256;
      }
     }
     return ret;
    };
    function ensureMethod(obj, methodName) {
     var fn;
     if (null != obj && (fn = obj[methodName]), "function" != typeof fn) {
      var message = "Object " + util.classString(obj) + " has no method '" + util.toString(methodName) + "'";
      throw new Promise.TypeError(message);
     }
     return fn;
    }
    function caller(obj) {
     return ensureMethod(obj, this.pop()).apply(obj, this);
    }
    function namedGetter(obj) {
     return obj[this];
    }
    function indexedGetter(obj) {
     var index = +this;
     return index < 0 && (index = Math.max(0, index + obj.length)), obj[index];
    }
    getMethodCaller = function(name) {
     return getCompiled(name, makeMethodCaller, callerCache);
    }, getGetter = function(name) {
     return getCompiled(name, makeGetter, getterCache);
    }, Promise.prototype.call = function(methodName) {
     for (var $_len = arguments.length, args = new Array(Math.max($_len - 1, 0)), $_i = 1; $_i < $_len; ++$_i) args[$_i - 1] = arguments[$_i];
     if (canEvaluate) {
      var maybeCaller = getMethodCaller(methodName);
      if (null !== maybeCaller) return this._then(maybeCaller, void 0, void 0, args, void 0);
     }
     return args.push(methodName), this._then(caller, void 0, void 0, args, void 0);
    }, Promise.prototype.get = function(propertyName) {
     var getter;
     if ("number" == typeof propertyName) getter = indexedGetter; else if (canEvaluate) {
      var maybeGetter = getGetter(propertyName);
      getter = null !== maybeGetter ? maybeGetter : namedGetter;
     } else getter = namedGetter;
     return this._then(getter, void 0, void 0, propertyName, void 0);
    };
   };
  },
  2994: (module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   module.exports = function(Promise, PromiseArray, apiRejection, debug) {
    var util = __webpack_require__(92208), tryCatch = util.tryCatch, errorObj = util.errorObj, async = Promise._async;
    Promise.prototype.break = Promise.prototype.cancel = function() {
     if (!debug.cancellation()) return this._warn("cancellation is disabled");
     for (var promise = this, child = promise; promise._isCancellable(); ) {
      if (!promise._cancelBy(child)) {
       child._isFollowing() ? child._followee().cancel() : child._cancelBranched();
       break;
      }
      var parent = promise._cancellationParent;
      if (null == parent || !parent._isCancellable()) {
       promise._isFollowing() ? promise._followee().cancel() : promise._cancelBranched();
       break;
      }
      promise._isFollowing() && promise._followee().cancel(), promise._setWillBeCancelled(), 
      child = promise, promise = parent;
     }
    }, Promise.prototype._branchHasCancelled = function() {
     this._branchesRemainingToCancel--;
    }, Promise.prototype._enoughBranchesHaveCancelled = function() {
     return void 0 === this._branchesRemainingToCancel || this._branchesRemainingToCancel <= 0;
    }, Promise.prototype._cancelBy = function(canceller) {
     return canceller === this ? (this._branchesRemainingToCancel = 0, this._invokeOnCancel(), 
     !0) : (this._branchHasCancelled(), !!this._enoughBranchesHaveCancelled() && (this._invokeOnCancel(), 
     !0));
    }, Promise.prototype._cancelBranched = function() {
     this._enoughBranchesHaveCancelled() && this._cancel();
    }, Promise.prototype._cancel = function() {
     this._isCancellable() && (this._setCancelled(), async.invoke(this._cancelPromises, this, void 0));
    }, Promise.prototype._cancelPromises = function() {
     this._length() > 0 && this._settlePromises();
    }, Promise.prototype._unsetOnCancel = function() {
     this._onCancelField = void 0;
    }, Promise.prototype._isCancellable = function() {
     return this.isPending() && !this._isCancelled();
    }, Promise.prototype.isCancellable = function() {
     return this.isPending() && !this.isCancelled();
    }, Promise.prototype._doInvokeOnCancel = function(onCancelCallback, internalOnly) {
     if (util.isArray(onCancelCallback)) for (var i = 0; i < onCancelCallback.length; ++i) this._doInvokeOnCancel(onCancelCallback[i], internalOnly); else if (void 0 !== onCancelCallback) if ("function" == typeof onCancelCallback) {
      if (!internalOnly) {
       var e = tryCatch(onCancelCallback).call(this._boundValue());
       e === errorObj && (this._attachExtraTrace(e.e), async.throwLater(e.e));
      }
     } else onCancelCallback._resultCancelled(this);
    }, Promise.prototype._invokeOnCancel = function() {
     var onCancelCallback = this._onCancel();
     this._unsetOnCancel(), async.invoke(this._doInvokeOnCancel, this, onCancelCallback);
    }, Promise.prototype._invokeInternalOnCancel = function() {
     this._isCancellable() && (this._doInvokeOnCancel(this._onCancel(), !0), this._unsetOnCancel());
    }, Promise.prototype._resultCancelled = function() {
     this.cancel();
    };
   };
  },
  91674: (module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   module.exports = function(NEXT_FILTER) {
    var util = __webpack_require__(92208), getKeys = __webpack_require__(7585).keys, tryCatch = util.tryCatch, errorObj = util.errorObj;
    return function(instances, cb, promise) {
     return function(e) {
      var boundTo = promise._boundValue();
      predicateLoop: for (var i = 0; i < instances.length; ++i) {
       var item = instances[i];
       if (item === Error || null != item && item.prototype instanceof Error) {
        if (e instanceof item) return tryCatch(cb).call(boundTo, e);
       } else if ("function" == typeof item) {
        var matchesPredicate = tryCatch(item).call(boundTo, e);
        if (matchesPredicate === errorObj) return matchesPredicate;
        if (matchesPredicate) return tryCatch(cb).call(boundTo, e);
       } else if (util.isObject(e)) {
        for (var keys = getKeys(item), j = 0; j < keys.length; ++j) {
         var key = keys[j];
         if (item[key] != e[key]) continue predicateLoop;
        }
        return tryCatch(cb).call(boundTo, e);
       }
      }
      return NEXT_FILTER;
     };
    };
   };
  },
  30297: module => {
   "use strict";
   module.exports = function(Promise) {
    var longStackTraces = !1, contextStack = [];
    function Context() {
     this._trace = new Context.CapturedTrace(peekContext());
    }
    function peekContext() {
     var lastIndex = contextStack.length - 1;
     if (lastIndex >= 0) return contextStack[lastIndex];
    }
    return Promise.prototype._promiseCreated = function() {}, Promise.prototype._pushContext = function() {}, 
    Promise.prototype._popContext = function() {
     return null;
    }, Promise._peekContext = Promise.prototype._peekContext = function() {}, Context.prototype._pushContext = function() {
     void 0 !== this._trace && (this._trace._promiseCreated = null, contextStack.push(this._trace));
    }, Context.prototype._popContext = function() {
     if (void 0 !== this._trace) {
      var trace = contextStack.pop(), ret = trace._promiseCreated;
      return trace._promiseCreated = null, ret;
     }
     return null;
    }, Context.CapturedTrace = null, Context.create = function() {
     if (longStackTraces) return new Context;
    }, Context.deactivateLongStackTraces = function() {}, Context.activateLongStackTraces = function() {
     var Promise_pushContext = Promise.prototype._pushContext, Promise_popContext = Promise.prototype._popContext, Promise_PeekContext = Promise._peekContext, Promise_peekContext = Promise.prototype._peekContext, Promise_promiseCreated = Promise.prototype._promiseCreated;
     Context.deactivateLongStackTraces = function() {
      Promise.prototype._pushContext = Promise_pushContext, Promise.prototype._popContext = Promise_popContext, 
      Promise._peekContext = Promise_PeekContext, Promise.prototype._peekContext = Promise_peekContext, 
      Promise.prototype._promiseCreated = Promise_promiseCreated, longStackTraces = !1;
     }, longStackTraces = !0, Promise.prototype._pushContext = Context.prototype._pushContext, 
     Promise.prototype._popContext = Context.prototype._popContext, Promise._peekContext = Promise.prototype._peekContext = peekContext, 
     Promise.prototype._promiseCreated = function() {
      var ctx = this._peekContext();
      ctx && null == ctx._promiseCreated && (ctx._promiseCreated = this);
     };
    }, Context;
   };
  },
  6636: (module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   module.exports = function(Promise, Context, enableAsyncHooks, disableAsyncHooks) {
    var unhandledRejectionHandled, possiblyUnhandledRejection, printWarning, deferUnhandledRejectionCheck, async = Promise._async, Warning = __webpack_require__(90403).Warning, util = __webpack_require__(92208), es5 = __webpack_require__(7585), canAttachTrace = util.canAttachTrace, bluebirdFramePattern = /[\\\/]bluebird[\\\/]js[\\\/](release|debug|instrumented)/, nodeFramePattern = /\((?:timers\.js):\d+:\d+\)/, parseLinePattern = /[\/<\(](.+?):(\d+):(\d+)\)?\s*$/, stackFramePattern = null, formatStack = null, indentStackFrames = !1, debugging = !(0 == util.env("BLUEBIRD_DEBUG") || !util.env("BLUEBIRD_DEBUG") && "development" !== util.env("NODE_ENV")), warnings = !(0 == util.env("BLUEBIRD_WARNINGS") || !debugging && !util.env("BLUEBIRD_WARNINGS")), longStackTraces = !(0 == util.env("BLUEBIRD_LONG_STACK_TRACES") || !debugging && !util.env("BLUEBIRD_LONG_STACK_TRACES")), wForgottenReturn = 0 != util.env("BLUEBIRD_W_FORGOTTEN_RETURN") && (warnings || !!util.env("BLUEBIRD_W_FORGOTTEN_RETURN"));
    !function() {
     var promises = [];
     function unhandledRejectionCheck() {
      for (var i = 0; i < promises.length; ++i) promises[i]._notifyUnhandledRejection();
      unhandledRejectionClear();
     }
     function unhandledRejectionClear() {
      promises.length = 0;
     }
     deferUnhandledRejectionCheck = function(promise) {
      promises.push(promise), setTimeout(unhandledRejectionCheck, 1);
     }, es5.defineProperty(Promise, "_unhandledRejectionCheck", {
      value: unhandledRejectionCheck
     }), es5.defineProperty(Promise, "_unhandledRejectionClear", {
      value: unhandledRejectionClear
     });
    }(), Promise.prototype.suppressUnhandledRejections = function() {
     var target = this._target();
     target._bitField = -1048577 & target._bitField | 524288;
    }, Promise.prototype._ensurePossibleRejectionHandled = function() {
     524288 & this._bitField || (this._setRejectionIsUnhandled(), deferUnhandledRejectionCheck(this));
    }, Promise.prototype._notifyUnhandledRejectionIsHandled = function() {
     fireRejectionEvent("rejectionHandled", unhandledRejectionHandled, void 0, this);
    }, Promise.prototype._setReturnedNonUndefined = function() {
     this._bitField = 268435456 | this._bitField;
    }, Promise.prototype._returnedNonUndefined = function() {
     return !!(268435456 & this._bitField);
    }, Promise.prototype._notifyUnhandledRejection = function() {
     if (this._isRejectionUnhandled()) {
      var reason = this._settledValue();
      this._setUnhandledRejectionIsNotified(), fireRejectionEvent("unhandledRejection", possiblyUnhandledRejection, reason, this);
     }
    }, Promise.prototype._setUnhandledRejectionIsNotified = function() {
     this._bitField = 262144 | this._bitField;
    }, Promise.prototype._unsetUnhandledRejectionIsNotified = function() {
     this._bitField = -262145 & this._bitField;
    }, Promise.prototype._isUnhandledRejectionNotified = function() {
     return (262144 & this._bitField) > 0;
    }, Promise.prototype._setRejectionIsUnhandled = function() {
     this._bitField = 1048576 | this._bitField;
    }, Promise.prototype._unsetRejectionIsUnhandled = function() {
     this._bitField = -1048577 & this._bitField, this._isUnhandledRejectionNotified() && (this._unsetUnhandledRejectionIsNotified(), 
     this._notifyUnhandledRejectionIsHandled());
    }, Promise.prototype._isRejectionUnhandled = function() {
     return (1048576 & this._bitField) > 0;
    }, Promise.prototype._warn = function(message, shouldUseOwnTrace, promise) {
     return warn(message, shouldUseOwnTrace, promise || this);
    }, Promise.onPossiblyUnhandledRejection = function(fn) {
     var context = Promise._getContext();
     possiblyUnhandledRejection = util.contextBind(context, fn);
    }, Promise.onUnhandledRejectionHandled = function(fn) {
     var context = Promise._getContext();
     unhandledRejectionHandled = util.contextBind(context, fn);
    };
    var disableLongStackTraces = function() {};
    Promise.longStackTraces = function() {
     if (async.haveItemsQueued() && !config.longStackTraces) throw new Error("cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n");
     if (!config.longStackTraces && longStackTracesIsSupported()) {
      var Promise_captureStackTrace = Promise.prototype._captureStackTrace, Promise_attachExtraTrace = Promise.prototype._attachExtraTrace, Promise_dereferenceTrace = Promise.prototype._dereferenceTrace;
      config.longStackTraces = !0, disableLongStackTraces = function() {
       if (async.haveItemsQueued() && !config.longStackTraces) throw new Error("cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n");
       Promise.prototype._captureStackTrace = Promise_captureStackTrace, Promise.prototype._attachExtraTrace = Promise_attachExtraTrace, 
       Promise.prototype._dereferenceTrace = Promise_dereferenceTrace, Context.deactivateLongStackTraces(), 
       config.longStackTraces = !1;
      }, Promise.prototype._captureStackTrace = longStackTracesCaptureStackTrace, Promise.prototype._attachExtraTrace = longStackTracesAttachExtraTrace, 
      Promise.prototype._dereferenceTrace = longStackTracesDereferenceTrace, Context.activateLongStackTraces();
     }
    }, Promise.hasLongStackTraces = function() {
     return config.longStackTraces && longStackTracesIsSupported();
    };
    var legacyHandlers = {
     unhandledrejection: {
      before: function() {
       var ret = util.global.onunhandledrejection;
       return util.global.onunhandledrejection = null, ret;
      },
      after: function(fn) {
       util.global.onunhandledrejection = fn;
      }
     },
     rejectionhandled: {
      before: function() {
       var ret = util.global.onrejectionhandled;
       return util.global.onrejectionhandled = null, ret;
      },
      after: function(fn) {
       util.global.onrejectionhandled = fn;
      }
     }
    }, fireDomEvent = function() {
     var dispatch = function(legacy, e) {
      if (!legacy) return !util.global.dispatchEvent(e);
      var fn;
      try {
       return fn = legacy.before(), !util.global.dispatchEvent(e);
      } finally {
       legacy.after(fn);
      }
     };
     try {
      if ("function" == typeof CustomEvent) {
       var event = new CustomEvent("CustomEvent");
       return util.global.dispatchEvent(event), function(name, event) {
        name = name.toLowerCase();
        var domEvent = new CustomEvent(name, {
         detail: event,
         cancelable: !0
        });
        return es5.defineProperty(domEvent, "promise", {
         value: event.promise
        }), es5.defineProperty(domEvent, "reason", {
         value: event.reason
        }), dispatch(legacyHandlers[name], domEvent);
       };
      }
      if ("function" == typeof Event) {
       event = new Event("CustomEvent");
       return util.global.dispatchEvent(event), function(name, event) {
        name = name.toLowerCase();
        var domEvent = new Event(name, {
         cancelable: !0
        });
        return domEvent.detail = event, es5.defineProperty(domEvent, "promise", {
         value: event.promise
        }), es5.defineProperty(domEvent, "reason", {
         value: event.reason
        }), dispatch(legacyHandlers[name], domEvent);
       };
      }
      return (event = document.createEvent("CustomEvent")).initCustomEvent("testingtheevent", !1, !0, {}), 
      util.global.dispatchEvent(event), function(name, event) {
       name = name.toLowerCase();
       var domEvent = document.createEvent("CustomEvent");
       return domEvent.initCustomEvent(name, !1, !0, event), dispatch(legacyHandlers[name], domEvent);
      };
     } catch (e) {}
     return function() {
      return !1;
     };
    }(), fireGlobalEvent = util.isNode ? function() {
     return process.emit.apply(process, arguments);
    } : util.global ? function(name) {
     var methodName = "on" + name.toLowerCase(), method = util.global[methodName];
     return !!method && (method.apply(util.global, [].slice.call(arguments, 1)), !0);
    } : function() {
     return !1;
    };
    function generatePromiseLifecycleEventObject(name, promise) {
     return {
      promise
     };
    }
    var eventToObjectGenerator = {
     promiseCreated: generatePromiseLifecycleEventObject,
     promiseFulfilled: generatePromiseLifecycleEventObject,
     promiseRejected: generatePromiseLifecycleEventObject,
     promiseResolved: generatePromiseLifecycleEventObject,
     promiseCancelled: generatePromiseLifecycleEventObject,
     promiseChained: function(name, promise, child) {
      return {
       promise,
       child
      };
     },
     warning: function(name, warning) {
      return {
       warning
      };
     },
     unhandledRejection: function(name, reason, promise) {
      return {
       reason,
       promise
      };
     },
     rejectionHandled: generatePromiseLifecycleEventObject
    }, activeFireEvent = function(name) {
     var globalEventFired = !1;
     try {
      globalEventFired = fireGlobalEvent.apply(null, arguments);
     } catch (e) {
      async.throwLater(e), globalEventFired = !0;
     }
     var domEventFired = !1;
     try {
      domEventFired = fireDomEvent(name, eventToObjectGenerator[name].apply(null, arguments));
     } catch (e) {
      async.throwLater(e), domEventFired = !0;
     }
     return domEventFired || globalEventFired;
    };
    function defaultFireEvent() {
     return !1;
    }
    function cancellationExecute(executor, resolve, reject) {
     var promise = this;
     try {
      executor(resolve, reject, (function(onCancel) {
       if ("function" != typeof onCancel) throw new TypeError("onCancel must be a function, got: " + util.toString(onCancel));
       promise._attachCancellationCallback(onCancel);
      }));
     } catch (e) {
      return e;
     }
    }
    function cancellationAttachCancellationCallback(onCancel) {
     if (!this._isCancellable()) return this;
     var previousOnCancel = this._onCancel();
     void 0 !== previousOnCancel ? util.isArray(previousOnCancel) ? previousOnCancel.push(onCancel) : this._setOnCancel([ previousOnCancel, onCancel ]) : this._setOnCancel(onCancel);
    }
    function cancellationOnCancel() {
     return this._onCancelField;
    }
    function cancellationSetOnCancel(onCancel) {
     this._onCancelField = onCancel;
    }
    function cancellationClearCancellationData() {
     this._cancellationParent = void 0, this._onCancelField = void 0;
    }
    function cancellationPropagateFrom(parent, flags) {
     if (1 & flags) {
      this._cancellationParent = parent;
      var branchesRemainingToCancel = parent._branchesRemainingToCancel;
      void 0 === branchesRemainingToCancel && (branchesRemainingToCancel = 0), parent._branchesRemainingToCancel = branchesRemainingToCancel + 1;
     }
     2 & flags && parent._isBound() && this._setBoundTo(parent._boundTo);
    }
    Promise.config = function(opts) {
     if ("longStackTraces" in (opts = Object(opts)) && (opts.longStackTraces ? Promise.longStackTraces() : !opts.longStackTraces && Promise.hasLongStackTraces() && disableLongStackTraces()), 
     "warnings" in opts) {
      var warningsOption = opts.warnings;
      config.warnings = !!warningsOption, wForgottenReturn = config.warnings, util.isObject(warningsOption) && "wForgottenReturn" in warningsOption && (wForgottenReturn = !!warningsOption.wForgottenReturn);
     }
     if ("cancellation" in opts && opts.cancellation && !config.cancellation) {
      if (async.haveItemsQueued()) throw new Error("cannot enable cancellation after promises are in use");
      Promise.prototype._clearCancellationData = cancellationClearCancellationData, Promise.prototype._propagateFrom = cancellationPropagateFrom, 
      Promise.prototype._onCancel = cancellationOnCancel, Promise.prototype._setOnCancel = cancellationSetOnCancel, 
      Promise.prototype._attachCancellationCallback = cancellationAttachCancellationCallback, 
      Promise.prototype._execute = cancellationExecute, propagateFromFunction = cancellationPropagateFrom, 
      config.cancellation = !0;
     }
     if ("monitoring" in opts && (opts.monitoring && !config.monitoring ? (config.monitoring = !0, 
     Promise.prototype._fireEvent = activeFireEvent) : !opts.monitoring && config.monitoring && (config.monitoring = !1, 
     Promise.prototype._fireEvent = defaultFireEvent)), "asyncHooks" in opts && util.nodeSupportsAsyncResource) {
      var prev = config.asyncHooks, cur = !!opts.asyncHooks;
      prev !== cur && (config.asyncHooks = cur, cur ? enableAsyncHooks() : disableAsyncHooks());
     }
     return Promise;
    }, Promise.prototype._fireEvent = defaultFireEvent, Promise.prototype._execute = function(executor, resolve, reject) {
     try {
      executor(resolve, reject);
     } catch (e) {
      return e;
     }
    }, Promise.prototype._onCancel = function() {}, Promise.prototype._setOnCancel = function(handler) {}, 
    Promise.prototype._attachCancellationCallback = function(onCancel) {}, Promise.prototype._captureStackTrace = function() {}, 
    Promise.prototype._attachExtraTrace = function() {}, Promise.prototype._dereferenceTrace = function() {}, 
    Promise.prototype._clearCancellationData = function() {}, Promise.prototype._propagateFrom = function(parent, flags) {};
    var propagateFromFunction = function(parent, flags) {
     2 & flags && parent._isBound() && this._setBoundTo(parent._boundTo);
    };
    function boundValueFunction() {
     var ret = this._boundTo;
     return void 0 !== ret && ret instanceof Promise ? ret.isFulfilled() ? ret.value() : void 0 : ret;
    }
    function longStackTracesCaptureStackTrace() {
     this._trace = new CapturedTrace(this._peekContext());
    }
    function longStackTracesAttachExtraTrace(error, ignoreSelf) {
     if (canAttachTrace(error)) {
      var trace = this._trace;
      if (void 0 !== trace && ignoreSelf && (trace = trace._parent), void 0 !== trace) trace.attachExtraTrace(error); else if (!error.__stackCleaned__) {
       var parsed = parseStackAndMessage(error);
       util.notEnumerableProp(error, "stack", parsed.message + "\n" + parsed.stack.join("\n")), 
       util.notEnumerableProp(error, "__stackCleaned__", !0);
      }
     }
    }
    function longStackTracesDereferenceTrace() {
     this._trace = void 0;
    }
    function warn(message, shouldUseOwnTrace, promise) {
     if (config.warnings) {
      var ctx, warning = new Warning(message);
      if (shouldUseOwnTrace) promise._attachExtraTrace(warning); else if (config.longStackTraces && (ctx = Promise._peekContext())) ctx.attachExtraTrace(warning); else {
       var parsed = parseStackAndMessage(warning);
       warning.stack = parsed.message + "\n" + parsed.stack.join("\n");
      }
      activeFireEvent("warning", warning) || formatAndLogError(warning, "", !0);
     }
    }
    function cleanStack(stack) {
     for (var ret = [], i = 0; i < stack.length; ++i) {
      var line = stack[i], isTraceLine = "    (No stack trace)" === line || stackFramePattern.test(line), isInternalFrame = isTraceLine && shouldIgnore(line);
      isTraceLine && !isInternalFrame && (indentStackFrames && " " !== line.charAt(0) && (line = "    " + line), 
      ret.push(line));
     }
     return ret;
    }
    function parseStackAndMessage(error) {
     var stack = error.stack, message = error.toString();
     return stack = "string" == typeof stack && stack.length > 0 ? function(error) {
      for (var stack = error.stack.replace(/\s+$/g, "").split("\n"), i = 0; i < stack.length; ++i) {
       var line = stack[i];
       if ("    (No stack trace)" === line || stackFramePattern.test(line)) break;
      }
      return i > 0 && "SyntaxError" != error.name && (stack = stack.slice(i)), stack;
     }(error) : [ "    (No stack trace)" ], {
      message,
      stack: "SyntaxError" == error.name ? stack : cleanStack(stack)
     };
    }
    function formatAndLogError(error, title, isSoft) {
     if ("undefined" != typeof console) {
      var message;
      if (util.isObject(error)) {
       var stack = error.stack;
       message = title + formatStack(stack, error);
      } else message = title + String(error);
      "function" == typeof printWarning ? printWarning(message, isSoft) : "function" != typeof console.log && "object" != typeof console.log || console.log(message);
     }
    }
    function fireRejectionEvent(name, localHandler, reason, promise) {
     var localEventFired = !1;
     try {
      "function" == typeof localHandler && (localEventFired = !0, "rejectionHandled" === name ? localHandler(promise) : localHandler(reason, promise));
     } catch (e) {
      async.throwLater(e);
     }
     "unhandledRejection" === name ? activeFireEvent(name, reason, promise) || localEventFired || formatAndLogError(reason, "Unhandled rejection ") : activeFireEvent(name, promise);
    }
    function formatNonError(obj) {
     var str;
     if ("function" == typeof obj) str = "[function " + (obj.name || "anonymous") + "]"; else {
      str = obj && "function" == typeof obj.toString ? obj.toString() : util.toString(obj);
      if (/\[object [a-zA-Z0-9$_]+\]/.test(str)) try {
       str = JSON.stringify(obj);
      } catch (e) {}
      0 === str.length && (str = "(empty array)");
     }
     return "(<" + function(str) {
      var maxChars = 41;
      if (str.length < maxChars) return str;
      return str.substr(0, maxChars - 3) + "...";
     }(str) + ">, no stack trace)";
    }
    function longStackTracesIsSupported() {
     return "function" == typeof captureStackTrace;
    }
    var shouldIgnore = function() {
     return !1;
    }, parseLineInfoRegex = /[\/<\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;
    function parseLineInfo(line) {
     var matches = line.match(parseLineInfoRegex);
     if (matches) return {
      fileName: matches[1],
      line: parseInt(matches[2], 10)
     };
    }
    function CapturedTrace(parent) {
     this._parent = parent, this._promisesCreated = 0;
     var length = this._length = 1 + (void 0 === parent ? 0 : parent._length);
     captureStackTrace(this, CapturedTrace), length > 32 && this.uncycle();
    }
    util.inherits(CapturedTrace, Error), Context.CapturedTrace = CapturedTrace, CapturedTrace.prototype.uncycle = function() {
     var length = this._length;
     if (!(length < 2)) {
      for (var nodes = [], stackToIndex = {}, i = 0, node = this; void 0 !== node; ++i) nodes.push(node), 
      node = node._parent;
      for (i = (length = this._length = i) - 1; i >= 0; --i) {
       var stack = nodes[i].stack;
       void 0 === stackToIndex[stack] && (stackToIndex[stack] = i);
      }
      for (i = 0; i < length; ++i) {
       var index = stackToIndex[nodes[i].stack];
       if (void 0 !== index && index !== i) {
        index > 0 && (nodes[index - 1]._parent = void 0, nodes[index - 1]._length = 1), 
        nodes[i]._parent = void 0, nodes[i]._length = 1;
        var cycleEdgeNode = i > 0 ? nodes[i - 1] : this;
        index < length - 1 ? (cycleEdgeNode._parent = nodes[index + 1], cycleEdgeNode._parent.uncycle(), 
        cycleEdgeNode._length = cycleEdgeNode._parent._length + 1) : (cycleEdgeNode._parent = void 0, 
        cycleEdgeNode._length = 1);
        for (var currentChildLength = cycleEdgeNode._length + 1, j = i - 2; j >= 0; --j) nodes[j]._length = currentChildLength, 
        currentChildLength++;
        return;
       }
      }
     }
    }, CapturedTrace.prototype.attachExtraTrace = function(error) {
     if (!error.__stackCleaned__) {
      this.uncycle();
      for (var parsed = parseStackAndMessage(error), message = parsed.message, stacks = [ parsed.stack ], trace = this; void 0 !== trace; ) stacks.push(cleanStack(trace.stack.split("\n"))), 
      trace = trace._parent;
      !function(stacks) {
       for (var current = stacks[0], i = 1; i < stacks.length; ++i) {
        for (var prev = stacks[i], currentLastIndex = current.length - 1, currentLastLine = current[currentLastIndex], commonRootMeetPoint = -1, j = prev.length - 1; j >= 0; --j) if (prev[j] === currentLastLine) {
         commonRootMeetPoint = j;
         break;
        }
        for (j = commonRootMeetPoint; j >= 0; --j) {
         var line = prev[j];
         if (current[currentLastIndex] !== line) break;
         current.pop(), currentLastIndex--;
        }
        current = prev;
       }
      }(stacks), function(stacks) {
       for (var i = 0; i < stacks.length; ++i) (0 === stacks[i].length || i + 1 < stacks.length && stacks[i][0] === stacks[i + 1][0]) && (stacks.splice(i, 1), 
       i--);
      }(stacks), util.notEnumerableProp(error, "stack", function(message, stacks) {
       for (var i = 0; i < stacks.length - 1; ++i) stacks[i].push("From previous event:"), 
       stacks[i] = stacks[i].join("\n");
       return i < stacks.length && (stacks[i] = stacks[i].join("\n")), message + "\n" + stacks.join("\n");
      }(message, stacks)), util.notEnumerableProp(error, "__stackCleaned__", !0);
     }
    };
    var captureStackTrace = function() {
     var v8stackFramePattern = /^\s*at\s*/, v8stackFormatter = function(stack, error) {
      return "string" == typeof stack ? stack : void 0 !== error.name && void 0 !== error.message ? error.toString() : formatNonError(error);
     };
     if ("number" == typeof Error.stackTraceLimit && "function" == typeof Error.captureStackTrace) {
      Error.stackTraceLimit += 6, stackFramePattern = v8stackFramePattern, formatStack = v8stackFormatter;
      var captureStackTrace = Error.captureStackTrace;
      return shouldIgnore = function(line) {
       return bluebirdFramePattern.test(line);
      }, function(receiver, ignoreUntil) {
       Error.stackTraceLimit += 6, captureStackTrace(receiver, ignoreUntil), Error.stackTraceLimit -= 6;
      };
     }
     var hasStackAfterThrow, err = new Error;
     if ("string" == typeof err.stack && err.stack.split("\n")[0].indexOf("stackDetection@") >= 0) return stackFramePattern = /@/, 
     formatStack = v8stackFormatter, indentStackFrames = !0, function(o) {
      o.stack = (new Error).stack;
     };
     try {
      throw new Error;
     } catch (e) {
      hasStackAfterThrow = "stack" in e;
     }
     return !("stack" in err) && hasStackAfterThrow && "number" == typeof Error.stackTraceLimit ? (stackFramePattern = v8stackFramePattern, 
     formatStack = v8stackFormatter, function(o) {
      Error.stackTraceLimit += 6;
      try {
       throw new Error;
      } catch (e) {
       o.stack = e.stack;
      }
      Error.stackTraceLimit -= 6;
     }) : (formatStack = function(stack, error) {
      return "string" == typeof stack ? stack : "object" != typeof error && "function" != typeof error || void 0 === error.name || void 0 === error.message ? formatNonError(error) : error.toString();
     }, null);
    }();
    "undefined" != typeof console && void 0 !== console.warn && (printWarning = function(message) {
     console.warn(message);
    }, util.isNode && process.stderr.isTTY ? printWarning = function(message, isSoft) {
     var color = isSoft ? "[33m" : "[31m";
     console.warn(color + message + "[0m\n");
    } : util.isNode || "string" != typeof (new Error).stack || (printWarning = function(message, isSoft) {
     console.warn("%c" + message, isSoft ? "color: darkorange" : "color: red");
    }));
    var config = {
     warnings,
     longStackTraces: !1,
     cancellation: !1,
     monitoring: !1,
     asyncHooks: !1
    };
    return longStackTraces && Promise.longStackTraces(), {
     asyncHooks: function() {
      return config.asyncHooks;
     },
     longStackTraces: function() {
      return config.longStackTraces;
     },
     warnings: function() {
      return config.warnings;
     },
     cancellation: function() {
      return config.cancellation;
     },
     monitoring: function() {
      return config.monitoring;
     },
     propagateFromFunction: function() {
      return propagateFromFunction;
     },
     boundValueFunction: function() {
      return boundValueFunction;
     },
     checkForgottenReturns: function(returnValue, promiseCreated, name, promise, parent) {
      if (void 0 === returnValue && null !== promiseCreated && wForgottenReturn) {
       if (void 0 !== parent && parent._returnedNonUndefined()) return;
       if (!(65535 & promise._bitField)) return;
       name && (name += " ");
       var handlerLine = "", creatorLine = "";
       if (promiseCreated._trace) {
        for (var traceLines = promiseCreated._trace.stack.split("\n"), stack = cleanStack(traceLines), i = stack.length - 1; i >= 0; --i) {
         var line = stack[i];
         if (!nodeFramePattern.test(line)) {
          var lineMatches = line.match(parseLinePattern);
          lineMatches && (handlerLine = "at " + lineMatches[1] + ":" + lineMatches[2] + ":" + lineMatches[3] + " ");
          break;
         }
        }
        if (stack.length > 0) {
         var firstUserLine = stack[0];
         for (i = 0; i < traceLines.length; ++i) if (traceLines[i] === firstUserLine) {
          i > 0 && (creatorLine = "\n" + traceLines[i - 1]);
          break;
         }
        }
       }
       var msg = "a promise was created in a " + name + "handler " + handlerLine + "but was not returned from it, see http://goo.gl/rRqMUw" + creatorLine;
       promise._warn(msg, !0, promiseCreated);
      }
     },
     setBounds: function(firstLineError, lastLineError) {
      if (longStackTracesIsSupported()) {
       for (var firstFileName, lastFileName, firstStackLines = (firstLineError.stack || "").split("\n"), lastStackLines = (lastLineError.stack || "").split("\n"), firstIndex = -1, lastIndex = -1, i = 0; i < firstStackLines.length; ++i) {
        if (result = parseLineInfo(firstStackLines[i])) {
         firstFileName = result.fileName, firstIndex = result.line;
         break;
        }
       }
       for (i = 0; i < lastStackLines.length; ++i) {
        var result;
        if (result = parseLineInfo(lastStackLines[i])) {
         lastFileName = result.fileName, lastIndex = result.line;
         break;
        }
       }
       firstIndex < 0 || lastIndex < 0 || !firstFileName || !lastFileName || firstFileName !== lastFileName || firstIndex >= lastIndex || (shouldIgnore = function(line) {
        if (bluebirdFramePattern.test(line)) return !0;
        var info = parseLineInfo(line);
        return !!(info && info.fileName === firstFileName && firstIndex <= info.line && info.line <= lastIndex);
       });
      }
     },
     warn,
     deprecated: function(name, replacement) {
      var message = name + " is deprecated and will be removed in a future version.";
      return replacement && (message += " Use " + replacement + " instead."), warn(message);
     },
     CapturedTrace,
     fireDomEvent,
     fireGlobalEvent
    };
   };
  },
  56774: module => {
   "use strict";
   module.exports = function(Promise) {
    function returner() {
     return this.value;
    }
    function thrower() {
     throw this.reason;
    }
    Promise.prototype.return = Promise.prototype.thenReturn = function(value) {
     return value instanceof Promise && value.suppressUnhandledRejections(), this._then(returner, void 0, void 0, {
      value
     }, void 0);
    }, Promise.prototype.throw = Promise.prototype.thenThrow = function(reason) {
     return this._then(thrower, void 0, void 0, {
      reason
     }, void 0);
    }, Promise.prototype.catchThrow = function(reason) {
     if (arguments.length <= 1) return this._then(void 0, thrower, void 0, {
      reason
     }, void 0);
     var _reason = arguments[1];
     return this.caught(reason, (function() {
      throw _reason;
     }));
    }, Promise.prototype.catchReturn = function(value) {
     if (arguments.length <= 1) return value instanceof Promise && value.suppressUnhandledRejections(), 
     this._then(void 0, returner, void 0, {
      value
     }, void 0);
     var _value = arguments[1];
     _value instanceof Promise && _value.suppressUnhandledRejections();
     return this.caught(value, (function() {
      return _value;
     }));
    };
   };
  },
  93425: module => {
   "use strict";
   module.exports = function(Promise, INTERNAL) {
    var PromiseReduce = Promise.reduce, PromiseAll = Promise.all;
    function promiseAllThis() {
     return PromiseAll(this);
    }
    Promise.prototype.each = function(fn) {
     return PromiseReduce(this, fn, INTERNAL, 0)._then(promiseAllThis, void 0, void 0, this, void 0);
    }, Promise.prototype.mapSeries = function(fn) {
     return PromiseReduce(this, fn, INTERNAL, INTERNAL);
    }, Promise.each = function(promises, fn) {
     return PromiseReduce(promises, fn, INTERNAL, 0)._then(promiseAllThis, void 0, void 0, promises, void 0);
    }, Promise.mapSeries = function(promises, fn) {
     return PromiseReduce(promises, fn, INTERNAL, INTERNAL);
    };
   };
  },
  90403: (module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   var _TypeError, _RangeError, es5 = __webpack_require__(7585), Objectfreeze = es5.freeze, util = __webpack_require__(92208), inherits = util.inherits, notEnumerableProp = util.notEnumerableProp;
   function subError(nameProperty, defaultMessage) {
    function SubError(message) {
     if (!(this instanceof SubError)) return new SubError(message);
     notEnumerableProp(this, "message", "string" == typeof message ? message : defaultMessage), 
     notEnumerableProp(this, "name", nameProperty), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : Error.call(this);
    }
    return inherits(SubError, Error), SubError;
   }
   var Warning = subError("Warning", "warning"), CancellationError = subError("CancellationError", "cancellation error"), TimeoutError = subError("TimeoutError", "timeout error"), AggregateError = subError("AggregateError", "aggregate error");
   try {
    _TypeError = TypeError, _RangeError = RangeError;
   } catch (e) {
    _TypeError = subError("TypeError", "type error"), _RangeError = subError("RangeError", "range error");
   }
   for (var methods = "join pop push shift unshift slice filter forEach some every map indexOf lastIndexOf reduce reduceRight sort reverse".split(" "), i = 0; i < methods.length; ++i) "function" == typeof Array.prototype[methods[i]] && (AggregateError.prototype[methods[i]] = Array.prototype[methods[i]]);
   es5.defineProperty(AggregateError.prototype, "length", {
    value: 0,
    configurable: !1,
    writable: !0,
    enumerable: !0
   }), AggregateError.prototype.isOperational = !0;
   var level = 0;
   function OperationalError(message) {
    if (!(this instanceof OperationalError)) return new OperationalError(message);
    notEnumerableProp(this, "name", "OperationalError"), notEnumerableProp(this, "message", message), 
    this.cause = message, this.isOperational = !0, message instanceof Error ? (notEnumerableProp(this, "message", message.message), 
    notEnumerableProp(this, "stack", message.stack)) : Error.captureStackTrace && Error.captureStackTrace(this, this.constructor);
   }
   AggregateError.prototype.toString = function() {
    var indent = Array(4 * level + 1).join(" "), ret = "\n" + indent + "AggregateError of:\n";
    level++, indent = Array(4 * level + 1).join(" ");
    for (var i = 0; i < this.length; ++i) {
     for (var str = this[i] === this ? "[Circular AggregateError]" : this[i] + "", lines = str.split("\n"), j = 0; j < lines.length; ++j) lines[j] = indent + lines[j];
     ret += (str = lines.join("\n")) + "\n";
    }
    return level--, ret;
   }, inherits(OperationalError, Error);
   var errorTypes = Error.__BluebirdErrorTypes__;
   errorTypes || (errorTypes = Objectfreeze({
    CancellationError,
    TimeoutError,
    OperationalError,
    RejectionError: OperationalError,
    AggregateError
   }), es5.defineProperty(Error, "__BluebirdErrorTypes__", {
    value: errorTypes,
    writable: !1,
    enumerable: !1,
    configurable: !1
   })), module.exports = {
    Error,
    TypeError: _TypeError,
    RangeError: _RangeError,
    CancellationError: errorTypes.CancellationError,
    OperationalError: errorTypes.OperationalError,
    TimeoutError: errorTypes.TimeoutError,
    AggregateError: errorTypes.AggregateError,
    Warning
   };
  },
  7585: module => {
   var isES5 = function() {
    "use strict";
    return void 0 === this;
   }();
   if (isES5) module.exports = {
    freeze: Object.freeze,
    defineProperty: Object.defineProperty,
    getDescriptor: Object.getOwnPropertyDescriptor,
    keys: Object.keys,
    names: Object.getOwnPropertyNames,
    getPrototypeOf: Object.getPrototypeOf,
    isArray: Array.isArray,
    isES5,
    propertyIsWritable: function(obj, prop) {
     var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
     return !(descriptor && !descriptor.writable && !descriptor.set);
    }
   }; else {
    var has = {}.hasOwnProperty, str = {}.toString, proto = {}.constructor.prototype, ObjectKeys = function(o) {
     var ret = [];
     for (var key in o) has.call(o, key) && ret.push(key);
     return ret;
    };
    module.exports = {
     isArray: function(obj) {
      try {
       return "[object Array]" === str.call(obj);
      } catch (e) {
       return !1;
      }
     },
     keys: ObjectKeys,
     names: ObjectKeys,
     defineProperty: function(o, key, desc) {
      return o[key] = desc.value, o;
     },
     getDescriptor: function(o, key) {
      return {
       value: o[key]
      };
     },
     freeze: function(obj) {
      return obj;
     },
     getPrototypeOf: function(obj) {
      try {
       return Object(obj).constructor.prototype;
      } catch (e) {
       return proto;
      }
     },
     isES5,
     propertyIsWritable: function() {
      return !0;
     }
    };
   }
  },
  72730: module => {
   "use strict";
   module.exports = function(Promise, INTERNAL) {
    var PromiseMap = Promise.map;
    Promise.prototype.filter = function(fn, options) {
     return PromiseMap(this, fn, options, INTERNAL);
    }, Promise.filter = function(promises, fn, options) {
     return PromiseMap(promises, fn, options, INTERNAL);
    };
   };
  },
  90401: (module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   module.exports = function(Promise, tryConvertToPromise, NEXT_FILTER) {
    var util = __webpack_require__(92208), CancellationError = Promise.CancellationError, errorObj = util.errorObj, catchFilter = __webpack_require__(91674)(NEXT_FILTER);
    function PassThroughHandlerContext(promise, type, handler) {
     this.promise = promise, this.type = type, this.handler = handler, this.called = !1, 
     this.cancelPromise = null;
    }
    function FinallyHandlerCancelReaction(finallyHandler) {
     this.finallyHandler = finallyHandler;
    }
    function checkCancel(ctx, reason) {
     return null != ctx.cancelPromise && (arguments.length > 1 ? ctx.cancelPromise._reject(reason) : ctx.cancelPromise._cancel(), 
     ctx.cancelPromise = null, !0);
    }
    function succeed() {
     return finallyHandler.call(this, this.promise._target()._settledValue());
    }
    function fail(reason) {
     if (!checkCancel(this, reason)) return errorObj.e = reason, errorObj;
    }
    function finallyHandler(reasonOrValue) {
     var promise = this.promise, handler = this.handler;
     if (!this.called) {
      this.called = !0;
      var ret = this.isFinallyHandler() ? handler.call(promise._boundValue()) : handler.call(promise._boundValue(), reasonOrValue);
      if (ret === NEXT_FILTER) return ret;
      if (void 0 !== ret) {
       promise._setReturnedNonUndefined();
       var maybePromise = tryConvertToPromise(ret, promise);
       if (maybePromise instanceof Promise) {
        if (null != this.cancelPromise) {
         if (maybePromise._isCancelled()) {
          var reason = new CancellationError("late cancellation observer");
          return promise._attachExtraTrace(reason), errorObj.e = reason, errorObj;
         }
         maybePromise.isPending() && maybePromise._attachCancellationCallback(new FinallyHandlerCancelReaction(this));
        }
        return maybePromise._then(succeed, fail, void 0, this, void 0);
       }
      }
     }
     return promise.isRejected() ? (checkCancel(this), errorObj.e = reasonOrValue, errorObj) : (checkCancel(this), 
     reasonOrValue);
    }
    return PassThroughHandlerContext.prototype.isFinallyHandler = function() {
     return 0 === this.type;
    }, FinallyHandlerCancelReaction.prototype._resultCancelled = function() {
     checkCancel(this.finallyHandler);
    }, Promise.prototype._passThrough = function(handler, type, success, fail) {
     return "function" != typeof handler ? this.then() : this._then(success, fail, void 0, new PassThroughHandlerContext(this, type, handler), void 0);
    }, Promise.prototype.lastly = Promise.prototype.finally = function(handler) {
     return this._passThrough(handler, 0, finallyHandler, finallyHandler);
    }, Promise.prototype.tap = function(handler) {
     return this._passThrough(handler, 1, finallyHandler);
    }, Promise.prototype.tapCatch = function(handlerOrPredicate) {
     var len = arguments.length;
     if (1 === len) return this._passThrough(handlerOrPredicate, 1, void 0, finallyHandler);
     var i, catchInstances = new Array(len - 1), j = 0;
     for (i = 0; i < len - 1; ++i) {
      var item = arguments[i];
      if (!util.isObject(item)) return Promise.reject(new TypeError("tapCatch statement predicate: expecting an object but got " + util.classString(item)));
      catchInstances[j++] = item;
     }
     catchInstances.length = j;
     var handler = arguments[i];
     return this._passThrough(catchFilter(catchInstances, handler, this), 1, void 0, finallyHandler);
    }, PassThroughHandlerContext;
   };
  },
  65734: (module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   module.exports = function(Promise, apiRejection, INTERNAL, tryConvertToPromise, Proxyable, debug) {
    var TypeError = __webpack_require__(90403).TypeError, util = __webpack_require__(92208), errorObj = util.errorObj, tryCatch = util.tryCatch, yieldHandlers = [];
    function PromiseSpawn(generatorFunction, receiver, yieldHandler, stack) {
     if (debug.cancellation()) {
      var internal = new Promise(INTERNAL), _finallyPromise = this._finallyPromise = new Promise(INTERNAL);
      this._promise = internal.lastly((function() {
       return _finallyPromise;
      })), internal._captureStackTrace(), internal._setOnCancel(this);
     } else {
      (this._promise = new Promise(INTERNAL))._captureStackTrace();
     }
     this._stack = stack, this._generatorFunction = generatorFunction, this._receiver = receiver, 
     this._generator = void 0, this._yieldHandlers = "function" == typeof yieldHandler ? [ yieldHandler ].concat(yieldHandlers) : yieldHandlers, 
     this._yieldedPromise = null, this._cancellationPhase = !1;
    }
    util.inherits(PromiseSpawn, Proxyable), PromiseSpawn.prototype._isResolved = function() {
     return null === this._promise;
    }, PromiseSpawn.prototype._cleanup = function() {
     this._promise = this._generator = null, debug.cancellation() && null !== this._finallyPromise && (this._finallyPromise._fulfill(), 
     this._finallyPromise = null);
    }, PromiseSpawn.prototype._promiseCancelled = function() {
     if (!this._isResolved()) {
      var result;
      if (void 0 !== this._generator.return) this._promise._pushContext(), result = tryCatch(this._generator.return).call(this._generator, void 0), 
      this._promise._popContext(); else {
       var reason = new Promise.CancellationError("generator .return() sentinel");
       Promise.coroutine.returnSentinel = reason, this._promise._attachExtraTrace(reason), 
       this._promise._pushContext(), result = tryCatch(this._generator.throw).call(this._generator, reason), 
       this._promise._popContext();
      }
      this._cancellationPhase = !0, this._yieldedPromise = null, this._continue(result);
     }
    }, PromiseSpawn.prototype._promiseFulfilled = function(value) {
     this._yieldedPromise = null, this._promise._pushContext();
     var result = tryCatch(this._generator.next).call(this._generator, value);
     this._promise._popContext(), this._continue(result);
    }, PromiseSpawn.prototype._promiseRejected = function(reason) {
     this._yieldedPromise = null, this._promise._attachExtraTrace(reason), this._promise._pushContext();
     var result = tryCatch(this._generator.throw).call(this._generator, reason);
     this._promise._popContext(), this._continue(result);
    }, PromiseSpawn.prototype._resultCancelled = function() {
     if (this._yieldedPromise instanceof Promise) {
      var promise = this._yieldedPromise;
      this._yieldedPromise = null, promise.cancel();
     }
    }, PromiseSpawn.prototype.promise = function() {
     return this._promise;
    }, PromiseSpawn.prototype._run = function() {
     this._generator = this._generatorFunction.call(this._receiver), this._receiver = this._generatorFunction = void 0, 
     this._promiseFulfilled(void 0);
    }, PromiseSpawn.prototype._continue = function(result) {
     var promise = this._promise;
     if (result === errorObj) return this._cleanup(), this._cancellationPhase ? promise.cancel() : promise._rejectCallback(result.e, !1);
     var value = result.value;
     if (!0 === result.done) return this._cleanup(), this._cancellationPhase ? promise.cancel() : promise._resolveCallback(value);
     var maybePromise = tryConvertToPromise(value, this._promise);
     if (maybePromise instanceof Promise || (maybePromise = function(value, yieldHandlers, traceParent) {
      for (var i = 0; i < yieldHandlers.length; ++i) {
       traceParent._pushContext();
       var result = tryCatch(yieldHandlers[i])(value);
       if (traceParent._popContext(), result === errorObj) {
        traceParent._pushContext();
        var ret = Promise.reject(errorObj.e);
        return traceParent._popContext(), ret;
       }
       var maybePromise = tryConvertToPromise(result, traceParent);
       if (maybePromise instanceof Promise) return maybePromise;
      }
      return null;
     }(maybePromise, this._yieldHandlers, this._promise), null !== maybePromise)) {
      var bitField = (maybePromise = maybePromise._target())._bitField;
      50397184 & bitField ? 33554432 & bitField ? Promise._async.invoke(this._promiseFulfilled, this, maybePromise._value()) : 16777216 & bitField ? Promise._async.invoke(this._promiseRejected, this, maybePromise._reason()) : this._promiseCancelled() : (this._yieldedPromise = maybePromise, 
      maybePromise._proxy(this, null));
     } else this._promiseRejected(new TypeError("A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/MqrFmX\n\n".replace("%s", String(value)) + "From coroutine:\n" + this._stack.split("\n").slice(1, -7).join("\n")));
    }, Promise.coroutine = function(generatorFunction, options) {
     if ("function" != typeof generatorFunction) throw new TypeError("generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n");
     var yieldHandler = Object(options).yieldHandler, PromiseSpawn$ = PromiseSpawn, stack = (new Error).stack;
     return function() {
      var generator = generatorFunction.apply(this, arguments), spawn = new PromiseSpawn$(void 0, void 0, yieldHandler, stack), ret = spawn.promise();
      return spawn._generator = generator, spawn._promiseFulfilled(void 0), ret;
     };
    }, Promise.coroutine.addYieldHandler = function(fn) {
     if ("function" != typeof fn) throw new TypeError("expecting a function but got " + util.classString(fn));
     yieldHandlers.push(fn);
    }, Promise.spawn = function(generatorFunction) {
     if (debug.deprecated("Promise.spawn()", "Promise.coroutine()"), "function" != typeof generatorFunction) return apiRejection("generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n");
     var spawn = new PromiseSpawn(generatorFunction, this), ret = spawn.promise();
     return spawn._run(Promise.spawn), ret;
    };
   };
  },
  46564: (module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   module.exports = function(Promise, PromiseArray, tryConvertToPromise, INTERNAL, async) {
    var reject, util = __webpack_require__(92208), canEvaluate = util.canEvaluate, tryCatch = util.tryCatch, errorObj = util.errorObj;
    if (canEvaluate) {
     for (var thenCallback = function(i) {
      return new Function("value", "holder", "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ".replace(/Index/g, i));
     }, promiseSetter = function(i) {
      return new Function("promise", "holder", "                           \n            'use strict';                                                    \n            holder.pIndex = promise;                                         \n            ".replace(/Index/g, i));
     }, generateHolderClass = function(total) {
      for (var props = new Array(total), i = 0; i < props.length; ++i) props[i] = "this.p" + (i + 1);
      var assignment = props.join(" = ") + " = null;", cancellationCode = "var promise;\n" + props.map((function(prop) {
       return "                                                         \n                promise = " + prop + ";                                      \n                if (promise instanceof Promise) {                            \n                    promise.cancel();                                        \n                }                                                            \n            ";
      })).join("\n"), passedArguments = props.join(", "), name = "Holder$" + total, code = "return function(tryCatch, errorObj, Promise, async) {    \n            'use strict';                                                    \n            function [TheName](fn) {                                         \n                [TheProperties]                                              \n                this.fn = fn;                                                \n                this.asyncNeeded = true;                                     \n                this.now = 0;                                                \n            }                                                                \n                                                                             \n            [TheName].prototype._callFunction = function(promise) {          \n                promise._pushContext();                                      \n                var ret = tryCatch(this.fn)([ThePassedArguments]);           \n                promise._popContext();                                       \n                if (ret === errorObj) {                                      \n                    promise._rejectCallback(ret.e, false);                   \n                } else {                                                     \n                    promise._resolveCallback(ret);                           \n                }                                                            \n            };                                                               \n                                                                             \n            [TheName].prototype.checkFulfillment = function(promise) {       \n                var now = ++this.now;                                        \n                if (now === [TheTotal]) {                                    \n                    if (this.asyncNeeded) {                                  \n                        async.invoke(this._callFunction, this, promise);     \n                    } else {                                                 \n                        this._callFunction(promise);                         \n                    }                                                        \n                                                                             \n                }                                                            \n            };                                                               \n                                                                             \n            [TheName].prototype._resultCancelled = function() {              \n                [CancellationCode]                                           \n            };                                                               \n                                                                             \n            return [TheName];                                                \n        }(tryCatch, errorObj, Promise, async);                               \n        ";
      return code = code.replace(/\[TheName\]/g, name).replace(/\[TheTotal\]/g, total).replace(/\[ThePassedArguments\]/g, passedArguments).replace(/\[TheProperties\]/g, assignment).replace(/\[CancellationCode\]/g, cancellationCode), 
      new Function("tryCatch", "errorObj", "Promise", "async", code)(tryCatch, errorObj, Promise, async);
     }, holderClasses = [], thenCallbacks = [], promiseSetters = [], i = 0; i < 8; ++i) holderClasses.push(generateHolderClass(i + 1)), 
     thenCallbacks.push(thenCallback(i + 1)), promiseSetters.push(promiseSetter(i + 1));
     reject = function(reason) {
      this._reject(reason);
     };
    }
    Promise.join = function() {
     var fn, last = arguments.length - 1;
     if (last > 0 && "function" == typeof arguments[last] && (fn = arguments[last], last <= 8 && canEvaluate)) {
      (ret = new Promise(INTERNAL))._captureStackTrace();
      for (var holder = new (0, holderClasses[last - 1])(fn), callbacks = thenCallbacks, i = 0; i < last; ++i) {
       var maybePromise = tryConvertToPromise(arguments[i], ret);
       if (maybePromise instanceof Promise) {
        var bitField = (maybePromise = maybePromise._target())._bitField;
        50397184 & bitField ? 33554432 & bitField ? callbacks[i].call(ret, maybePromise._value(), holder) : 16777216 & bitField ? ret._reject(maybePromise._reason()) : ret._cancel() : (maybePromise._then(callbacks[i], reject, void 0, ret, holder), 
        promiseSetters[i](maybePromise, holder), holder.asyncNeeded = !1);
       } else callbacks[i].call(ret, maybePromise, holder);
      }
      if (!ret._isFateSealed()) {
       if (holder.asyncNeeded) {
        var context = Promise._getContext();
        holder.fn = util.contextBind(context, holder.fn);
       }
       ret._setAsyncGuaranteed(), ret._setOnCancel(holder);
      }
      return ret;
     }
     for (var $_len = arguments.length, args = new Array($_len), $_i = 0; $_i < $_len; ++$_i) args[$_i] = arguments[$_i];
     fn && args.pop();
     var ret = new PromiseArray(args).promise();
     return void 0 !== fn ? ret.spread(fn) : ret;
    };
   };
  },
  35956: (module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   module.exports = function(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug) {
    var util = __webpack_require__(92208), tryCatch = util.tryCatch, errorObj = util.errorObj, async = Promise._async;
    function MappingPromiseArray(promises, fn, limit, _filter) {
     this.constructor$(promises), this._promise._captureStackTrace();
     var context = Promise._getContext();
     if (this._callback = util.contextBind(context, fn), this._preservedValues = _filter === INTERNAL ? new Array(this.length()) : null, 
     this._limit = limit, this._inFlight = 0, this._queue = [], async.invoke(this._asyncInit, this, void 0), 
     util.isArray(promises)) for (var i = 0; i < promises.length; ++i) {
      var maybePromise = promises[i];
      maybePromise instanceof Promise && maybePromise.suppressUnhandledRejections();
     }
    }
    function map(promises, fn, options, _filter) {
     if ("function" != typeof fn) return apiRejection("expecting a function but got " + util.classString(fn));
     var limit = 0;
     if (void 0 !== options) {
      if ("object" != typeof options || null === options) return Promise.reject(new TypeError("options argument must be an object but it is " + util.classString(options)));
      if ("number" != typeof options.concurrency) return Promise.reject(new TypeError("'concurrency' must be a number but it is " + util.classString(options.concurrency)));
      limit = options.concurrency;
     }
     return new MappingPromiseArray(promises, fn, limit = "number" == typeof limit && isFinite(limit) && limit >= 1 ? limit : 0, _filter).promise();
    }
    util.inherits(MappingPromiseArray, PromiseArray), MappingPromiseArray.prototype._asyncInit = function() {
     this._init$(void 0, -2);
    }, MappingPromiseArray.prototype._init = function() {}, MappingPromiseArray.prototype._promiseFulfilled = function(value, index) {
     var values = this._values, length = this.length(), preservedValues = this._preservedValues, limit = this._limit;
     if (index < 0) {
      if (values[index = -1 * index - 1] = value, limit >= 1 && (this._inFlight--, this._drainQueue(), 
      this._isResolved())) return !0;
     } else {
      if (limit >= 1 && this._inFlight >= limit) return values[index] = value, this._queue.push(index), 
      !1;
      null !== preservedValues && (preservedValues[index] = value);
      var promise = this._promise, callback = this._callback, receiver = promise._boundValue();
      promise._pushContext();
      var ret = tryCatch(callback).call(receiver, value, index, length), promiseCreated = promise._popContext();
      if (debug.checkForgottenReturns(ret, promiseCreated, null !== preservedValues ? "Promise.filter" : "Promise.map", promise), 
      ret === errorObj) return this._reject(ret.e), !0;
      var maybePromise = tryConvertToPromise(ret, this._promise);
      if (maybePromise instanceof Promise) {
       var bitField = (maybePromise = maybePromise._target())._bitField;
       if (!(50397184 & bitField)) return limit >= 1 && this._inFlight++, values[index] = maybePromise, 
       maybePromise._proxy(this, -1 * (index + 1)), !1;
       if (!(33554432 & bitField)) return 16777216 & bitField ? (this._reject(maybePromise._reason()), 
       !0) : (this._cancel(), !0);
       ret = maybePromise._value();
      }
      values[index] = ret;
     }
     return ++this._totalResolved >= length && (null !== preservedValues ? this._filter(values, preservedValues) : this._resolve(values), 
     !0);
    }, MappingPromiseArray.prototype._drainQueue = function() {
     for (var queue = this._queue, limit = this._limit, values = this._values; queue.length > 0 && this._inFlight < limit; ) {
      if (this._isResolved()) return;
      var index = queue.pop();
      this._promiseFulfilled(values[index], index);
     }
    }, MappingPromiseArray.prototype._filter = function(booleans, values) {
     for (var len = values.length, ret = new Array(len), j = 0, i = 0; i < len; ++i) booleans[i] && (ret[j++] = values[i]);
     ret.length = j, this._resolve(ret);
    }, MappingPromiseArray.prototype.preservedValues = function() {
     return this._preservedValues;
    }, Promise.prototype.map = function(fn, options) {
     return map(this, fn, options, null);
    }, Promise.map = function(promises, fn, options, _filter) {
     return map(promises, fn, options, _filter);
    };
   };
  },
  6241: (module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   module.exports = function(Promise, INTERNAL, tryConvertToPromise, apiRejection, debug) {
    var util = __webpack_require__(92208), tryCatch = util.tryCatch;
    Promise.method = function(fn) {
     if ("function" != typeof fn) throw new Promise.TypeError("expecting a function but got " + util.classString(fn));
     return function() {
      var ret = new Promise(INTERNAL);
      ret._captureStackTrace(), ret._pushContext();
      var value = tryCatch(fn).apply(this, arguments), promiseCreated = ret._popContext();
      return debug.checkForgottenReturns(value, promiseCreated, "Promise.method", ret), 
      ret._resolveFromSyncValue(value), ret;
     };
    }, Promise.attempt = Promise.try = function(fn) {
     if ("function" != typeof fn) return apiRejection("expecting a function but got " + util.classString(fn));
     var value, ret = new Promise(INTERNAL);
     if (ret._captureStackTrace(), ret._pushContext(), arguments.length > 1) {
      debug.deprecated("calling Promise.try with more than 1 argument");
      var arg = arguments[1], ctx = arguments[2];
      value = util.isArray(arg) ? tryCatch(fn).apply(ctx, arg) : tryCatch(fn).call(ctx, arg);
     } else value = tryCatch(fn)();
     var promiseCreated = ret._popContext();
     return debug.checkForgottenReturns(value, promiseCreated, "Promise.try", ret), ret._resolveFromSyncValue(value), 
     ret;
    }, Promise.prototype._resolveFromSyncValue = function(value) {
     value === util.errorObj ? this._rejectCallback(value.e, !1) : this._resolveCallback(value, !0);
    };
   };
  },
  41231: (module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   var util = __webpack_require__(92208), maybeWrapAsError = util.maybeWrapAsError, OperationalError = __webpack_require__(90403).OperationalError, es5 = __webpack_require__(7585);
   var rErrorKey = /^(?:name|message|stack|cause)$/;
   function wrapAsOperationalError(obj) {
    var ret;
    if (function(obj) {
     return obj instanceof Error && es5.getPrototypeOf(obj) === Error.prototype;
    }(obj)) {
     (ret = new OperationalError(obj)).name = obj.name, ret.message = obj.message, ret.stack = obj.stack;
     for (var keys = es5.keys(obj), i = 0; i < keys.length; ++i) {
      var key = keys[i];
      rErrorKey.test(key) || (ret[key] = obj[key]);
     }
     return ret;
    }
    return util.markAsOriginatingFromRejection(obj), obj;
   }
   module.exports = function(promise, multiArgs) {
    return function(err, value) {
     if (null !== promise) {
      if (err) {
       var wrapped = wrapAsOperationalError(maybeWrapAsError(err));
       promise._attachExtraTrace(wrapped), promise._reject(wrapped);
      } else if (multiArgs) {
       for (var $_len = arguments.length, args = new Array(Math.max($_len - 1, 0)), $_i = 1; $_i < $_len; ++$_i) args[$_i - 1] = arguments[$_i];
       promise._fulfill(args);
      } else promise._fulfill(value);
      promise = null;
     }
    };
   };
  },
  36340: (module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   module.exports = function(Promise) {
    var util = __webpack_require__(92208), async = Promise._async, tryCatch = util.tryCatch, errorObj = util.errorObj;
    function spreadAdapter(val, nodeback) {
     if (!util.isArray(val)) return successAdapter.call(this, val, nodeback);
     var ret = tryCatch(nodeback).apply(this._boundValue(), [ null ].concat(val));
     ret === errorObj && async.throwLater(ret.e);
    }
    function successAdapter(val, nodeback) {
     var receiver = this._boundValue(), ret = void 0 === val ? tryCatch(nodeback).call(receiver, null) : tryCatch(nodeback).call(receiver, null, val);
     ret === errorObj && async.throwLater(ret.e);
    }
    function errorAdapter(reason, nodeback) {
     if (!reason) {
      var newReason = new Error(reason + "");
      newReason.cause = reason, reason = newReason;
     }
     var ret = tryCatch(nodeback).call(this._boundValue(), reason);
     ret === errorObj && async.throwLater(ret.e);
    }
    Promise.prototype.asCallback = Promise.prototype.nodeify = function(nodeback, options) {
     if ("function" == typeof nodeback) {
      var adapter = successAdapter;
      void 0 !== options && Object(options).spread && (adapter = spreadAdapter), this._then(adapter, errorAdapter, void 0, this, nodeback);
     }
     return this;
    };
   };
  },
  39979: (module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   module.exports = function() {
    var makeSelfResolutionError = function() {
     return new TypeError("circular promise resolution chain\n\n    See http://goo.gl/MqrFmX\n");
    }, reflectHandler = function() {
     return new Promise.PromiseInspection(this._target());
    }, apiRejection = function(msg) {
     return Promise.reject(new TypeError(msg));
    };
    function Proxyable() {}
    var UNDEFINED_BINDING = {}, util = __webpack_require__(92208);
    util.setReflectHandler(reflectHandler);
    var getDomain = function() {
     var domain = process.domain;
     return void 0 === domain ? null : domain;
    }, getContextDomain = function() {
     return {
      domain: getDomain(),
      async: null
     };
    }, AsyncResource = util.isNode && util.nodeSupportsAsyncResource ? __webpack_require__(90290).AsyncResource : null, getContextAsyncHooks = function() {
     return {
      domain: getDomain(),
      async: new AsyncResource("Bluebird::Promise")
     };
    }, getContext = util.isNode ? getContextDomain : function() {
     return null;
    };
    util.notEnumerableProp(Promise, "_getContext", getContext);
    var es5 = __webpack_require__(7585), Async = __webpack_require__(28210), async = new Async;
    es5.defineProperty(Promise, "_async", {
     value: async
    });
    var errors = __webpack_require__(90403), TypeError = Promise.TypeError = errors.TypeError;
    Promise.RangeError = errors.RangeError;
    var CancellationError = Promise.CancellationError = errors.CancellationError;
    Promise.TimeoutError = errors.TimeoutError, Promise.OperationalError = errors.OperationalError, 
    Promise.RejectionError = errors.OperationalError, Promise.AggregateError = errors.AggregateError;
    var INTERNAL = function() {}, APPLY = {}, NEXT_FILTER = {}, tryConvertToPromise = __webpack_require__(78974)(Promise, INTERNAL), PromiseArray = __webpack_require__(52661)(Promise, INTERNAL, tryConvertToPromise, apiRejection, Proxyable), Context = __webpack_require__(30297)(Promise), createContext = Context.create, debug = __webpack_require__(6636)(Promise, Context, (function() {
     getContext = getContextAsyncHooks, util.notEnumerableProp(Promise, "_getContext", getContextAsyncHooks);
    }), (function() {
     getContext = getContextDomain, util.notEnumerableProp(Promise, "_getContext", getContextDomain);
    })), PassThroughHandlerContext = (debug.CapturedTrace, __webpack_require__(90401)(Promise, tryConvertToPromise, NEXT_FILTER)), catchFilter = __webpack_require__(91674)(NEXT_FILTER), nodebackForPromise = __webpack_require__(41231), errorObj = util.errorObj, tryCatch = util.tryCatch;
    function Promise(executor) {
     executor !== INTERNAL && function(self, executor) {
      if (null == self || self.constructor !== Promise) throw new TypeError("the promise constructor cannot be invoked directly\n\n    See http://goo.gl/MqrFmX\n");
      if ("function" != typeof executor) throw new TypeError("expecting a function but got " + util.classString(executor));
     }(this, executor), this._bitField = 0, this._fulfillmentHandler0 = void 0, this._rejectionHandler0 = void 0, 
     this._promise0 = void 0, this._receiver0 = void 0, this._resolveFromExecutor(executor), 
     this._promiseCreated(), this._fireEvent("promiseCreated", this);
    }
    function deferResolve(v) {
     this.promise._resolveCallback(v);
    }
    function deferReject(v) {
     this.promise._rejectCallback(v, !1);
    }
    function fillTypes(value) {
     var p = new Promise(INTERNAL);
     p._fulfillmentHandler0 = value, p._rejectionHandler0 = value, p._promise0 = value, 
     p._receiver0 = value;
    }
    return Promise.prototype.toString = function() {
     return "[object Promise]";
    }, Promise.prototype.caught = Promise.prototype.catch = function(fn) {
     var len = arguments.length;
     if (len > 1) {
      var i, catchInstances = new Array(len - 1), j = 0;
      for (i = 0; i < len - 1; ++i) {
       var item = arguments[i];
       if (!util.isObject(item)) return apiRejection("Catch statement predicate: expecting an object but got " + util.classString(item));
       catchInstances[j++] = item;
      }
      if (catchInstances.length = j, "function" != typeof (fn = arguments[i])) throw new TypeError("The last argument to .catch() must be a function, got " + util.toString(fn));
      return this.then(void 0, catchFilter(catchInstances, fn, this));
     }
     return this.then(void 0, fn);
    }, Promise.prototype.reflect = function() {
     return this._then(reflectHandler, reflectHandler, void 0, this, void 0);
    }, Promise.prototype.then = function(didFulfill, didReject) {
     if (debug.warnings() && arguments.length > 0 && "function" != typeof didFulfill && "function" != typeof didReject) {
      var msg = ".then() only accepts functions but was passed: " + util.classString(didFulfill);
      arguments.length > 1 && (msg += ", " + util.classString(didReject)), this._warn(msg);
     }
     return this._then(didFulfill, didReject, void 0, void 0, void 0);
    }, Promise.prototype.done = function(didFulfill, didReject) {
     this._then(didFulfill, didReject, void 0, void 0, void 0)._setIsFinal();
    }, Promise.prototype.spread = function(fn) {
     return "function" != typeof fn ? apiRejection("expecting a function but got " + util.classString(fn)) : this.all()._then(fn, void 0, void 0, APPLY, void 0);
    }, Promise.prototype.toJSON = function() {
     var ret = {
      isFulfilled: !1,
      isRejected: !1,
      fulfillmentValue: void 0,
      rejectionReason: void 0
     };
     return this.isFulfilled() ? (ret.fulfillmentValue = this.value(), ret.isFulfilled = !0) : this.isRejected() && (ret.rejectionReason = this.reason(), 
     ret.isRejected = !0), ret;
    }, Promise.prototype.all = function() {
     return arguments.length > 0 && this._warn(".all() was passed arguments but it does not take any"), 
     new PromiseArray(this).promise();
    }, Promise.prototype.error = function(fn) {
     return this.caught(util.originatesFromRejection, fn);
    }, Promise.getNewLibraryCopy = module.exports, Promise.is = function(val) {
     return val instanceof Promise;
    }, Promise.fromNode = Promise.fromCallback = function(fn) {
     var ret = new Promise(INTERNAL);
     ret._captureStackTrace();
     var multiArgs = arguments.length > 1 && !!Object(arguments[1]).multiArgs, result = tryCatch(fn)(nodebackForPromise(ret, multiArgs));
     return result === errorObj && ret._rejectCallback(result.e, !0), ret._isFateSealed() || ret._setAsyncGuaranteed(), 
     ret;
    }, Promise.all = function(promises) {
     return new PromiseArray(promises).promise();
    }, Promise.cast = function(obj) {
     var ret = tryConvertToPromise(obj);
     return ret instanceof Promise || ((ret = new Promise(INTERNAL))._captureStackTrace(), 
     ret._setFulfilled(), ret._rejectionHandler0 = obj), ret;
    }, Promise.resolve = Promise.fulfilled = Promise.cast, Promise.reject = Promise.rejected = function(reason) {
     var ret = new Promise(INTERNAL);
     return ret._captureStackTrace(), ret._rejectCallback(reason, !0), ret;
    }, Promise.setScheduler = function(fn) {
     if ("function" != typeof fn) throw new TypeError("expecting a function but got " + util.classString(fn));
     return async.setScheduler(fn);
    }, Promise.prototype._then = function(didFulfill, didReject, _, receiver, internalData) {
     var haveInternalData = void 0 !== internalData, promise = haveInternalData ? internalData : new Promise(INTERNAL), target = this._target(), bitField = target._bitField;
     haveInternalData || (promise._propagateFrom(this, 3), promise._captureStackTrace(), 
     void 0 === receiver && 2097152 & this._bitField && (receiver = 50397184 & bitField ? this._boundValue() : target === this ? void 0 : this._boundTo), 
     this._fireEvent("promiseChained", this, promise));
     var context = getContext();
     if (50397184 & bitField) {
      var handler, value, settler = target._settlePromiseCtx;
      33554432 & bitField ? (value = target._rejectionHandler0, handler = didFulfill) : 16777216 & bitField ? (value = target._fulfillmentHandler0, 
      handler = didReject, target._unsetRejectionIsUnhandled()) : (settler = target._settlePromiseLateCancellationObserver, 
      value = new CancellationError("late cancellation observer"), target._attachExtraTrace(value), 
      handler = didReject), async.invoke(settler, target, {
       handler: util.contextBind(context, handler),
       promise,
       receiver,
       value
      });
     } else target._addCallbacks(didFulfill, didReject, promise, receiver, context);
     return promise;
    }, Promise.prototype._length = function() {
     return 65535 & this._bitField;
    }, Promise.prototype._isFateSealed = function() {
     return !!(117506048 & this._bitField);
    }, Promise.prototype._isFollowing = function() {
     return !(67108864 & ~this._bitField);
    }, Promise.prototype._setLength = function(len) {
     this._bitField = -65536 & this._bitField | 65535 & len;
    }, Promise.prototype._setFulfilled = function() {
     this._bitField = 33554432 | this._bitField, this._fireEvent("promiseFulfilled", this);
    }, Promise.prototype._setRejected = function() {
     this._bitField = 16777216 | this._bitField, this._fireEvent("promiseRejected", this);
    }, Promise.prototype._setFollowing = function() {
     this._bitField = 67108864 | this._bitField, this._fireEvent("promiseResolved", this);
    }, Promise.prototype._setIsFinal = function() {
     this._bitField = 4194304 | this._bitField;
    }, Promise.prototype._isFinal = function() {
     return (4194304 & this._bitField) > 0;
    }, Promise.prototype._unsetCancelled = function() {
     this._bitField = -65537 & this._bitField;
    }, Promise.prototype._setCancelled = function() {
     this._bitField = 65536 | this._bitField, this._fireEvent("promiseCancelled", this);
    }, Promise.prototype._setWillBeCancelled = function() {
     this._bitField = 8388608 | this._bitField;
    }, Promise.prototype._setAsyncGuaranteed = function() {
     if (!async.hasCustomScheduler()) {
      var bitField = this._bitField;
      this._bitField = bitField | (536870912 & bitField) >> 2 ^ 134217728;
     }
    }, Promise.prototype._setNoAsyncGuarantee = function() {
     this._bitField = -134217729 & this._bitField | 536870912;
    }, Promise.prototype._receiverAt = function(index) {
     var ret = 0 === index ? this._receiver0 : this[4 * index - 4 + 3];
     if (ret !== UNDEFINED_BINDING) return void 0 === ret && this._isBound() ? this._boundValue() : ret;
    }, Promise.prototype._promiseAt = function(index) {
     return this[4 * index - 4 + 2];
    }, Promise.prototype._fulfillmentHandlerAt = function(index) {
     return this[4 * index - 4 + 0];
    }, Promise.prototype._rejectionHandlerAt = function(index) {
     return this[4 * index - 4 + 1];
    }, Promise.prototype._boundValue = function() {}, Promise.prototype._migrateCallback0 = function(follower) {
     follower._bitField;
     var fulfill = follower._fulfillmentHandler0, reject = follower._rejectionHandler0, promise = follower._promise0, receiver = follower._receiverAt(0);
     void 0 === receiver && (receiver = UNDEFINED_BINDING), this._addCallbacks(fulfill, reject, promise, receiver, null);
    }, Promise.prototype._migrateCallbackAt = function(follower, index) {
     var fulfill = follower._fulfillmentHandlerAt(index), reject = follower._rejectionHandlerAt(index), promise = follower._promiseAt(index), receiver = follower._receiverAt(index);
     void 0 === receiver && (receiver = UNDEFINED_BINDING), this._addCallbacks(fulfill, reject, promise, receiver, null);
    }, Promise.prototype._addCallbacks = function(fulfill, reject, promise, receiver, context) {
     var index = this._length();
     if (index >= 65531 && (index = 0, this._setLength(0)), 0 === index) this._promise0 = promise, 
     this._receiver0 = receiver, "function" == typeof fulfill && (this._fulfillmentHandler0 = util.contextBind(context, fulfill)), 
     "function" == typeof reject && (this._rejectionHandler0 = util.contextBind(context, reject)); else {
      var base = 4 * index - 4;
      this[base + 2] = promise, this[base + 3] = receiver, "function" == typeof fulfill && (this[base + 0] = util.contextBind(context, fulfill)), 
      "function" == typeof reject && (this[base + 1] = util.contextBind(context, reject));
     }
     return this._setLength(index + 1), index;
    }, Promise.prototype._proxy = function(proxyable, arg) {
     this._addCallbacks(void 0, void 0, arg, proxyable, null);
    }, Promise.prototype._resolveCallback = function(value, shouldBind) {
     if (!(117506048 & this._bitField)) {
      if (value === this) return this._rejectCallback(makeSelfResolutionError(), !1);
      var maybePromise = tryConvertToPromise(value, this);
      if (!(maybePromise instanceof Promise)) return this._fulfill(value);
      shouldBind && this._propagateFrom(maybePromise, 2);
      var promise = maybePromise._target();
      if (promise !== this) {
       var bitField = promise._bitField;
       if (50397184 & bitField) if (33554432 & bitField) this._fulfill(promise._value()); else if (16777216 & bitField) this._reject(promise._reason()); else {
        var reason = new CancellationError("late cancellation observer");
        promise._attachExtraTrace(reason), this._reject(reason);
       } else {
        var len = this._length();
        len > 0 && promise._migrateCallback0(this);
        for (var i = 1; i < len; ++i) promise._migrateCallbackAt(this, i);
        this._setFollowing(), this._setLength(0), this._setFollowee(maybePromise);
       }
      } else this._reject(makeSelfResolutionError());
     }
    }, Promise.prototype._rejectCallback = function(reason, synchronous, ignoreNonErrorWarnings) {
     var trace = util.ensureErrorObject(reason), hasStack = trace === reason;
     if (!hasStack && !ignoreNonErrorWarnings && debug.warnings()) {
      var message = "a promise was rejected with a non-error: " + util.classString(reason);
      this._warn(message, !0);
     }
     this._attachExtraTrace(trace, !!synchronous && hasStack), this._reject(reason);
    }, Promise.prototype._resolveFromExecutor = function(executor) {
     if (executor !== INTERNAL) {
      var promise = this;
      this._captureStackTrace(), this._pushContext();
      var synchronous = !0, r = this._execute(executor, (function(value) {
       promise._resolveCallback(value);
      }), (function(reason) {
       promise._rejectCallback(reason, synchronous);
      }));
      synchronous = !1, this._popContext(), void 0 !== r && promise._rejectCallback(r, !0);
     }
    }, Promise.prototype._settlePromiseFromHandler = function(handler, receiver, value, promise) {
     var bitField = promise._bitField;
     if (!(65536 & bitField)) {
      var x;
      promise._pushContext(), receiver === APPLY ? value && "number" == typeof value.length ? x = tryCatch(handler).apply(this._boundValue(), value) : (x = errorObj).e = new TypeError("cannot .spread() a non-array: " + util.classString(value)) : x = tryCatch(handler).call(receiver, value);
      var promiseCreated = promise._popContext();
      65536 & (bitField = promise._bitField) || (x === NEXT_FILTER ? promise._reject(value) : x === errorObj ? promise._rejectCallback(x.e, !1) : (debug.checkForgottenReturns(x, promiseCreated, "", promise, this), 
      promise._resolveCallback(x)));
     }
    }, Promise.prototype._target = function() {
     for (var ret = this; ret._isFollowing(); ) ret = ret._followee();
     return ret;
    }, Promise.prototype._followee = function() {
     return this._rejectionHandler0;
    }, Promise.prototype._setFollowee = function(promise) {
     this._rejectionHandler0 = promise;
    }, Promise.prototype._settlePromise = function(promise, handler, receiver, value) {
     var isPromise = promise instanceof Promise, bitField = this._bitField, asyncGuaranteed = !!(134217728 & bitField);
     65536 & bitField ? (isPromise && promise._invokeInternalOnCancel(), receiver instanceof PassThroughHandlerContext && receiver.isFinallyHandler() ? (receiver.cancelPromise = promise, 
     tryCatch(handler).call(receiver, value) === errorObj && promise._reject(errorObj.e)) : handler === reflectHandler ? promise._fulfill(reflectHandler.call(receiver)) : receiver instanceof Proxyable ? receiver._promiseCancelled(promise) : isPromise || promise instanceof PromiseArray ? promise._cancel() : receiver.cancel()) : "function" == typeof handler ? isPromise ? (asyncGuaranteed && promise._setAsyncGuaranteed(), 
     this._settlePromiseFromHandler(handler, receiver, value, promise)) : handler.call(receiver, value, promise) : receiver instanceof Proxyable ? receiver._isResolved() || (33554432 & bitField ? receiver._promiseFulfilled(value, promise) : receiver._promiseRejected(value, promise)) : isPromise && (asyncGuaranteed && promise._setAsyncGuaranteed(), 
     33554432 & bitField ? promise._fulfill(value) : promise._reject(value));
    }, Promise.prototype._settlePromiseLateCancellationObserver = function(ctx) {
     var handler = ctx.handler, promise = ctx.promise, receiver = ctx.receiver, value = ctx.value;
     "function" == typeof handler ? promise instanceof Promise ? this._settlePromiseFromHandler(handler, receiver, value, promise) : handler.call(receiver, value, promise) : promise instanceof Promise && promise._reject(value);
    }, Promise.prototype._settlePromiseCtx = function(ctx) {
     this._settlePromise(ctx.promise, ctx.handler, ctx.receiver, ctx.value);
    }, Promise.prototype._settlePromise0 = function(handler, value, bitField) {
     var promise = this._promise0, receiver = this._receiverAt(0);
     this._promise0 = void 0, this._receiver0 = void 0, this._settlePromise(promise, handler, receiver, value);
    }, Promise.prototype._clearCallbackDataAtIndex = function(index) {
     var base = 4 * index - 4;
     this[base + 2] = this[base + 3] = this[base + 0] = this[base + 1] = void 0;
    }, Promise.prototype._fulfill = function(value) {
     var bitField = this._bitField;
     if (!((117506048 & bitField) >>> 16)) {
      if (value === this) {
       var err = makeSelfResolutionError();
       return this._attachExtraTrace(err), this._reject(err);
      }
      this._setFulfilled(), this._rejectionHandler0 = value, (65535 & bitField) > 0 && (134217728 & bitField ? this._settlePromises() : async.settlePromises(this), 
      this._dereferenceTrace());
     }
    }, Promise.prototype._reject = function(reason) {
     var bitField = this._bitField;
     if (!((117506048 & bitField) >>> 16)) {
      if (this._setRejected(), this._fulfillmentHandler0 = reason, this._isFinal()) return async.fatalError(reason, util.isNode);
      (65535 & bitField) > 0 ? async.settlePromises(this) : this._ensurePossibleRejectionHandled();
     }
    }, Promise.prototype._fulfillPromises = function(len, value) {
     for (var i = 1; i < len; i++) {
      var handler = this._fulfillmentHandlerAt(i), promise = this._promiseAt(i), receiver = this._receiverAt(i);
      this._clearCallbackDataAtIndex(i), this._settlePromise(promise, handler, receiver, value);
     }
    }, Promise.prototype._rejectPromises = function(len, reason) {
     for (var i = 1; i < len; i++) {
      var handler = this._rejectionHandlerAt(i), promise = this._promiseAt(i), receiver = this._receiverAt(i);
      this._clearCallbackDataAtIndex(i), this._settlePromise(promise, handler, receiver, reason);
     }
    }, Promise.prototype._settlePromises = function() {
     var bitField = this._bitField, len = 65535 & bitField;
     if (len > 0) {
      if (16842752 & bitField) {
       var reason = this._fulfillmentHandler0;
       this._settlePromise0(this._rejectionHandler0, reason, bitField), this._rejectPromises(len, reason);
      } else {
       var value = this._rejectionHandler0;
       this._settlePromise0(this._fulfillmentHandler0, value, bitField), this._fulfillPromises(len, value);
      }
      this._setLength(0);
     }
     this._clearCancellationData();
    }, Promise.prototype._settledValue = function() {
     var bitField = this._bitField;
     return 33554432 & bitField ? this._rejectionHandler0 : 16777216 & bitField ? this._fulfillmentHandler0 : void 0;
    }, "undefined" != typeof Symbol && Symbol.toStringTag && es5.defineProperty(Promise.prototype, Symbol.toStringTag, {
     get: function() {
      return "Object";
     }
    }), Promise.defer = Promise.pending = function() {
     return debug.deprecated("Promise.defer", "new Promise"), {
      promise: new Promise(INTERNAL),
      resolve: deferResolve,
      reject: deferReject
     };
    }, util.notEnumerableProp(Promise, "_makeSelfResolutionError", makeSelfResolutionError), 
    __webpack_require__(6241)(Promise, INTERNAL, tryConvertToPromise, apiRejection, debug), 
    __webpack_require__(54271)(Promise, INTERNAL, tryConvertToPromise, debug), __webpack_require__(2994)(Promise, PromiseArray, apiRejection, debug), 
    __webpack_require__(56774)(Promise), __webpack_require__(34900)(Promise), __webpack_require__(46564)(Promise, PromiseArray, tryConvertToPromise, INTERNAL, async), 
    Promise.Promise = Promise, Promise.version = "3.7.2", __webpack_require__(31675)(Promise), 
    __webpack_require__(65734)(Promise, apiRejection, INTERNAL, tryConvertToPromise, Proxyable, debug), 
    __webpack_require__(35956)(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug), 
    __webpack_require__(36340)(Promise), __webpack_require__(75818)(Promise, INTERNAL), 
    __webpack_require__(74416)(Promise, PromiseArray, tryConvertToPromise, apiRejection), 
    __webpack_require__(33381)(Promise, INTERNAL, tryConvertToPromise, apiRejection), 
    __webpack_require__(68722)(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug), 
    __webpack_require__(59047)(Promise, PromiseArray, debug), __webpack_require__(47784)(Promise, PromiseArray, apiRejection), 
    __webpack_require__(76406)(Promise, INTERNAL, debug), __webpack_require__(46178)(Promise, apiRejection, tryConvertToPromise, createContext, INTERNAL, debug), 
    __webpack_require__(7988)(Promise), __webpack_require__(93425)(Promise, INTERNAL), 
    __webpack_require__(72730)(Promise, INTERNAL), util.toFastProperties(Promise), util.toFastProperties(Promise.prototype), 
    fillTypes({
     a: 1
    }), fillTypes({
     b: 2
    }), fillTypes({
     c: 3
    }), fillTypes(1), fillTypes((function() {})), fillTypes(void 0), fillTypes(!1), 
    fillTypes(new Promise(INTERNAL)), debug.setBounds(Async.firstLineError, util.lastLineError), 
    Promise;
   };
  },
  52661: (module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   module.exports = function(Promise, INTERNAL, tryConvertToPromise, apiRejection, Proxyable) {
    var util = __webpack_require__(92208);
    util.isArray;
    function PromiseArray(values) {
     var promise = this._promise = new Promise(INTERNAL);
     values instanceof Promise && (promise._propagateFrom(values, 3), values.suppressUnhandledRejections()), 
     promise._setOnCancel(this), this._values = values, this._length = 0, this._totalResolved = 0, 
     this._init(void 0, -2);
    }
    return util.inherits(PromiseArray, Proxyable), PromiseArray.prototype.length = function() {
     return this._length;
    }, PromiseArray.prototype.promise = function() {
     return this._promise;
    }, PromiseArray.prototype._init = function init(_, resolveValueIfEmpty) {
     var values = tryConvertToPromise(this._values, this._promise);
     if (values instanceof Promise) {
      var bitField = (values = values._target())._bitField;
      if (this._values = values, !(50397184 & bitField)) return this._promise._setAsyncGuaranteed(), 
      values._then(init, this._reject, void 0, this, resolveValueIfEmpty);
      if (!(33554432 & bitField)) return 16777216 & bitField ? this._reject(values._reason()) : this._cancel();
      values = values._value();
     }
     if (null !== (values = util.asArray(values))) 0 !== values.length ? this._iterate(values) : -5 === resolveValueIfEmpty ? this._resolveEmptyArray() : this._resolve(function(val) {
      switch (val) {
      case -2:
       return [];

      case -3:
       return {};

      case -6:
       return new Map;
      }
     }(resolveValueIfEmpty)); else {
      var err = apiRejection("expecting an array or an iterable object but got " + util.classString(values)).reason();
      this._promise._rejectCallback(err, !1);
     }
    }, PromiseArray.prototype._iterate = function(values) {
     var len = this.getActualLength(values.length);
     this._length = len, this._values = this.shouldCopyValues() ? new Array(len) : this._values;
     for (var result = this._promise, isResolved = !1, bitField = null, i = 0; i < len; ++i) {
      var maybePromise = tryConvertToPromise(values[i], result);
      bitField = maybePromise instanceof Promise ? (maybePromise = maybePromise._target())._bitField : null, 
      isResolved ? null !== bitField && maybePromise.suppressUnhandledRejections() : null !== bitField ? 50397184 & bitField ? isResolved = 33554432 & bitField ? this._promiseFulfilled(maybePromise._value(), i) : 16777216 & bitField ? this._promiseRejected(maybePromise._reason(), i) : this._promiseCancelled(i) : (maybePromise._proxy(this, i), 
      this._values[i] = maybePromise) : isResolved = this._promiseFulfilled(maybePromise, i);
     }
     isResolved || result._setAsyncGuaranteed();
    }, PromiseArray.prototype._isResolved = function() {
     return null === this._values;
    }, PromiseArray.prototype._resolve = function(value) {
     this._values = null, this._promise._fulfill(value);
    }, PromiseArray.prototype._cancel = function() {
     !this._isResolved() && this._promise._isCancellable() && (this._values = null, this._promise._cancel());
    }, PromiseArray.prototype._reject = function(reason) {
     this._values = null, this._promise._rejectCallback(reason, !1);
    }, PromiseArray.prototype._promiseFulfilled = function(value, index) {
     return this._values[index] = value, ++this._totalResolved >= this._length && (this._resolve(this._values), 
     !0);
    }, PromiseArray.prototype._promiseCancelled = function() {
     return this._cancel(), !0;
    }, PromiseArray.prototype._promiseRejected = function(reason) {
     return this._totalResolved++, this._reject(reason), !0;
    }, PromiseArray.prototype._resultCancelled = function() {
     if (!this._isResolved()) {
      var values = this._values;
      if (this._cancel(), values instanceof Promise) values.cancel(); else for (var i = 0; i < values.length; ++i) values[i] instanceof Promise && values[i].cancel();
     }
    }, PromiseArray.prototype.shouldCopyValues = function() {
     return !0;
    }, PromiseArray.prototype.getActualLength = function(len) {
     return len;
    }, PromiseArray;
   };
  },
  75818: (module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   module.exports = function(Promise, INTERNAL) {
    var THIS = {}, util = __webpack_require__(92208), nodebackForPromise = __webpack_require__(41231), withAppended = util.withAppended, maybeWrapAsError = util.maybeWrapAsError, canEvaluate = util.canEvaluate, TypeError = __webpack_require__(90403).TypeError, defaultPromisified = {
     __isPromisified__: !0
    }, noCopyPropsPattern = new RegExp("^(?:" + [ "arity", "length", "name", "arguments", "caller", "callee", "prototype", "__isPromisified__" ].join("|") + ")$"), defaultFilter = function(name) {
     return util.isIdentifier(name) && "_" !== name.charAt(0) && "constructor" !== name;
    };
    function propsFilter(key) {
     return !noCopyPropsPattern.test(key);
    }
    function isPromisified(fn) {
     try {
      return !0 === fn.__isPromisified__;
     } catch (e) {
      return !1;
     }
    }
    function hasPromisified(obj, key, suffix) {
     var val = util.getDataPropertyOrDefault(obj, key + suffix, defaultPromisified);
     return !!val && isPromisified(val);
    }
    function promisifiableMethods(obj, suffix, suffixRegexp, filter) {
     for (var keys = util.inheritedDataKeys(obj), ret = [], i = 0; i < keys.length; ++i) {
      var key = keys[i], value = obj[key], passesDefaultFilter = filter === defaultFilter || defaultFilter(key);
      "function" != typeof value || isPromisified(value) || hasPromisified(obj, key, suffix) || !filter(key, value, obj, passesDefaultFilter) || ret.push(key, value);
     }
     return function(ret, suffix, suffixRegexp) {
      for (var i = 0; i < ret.length; i += 2) {
       var key = ret[i];
       if (suffixRegexp.test(key)) for (var keyWithoutAsyncSuffix = key.replace(suffixRegexp, ""), j = 0; j < ret.length; j += 2) if (ret[j] === keyWithoutAsyncSuffix) throw new TypeError("Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/MqrFmX\n".replace("%s", suffix));
      }
     }(ret, suffix, suffixRegexp), ret;
    }
    var makeNodePromisifiedEval;
    makeNodePromisifiedEval = function(callback, receiver, originalName, fn, _, multiArgs) {
     var newParameterCount = Math.max(0, function(fn) {
      return "number" == typeof fn.length ? Math.max(Math.min(fn.length, 1024), 0) : 0;
     }(fn) - 1), argumentOrder = function(likelyArgumentCount) {
      for (var ret = [ likelyArgumentCount ], min = Math.max(0, likelyArgumentCount - 1 - 3), i = likelyArgumentCount - 1; i >= min; --i) ret.push(i);
      for (i = likelyArgumentCount + 1; i <= 3; ++i) ret.push(i);
      return ret;
     }(newParameterCount), shouldProxyThis = "string" == typeof callback || receiver === THIS;
     function generateCallForArgumentCount(count) {
      var argumentCount, args = (argumentCount = count, util.filledRange(argumentCount, "_arg", "")).join(", "), comma = count > 0 ? ", " : "";
      return (shouldProxyThis ? "ret = callback.call(this, {{args}}, nodeback); break;\n" : void 0 === receiver ? "ret = callback({{args}}, nodeback); break;\n" : "ret = callback.call(receiver, {{args}}, nodeback); break;\n").replace("{{args}}", args).replace(", ", comma);
     }
     var getFunctionCode = "string" == typeof callback ? "this != null ? this['" + callback + "'] : fn" : "fn", body = "'use strict';                                                \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise, " + multiArgs + ");   \n            var ret;                                                         \n            var callback = tryCatch([GetFunctionCode]);                      \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n            }                                                                \n            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     \n            return promise;                                                  \n        };                                                                   \n        notEnumerableProp(ret, '__isPromisified__', true);                   \n        return ret;                                                          \n    ".replace("[CodeForSwitchCase]", function() {
      for (var ret = "", i = 0; i < argumentOrder.length; ++i) ret += "case " + argumentOrder[i] + ":" + generateCallForArgumentCount(argumentOrder[i]);
      return ret += "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        ".replace("[CodeForCall]", shouldProxyThis ? "ret = callback.apply(this, args);\n" : "ret = callback.apply(receiver, args);\n");
     }()).replace("[GetFunctionCode]", getFunctionCode);
     return body = body.replace("Parameters", function(parameterCount) {
      return util.filledRange(Math.max(parameterCount, 3), "_arg", "");
     }(newParameterCount)), new Function("Promise", "fn", "receiver", "withAppended", "maybeWrapAsError", "nodebackForPromise", "tryCatch", "errorObj", "notEnumerableProp", "INTERNAL", body)(Promise, fn, receiver, withAppended, maybeWrapAsError, nodebackForPromise, util.tryCatch, util.errorObj, util.notEnumerableProp, INTERNAL);
    };
    var makeNodePromisified = canEvaluate ? makeNodePromisifiedEval : function(callback, receiver, _, fn, __, multiArgs) {
     var defaultThis = function() {
      return this;
     }(), method = callback;
     function promisified() {
      var _receiver = receiver;
      receiver === THIS && (_receiver = this);
      var promise = new Promise(INTERNAL);
      promise._captureStackTrace();
      var cb = "string" == typeof method && this !== defaultThis ? this[method] : callback, fn = nodebackForPromise(promise, multiArgs);
      try {
       cb.apply(_receiver, withAppended(arguments, fn));
      } catch (e) {
       promise._rejectCallback(maybeWrapAsError(e), !0, !0);
      }
      return promise._isFateSealed() || promise._setAsyncGuaranteed(), promise;
     }
     return "string" == typeof method && (callback = fn), util.notEnumerableProp(promisified, "__isPromisified__", !0), 
     promisified;
    };
    function promisifyAll(obj, suffix, filter, promisifier, multiArgs) {
     for (var suffixRegexp = new RegExp(suffix.replace(/([$])/, "\\$") + "$"), methods = promisifiableMethods(obj, suffix, suffixRegexp, filter), i = 0, len = methods.length; i < len; i += 2) {
      var key = methods[i], fn = methods[i + 1], promisifiedKey = key + suffix;
      if (promisifier === makeNodePromisified) obj[promisifiedKey] = makeNodePromisified(key, THIS, key, fn, suffix, multiArgs); else {
       var promisified = promisifier(fn, (function() {
        return makeNodePromisified(key, THIS, key, fn, suffix, multiArgs);
       }));
       util.notEnumerableProp(promisified, "__isPromisified__", !0), obj[promisifiedKey] = promisified;
      }
     }
     return util.toFastProperties(obj), obj;
    }
    Promise.promisify = function(fn, options) {
     if ("function" != typeof fn) throw new TypeError("expecting a function but got " + util.classString(fn));
     if (isPromisified(fn)) return fn;
     var ret = function(callback, receiver, multiArgs) {
      return makeNodePromisified(callback, receiver, void 0, callback, null, multiArgs);
     }(fn, void 0 === (options = Object(options)).context ? THIS : options.context, !!options.multiArgs);
     return util.copyDescriptors(fn, ret, propsFilter), ret;
    }, Promise.promisifyAll = function(target, options) {
     if ("function" != typeof target && "object" != typeof target) throw new TypeError("the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/MqrFmX\n");
     var multiArgs = !!(options = Object(options)).multiArgs, suffix = options.suffix;
     "string" != typeof suffix && (suffix = "Async");
     var filter = options.filter;
     "function" != typeof filter && (filter = defaultFilter);
     var promisifier = options.promisifier;
     if ("function" != typeof promisifier && (promisifier = makeNodePromisified), !util.isIdentifier(suffix)) throw new RangeError("suffix must be a valid identifier\n\n    See http://goo.gl/MqrFmX\n");
     for (var keys = util.inheritedDataKeys(target), i = 0; i < keys.length; ++i) {
      var value = target[keys[i]];
      "constructor" !== keys[i] && util.isClass(value) && (promisifyAll(value.prototype, suffix, filter, promisifier, multiArgs), 
      promisifyAll(value, suffix, filter, promisifier, multiArgs));
     }
     return promisifyAll(target, suffix, filter, promisifier, multiArgs);
    };
   };
  },
  74416: (module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   module.exports = function(Promise, PromiseArray, tryConvertToPromise, apiRejection) {
    var Es6Map, util = __webpack_require__(92208), isObject = util.isObject, es5 = __webpack_require__(7585);
    "function" == typeof Map && (Es6Map = Map);
    var mapToEntries = function() {
     var index = 0, size = 0;
     function extractEntry(value, key) {
      this[index] = value, this[index + size] = key, index++;
     }
     return function(map) {
      size = map.size, index = 0;
      var ret = new Array(2 * map.size);
      return map.forEach(extractEntry, ret), ret;
     };
    }();
    function PropertiesPromiseArray(obj) {
     var entries, isMap = !1;
     if (void 0 !== Es6Map && obj instanceof Es6Map) entries = mapToEntries(obj), isMap = !0; else {
      var keys = es5.keys(obj), len = keys.length;
      entries = new Array(2 * len);
      for (var i = 0; i < len; ++i) {
       var key = keys[i];
       entries[i] = obj[key], entries[i + len] = key;
      }
     }
     this.constructor$(entries), this._isMap = isMap, this._init$(void 0, isMap ? -6 : -3);
    }
    function props(promises) {
     var ret, castValue = tryConvertToPromise(promises);
     return isObject(castValue) ? (ret = castValue instanceof Promise ? castValue._then(Promise.props, void 0, void 0, void 0, void 0) : new PropertiesPromiseArray(castValue).promise(), 
     castValue instanceof Promise && ret._propagateFrom(castValue, 2), ret) : apiRejection("cannot await properties of a non-object\n\n    See http://goo.gl/MqrFmX\n");
    }
    util.inherits(PropertiesPromiseArray, PromiseArray), PropertiesPromiseArray.prototype._init = function() {}, 
    PropertiesPromiseArray.prototype._promiseFulfilled = function(value, index) {
     if (this._values[index] = value, ++this._totalResolved >= this._length) {
      var val;
      if (this._isMap) val = function(entries) {
       for (var ret = new Es6Map, length = entries.length / 2 | 0, i = 0; i < length; ++i) {
        var key = entries[length + i], value = entries[i];
        ret.set(key, value);
       }
       return ret;
      }(this._values); else {
       val = {};
       for (var keyOffset = this.length(), i = 0, len = this.length(); i < len; ++i) val[this._values[i + keyOffset]] = this._values[i];
      }
      return this._resolve(val), !0;
     }
     return !1;
    }, PropertiesPromiseArray.prototype.shouldCopyValues = function() {
     return !1;
    }, PropertiesPromiseArray.prototype.getActualLength = function(len) {
     return len >> 1;
    }, Promise.prototype.props = function() {
     return props(this);
    }, Promise.props = function(promises) {
     return props(promises);
    };
   };
  },
  49937: module => {
   "use strict";
   function Queue(capacity) {
    this._capacity = capacity, this._length = 0, this._front = 0;
   }
   Queue.prototype._willBeOverCapacity = function(size) {
    return this._capacity < size;
   }, Queue.prototype._pushOne = function(arg) {
    var length = this.length();
    this._checkCapacity(length + 1), this[this._front + length & this._capacity - 1] = arg, 
    this._length = length + 1;
   }, Queue.prototype.push = function(fn, receiver, arg) {
    var length = this.length() + 3;
    if (this._willBeOverCapacity(length)) return this._pushOne(fn), this._pushOne(receiver), 
    void this._pushOne(arg);
    var j = this._front + length - 3;
    this._checkCapacity(length);
    var wrapMask = this._capacity - 1;
    this[j + 0 & wrapMask] = fn, this[j + 1 & wrapMask] = receiver, this[j + 2 & wrapMask] = arg, 
    this._length = length;
   }, Queue.prototype.shift = function() {
    var front = this._front, ret = this[front];
    return this[front] = void 0, this._front = front + 1 & this._capacity - 1, this._length--, 
    ret;
   }, Queue.prototype.length = function() {
    return this._length;
   }, Queue.prototype._checkCapacity = function(size) {
    this._capacity < size && this._resizeTo(this._capacity << 1);
   }, Queue.prototype._resizeTo = function(capacity) {
    var oldCapacity = this._capacity;
    this._capacity = capacity, function(src, srcIndex, dst, dstIndex, len) {
     for (var j = 0; j < len; ++j) dst[j + dstIndex] = src[j + srcIndex], src[j + srcIndex] = void 0;
    }(this, 0, this, oldCapacity, this._front + this._length & oldCapacity - 1);
   }, module.exports = Queue;
  },
  33381: (module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   module.exports = function(Promise, INTERNAL, tryConvertToPromise, apiRejection) {
    var util = __webpack_require__(92208);
    function race(promises, parent) {
     var promise, maybePromise = tryConvertToPromise(promises);
     if (maybePromise instanceof Promise) return (promise = maybePromise).then((function(array) {
      return race(array, promise);
     }));
     if (null === (promises = util.asArray(promises))) return apiRejection("expecting an array or an iterable object but got " + util.classString(promises));
     var ret = new Promise(INTERNAL);
     void 0 !== parent && ret._propagateFrom(parent, 3);
     for (var fulfill = ret._fulfill, reject = ret._reject, i = 0, len = promises.length; i < len; ++i) {
      var val = promises[i];
      (void 0 !== val || i in promises) && Promise.cast(val)._then(fulfill, reject, void 0, ret, null);
     }
     return ret;
    }
    Promise.race = function(promises) {
     return race(promises, void 0);
    }, Promise.prototype.race = function() {
     return race(this, void 0);
    };
   };
  },
  68722: (module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   module.exports = function(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug) {
    var util = __webpack_require__(92208), tryCatch = util.tryCatch;
    function ReductionPromiseArray(promises, fn, initialValue, _each) {
     this.constructor$(promises);
     var context = Promise._getContext();
     this._fn = util.contextBind(context, fn), void 0 !== initialValue && (initialValue = Promise.resolve(initialValue))._attachCancellationCallback(this), 
     this._initialValue = initialValue, this._currentCancellable = null, this._eachValues = _each === INTERNAL ? Array(this._length) : 0 === _each ? null : void 0, 
     this._promise._captureStackTrace(), this._init$(void 0, -5);
    }
    function completed(valueOrReason, array) {
     this.isFulfilled() ? array._resolve(valueOrReason) : array._reject(valueOrReason);
    }
    function reduce(promises, fn, initialValue, _each) {
     return "function" != typeof fn ? apiRejection("expecting a function but got " + util.classString(fn)) : new ReductionPromiseArray(promises, fn, initialValue, _each).promise();
    }
    function gotAccum(accum) {
     this.accum = accum, this.array._gotAccum(accum);
     var value = tryConvertToPromise(this.value, this.array._promise);
     return value instanceof Promise ? (this.array._currentCancellable = value, value._then(gotValue, void 0, void 0, this, void 0)) : gotValue.call(this, value);
    }
    function gotValue(value) {
     var ret, array = this.array, promise = array._promise, fn = tryCatch(array._fn);
     promise._pushContext(), (ret = void 0 !== array._eachValues ? fn.call(promise._boundValue(), value, this.index, this.length) : fn.call(promise._boundValue(), this.accum, value, this.index, this.length)) instanceof Promise && (array._currentCancellable = ret);
     var promiseCreated = promise._popContext();
     return debug.checkForgottenReturns(ret, promiseCreated, void 0 !== array._eachValues ? "Promise.each" : "Promise.reduce", promise), 
     ret;
    }
    util.inherits(ReductionPromiseArray, PromiseArray), ReductionPromiseArray.prototype._gotAccum = function(accum) {
     void 0 !== this._eachValues && null !== this._eachValues && accum !== INTERNAL && this._eachValues.push(accum);
    }, ReductionPromiseArray.prototype._eachComplete = function(value) {
     return null !== this._eachValues && this._eachValues.push(value), this._eachValues;
    }, ReductionPromiseArray.prototype._init = function() {}, ReductionPromiseArray.prototype._resolveEmptyArray = function() {
     this._resolve(void 0 !== this._eachValues ? this._eachValues : this._initialValue);
    }, ReductionPromiseArray.prototype.shouldCopyValues = function() {
     return !1;
    }, ReductionPromiseArray.prototype._resolve = function(value) {
     this._promise._resolveCallback(value), this._values = null;
    }, ReductionPromiseArray.prototype._resultCancelled = function(sender) {
     if (sender === this._initialValue) return this._cancel();
     this._isResolved() || (this._resultCancelled$(), this._currentCancellable instanceof Promise && this._currentCancellable.cancel(), 
     this._initialValue instanceof Promise && this._initialValue.cancel());
    }, ReductionPromiseArray.prototype._iterate = function(values) {
     var value, i;
     this._values = values;
     var length = values.length;
     void 0 !== this._initialValue ? (value = this._initialValue, i = 0) : (value = Promise.resolve(values[0]), 
     i = 1), this._currentCancellable = value;
     for (var j = i; j < length; ++j) {
      var maybePromise = values[j];
      maybePromise instanceof Promise && maybePromise.suppressUnhandledRejections();
     }
     if (!value.isRejected()) for (;i < length; ++i) {
      var ctx = {
       accum: null,
       value: values[i],
       index: i,
       length,
       array: this
      };
      value = value._then(gotAccum, void 0, void 0, ctx, void 0), 127 & i || value._setNoAsyncGuarantee();
     }
     void 0 !== this._eachValues && (value = value._then(this._eachComplete, void 0, void 0, this, void 0)), 
     value._then(completed, completed, void 0, value, this);
    }, Promise.prototype.reduce = function(fn, initialValue) {
     return reduce(this, fn, initialValue, null);
    }, Promise.reduce = function(promises, fn, initialValue, _each) {
     return reduce(promises, fn, initialValue, _each);
    };
   };
  },
  71065: (module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   var schedule, util = __webpack_require__(92208), NativePromise = util.getNativePromise();
   if (util.isNode && "undefined" == typeof MutationObserver) {
    var GlobalSetImmediate = global.setImmediate, ProcessNextTick = process.nextTick;
    schedule = util.isRecentNode ? function(fn) {
     GlobalSetImmediate.call(global, fn);
    } : function(fn) {
     ProcessNextTick.call(process, fn);
    };
   } else if ("function" == typeof NativePromise && "function" == typeof NativePromise.resolve) {
    var nativePromise = NativePromise.resolve();
    schedule = function(fn) {
     nativePromise.then(fn);
    };
   } else schedule = "undefined" == typeof MutationObserver || "undefined" != typeof window && window.navigator && (window.navigator.standalone || window.cordova) || !("classList" in document.documentElement) ? "undefined" != typeof setImmediate ? function(fn) {
    setImmediate(fn);
   } : "undefined" != typeof setTimeout ? function(fn) {
    setTimeout(fn, 0);
   } : function() {
    throw new Error("No async scheduler available\n\n    See http://goo.gl/MqrFmX\n");
   } : function() {
    var div = document.createElement("div"), opts = {
     attributes: !0
    }, toggleScheduled = !1, div2 = document.createElement("div");
    new MutationObserver((function() {
     div.classList.toggle("foo"), toggleScheduled = !1;
    })).observe(div2, opts);
    return function(fn) {
     var o = new MutationObserver((function() {
      o.disconnect(), fn();
     }));
     o.observe(div, opts), toggleScheduled || (toggleScheduled = !0, div2.classList.toggle("foo"));
    };
   }();
   module.exports = schedule;
  },
  59047: (module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   module.exports = function(Promise, PromiseArray, debug) {
    var PromiseInspection = Promise.PromiseInspection;
    function SettledPromiseArray(values) {
     this.constructor$(values);
    }
    __webpack_require__(92208).inherits(SettledPromiseArray, PromiseArray), SettledPromiseArray.prototype._promiseResolved = function(index, inspection) {
     return this._values[index] = inspection, ++this._totalResolved >= this._length && (this._resolve(this._values), 
     !0);
    }, SettledPromiseArray.prototype._promiseFulfilled = function(value, index) {
     var ret = new PromiseInspection;
     return ret._bitField = 33554432, ret._settledValueField = value, this._promiseResolved(index, ret);
    }, SettledPromiseArray.prototype._promiseRejected = function(reason, index) {
     var ret = new PromiseInspection;
     return ret._bitField = 16777216, ret._settledValueField = reason, this._promiseResolved(index, ret);
    }, Promise.settle = function(promises) {
     return debug.deprecated(".settle()", ".reflect()"), new SettledPromiseArray(promises).promise();
    }, Promise.allSettled = function(promises) {
     return new SettledPromiseArray(promises).promise();
    }, Promise.prototype.settle = function() {
     return Promise.settle(this);
    };
   };
  },
  47784: (module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   module.exports = function(Promise, PromiseArray, apiRejection) {
    var util = __webpack_require__(92208), RangeError = __webpack_require__(90403).RangeError, AggregateError = __webpack_require__(90403).AggregateError, isArray = util.isArray, CANCELLATION = {};
    function SomePromiseArray(values) {
     this.constructor$(values), this._howMany = 0, this._unwrap = !1, this._initialized = !1;
    }
    function some(promises, howMany) {
     if ((0 | howMany) !== howMany || howMany < 0) return apiRejection("expecting a positive integer\n\n    See http://goo.gl/MqrFmX\n");
     var ret = new SomePromiseArray(promises), promise = ret.promise();
     return ret.setHowMany(howMany), ret.init(), promise;
    }
    util.inherits(SomePromiseArray, PromiseArray), SomePromiseArray.prototype._init = function() {
     if (this._initialized) if (0 !== this._howMany) {
      this._init$(void 0, -5);
      var isArrayResolved = isArray(this._values);
      !this._isResolved() && isArrayResolved && this._howMany > this._canPossiblyFulfill() && this._reject(this._getRangeError(this.length()));
     } else this._resolve([]);
    }, SomePromiseArray.prototype.init = function() {
     this._initialized = !0, this._init();
    }, SomePromiseArray.prototype.setUnwrap = function() {
     this._unwrap = !0;
    }, SomePromiseArray.prototype.howMany = function() {
     return this._howMany;
    }, SomePromiseArray.prototype.setHowMany = function(count) {
     this._howMany = count;
    }, SomePromiseArray.prototype._promiseFulfilled = function(value) {
     return this._addFulfilled(value), this._fulfilled() === this.howMany() && (this._values.length = this.howMany(), 
     1 === this.howMany() && this._unwrap ? this._resolve(this._values[0]) : this._resolve(this._values), 
     !0);
    }, SomePromiseArray.prototype._promiseRejected = function(reason) {
     return this._addRejected(reason), this._checkOutcome();
    }, SomePromiseArray.prototype._promiseCancelled = function() {
     return this._values instanceof Promise || null == this._values ? this._cancel() : (this._addRejected(CANCELLATION), 
     this._checkOutcome());
    }, SomePromiseArray.prototype._checkOutcome = function() {
     if (this.howMany() > this._canPossiblyFulfill()) {
      for (var e = new AggregateError, i = this.length(); i < this._values.length; ++i) this._values[i] !== CANCELLATION && e.push(this._values[i]);
      return e.length > 0 ? this._reject(e) : this._cancel(), !0;
     }
     return !1;
    }, SomePromiseArray.prototype._fulfilled = function() {
     return this._totalResolved;
    }, SomePromiseArray.prototype._rejected = function() {
     return this._values.length - this.length();
    }, SomePromiseArray.prototype._addRejected = function(reason) {
     this._values.push(reason);
    }, SomePromiseArray.prototype._addFulfilled = function(value) {
     this._values[this._totalResolved++] = value;
    }, SomePromiseArray.prototype._canPossiblyFulfill = function() {
     return this.length() - this._rejected();
    }, SomePromiseArray.prototype._getRangeError = function(count) {
     var message = "Input array must contain at least " + this._howMany + " items but contains only " + count + " items";
     return new RangeError(message);
    }, SomePromiseArray.prototype._resolveEmptyArray = function() {
     this._reject(this._getRangeError(0));
    }, Promise.some = function(promises, howMany) {
     return some(promises, howMany);
    }, Promise.prototype.some = function(howMany) {
     return some(this, howMany);
    }, Promise._SomePromiseArray = SomePromiseArray;
   };
  },
  34900: module => {
   "use strict";
   module.exports = function(Promise) {
    function PromiseInspection(promise) {
     void 0 !== promise ? (promise = promise._target(), this._bitField = promise._bitField, 
     this._settledValueField = promise._isFateSealed() ? promise._settledValue() : void 0) : (this._bitField = 0, 
     this._settledValueField = void 0);
    }
    PromiseInspection.prototype._settledValue = function() {
     return this._settledValueField;
    };
    var value = PromiseInspection.prototype.value = function() {
     if (!this.isFulfilled()) throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/MqrFmX\n");
     return this._settledValue();
    }, reason = PromiseInspection.prototype.error = PromiseInspection.prototype.reason = function() {
     if (!this.isRejected()) throw new TypeError("cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/MqrFmX\n");
     return this._settledValue();
    }, isFulfilled = PromiseInspection.prototype.isFulfilled = function() {
     return !!(33554432 & this._bitField);
    }, isRejected = PromiseInspection.prototype.isRejected = function() {
     return !!(16777216 & this._bitField);
    }, isPending = PromiseInspection.prototype.isPending = function() {
     return !(50397184 & this._bitField);
    }, isResolved = PromiseInspection.prototype.isResolved = function() {
     return !!(50331648 & this._bitField);
    };
    PromiseInspection.prototype.isCancelled = function() {
     return !!(8454144 & this._bitField);
    }, Promise.prototype.__isCancelled = function() {
     return !(65536 & ~this._bitField);
    }, Promise.prototype._isCancelled = function() {
     return this._target().__isCancelled();
    }, Promise.prototype.isCancelled = function() {
     return !!(8454144 & this._target()._bitField);
    }, Promise.prototype.isPending = function() {
     return isPending.call(this._target());
    }, Promise.prototype.isRejected = function() {
     return isRejected.call(this._target());
    }, Promise.prototype.isFulfilled = function() {
     return isFulfilled.call(this._target());
    }, Promise.prototype.isResolved = function() {
     return isResolved.call(this._target());
    }, Promise.prototype.value = function() {
     return value.call(this._target());
    }, Promise.prototype.reason = function() {
     var target = this._target();
     return target._unsetRejectionIsUnhandled(), reason.call(target);
    }, Promise.prototype._value = function() {
     return this._settledValue();
    }, Promise.prototype._reason = function() {
     return this._unsetRejectionIsUnhandled(), this._settledValue();
    }, Promise.PromiseInspection = PromiseInspection;
   };
  },
  78974: (module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   module.exports = function(Promise, INTERNAL) {
    var util = __webpack_require__(92208), errorObj = util.errorObj, isObject = util.isObject;
    var hasProp = {}.hasOwnProperty;
    return function(obj, context) {
     if (isObject(obj)) {
      if (obj instanceof Promise) return obj;
      var then = function(obj) {
       try {
        return function(obj) {
         return obj.then;
        }(obj);
       } catch (e) {
        return errorObj.e = e, errorObj;
       }
      }(obj);
      if (then === errorObj) {
       context && context._pushContext();
       var ret = Promise.reject(then.e);
       return context && context._popContext(), ret;
      }
      if ("function" == typeof then) {
       if (function(obj) {
        try {
         return hasProp.call(obj, "_promise0");
        } catch (e) {
         return !1;
        }
       }(obj)) {
        ret = new Promise(INTERNAL);
        return obj._then(ret._fulfill, ret._reject, void 0, ret, null), ret;
       }
       return function(x, then, context) {
        var promise = new Promise(INTERNAL), ret = promise;
        context && context._pushContext();
        promise._captureStackTrace(), context && context._popContext();
        var synchronous = !0, result = util.tryCatch(then).call(x, resolve, reject);
        synchronous = !1, promise && result === errorObj && (promise._rejectCallback(result.e, !0, !0), 
        promise = null);
        function resolve(value) {
         promise && (promise._resolveCallback(value), promise = null);
        }
        function reject(reason) {
         promise && (promise._rejectCallback(reason, synchronous, !0), promise = null);
        }
        return ret;
       }(obj, then, context);
      }
     }
     return obj;
    };
   };
  },
  76406: (module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   module.exports = function(Promise, INTERNAL, debug) {
    var util = __webpack_require__(92208), TimeoutError = Promise.TimeoutError;
    function HandleWrapper(handle) {
     this.handle = handle;
    }
    HandleWrapper.prototype._resultCancelled = function() {
     clearTimeout(this.handle);
    };
    var afterValue = function(value) {
     return delay(+this).thenReturn(value);
    }, delay = Promise.delay = function(ms, value) {
     var ret, handle;
     return void 0 !== value ? (ret = Promise.resolve(value)._then(afterValue, null, null, ms, void 0), 
     debug.cancellation() && value instanceof Promise && ret._setOnCancel(value)) : (ret = new Promise(INTERNAL), 
     handle = setTimeout((function() {
      ret._fulfill();
     }), +ms), debug.cancellation() && ret._setOnCancel(new HandleWrapper(handle)), ret._captureStackTrace()), 
     ret._setAsyncGuaranteed(), ret;
    };
    Promise.prototype.delay = function(ms) {
     return delay(ms, this);
    };
    function successClear(value) {
     return clearTimeout(this.handle), value;
    }
    function failureClear(reason) {
     throw clearTimeout(this.handle), reason;
    }
    Promise.prototype.timeout = function(ms, message) {
     var ret, parent;
     ms = +ms;
     var handleWrapper = new HandleWrapper(setTimeout((function() {
      ret.isPending() && function(promise, message, parent) {
       var err;
       err = "string" != typeof message ? message instanceof Error ? message : new TimeoutError("operation timed out") : new TimeoutError(message), 
       util.markAsOriginatingFromRejection(err), promise._attachExtraTrace(err), promise._reject(err), 
       null != parent && parent.cancel();
      }(ret, message, parent);
     }), ms));
     return debug.cancellation() ? (parent = this.then(), (ret = parent._then(successClear, failureClear, void 0, handleWrapper, void 0))._setOnCancel(handleWrapper)) : ret = this._then(successClear, failureClear, void 0, handleWrapper, void 0), 
     ret;
    };
   };
  },
  46178: (module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   module.exports = function(Promise, apiRejection, tryConvertToPromise, createContext, INTERNAL, debug) {
    var util = __webpack_require__(92208), TypeError = __webpack_require__(90403).TypeError, inherits = __webpack_require__(92208).inherits, errorObj = util.errorObj, tryCatch = util.tryCatch, NULL = {};
    function thrower(e) {
     setTimeout((function() {
      throw e;
     }), 0);
    }
    function dispose(resources, inspection) {
     var i = 0, len = resources.length, ret = new Promise(INTERNAL);
     return function iterator() {
      if (i >= len) return ret._fulfill();
      var maybePromise = function(thenable) {
       var maybePromise = tryConvertToPromise(thenable);
       return maybePromise !== thenable && "function" == typeof thenable._isDisposable && "function" == typeof thenable._getDisposer && thenable._isDisposable() && maybePromise._setDisposable(thenable._getDisposer()), 
       maybePromise;
      }(resources[i++]);
      if (maybePromise instanceof Promise && maybePromise._isDisposable()) {
       try {
        maybePromise = tryConvertToPromise(maybePromise._getDisposer().tryDispose(inspection), resources.promise);
       } catch (e) {
        return thrower(e);
       }
       if (maybePromise instanceof Promise) return maybePromise._then(iterator, thrower, null, null, null);
      }
      iterator();
     }(), ret;
    }
    function Disposer(data, promise, context) {
     this._data = data, this._promise = promise, this._context = context;
    }
    function FunctionDisposer(fn, promise, context) {
     this.constructor$(fn, promise, context);
    }
    function maybeUnwrapDisposer(value) {
     return Disposer.isDisposer(value) ? (this.resources[this.index]._setDisposable(value), 
     value.promise()) : value;
    }
    function ResourceList(length) {
     this.length = length, this.promise = null, this[length - 1] = null;
    }
    Disposer.prototype.data = function() {
     return this._data;
    }, Disposer.prototype.promise = function() {
     return this._promise;
    }, Disposer.prototype.resource = function() {
     return this.promise().isFulfilled() ? this.promise().value() : NULL;
    }, Disposer.prototype.tryDispose = function(inspection) {
     var resource = this.resource(), context = this._context;
     void 0 !== context && context._pushContext();
     var ret = resource !== NULL ? this.doDispose(resource, inspection) : null;
     return void 0 !== context && context._popContext(), this._promise._unsetDisposable(), 
     this._data = null, ret;
    }, Disposer.isDisposer = function(d) {
     return null != d && "function" == typeof d.resource && "function" == typeof d.tryDispose;
    }, inherits(FunctionDisposer, Disposer), FunctionDisposer.prototype.doDispose = function(resource, inspection) {
     return this.data().call(resource, resource, inspection);
    }, ResourceList.prototype._resultCancelled = function() {
     for (var len = this.length, i = 0; i < len; ++i) {
      var item = this[i];
      item instanceof Promise && item.cancel();
     }
    }, Promise.using = function() {
     var len = arguments.length;
     if (len < 2) return apiRejection("you must pass at least 2 arguments to Promise.using");
     var input, fn = arguments[len - 1];
     if ("function" != typeof fn) return apiRejection("expecting a function but got " + util.classString(fn));
     var spreadArgs = !0;
     2 === len && Array.isArray(arguments[0]) ? (len = (input = arguments[0]).length, 
     spreadArgs = !1) : (input = arguments, len--);
     for (var resources = new ResourceList(len), i = 0; i < len; ++i) {
      var resource = input[i];
      if (Disposer.isDisposer(resource)) {
       var disposer = resource;
       (resource = resource.promise())._setDisposable(disposer);
      } else {
       var maybePromise = tryConvertToPromise(resource);
       maybePromise instanceof Promise && (resource = maybePromise._then(maybeUnwrapDisposer, null, null, {
        resources,
        index: i
       }, void 0));
      }
      resources[i] = resource;
     }
     var reflectedResources = new Array(resources.length);
     for (i = 0; i < reflectedResources.length; ++i) reflectedResources[i] = Promise.resolve(resources[i]).reflect();
     var resultPromise = Promise.all(reflectedResources).then((function(inspections) {
      for (var i = 0; i < inspections.length; ++i) {
       var inspection = inspections[i];
       if (inspection.isRejected()) return errorObj.e = inspection.error(), errorObj;
       if (!inspection.isFulfilled()) return void resultPromise.cancel();
       inspections[i] = inspection.value();
      }
      promise._pushContext(), fn = tryCatch(fn);
      var ret = spreadArgs ? fn.apply(void 0, inspections) : fn(inspections), promiseCreated = promise._popContext();
      return debug.checkForgottenReturns(ret, promiseCreated, "Promise.using", promise), 
      ret;
     })), promise = resultPromise.lastly((function() {
      var inspection = new Promise.PromiseInspection(resultPromise);
      return dispose(resources, inspection);
     }));
     return resources.promise = promise, promise._setOnCancel(resources), promise;
    }, Promise.prototype._setDisposable = function(disposer) {
     this._bitField = 131072 | this._bitField, this._disposer = disposer;
    }, Promise.prototype._isDisposable = function() {
     return (131072 & this._bitField) > 0;
    }, Promise.prototype._getDisposer = function() {
     return this._disposer;
    }, Promise.prototype._unsetDisposable = function() {
     this._bitField = -131073 & this._bitField, this._disposer = void 0;
    }, Promise.prototype.disposer = function(fn) {
     if ("function" == typeof fn) return new FunctionDisposer(fn, this, createContext());
     throw new TypeError;
    };
   };
  },
  92208: function(module, __unused_webpack_exports, __webpack_require__) {
   "use strict";
   var es5 = __webpack_require__(7585), canEvaluate = "undefined" == typeof navigator, errorObj = {
    e: {}
   }, tryCatchTarget, globalObject = "undefined" != typeof self ? self : "undefined" != typeof window ? window : "undefined" != typeof global ? global : void 0 !== this ? this : null;
   function tryCatcher() {
    try {
     var target = tryCatchTarget;
     return tryCatchTarget = null, target.apply(this, arguments);
    } catch (e) {
     return errorObj.e = e, errorObj;
    }
   }
   function tryCatch(fn) {
    return tryCatchTarget = fn, tryCatcher;
   }
   var inherits = function(Child, Parent) {
    var hasProp = {}.hasOwnProperty;
    function T() {
     for (var propertyName in this.constructor = Child, this.constructor$ = Parent, Parent.prototype) hasProp.call(Parent.prototype, propertyName) && "$" !== propertyName.charAt(propertyName.length - 1) && (this[propertyName + "$"] = Parent.prototype[propertyName]);
    }
    return T.prototype = Parent.prototype, Child.prototype = new T, Child.prototype;
   };
   function isPrimitive(val) {
    return null == val || !0 === val || !1 === val || "string" == typeof val || "number" == typeof val;
   }
   function isObject(value) {
    return "function" == typeof value || "object" == typeof value && null !== value;
   }
   function maybeWrapAsError(maybeError) {
    return isPrimitive(maybeError) ? new Error(safeToString(maybeError)) : maybeError;
   }
   function withAppended(target, appendee) {
    var i, len = target.length, ret = new Array(len + 1);
    for (i = 0; i < len; ++i) ret[i] = target[i];
    return ret[i] = appendee, ret;
   }
   function getDataPropertyOrDefault(obj, key, defaultValue) {
    if (!es5.isES5) return {}.hasOwnProperty.call(obj, key) ? obj[key] : void 0;
    var desc = Object.getOwnPropertyDescriptor(obj, key);
    return null != desc ? null == desc.get && null == desc.set ? desc.value : defaultValue : void 0;
   }
   function notEnumerableProp(obj, name, value) {
    if (isPrimitive(obj)) return obj;
    var descriptor = {
     value,
     configurable: !0,
     enumerable: !1,
     writable: !0
    };
    return es5.defineProperty(obj, name, descriptor), obj;
   }
   function thrower(r) {
    throw r;
   }
   var inheritedDataKeys = function() {
    var excludedPrototypes = [ Array.prototype, Object.prototype, Function.prototype ], isExcludedProto = function(val) {
     for (var i = 0; i < excludedPrototypes.length; ++i) if (excludedPrototypes[i] === val) return !0;
     return !1;
    };
    if (es5.isES5) {
     var getKeys = Object.getOwnPropertyNames;
     return function(obj) {
      for (var ret = [], visitedKeys = Object.create(null); null != obj && !isExcludedProto(obj); ) {
       var keys;
       try {
        keys = getKeys(obj);
       } catch (e) {
        return ret;
       }
       for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        if (!visitedKeys[key]) {
         visitedKeys[key] = !0;
         var desc = Object.getOwnPropertyDescriptor(obj, key);
         null != desc && null == desc.get && null == desc.set && ret.push(key);
        }
       }
       obj = es5.getPrototypeOf(obj);
      }
      return ret;
     };
    }
    var hasProp = {}.hasOwnProperty;
    return function(obj) {
     if (isExcludedProto(obj)) return [];
     var ret = [];
     enumeration: for (var key in obj) if (hasProp.call(obj, key)) ret.push(key); else {
      for (var i = 0; i < excludedPrototypes.length; ++i) if (hasProp.call(excludedPrototypes[i], key)) continue enumeration;
      ret.push(key);
     }
     return ret;
    };
   }(), thisAssignmentPattern = /this\s*\.\s*\S+\s*=/;
   function isClass(fn) {
    try {
     if ("function" == typeof fn) {
      var keys = es5.names(fn.prototype), hasMethods = es5.isES5 && keys.length > 1, hasMethodsOtherThanConstructor = keys.length > 0 && !(1 === keys.length && "constructor" === keys[0]), hasThisAssignmentAndStaticMethods = thisAssignmentPattern.test(fn + "") && es5.names(fn).length > 0;
      if (hasMethods || hasMethodsOtherThanConstructor || hasThisAssignmentAndStaticMethods) return !0;
     }
     return !1;
    } catch (e) {
     return !1;
    }
   }
   function toFastProperties(obj) {
    function FakeConstructor() {}
    FakeConstructor.prototype = obj;
    var receiver = new FakeConstructor;
    function ic() {
     return typeof receiver.foo;
    }
    return ic(), ic(), obj;
   }
   var rident = /^[a-z$_][a-z$_0-9]*$/i;
   function isIdentifier(str) {
    return rident.test(str);
   }
   function filledRange(count, prefix, suffix) {
    for (var ret = new Array(count), i = 0; i < count; ++i) ret[i] = prefix + i + suffix;
    return ret;
   }
   function safeToString(obj) {
    try {
     return obj + "";
    } catch (e) {
     return "[no string representation]";
    }
   }
   function isError(obj) {
    return obj instanceof Error || null !== obj && "object" == typeof obj && "string" == typeof obj.message && "string" == typeof obj.name;
   }
   function markAsOriginatingFromRejection(e) {
    try {
     notEnumerableProp(e, "isOperational", !0);
    } catch (ignore) {}
   }
   function originatesFromRejection(e) {
    return null != e && (e instanceof Error.__BluebirdErrorTypes__.OperationalError || !0 === e.isOperational);
   }
   function canAttachTrace(obj) {
    return isError(obj) && es5.propertyIsWritable(obj, "stack");
   }
   var ensureErrorObject = "stack" in new Error ? function(value) {
    return canAttachTrace(value) ? value : new Error(safeToString(value));
   } : function(value) {
    if (canAttachTrace(value)) return value;
    try {
     throw new Error(safeToString(value));
    } catch (err) {
     return err;
    }
   };
   function classString(obj) {
    return {}.toString.call(obj);
   }
   function copyDescriptors(from, to, filter) {
    for (var keys = es5.names(from), i = 0; i < keys.length; ++i) {
     var key = keys[i];
     if (filter(key)) try {
      es5.defineProperty(to, key, es5.getDescriptor(from, key));
     } catch (ignore) {}
    }
   }
   var asArray = function(v) {
    return es5.isArray(v) ? v : null;
   };
   if ("undefined" != typeof Symbol && Symbol.iterator) {
    var ArrayFrom = "function" == typeof Array.from ? function(v) {
     return Array.from(v);
    } : function(v) {
     for (var itResult, ret = [], it = v[Symbol.iterator](); !(itResult = it.next()).done; ) ret.push(itResult.value);
     return ret;
    };
    asArray = function(v) {
     return es5.isArray(v) ? v : null != v && "function" == typeof v[Symbol.iterator] ? ArrayFrom(v) : null;
    };
   }
   var isNode = "undefined" != typeof process && "[object process]" === classString(process).toLowerCase(), hasEnvVariables = "undefined" != typeof process && void 0 !== process.env, reflectHandler;
   function env(key) {
    return hasEnvVariables ? process.env[key] : void 0;
   }
   function getNativePromise() {
    if ("function" == typeof Promise) try {
     if ("[object Promise]" === classString(new Promise((function() {})))) return Promise;
    } catch (e) {}
   }
   function contextBind(ctx, cb) {
    if (null === ctx || "function" != typeof cb || cb === reflectHandler) return cb;
    null !== ctx.domain && (cb = ctx.domain.bind(cb));
    var async = ctx.async;
    if (null !== async) {
     var old = cb;
     cb = function() {
      for (var $_len = arguments.length + 2, args = new Array($_len), $_i = 2; $_i < $_len; ++$_i) args[$_i] = arguments[$_i - 2];
      return args[0] = old, args[1] = this, async.runInAsyncScope.apply(async, args);
     };
    }
    return cb;
   }
   var ret = {
    setReflectHandler: function(fn) {
     reflectHandler = fn;
    },
    isClass,
    isIdentifier,
    inheritedDataKeys,
    getDataPropertyOrDefault,
    thrower,
    isArray: es5.isArray,
    asArray,
    notEnumerableProp,
    isPrimitive,
    isObject,
    isError,
    canEvaluate,
    errorObj,
    tryCatch,
    inherits,
    withAppended,
    maybeWrapAsError,
    toFastProperties,
    filledRange,
    toString: safeToString,
    canAttachTrace,
    ensureErrorObject,
    originatesFromRejection,
    markAsOriginatingFromRejection,
    classString,
    copyDescriptors,
    isNode,
    hasEnvVariables,
    env,
    global: globalObject,
    getNativePromise,
    contextBind
   }, version;
   ret.isRecentNode = ret.isNode && (process.versions && process.versions.node ? version = process.versions.node.split(".").map(Number) : process.version && (version = process.version.split(".").map(Number)), 
   0 === version[0] && version[1] > 10 || version[0] > 0), ret.nodeSupportsAsyncResource = ret.isNode && function() {
    var supportsAsync = !1;
    try {
     supportsAsync = "function" == typeof __webpack_require__(90290).AsyncResource.prototype.runInAsyncScope;
    } catch (e) {
     supportsAsync = !1;
    }
    return supportsAsync;
   }(), ret.isNode && ret.toFastProperties(process);
   try {
    throw new Error;
   } catch (e) {
    ret.lastLineError = e;
   }
   module.exports = ret;
  },
  35906: (__unused_webpack_module, exports) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   });
   exports.METADATA_KEY = {
    provide: "inversify-binding-decorators:provide"
   };
  },
  10941: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   });
   var provide_in_when_on_syntax_1 = __webpack_require__(64147), provide_when_syntax_1 = __webpack_require__(26175), provide_on_syntax_1 = __webpack_require__(72472), provide_in_syntax_1 = __webpack_require__(71902), provide_done_syntax_1 = __webpack_require__(41151);
   exports.default = function(serviceIdentifier) {
    var bindingWhenOnSyntax = function(bind, target) {
     return bind(serviceIdentifier).to(target);
    }, provideDoneSyntax = new provide_done_syntax_1.default((function(bind, target) {
     return bindingWhenOnSyntax(bind, target)._binding;
    }));
    return new provide_in_when_on_syntax_1.default(new provide_in_syntax_1.default((function(bind, target) {
     return bindingWhenOnSyntax(bind, target);
    }), provideDoneSyntax), new provide_when_syntax_1.default(bindingWhenOnSyntax, provideDoneSyntax), new provide_on_syntax_1.default(bindingWhenOnSyntax, provideDoneSyntax));
   };
  },
  28044: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   });
   var inversify_1 = __webpack_require__(25891), constants_1 = __webpack_require__(35906);
   exports.default = function(serviceIdentifier, force) {
    return function(target) {
     var isAlreadyDecorated = Reflect.hasOwnMetadata(inversify_1.METADATA_KEY.PARAM_TYPES, target), redecorateWithInject = !0 === force;
     if (!0 === redecorateWithInject && !1 === isAlreadyDecorated) inversify_1.decorate(inversify_1.injectable(), target); else if (!0 === redecorateWithInject && !0 === isAlreadyDecorated) ; else try {
      inversify_1.decorate(inversify_1.injectable(), target);
     } catch (e) {
      throw new Error("Cannot apply @provide decorator multiple times but is has been used multiple times in " + target.name + " Please use @provide(ID, true) if you are trying to declare multiple bindings!");
     }
     var currentMetadata = {
      constraint: function(bind, bindTarget) {
       return bind(serviceIdentifier).to(bindTarget);
      },
      implementationType: target
     }, previousMetadata = Reflect.getMetadata(constants_1.METADATA_KEY.provide, Reflect) || [], newMetadata = [ currentMetadata ].concat(previousMetadata);
     return Reflect.defineMetadata(constants_1.METADATA_KEY.provide, newMetadata, Reflect), 
     target;
    };
   };
  },
  34069: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   });
   var constants_1 = __webpack_require__(35906), inversify_1 = __webpack_require__(25891);
   exports.default = function() {
    return new inversify_1.ContainerModule((function(bind, unbind) {
     (Reflect.getMetadata(constants_1.METADATA_KEY.provide, Reflect) || []).map((function(metadata) {
      return function(metadata, bind) {
       return metadata.constraint(bind, metadata.implementationType);
      }(metadata, bind);
     }));
    }));
   };
  },
  25567: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   });
   var auto_wire_1 = __webpack_require__(69080);
   exports.autoProvide = auto_wire_1.default;
   var provide_1 = __webpack_require__(28044);
   exports.provide = provide_1.default;
   var fluent_provide_1 = __webpack_require__(10941);
   exports.fluentProvide = fluent_provide_1.default;
   var module_factory_1 = __webpack_require__(34069);
   exports.buildProviderModule = module_factory_1.default;
  },
  41151: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   });
   var inversify_1 = __webpack_require__(25891), inversify_2 = __webpack_require__(25891), constants_1 = __webpack_require__(35906), ProvideDoneSyntax = function() {
    function ProvideDoneSyntax(binding) {
     this._binding = binding;
    }
    return ProvideDoneSyntax.prototype.done = function(force) {
     var that = this;
     return function(target) {
      var isAlreadyDecorated = Reflect.hasOwnMetadata(inversify_2.METADATA_KEY.PARAM_TYPES, target), redecorateWithInject = !0 === force;
      if (!0 === redecorateWithInject && !1 === isAlreadyDecorated) inversify_1.decorate(inversify_1.injectable(), target); else if (!0 === redecorateWithInject && !0 === isAlreadyDecorated) ; else try {
       inversify_1.decorate(inversify_1.injectable(), target);
      } catch (e) {
       throw new Error("Cannot apply @provideFluent decorator multiple times but is has been used multiple times in " + target.name + " Please use done(true) if you are trying to declare multiple bindings!");
      }
      var currentMetadata = {
       constraint: that._binding,
       implementationType: target
      }, previousMetadata = Reflect.getMetadata(constants_1.METADATA_KEY.provide, Reflect) || [], newMetadata = [ currentMetadata ].concat(previousMetadata);
      return Reflect.defineMetadata(constants_1.METADATA_KEY.provide, newMetadata, Reflect), 
      target;
     };
    }, ProvideDoneSyntax;
   }();
   exports.default = ProvideDoneSyntax;
  },
  71902: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   });
   var provide_when_on_syntax_1 = __webpack_require__(62303), provide_when_syntax_1 = __webpack_require__(26175), provide_on_syntax_1 = __webpack_require__(72472), provide_done_syntax_1 = __webpack_require__(41151), ProvideInSyntax = function() {
    function ProvideInSyntax(bindingInSyntax, provideDoneSyntax) {
     this._bindingInSyntax = bindingInSyntax, this._provideDoneSyntax = provideDoneSyntax;
    }
    return ProvideInSyntax.prototype.inSingletonScope = function() {
     var _this = this, bindingWhenOnSyntax = function(bind, target) {
      return _this._bindingInSyntax(bind, target).inSingletonScope();
     }, inDoneSyntax = new provide_done_syntax_1.default(bindingWhenOnSyntax), provideWhenSyntax = new provide_when_syntax_1.default(bindingWhenOnSyntax, inDoneSyntax), provideOnSyntax = new provide_on_syntax_1.default(bindingWhenOnSyntax, inDoneSyntax);
     return new provide_when_on_syntax_1.default(provideWhenSyntax, provideOnSyntax);
    }, ProvideInSyntax.prototype.inTransientScope = function() {
     var _this = this, bindingWhenOnSyntax = function(bind, target) {
      return _this._bindingInSyntax(bind, target).inTransientScope();
     }, inDoneSyntax = new provide_done_syntax_1.default(bindingWhenOnSyntax), provideWhenSyntax = new provide_when_syntax_1.default(bindingWhenOnSyntax, inDoneSyntax), provideOnSyntax = new provide_on_syntax_1.default(bindingWhenOnSyntax, inDoneSyntax);
     return new provide_when_on_syntax_1.default(provideWhenSyntax, provideOnSyntax);
    }, ProvideInSyntax.prototype.done = function(force) {
     return this._provideDoneSyntax.done(force);
    }, ProvideInSyntax;
   }();
   exports.default = ProvideInSyntax;
  },
  64147: (__unused_webpack_module, exports) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   });
   var ProvideInWhenOnSyntax = function() {
    function ProvideInWhenOnSyntax(provideInSyntax, provideWhenSyntax, provideOnSyntax) {
     this._provideInSyntax = provideInSyntax, this._provideWhenSyntax = provideWhenSyntax, 
     this._provideOnSyntax = provideOnSyntax;
    }
    return ProvideInWhenOnSyntax.prototype.when = function(constraint) {
     return this._provideWhenSyntax.when(constraint);
    }, ProvideInWhenOnSyntax.prototype.whenTargetNamed = function(name) {
     return this._provideWhenSyntax.whenTargetNamed(name);
    }, ProvideInWhenOnSyntax.prototype.whenTargetTagged = function(tag, value) {
     return this._provideWhenSyntax.whenTargetTagged(tag, value);
    }, ProvideInWhenOnSyntax.prototype.whenInjectedInto = function(parent) {
     return this._provideWhenSyntax.whenInjectedInto(parent);
    }, ProvideInWhenOnSyntax.prototype.whenParentNamed = function(name) {
     return this._provideWhenSyntax.whenParentNamed(name);
    }, ProvideInWhenOnSyntax.prototype.whenParentTagged = function(tag, value) {
     return this._provideWhenSyntax.whenParentTagged(tag, value);
    }, ProvideInWhenOnSyntax.prototype.whenAnyAncestorIs = function(ancestor) {
     return this._provideWhenSyntax.whenAnyAncestorIs(ancestor);
    }, ProvideInWhenOnSyntax.prototype.whenNoAncestorIs = function(ancestor) {
     return this._provideWhenSyntax.whenNoAncestorIs(ancestor);
    }, ProvideInWhenOnSyntax.prototype.whenAnyAncestorNamed = function(name) {
     return this._provideWhenSyntax.whenAnyAncestorNamed(name);
    }, ProvideInWhenOnSyntax.prototype.whenAnyAncestorTagged = function(tag, value) {
     return this._provideWhenSyntax.whenAnyAncestorTagged(tag, value);
    }, ProvideInWhenOnSyntax.prototype.whenNoAncestorNamed = function(name) {
     return this._provideWhenSyntax.whenNoAncestorNamed(name);
    }, ProvideInWhenOnSyntax.prototype.whenNoAncestorTagged = function(tag, value) {
     return this._provideWhenSyntax.whenNoAncestorTagged(tag, value);
    }, ProvideInWhenOnSyntax.prototype.whenAnyAncestorMatches = function(constraint) {
     return this._provideWhenSyntax.whenAnyAncestorMatches(constraint);
    }, ProvideInWhenOnSyntax.prototype.whenNoAncestorMatches = function(constraint) {
     return this._provideWhenSyntax.whenNoAncestorMatches(constraint);
    }, ProvideInWhenOnSyntax.prototype.onActivation = function(fn) {
     return this._provideOnSyntax.onActivation(fn);
    }, ProvideInWhenOnSyntax.prototype.inSingletonScope = function() {
     return this._provideInSyntax.inSingletonScope();
    }, ProvideInWhenOnSyntax.prototype.inTransientScope = function() {
     return this._provideInSyntax.inTransientScope();
    }, ProvideInWhenOnSyntax.prototype.done = function(force) {
     return this._provideInSyntax.done(force);
    }, ProvideInWhenOnSyntax;
   }();
   exports.default = ProvideInWhenOnSyntax;
  },
  72472: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   });
   var provide_when_syntax_1 = __webpack_require__(26175), provide_done_syntax_1 = __webpack_require__(41151), ProvideOnSyntax = function() {
    function ProvideOnSyntax(bindingOnSyntax, provideDoneSyntax) {
     this._bindingOnSyntax = bindingOnSyntax, this._provideDoneSyntax = provideDoneSyntax;
    }
    return ProvideOnSyntax.prototype.onActivation = function(fn) {
     var _this = this, bindingWhenSyntax = function(bind, target) {
      return _this._bindingOnSyntax(bind, target).onActivation(fn);
     }, onDoneSyntax = new provide_done_syntax_1.default(bindingWhenSyntax);
     return new provide_when_syntax_1.default(bindingWhenSyntax, onDoneSyntax);
    }, ProvideOnSyntax.prototype.done = function(force) {
     return this._provideDoneSyntax.done(force);
    }, ProvideOnSyntax;
   }();
   exports.default = ProvideOnSyntax;
  },
  62303: (__unused_webpack_module, exports) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   });
   var ProvideWhenOnSyntax = function() {
    function ProvideWhenOnSyntax(provideWhenSyntax, provideOnSyntax) {
     this._provideWhenSyntax = provideWhenSyntax, this._provideOnSyntax = provideOnSyntax;
    }
    return ProvideWhenOnSyntax.prototype.when = function(constraint) {
     return this._provideWhenSyntax.when(constraint);
    }, ProvideWhenOnSyntax.prototype.whenTargetNamed = function(name) {
     return this._provideWhenSyntax.whenTargetNamed(name);
    }, ProvideWhenOnSyntax.prototype.whenTargetTagged = function(tag, value) {
     return this._provideWhenSyntax.whenTargetTagged(tag, value);
    }, ProvideWhenOnSyntax.prototype.whenInjectedInto = function(parent) {
     return this._provideWhenSyntax.whenInjectedInto(parent);
    }, ProvideWhenOnSyntax.prototype.whenParentNamed = function(name) {
     return this._provideWhenSyntax.whenParentNamed(name);
    }, ProvideWhenOnSyntax.prototype.whenParentTagged = function(tag, value) {
     return this._provideWhenSyntax.whenParentTagged(tag, value);
    }, ProvideWhenOnSyntax.prototype.whenAnyAncestorIs = function(ancestor) {
     return this._provideWhenSyntax.whenAnyAncestorIs(ancestor);
    }, ProvideWhenOnSyntax.prototype.whenNoAncestorIs = function(ancestor) {
     return this._provideWhenSyntax.whenNoAncestorIs(ancestor);
    }, ProvideWhenOnSyntax.prototype.whenAnyAncestorNamed = function(name) {
     return this._provideWhenSyntax.whenAnyAncestorNamed(name);
    }, ProvideWhenOnSyntax.prototype.whenAnyAncestorTagged = function(tag, value) {
     return this._provideWhenSyntax.whenAnyAncestorTagged(tag, value);
    }, ProvideWhenOnSyntax.prototype.whenNoAncestorNamed = function(name) {
     return this._provideWhenSyntax.whenNoAncestorNamed(name);
    }, ProvideWhenOnSyntax.prototype.whenNoAncestorTagged = function(tag, value) {
     return this._provideWhenSyntax.whenNoAncestorTagged(tag, value);
    }, ProvideWhenOnSyntax.prototype.whenAnyAncestorMatches = function(constraint) {
     return this._provideWhenSyntax.whenAnyAncestorMatches(constraint);
    }, ProvideWhenOnSyntax.prototype.whenNoAncestorMatches = function(constraint) {
     return this._provideWhenSyntax.whenNoAncestorMatches(constraint);
    }, ProvideWhenOnSyntax.prototype.onActivation = function(fn) {
     return this._provideOnSyntax.onActivation(fn);
    }, ProvideWhenOnSyntax.prototype.done = function(force) {
     return this._provideWhenSyntax.done(force);
    }, ProvideWhenOnSyntax;
   }();
   exports.default = ProvideWhenOnSyntax;
  },
  26175: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   });
   var provide_on_syntax_1 = __webpack_require__(72472), provide_done_syntax_1 = __webpack_require__(41151), ProvideWhenSyntax = function() {
    function ProvideWhenSyntax(bindingWhenSyntax, provideDoneSyntax) {
     this._bindingWhenSyntax = bindingWhenSyntax, this._provideDoneSyntax = provideDoneSyntax;
    }
    return ProvideWhenSyntax.prototype.when = function(constraint) {
     var _this = this, bindingOnSyntax = function(bind, target) {
      return _this._bindingWhenSyntax(bind, target).when(constraint);
     }, whenDoneSyntax = new provide_done_syntax_1.default(bindingOnSyntax);
     return new provide_on_syntax_1.default(bindingOnSyntax, whenDoneSyntax);
    }, ProvideWhenSyntax.prototype.whenTargetNamed = function(name) {
     var _this = this, bindingOnSyntax = function(bind, target) {
      return _this._bindingWhenSyntax(bind, target).whenTargetNamed(name);
     }, whenDoneSyntax = new provide_done_syntax_1.default(bindingOnSyntax);
     return new provide_on_syntax_1.default(bindingOnSyntax, whenDoneSyntax);
    }, ProvideWhenSyntax.prototype.whenTargetTagged = function(tag, value) {
     var _this = this, bindingOnSyntax = function(bind, target) {
      return _this._bindingWhenSyntax(bind, target).whenTargetTagged(tag, value);
     }, whenDoneSyntax = new provide_done_syntax_1.default(bindingOnSyntax);
     return new provide_on_syntax_1.default(bindingOnSyntax, whenDoneSyntax);
    }, ProvideWhenSyntax.prototype.whenInjectedInto = function(parent) {
     var _this = this, bindingOnSyntax = function(bind, target) {
      return _this._bindingWhenSyntax(bind, target).whenInjectedInto(parent);
     }, whenDoneSyntax = new provide_done_syntax_1.default(bindingOnSyntax);
     return new provide_on_syntax_1.default(bindingOnSyntax, whenDoneSyntax);
    }, ProvideWhenSyntax.prototype.whenParentNamed = function(name) {
     var _this = this, bindingOnSyntax = function(bind, target) {
      return _this._bindingWhenSyntax(bind, target).whenParentNamed(name);
     }, whenDoneSyntax = new provide_done_syntax_1.default(bindingOnSyntax);
     return new provide_on_syntax_1.default(bindingOnSyntax, whenDoneSyntax);
    }, ProvideWhenSyntax.prototype.whenParentTagged = function(tag, value) {
     var _this = this, bindingOnSyntax = function(bind, target) {
      return _this._bindingWhenSyntax(bind, target).whenParentTagged(tag, value);
     }, whenDoneSyntax = new provide_done_syntax_1.default(bindingOnSyntax);
     return new provide_on_syntax_1.default(bindingOnSyntax, whenDoneSyntax);
    }, ProvideWhenSyntax.prototype.whenAnyAncestorIs = function(ancestor) {
     var _this = this, bindingOnSyntax = function(bind, target) {
      return _this._bindingWhenSyntax(bind, target).whenAnyAncestorIs(ancestor);
     }, whenDoneSyntax = new provide_done_syntax_1.default(bindingOnSyntax);
     return new provide_on_syntax_1.default(bindingOnSyntax, whenDoneSyntax);
    }, ProvideWhenSyntax.prototype.whenNoAncestorIs = function(ancestor) {
     var _this = this, bindingOnSyntax = function(bind, target) {
      return _this._bindingWhenSyntax(bind, target).whenNoAncestorIs(ancestor);
     }, whenDoneSyntax = new provide_done_syntax_1.default(bindingOnSyntax);
     return new provide_on_syntax_1.default(bindingOnSyntax, whenDoneSyntax);
    }, ProvideWhenSyntax.prototype.whenAnyAncestorNamed = function(name) {
     var _this = this, bindingOnSyntax = function(bind, target) {
      return _this._bindingWhenSyntax(bind, target).whenAnyAncestorNamed(name);
     }, whenDoneSyntax = new provide_done_syntax_1.default(bindingOnSyntax);
     return new provide_on_syntax_1.default(bindingOnSyntax, whenDoneSyntax);
    }, ProvideWhenSyntax.prototype.whenAnyAncestorTagged = function(tag, value) {
     var _this = this, bindingOnSyntax = function(bind, target) {
      return _this._bindingWhenSyntax(bind, target).whenAnyAncestorTagged(tag, value);
     }, whenDoneSyntax = new provide_done_syntax_1.default(bindingOnSyntax);
     return new provide_on_syntax_1.default(bindingOnSyntax, whenDoneSyntax);
    }, ProvideWhenSyntax.prototype.whenNoAncestorNamed = function(name) {
     var _this = this, bindingOnSyntax = function(bind, target) {
      return _this._bindingWhenSyntax(bind, target).whenNoAncestorNamed(name);
     }, whenDoneSyntax = new provide_done_syntax_1.default(bindingOnSyntax);
     return new provide_on_syntax_1.default(bindingOnSyntax, whenDoneSyntax);
    }, ProvideWhenSyntax.prototype.whenNoAncestorTagged = function(tag, value) {
     var _this = this, bindingOnSyntax = function(bind, target) {
      return _this._bindingWhenSyntax(bind, target).whenNoAncestorTagged(tag, value);
     }, whenDoneSyntax = new provide_done_syntax_1.default(bindingOnSyntax);
     return new provide_on_syntax_1.default(bindingOnSyntax, whenDoneSyntax);
    }, ProvideWhenSyntax.prototype.whenAnyAncestorMatches = function(constraint) {
     var _this = this, bindingOnSyntax = function(bind, target) {
      return _this._bindingWhenSyntax(bind, target).whenAnyAncestorMatches(constraint);
     }, whenDoneSyntax = new provide_done_syntax_1.default(bindingOnSyntax);
     return new provide_on_syntax_1.default(bindingOnSyntax, whenDoneSyntax);
    }, ProvideWhenSyntax.prototype.whenNoAncestorMatches = function(constraint) {
     var _this = this, bindingOnSyntax = function(bind, target) {
      return _this._bindingWhenSyntax(bind, target).whenNoAncestorMatches(constraint);
     }, whenDoneSyntax = new provide_done_syntax_1.default(bindingOnSyntax);
     return new provide_on_syntax_1.default(bindingOnSyntax, whenDoneSyntax);
    }, ProvideWhenSyntax.prototype.done = function(force) {
     return this._provideDoneSyntax.done(force);
    }, ProvideWhenSyntax;
   }();
   exports.default = ProvideWhenSyntax;
  },
  69080: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   });
   var inversify_1 = __webpack_require__(25891), provide_1 = __webpack_require__(28044);
   exports.default = function(container) {
    for (var modules = [], _i = 1; _i < arguments.length; _i++) modules[_i - 1] = arguments[_i];
    modules.forEach((function(module) {
     Object.keys(module).forEach((function(key) {
      var entity = module[key], decorator = provide_1.default(entity);
      inversify_1.decorate(decorator, entity);
     }));
    }));
   };
  },
  25891: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.r(__webpack_exports__), __webpack_require__.d(__webpack_exports__, {
    AsyncContainerModule: () => AsyncContainerModule,
    BindingScopeEnum: () => BindingScopeEnum,
    BindingTypeEnum: () => BindingTypeEnum,
    Container: () => Container,
    ContainerModule: () => ContainerModule,
    LazyServiceIdentifer: () => LazyServiceIdentifier,
    LazyServiceIdentifier: () => LazyServiceIdentifier,
    METADATA_KEY: () => METADATA_KEY,
    MetadataReader: () => MetadataReader,
    TargetTypeEnum: () => TargetTypeEnum,
    createTaggedDecorator: () => createTaggedDecorator,
    decorate: () => decorate,
    getServiceIdentifierAsString: () => getServiceIdentifierAsString,
    id: () => id,
    inject: () => inject,
    injectable: () => injectable,
    interfaces: () => interfaces,
    multiBindToService: () => multiBindToService,
    multiInject: () => multiInject,
    named: () => named,
    namedConstraint: () => namedConstraint,
    optional: () => optional,
    postConstruct: () => postConstruct,
    preDestroy: () => preDestroy,
    tagged: () => tagged,
    taggedConstraint: () => taggedConstraint,
    targetName: () => targetName,
    traverseAncerstors: () => traverseAncerstors,
    typeConstraint: () => typeConstraint,
    unmanaged: () => unmanaged
   });
   var metadata_keys_namespaceObject = {};
   __webpack_require__.r(metadata_keys_namespaceObject), __webpack_require__.d(metadata_keys_namespaceObject, {
    DESIGN_PARAM_TYPES: () => DESIGN_PARAM_TYPES,
    INJECT_TAG: () => INJECT_TAG,
    MULTI_INJECT_TAG: () => MULTI_INJECT_TAG,
    NAMED_TAG: () => NAMED_TAG,
    NAME_TAG: () => NAME_TAG,
    NON_CUSTOM_TAG_KEYS: () => NON_CUSTOM_TAG_KEYS,
    OPTIONAL_TAG: () => OPTIONAL_TAG,
    PARAM_TYPES: () => PARAM_TYPES,
    POST_CONSTRUCT: () => POST_CONSTRUCT,
    PRE_DESTROY: () => PRE_DESTROY,
    TAGGED: () => TAGGED,
    TAGGED_PROP: () => TAGGED_PROP,
    UNMANAGED_TAG: () => UNMANAGED_TAG
   });
   var NAMED_TAG = "named", NAME_TAG = "name", UNMANAGED_TAG = "unmanaged", OPTIONAL_TAG = "optional", INJECT_TAG = "inject", MULTI_INJECT_TAG = "multi_inject", TAGGED = "inversify:tagged", TAGGED_PROP = "inversify:tagged_props", PARAM_TYPES = "inversify:paramtypes", DESIGN_PARAM_TYPES = "design:paramtypes", POST_CONSTRUCT = "post_construct", PRE_DESTROY = "pre_destroy";
   var NON_CUSTOM_TAG_KEYS = [ INJECT_TAG, MULTI_INJECT_TAG, NAME_TAG, UNMANAGED_TAG, NAMED_TAG, OPTIONAL_TAG ], BindingScopeEnum = {
    Request: "Request",
    Singleton: "Singleton",
    Transient: "Transient"
   }, BindingTypeEnum = {
    ConstantValue: "ConstantValue",
    Constructor: "Constructor",
    DynamicValue: "DynamicValue",
    Factory: "Factory",
    Function: "Function",
    Instance: "Instance",
    Invalid: "Invalid",
    Provider: "Provider"
   }, TargetTypeEnum = {
    ClassProperty: "ClassProperty",
    ConstructorArgument: "ConstructorArgument",
    Variable: "Variable"
   }, idCounter = 0;
   function id() {
    return idCounter++;
   }
   var Binding = function() {
    function Binding(serviceIdentifier, scope) {
     this.id = id(), this.activated = !1, this.serviceIdentifier = serviceIdentifier, 
     this.scope = scope, this.type = BindingTypeEnum.Invalid, this.constraint = function(request) {
      return !0;
     }, this.implementationType = null, this.cache = null, this.factory = null, this.provider = null, 
     this.onActivation = null, this.onDeactivation = null, this.dynamicValue = null;
    }
    return Binding.prototype.clone = function() {
     var clone = new Binding(this.serviceIdentifier, this.scope);
     return clone.activated = clone.scope === BindingScopeEnum.Singleton && this.activated, 
     clone.implementationType = this.implementationType, clone.dynamicValue = this.dynamicValue, 
     clone.scope = this.scope, clone.type = this.type, clone.factory = this.factory, 
     clone.provider = this.provider, clone.constraint = this.constraint, clone.onActivation = this.onActivation, 
     clone.onDeactivation = this.onDeactivation, clone.cache = this.cache, clone;
    }, Binding;
   }(), DUPLICATED_INJECTABLE_DECORATOR = "Cannot apply @injectable decorator multiple times.", DUPLICATED_METADATA = "Metadata key was used more than once in a parameter:", NOT_REGISTERED = "No matching bindings found for serviceIdentifier:", INVALID_DECORATOR_OPERATION = "The @inject @multiInject @tagged and @named decorators must be applied to the parameters of a class constructor or a class property.", ON_DEACTIVATION_ERROR = function(clazz, errorMessage) {
    return "onDeactivation() error in class " + clazz + ": " + errorMessage;
   }, MetadataReader = function() {
    function MetadataReader() {}
    return MetadataReader.prototype.getConstructorMetadata = function(constructorFunc) {
     return {
      compilerGeneratedMetadata: Reflect.getMetadata(PARAM_TYPES, constructorFunc),
      userGeneratedMetadata: Reflect.getMetadata(TAGGED, constructorFunc) || {}
     };
    }, MetadataReader.prototype.getPropertiesMetadata = function(constructorFunc) {
     return Reflect.getMetadata(TAGGED_PROP, constructorFunc) || [];
    }, MetadataReader;
   }(), BindingCount_NoBindingsAvailable = 0, BindingCount_OnlyOneBindingAvailable = 1;
   function isStackOverflowExeption(error) {
    return error instanceof RangeError || "Maximum call stack size exceeded" === error.message;
   }
   function getServiceIdentifierAsString(serviceIdentifier) {
    return "function" == typeof serviceIdentifier ? serviceIdentifier.name : "symbol" == typeof serviceIdentifier ? serviceIdentifier.toString() : serviceIdentifier;
   }
   function listRegisteredBindingsForServiceIdentifier(container, serviceIdentifier, getBindings) {
    var registeredBindingsList = "", registeredBindings = getBindings(container, serviceIdentifier);
    return 0 !== registeredBindings.length && (registeredBindingsList = "\nRegistered bindings:", 
    registeredBindings.forEach((function(binding) {
     var name = "Object";
     null !== binding.implementationType && (name = getFunctionName(binding.implementationType)), 
     registeredBindingsList = registeredBindingsList + "\n " + name, binding.constraint.metaData && (registeredBindingsList = registeredBindingsList + " - " + binding.constraint.metaData);
    }))), registeredBindingsList;
   }
   function alreadyDependencyChain(request, serviceIdentifier) {
    return null !== request.parentRequest && (request.parentRequest.serviceIdentifier === serviceIdentifier || alreadyDependencyChain(request.parentRequest, serviceIdentifier));
   }
   function circularDependencyToException(request) {
    request.childRequests.forEach((function(childRequest) {
     if (alreadyDependencyChain(childRequest, childRequest.serviceIdentifier)) {
      var services = function(request) {
       var stringArr = function _createStringArr(req, result) {
        void 0 === result && (result = []);
        var serviceIdentifier = getServiceIdentifierAsString(req.serviceIdentifier);
        return result.push(serviceIdentifier), null !== req.parentRequest ? _createStringArr(req.parentRequest, result) : result;
       }(request);
       return stringArr.reverse().join(" --\x3e ");
      }(childRequest);
      throw new Error("Circular dependency found: " + services);
     }
     circularDependencyToException(childRequest);
    }));
   }
   function getFunctionName(func) {
    if (func.name) return func.name;
    var name_1 = func.toString(), match = name_1.match(/^function\s*([^\s(]+)/);
    return match ? match[1] : "Anonymous function: " + name_1;
   }
   var Context = function() {
    function Context(container) {
     this.id = id(), this.container = container;
    }
    return Context.prototype.addPlan = function(plan) {
     this.plan = plan;
    }, Context.prototype.setCurrentRequest = function(currentRequest) {
     this.currentRequest = currentRequest;
    }, Context;
   }(), Metadata = function() {
    function Metadata(key, value) {
     this.key = key, this.value = value;
    }
    return Metadata.prototype.toString = function() {
     return this.key === NAMED_TAG ? "named: " + String(this.value).toString() + " " : "tagged: { key:" + this.key.toString() + ", value: " + String(this.value) + " }";
    }, Metadata;
   }(), Plan = function(parentContext, rootRequest) {
    this.parentContext = parentContext, this.rootRequest = rootRequest;
   }, LazyServiceIdentifier = function() {
    function LazyServiceIdentifier(cb) {
     this._cb = cb;
    }
    return LazyServiceIdentifier.prototype.unwrap = function() {
     return this._cb();
    }, LazyServiceIdentifier;
   }(), QueryableString = function() {
    function QueryableString(str) {
     this.str = str;
    }
    return QueryableString.prototype.startsWith = function(searchString) {
     return 0 === this.str.indexOf(searchString);
    }, QueryableString.prototype.endsWith = function(searchString) {
     var reverseString, reverseSearchString = searchString.split("").reverse().join("");
     return reverseString = this.str.split("").reverse().join(""), this.startsWith.call({
      str: reverseString
     }, reverseSearchString);
    }, QueryableString.prototype.contains = function(searchString) {
     return -1 !== this.str.indexOf(searchString);
    }, QueryableString.prototype.equals = function(compareString) {
     return this.str === compareString;
    }, QueryableString.prototype.value = function() {
     return this.str;
    }, QueryableString;
   }(), Target = function() {
    function Target(type, identifier, serviceIdentifier, namedOrTagged) {
     this.id = id(), this.type = type, this.serviceIdentifier = serviceIdentifier;
     var queryableName = "symbol" == typeof identifier ? identifier.toString().slice(7, -1) : identifier;
     this.name = new QueryableString(queryableName || ""), this.identifier = identifier, 
     this.metadata = new Array;
     var metadataItem = null;
     "string" == typeof namedOrTagged ? metadataItem = new Metadata(NAMED_TAG, namedOrTagged) : namedOrTagged instanceof Metadata && (metadataItem = namedOrTagged), 
     null !== metadataItem && this.metadata.push(metadataItem);
    }
    return Target.prototype.hasTag = function(key) {
     for (var _i = 0, _a = this.metadata; _i < _a.length; _i++) {
      if (_a[_i].key === key) return !0;
     }
     return !1;
    }, Target.prototype.isArray = function() {
     return this.hasTag(MULTI_INJECT_TAG);
    }, Target.prototype.matchesArray = function(name) {
     return this.matchesTag(MULTI_INJECT_TAG)(name);
    }, Target.prototype.isNamed = function() {
     return this.hasTag(NAMED_TAG);
    }, Target.prototype.isTagged = function() {
     return this.metadata.some((function(metadata) {
      return NON_CUSTOM_TAG_KEYS.every((function(key) {
       return metadata.key !== key;
      }));
     }));
    }, Target.prototype.isOptional = function() {
     return this.matchesTag(OPTIONAL_TAG)(!0);
    }, Target.prototype.getNamedTag = function() {
     return this.isNamed() ? this.metadata.filter((function(m) {
      return m.key === NAMED_TAG;
     }))[0] : null;
    }, Target.prototype.getCustomTags = function() {
     return this.isTagged() ? this.metadata.filter((function(metadata) {
      return NON_CUSTOM_TAG_KEYS.every((function(key) {
       return metadata.key !== key;
      }));
     })) : null;
    }, Target.prototype.matchesNamedTag = function(name) {
     return this.matchesTag(NAMED_TAG)(name);
    }, Target.prototype.matchesTag = function(key) {
     var _this = this;
     return function(value) {
      for (var _i = 0, _a = _this.metadata; _i < _a.length; _i++) {
       var m = _a[_i];
       if (m.key === key && m.value === value) return !0;
      }
      return !1;
     };
    }, Target;
   }(), __spreadArray = function(to, from, pack) {
    if (pack || 2 === arguments.length) for (var ar, i = 0, l = from.length; i < l; i++) !ar && i in from || (ar || (ar = Array.prototype.slice.call(from, 0, i)), 
    ar[i] = from[i]);
    return to.concat(ar || Array.prototype.slice.call(from));
   };
   function getTargets(metadataReader, constructorName, func, isBaseClass) {
    var metadata = metadataReader.getConstructorMetadata(func), serviceIdentifiers = metadata.compilerGeneratedMetadata;
    if (void 0 === serviceIdentifiers) throw new Error("Missing required @injectable annotation in: " + constructorName + ".");
    var constructorArgsMetadata = metadata.userGeneratedMetadata, keys = Object.keys(constructorArgsMetadata), hasUserDeclaredUnknownInjections = 0 === func.length && keys.length > 0, hasOptionalParameters = keys.length > func.length, constructorTargets = function(isBaseClass, constructorName, serviceIdentifiers, constructorArgsMetadata, iterations) {
     for (var targets = [], i = 0; i < iterations; i++) {
      var target = getConstructorArgsAsTarget(i, isBaseClass, constructorName, serviceIdentifiers, constructorArgsMetadata);
      null !== target && targets.push(target);
     }
     return targets;
    }(isBaseClass, constructorName, serviceIdentifiers, constructorArgsMetadata, hasUserDeclaredUnknownInjections || hasOptionalParameters ? keys.length : func.length), propertyTargets = getClassPropsAsTargets(metadataReader, func, constructorName);
    return __spreadArray(__spreadArray([], constructorTargets, !0), propertyTargets, !0);
   }
   function getConstructorArgsAsTarget(index, isBaseClass, constructorName, serviceIdentifiers, constructorArgsMetadata) {
    var targetMetadata = constructorArgsMetadata[index.toString()] || [], metadata = formatTargetMetadata(targetMetadata), isManaged = !0 !== metadata.unmanaged, serviceIdentifier = serviceIdentifiers[index], injectIdentifier = metadata.inject || metadata.multiInject;
    if ((serviceIdentifier = injectIdentifier || serviceIdentifier) instanceof LazyServiceIdentifier && (serviceIdentifier = serviceIdentifier.unwrap()), 
    isManaged) {
     if (!isBaseClass && (serviceIdentifier === Object || serviceIdentifier === Function || void 0 === serviceIdentifier)) throw new Error("Missing required @inject or @multiInject annotation in: argument " + index + " in class " + constructorName + ".");
     var target = new Target(TargetTypeEnum.ConstructorArgument, metadata.targetName, serviceIdentifier);
     return target.metadata = targetMetadata, target;
    }
    return null;
   }
   function _getServiceIdentifierForProperty(inject, multiInject, propertyName, className) {
    var serviceIdentifier = inject || multiInject;
    if (void 0 === serviceIdentifier) {
     var msg = "Missing required @injectable annotation in: for property " + String(propertyName) + " in class " + className + ".";
     throw new Error(msg);
    }
    return serviceIdentifier;
   }
   function getClassPropsAsTargets(metadataReader, constructorFunc, constructorName) {
    for (var classPropsMetadata = metadataReader.getPropertiesMetadata(constructorFunc), targets = [], symbolKeys = Object.getOwnPropertySymbols(classPropsMetadata), _i = 0, keys_1 = Object.keys(classPropsMetadata).concat(symbolKeys); _i < keys_1.length; _i++) {
     var key = keys_1[_i], targetMetadata = classPropsMetadata[key], metadata = formatTargetMetadata(targetMetadata), identifier = metadata.targetName || key, serviceIdentifier = _getServiceIdentifierForProperty(metadata.inject, metadata.multiInject, key, constructorName), target = new Target(TargetTypeEnum.ClassProperty, identifier, serviceIdentifier);
     target.metadata = targetMetadata, targets.push(target);
    }
    var baseConstructor = Object.getPrototypeOf(constructorFunc.prototype).constructor;
    if (baseConstructor !== Object) {
     var baseTargets = getClassPropsAsTargets(metadataReader, baseConstructor, constructorName);
     targets = __spreadArray(__spreadArray([], targets, !0), baseTargets, !0);
    }
    return targets;
   }
   function getBaseClassDependencyCount(metadataReader, func) {
    var baseConstructor = Object.getPrototypeOf(func.prototype).constructor;
    if (baseConstructor !== Object) {
     var targets = getTargets(metadataReader, getFunctionName(baseConstructor), baseConstructor, !0), metadata = targets.map((function(t) {
      return t.metadata.filter((function(m) {
       return m.key === UNMANAGED_TAG;
      }));
     })), unmanagedCount = [].concat.apply([], metadata).length, dependencyCount = targets.length - unmanagedCount;
     return dependencyCount > 0 ? dependencyCount : getBaseClassDependencyCount(metadataReader, baseConstructor);
    }
    return 0;
   }
   function formatTargetMetadata(targetMetadata) {
    var targetMetadataMap = {};
    return targetMetadata.forEach((function(m) {
     targetMetadataMap[m.key.toString()] = m.value;
    })), {
     inject: targetMetadataMap[INJECT_TAG],
     multiInject: targetMetadataMap[MULTI_INJECT_TAG],
     targetName: targetMetadataMap[NAME_TAG],
     unmanaged: targetMetadataMap[UNMANAGED_TAG]
    };
   }
   var Request = function() {
    function Request(serviceIdentifier, parentContext, parentRequest, bindings, target) {
     this.id = id(), this.serviceIdentifier = serviceIdentifier, this.parentContext = parentContext, 
     this.parentRequest = parentRequest, this.target = target, this.childRequests = [], 
     this.bindings = Array.isArray(bindings) ? bindings : [ bindings ], this.requestScope = null === parentRequest ? new Map : null;
    }
    return Request.prototype.addChildRequest = function(serviceIdentifier, bindings, target) {
     var child = new Request(serviceIdentifier, this.parentContext, this, bindings, target);
     return this.childRequests.push(child), child;
    }, Request;
   }();
   function getBindingDictionary(cntnr) {
    return cntnr._bindingDictionary;
   }
   function _getActiveBindings(metadataReader, avoidConstraints, context, parentRequest, target) {
    var bindings = getBindings(context.container, target.serviceIdentifier), activeBindings = [];
    return bindings.length === BindingCount_NoBindingsAvailable && context.container.options.autoBindInjectable && "function" == typeof target.serviceIdentifier && metadataReader.getConstructorMetadata(target.serviceIdentifier).compilerGeneratedMetadata && (context.container.bind(target.serviceIdentifier).toSelf(), 
    bindings = getBindings(context.container, target.serviceIdentifier)), activeBindings = avoidConstraints ? bindings : bindings.filter((function(binding) {
     var request = new Request(binding.serviceIdentifier, context, parentRequest, binding, target);
     return binding.constraint(request);
    })), function(serviceIdentifier, bindings, target, container) {
     switch (bindings.length) {
     case BindingCount_NoBindingsAvailable:
      if (target.isOptional()) return bindings;
      var serviceIdentifierString = getServiceIdentifierAsString(serviceIdentifier), msg = NOT_REGISTERED;
      throw msg += function(serviceIdentifierString, target) {
       if (target.isTagged() || target.isNamed()) {
        var m_1 = "", namedTag = target.getNamedTag(), otherTags = target.getCustomTags();
        return null !== namedTag && (m_1 += namedTag.toString() + "\n"), null !== otherTags && otherTags.forEach((function(tag) {
         m_1 += tag.toString() + "\n";
        })), " " + serviceIdentifierString + "\n " + serviceIdentifierString + " - " + m_1;
       }
       return " " + serviceIdentifierString;
      }(serviceIdentifierString, target), msg += listRegisteredBindingsForServiceIdentifier(container, serviceIdentifierString, getBindings), 
      new Error(msg);

     case BindingCount_OnlyOneBindingAvailable:
      return bindings;

     default:
      if (target.isArray()) return bindings;
      msg = "Ambiguous match found for serviceIdentifier: " + (serviceIdentifierString = getServiceIdentifierAsString(serviceIdentifier));
      throw msg += listRegisteredBindingsForServiceIdentifier(container, serviceIdentifierString, getBindings), 
      new Error(msg);
     }
    }(target.serviceIdentifier, activeBindings, target, context.container), activeBindings;
   }
   function _createSubRequests(metadataReader, avoidConstraints, serviceIdentifier, context, parentRequest, target) {
    var activeBindings, childRequest;
    if (null === parentRequest) {
     activeBindings = _getActiveBindings(metadataReader, avoidConstraints, context, null, target), 
     childRequest = new Request(serviceIdentifier, context, null, activeBindings, target);
     var thePlan = new Plan(context, childRequest);
     context.addPlan(thePlan);
    } else activeBindings = _getActiveBindings(metadataReader, avoidConstraints, context, parentRequest, target), 
    childRequest = parentRequest.addChildRequest(target.serviceIdentifier, activeBindings, target);
    activeBindings.forEach((function(binding) {
     var subChildRequest = null;
     if (target.isArray()) subChildRequest = childRequest.addChildRequest(binding.serviceIdentifier, binding, target); else {
      if (binding.cache) return;
      subChildRequest = childRequest;
     }
     if (binding.type === BindingTypeEnum.Instance && null !== binding.implementationType) {
      var dependencies = function(metadataReader, func) {
       return getTargets(metadataReader, getFunctionName(func), func, !1);
      }(metadataReader, binding.implementationType);
      if (!context.container.options.skipBaseClassChecks) {
       var baseClassDependencyCount = getBaseClassDependencyCount(metadataReader, binding.implementationType);
       if (dependencies.length < baseClassDependencyCount) {
        var error = function() {
         for (var values = [], _i = 0; _i < arguments.length; _i++) values[_i] = arguments[_i];
         return "The number of constructor arguments in the derived class " + values[0] + " must be >= than the number of constructor arguments of its base class.";
        }(getFunctionName(binding.implementationType));
        throw new Error(error);
       }
      }
      dependencies.forEach((function(dependency) {
       _createSubRequests(metadataReader, !1, dependency.serviceIdentifier, context, subChildRequest, dependency);
      }));
     }
    }));
   }
   function getBindings(container, serviceIdentifier) {
    var bindings = [], bindingDictionary = getBindingDictionary(container);
    return bindingDictionary.hasKey(serviceIdentifier) ? bindings = bindingDictionary.get(serviceIdentifier) : null !== container.parent && (bindings = getBindings(container.parent, serviceIdentifier)), 
    bindings;
   }
   function plan(metadataReader, container, isMultiInject, targetType, serviceIdentifier, key, value, avoidConstraints) {
    void 0 === avoidConstraints && (avoidConstraints = !1);
    var context = new Context(container), target = function(isMultiInject, targetType, serviceIdentifier, name, key, value) {
     var injectMetadata = new Metadata(isMultiInject ? MULTI_INJECT_TAG : INJECT_TAG, serviceIdentifier), target = new Target(targetType, name, serviceIdentifier, injectMetadata);
     if (void 0 !== key) {
      var tagMetadata = new Metadata(key, value);
      target.metadata.push(tagMetadata);
     }
     return target;
    }(isMultiInject, targetType, serviceIdentifier, "", key, value);
    try {
     return _createSubRequests(metadataReader, avoidConstraints, serviceIdentifier, context, null, target), 
     context;
    } catch (error) {
     throw isStackOverflowExeption(error) && circularDependencyToException(context.plan.rootRequest), 
     error;
    }
   }
   function isPromise(object) {
    return ("object" == typeof object && null !== object || "function" == typeof object) && "function" == typeof object.then;
   }
   function isPromiseOrContainsPromise(object) {
    return !!isPromise(object) || Array.isArray(object) && object.some(isPromise);
   }
   var FactoryType, __awaiter = function(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))((function(resolve, reject) {
     function fulfilled(value) {
      try {
       step(generator.next(value));
      } catch (e) {
       reject(e);
      }
     }
     function rejected(value) {
      try {
       step(generator.throw(value));
      } catch (e) {
       reject(e);
      }
     }
     function step(result) {
      var value;
      result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P((function(resolve) {
       resolve(value);
      }))).then(fulfilled, rejected);
     }
     step((generator = generator.apply(thisArg, _arguments || [])).next());
    }));
   }, __generator = function(thisArg, body) {
    var f, y, t, g, _ = {
     label: 0,
     sent: function() {
      if (1 & t[0]) throw t[1];
      return t[1];
     },
     trys: [],
     ops: []
    };
    return g = {
     next: verb(0),
     throw: verb(1),
     return: verb(2)
    }, "function" == typeof Symbol && (g[Symbol.iterator] = function() {
     return this;
    }), g;
    function verb(n) {
     return function(v) {
      return function(op) {
       if (f) throw new TypeError("Generator is already executing.");
       for (;_; ) try {
        if (f = 1, y && (t = 2 & op[0] ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 
        0) : y.next) && !(t = t.call(y, op[1])).done) return t;
        switch (y = 0, t && (op = [ 2 & op[0], t.value ]), op[0]) {
        case 0:
        case 1:
         t = op;
         break;

        case 4:
         return _.label++, {
          value: op[1],
          done: !1
         };

        case 5:
         _.label++, y = op[1], op = [ 0 ];
         continue;

        case 7:
         op = _.ops.pop(), _.trys.pop();
         continue;

        default:
         if (!(t = _.trys, (t = t.length > 0 && t[t.length - 1]) || 6 !== op[0] && 2 !== op[0])) {
          _ = 0;
          continue;
         }
         if (3 === op[0] && (!t || op[1] > t[0] && op[1] < t[3])) {
          _.label = op[1];
          break;
         }
         if (6 === op[0] && _.label < t[1]) {
          _.label = t[1], t = op;
          break;
         }
         if (t && _.label < t[2]) {
          _.label = t[2], _.ops.push(op);
          break;
         }
         t[2] && _.ops.pop(), _.trys.pop();
         continue;
        }
        op = body.call(thisArg, _);
       } catch (e) {
        op = [ 6, e ], y = 0;
       } finally {
        f = t = 0;
       }
       if (5 & op[0]) throw op[1];
       return {
        value: op[0] ? op[1] : void 0,
        done: !0
       };
      }([ n, v ]);
     };
    }
   }, _saveToRequestScope = function(requestScope, binding, result) {
    requestScope.has(binding.id) || requestScope.set(binding.id, result);
   }, _saveToSingletonScope = function(binding, result) {
    binding.cache = result, binding.activated = !0, isPromise(result) && _saveAsyncResultToSingletonScope(binding, result);
   }, _saveAsyncResultToSingletonScope = function(binding, asyncResult) {
    return __awaiter(void 0, void 0, void 0, (function() {
     var result, ex_1;
     return __generator(this, (function(_a) {
      switch (_a.label) {
      case 0:
       return _a.trys.push([ 0, 2, , 3 ]), [ 4, asyncResult ];

      case 1:
       return result = _a.sent(), binding.cache = result, [ 3, 3 ];

      case 2:
       throw ex_1 = _a.sent(), binding.cache = null, binding.activated = !1, ex_1;

      case 3:
       return [ 2 ];
      }
     }));
    }));
   };
   !function(FactoryType) {
    FactoryType.DynamicValue = "toDynamicValue", FactoryType.Factory = "toFactory", 
    FactoryType.Provider = "toProvider";
   }(FactoryType || (FactoryType = {}));
   var multiBindToService = function(container) {
    return function(service) {
     return function() {
      for (var types = [], _i = 0; _i < arguments.length; _i++) types[_i] = arguments[_i];
      return types.forEach((function(t) {
       return container.bind(t).toService(service);
      }));
     };
    };
   }, __assign = function() {
    return __assign = Object.assign || function(t) {
     for (var s, i = 1, n = arguments.length; i < n; i++) for (var p in s = arguments[i]) Object.prototype.hasOwnProperty.call(s, p) && (t[p] = s[p]);
     return t;
    }, __assign.apply(this, arguments);
   }, instantiation_awaiter = function(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))((function(resolve, reject) {
     function fulfilled(value) {
      try {
       step(generator.next(value));
      } catch (e) {
       reject(e);
      }
     }
     function rejected(value) {
      try {
       step(generator.throw(value));
      } catch (e) {
       reject(e);
      }
     }
     function step(result) {
      var value;
      result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P((function(resolve) {
       resolve(value);
      }))).then(fulfilled, rejected);
     }
     step((generator = generator.apply(thisArg, _arguments || [])).next());
    }));
   }, instantiation_generator = function(thisArg, body) {
    var f, y, t, g, _ = {
     label: 0,
     sent: function() {
      if (1 & t[0]) throw t[1];
      return t[1];
     },
     trys: [],
     ops: []
    };
    return g = {
     next: verb(0),
     throw: verb(1),
     return: verb(2)
    }, "function" == typeof Symbol && (g[Symbol.iterator] = function() {
     return this;
    }), g;
    function verb(n) {
     return function(v) {
      return function(op) {
       if (f) throw new TypeError("Generator is already executing.");
       for (;_; ) try {
        if (f = 1, y && (t = 2 & op[0] ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 
        0) : y.next) && !(t = t.call(y, op[1])).done) return t;
        switch (y = 0, t && (op = [ 2 & op[0], t.value ]), op[0]) {
        case 0:
        case 1:
         t = op;
         break;

        case 4:
         return _.label++, {
          value: op[1],
          done: !1
         };

        case 5:
         _.label++, y = op[1], op = [ 0 ];
         continue;

        case 7:
         op = _.ops.pop(), _.trys.pop();
         continue;

        default:
         if (!(t = _.trys, (t = t.length > 0 && t[t.length - 1]) || 6 !== op[0] && 2 !== op[0])) {
          _ = 0;
          continue;
         }
         if (3 === op[0] && (!t || op[1] > t[0] && op[1] < t[3])) {
          _.label = op[1];
          break;
         }
         if (6 === op[0] && _.label < t[1]) {
          _.label = t[1], t = op;
          break;
         }
         if (t && _.label < t[2]) {
          _.label = t[2], _.ops.push(op);
          break;
         }
         t[2] && _.ops.pop(), _.trys.pop();
         continue;
        }
        op = body.call(thisArg, _);
       } catch (e) {
        op = [ 6, e ], y = 0;
       } finally {
        f = t = 0;
       }
       if (5 & op[0]) throw op[1];
       return {
        value: op[0] ? op[1] : void 0,
        done: !0
       };
      }([ n, v ]);
     };
    }
   }, instantiation_spreadArray = function(to, from, pack) {
    if (pack || 2 === arguments.length) for (var ar, i = 0, l = from.length; i < l; i++) !ar && i in from || (ar || (ar = Array.prototype.slice.call(from, 0, i)), 
    ar[i] = from[i]);
    return to.concat(ar || Array.prototype.slice.call(from));
   };
   function _createInstance(constr, childRequests, resolveRequest) {
    var result;
    if (childRequests.length > 0) {
     var resolved = function(childRequests, resolveRequest) {
      return childRequests.reduce((function(resolvedRequests, childRequest) {
       var injection = resolveRequest(childRequest);
       return childRequest.target.type === TargetTypeEnum.ConstructorArgument ? resolvedRequests.constructorInjections.push(injection) : (resolvedRequests.propertyRequests.push(childRequest), 
       resolvedRequests.propertyInjections.push(injection)), resolvedRequests.isAsync || (resolvedRequests.isAsync = isPromiseOrContainsPromise(injection)), 
       resolvedRequests;
      }), {
       constructorInjections: [],
       propertyInjections: [],
       propertyRequests: [],
       isAsync: !1
      });
     }(childRequests, resolveRequest), createInstanceWithInjectionsArg = __assign(__assign({}, resolved), {
      constr
     });
     result = resolved.isAsync ? function(args) {
      return instantiation_awaiter(this, void 0, void 0, (function() {
       var constructorInjections, propertyInjections;
       return instantiation_generator(this, (function(_a) {
        switch (_a.label) {
        case 0:
         return [ 4, possiblyWaitInjections(args.constructorInjections) ];

        case 1:
         return constructorInjections = _a.sent(), [ 4, possiblyWaitInjections(args.propertyInjections) ];

        case 2:
         return propertyInjections = _a.sent(), [ 2, createInstanceWithInjections(__assign(__assign({}, args), {
          constructorInjections,
          propertyInjections
         })) ];
        }
       }));
      }));
     }(createInstanceWithInjectionsArg) : createInstanceWithInjections(createInstanceWithInjectionsArg);
    } else result = new constr;
    return result;
   }
   function createInstanceWithInjections(args) {
    var _a, instance = new ((_a = args.constr).bind.apply(_a, instantiation_spreadArray([ void 0 ], args.constructorInjections, !1)));
    return args.propertyRequests.forEach((function(r, index) {
     var property = r.target.identifier, injection = args.propertyInjections[index];
     r.target.isOptional() && void 0 === injection || (instance[property] = injection);
    })), instance;
   }
   function possiblyWaitInjections(possiblePromiseinjections) {
    return instantiation_awaiter(this, void 0, void 0, (function() {
     var injections, _i, possiblePromiseinjections_1, injection;
     return instantiation_generator(this, (function(_a) {
      for (injections = [], _i = 0, possiblePromiseinjections_1 = possiblePromiseinjections; _i < possiblePromiseinjections_1.length; _i++) injection = possiblePromiseinjections_1[_i], 
      Array.isArray(injection) ? injections.push(Promise.all(injection)) : injections.push(injection);
      return [ 2, Promise.all(injections) ];
     }));
    }));
   }
   function _getInstanceAfterPostConstruct(constr, result) {
    var postConstructResult = function(constr, instance) {
     var _a, _b;
     if (Reflect.hasMetadata(POST_CONSTRUCT, constr)) {
      var data = Reflect.getMetadata(POST_CONSTRUCT, constr);
      try {
       return null === (_b = (_a = instance)[data.value]) || void 0 === _b ? void 0 : _b.call(_a);
      } catch (e) {
       if (e instanceof Error) throw new Error((clazz = constr.name, errorMessage = e.message, 
       "@postConstruct error in class " + clazz + ": " + errorMessage));
      }
     }
     var clazz, errorMessage;
    }(constr, result);
    return isPromise(postConstructResult) ? postConstructResult.then((function() {
     return result;
    })) : result;
   }
   function _validateInstanceResolution(binding, constr) {
    binding.scope !== BindingScopeEnum.Singleton && function(binding, constr) {
     var scopeErrorMessage = "Class cannot be instantiated in " + (binding.scope === BindingScopeEnum.Request ? "request" : "transient") + " scope.";
     if ("function" == typeof binding.onDeactivation) throw new Error(ON_DEACTIVATION_ERROR(constr.name, scopeErrorMessage));
     if (Reflect.hasMetadata(PRE_DESTROY, constr)) throw new Error("@preDestroy error in class " + constr.name + ": " + scopeErrorMessage);
    }(binding, constr);
   }
   var resolver_awaiter = function(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))((function(resolve, reject) {
     function fulfilled(value) {
      try {
       step(generator.next(value));
      } catch (e) {
       reject(e);
      }
     }
     function rejected(value) {
      try {
       step(generator.throw(value));
      } catch (e) {
       reject(e);
      }
     }
     function step(result) {
      var value;
      result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P((function(resolve) {
       resolve(value);
      }))).then(fulfilled, rejected);
     }
     step((generator = generator.apply(thisArg, _arguments || [])).next());
    }));
   }, resolver_generator = function(thisArg, body) {
    var f, y, t, g, _ = {
     label: 0,
     sent: function() {
      if (1 & t[0]) throw t[1];
      return t[1];
     },
     trys: [],
     ops: []
    };
    return g = {
     next: verb(0),
     throw: verb(1),
     return: verb(2)
    }, "function" == typeof Symbol && (g[Symbol.iterator] = function() {
     return this;
    }), g;
    function verb(n) {
     return function(v) {
      return function(op) {
       if (f) throw new TypeError("Generator is already executing.");
       for (;_; ) try {
        if (f = 1, y && (t = 2 & op[0] ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 
        0) : y.next) && !(t = t.call(y, op[1])).done) return t;
        switch (y = 0, t && (op = [ 2 & op[0], t.value ]), op[0]) {
        case 0:
        case 1:
         t = op;
         break;

        case 4:
         return _.label++, {
          value: op[1],
          done: !1
         };

        case 5:
         _.label++, y = op[1], op = [ 0 ];
         continue;

        case 7:
         op = _.ops.pop(), _.trys.pop();
         continue;

        default:
         if (!(t = _.trys, (t = t.length > 0 && t[t.length - 1]) || 6 !== op[0] && 2 !== op[0])) {
          _ = 0;
          continue;
         }
         if (3 === op[0] && (!t || op[1] > t[0] && op[1] < t[3])) {
          _.label = op[1];
          break;
         }
         if (6 === op[0] && _.label < t[1]) {
          _.label = t[1], t = op;
          break;
         }
         if (t && _.label < t[2]) {
          _.label = t[2], _.ops.push(op);
          break;
         }
         t[2] && _.ops.pop(), _.trys.pop();
         continue;
        }
        op = body.call(thisArg, _);
       } catch (e) {
        op = [ 6, e ], y = 0;
       } finally {
        f = t = 0;
       }
       if (5 & op[0]) throw op[1];
       return {
        value: op[0] ? op[1] : void 0,
        done: !0
       };
      }([ n, v ]);
     };
    }
   }, _resolveRequest = function(requestScope) {
    return function(request) {
     request.parentContext.setCurrentRequest(request);
     var bindings = request.bindings, childRequests = request.childRequests, targetIsAnArray = request.target && request.target.isArray(), targetParentIsNotAnArray = !(request.parentRequest && request.parentRequest.target && request.target && request.parentRequest.target.matchesArray(request.target.serviceIdentifier));
     if (targetIsAnArray && targetParentIsNotAnArray) return childRequests.map((function(childRequest) {
      return _resolveRequest(requestScope)(childRequest);
     }));
     if (!request.target.isOptional() || 0 !== bindings.length) {
      var binding = bindings[0];
      return _resolveBinding(requestScope, request, binding);
     }
    };
   }, _resolveFactoryFromBinding = function(binding, context) {
    var factoryDetails = function(binding) {
     switch (binding.type) {
     case BindingTypeEnum.Factory:
      return {
       factory: binding.factory,
       factoryType: FactoryType.Factory
      };

     case BindingTypeEnum.Provider:
      return {
       factory: binding.provider,
       factoryType: FactoryType.Provider
      };

     case BindingTypeEnum.DynamicValue:
      return {
       factory: binding.dynamicValue,
       factoryType: FactoryType.DynamicValue
      };

     default:
      throw new Error("Unexpected factory type " + binding.type);
     }
    }(binding);
    return function(fn, errorCallback) {
     try {
      return fn();
     } catch (error) {
      throw isStackOverflowExeption(error) && (error = errorCallback()), error;
     }
    }((function() {
     return factoryDetails.factory.bind(binding)(context);
    }), (function() {
     return new Error((factoryType = factoryDetails.factoryType, serviceIdentifier = context.currentRequest.serviceIdentifier.toString(), 
     "It looks like there is a circular dependency in one of the '" + factoryType + "' bindings. Please investigate bindings with service identifier '" + serviceIdentifier + "'."));
     var factoryType, serviceIdentifier;
    }));
   }, _getResolvedFromBinding = function(requestScope, request, binding) {
    var result, childRequests = request.childRequests;
    switch (function(binding) {
     var boundValue = null;
     switch (binding.type) {
     case BindingTypeEnum.ConstantValue:
     case BindingTypeEnum.Function:
      boundValue = binding.cache;
      break;

     case BindingTypeEnum.Constructor:
     case BindingTypeEnum.Instance:
      boundValue = binding.implementationType;
      break;

     case BindingTypeEnum.DynamicValue:
      boundValue = binding.dynamicValue;
      break;

     case BindingTypeEnum.Provider:
      boundValue = binding.provider;
      break;

     case BindingTypeEnum.Factory:
      boundValue = binding.factory;
     }
     if (null === boundValue) {
      var serviceIdentifierAsString = getServiceIdentifierAsString(binding.serviceIdentifier);
      throw new Error("Invalid binding type: " + serviceIdentifierAsString);
     }
    }(binding), binding.type) {
    case BindingTypeEnum.ConstantValue:
    case BindingTypeEnum.Function:
     result = binding.cache;
     break;

    case BindingTypeEnum.Constructor:
     result = binding.implementationType;
     break;

    case BindingTypeEnum.Instance:
     result = function(binding, constr, childRequests, resolveRequest) {
      _validateInstanceResolution(binding, constr);
      var result = _createInstance(constr, childRequests, resolveRequest);
      return isPromise(result) ? result.then((function(resolvedResult) {
       return _getInstanceAfterPostConstruct(constr, resolvedResult);
      })) : _getInstanceAfterPostConstruct(constr, result);
     }(binding, binding.implementationType, childRequests, _resolveRequest(requestScope));
     break;

    default:
     result = _resolveFactoryFromBinding(binding, request.parentContext);
    }
    return result;
   }, _resolveInScope = function(requestScope, binding, resolveFromBinding) {
    var result = function(requestScope, binding) {
     return binding.scope === BindingScopeEnum.Singleton && binding.activated ? binding.cache : binding.scope === BindingScopeEnum.Request && requestScope.has(binding.id) ? requestScope.get(binding.id) : null;
    }(requestScope, binding);
    return null !== result || function(requestScope, binding, result) {
     binding.scope === BindingScopeEnum.Singleton && _saveToSingletonScope(binding, result), 
     binding.scope === BindingScopeEnum.Request && _saveToRequestScope(requestScope, binding, result);
    }(requestScope, binding, result = resolveFromBinding()), result;
   }, _resolveBinding = function(requestScope, request, binding) {
    return _resolveInScope(requestScope, binding, (function() {
     var result = _getResolvedFromBinding(requestScope, request, binding);
     return result = isPromise(result) ? result.then((function(resolved) {
      return _onActivation(request, binding, resolved);
     })) : _onActivation(request, binding, result);
    }));
   };
   function _onActivation(request, binding, resolved) {
    var container, result = _bindingActivation(request.parentContext, binding, resolved), containersIterator = _getContainersIterator(request.parentContext.container), containersIteratorResult = containersIterator.next();
    do {
     container = containersIteratorResult.value;
     var context_1 = request.parentContext, serviceIdentifier = request.serviceIdentifier, activationsIterator = _getContainerActivationsForService(container, serviceIdentifier);
     result = isPromise(result) ? _activateContainerAsync(activationsIterator, context_1, result) : _activateContainer(activationsIterator, context_1, result), 
     containersIteratorResult = containersIterator.next();
    } while (!0 !== containersIteratorResult.done && !getBindingDictionary(container).hasKey(request.serviceIdentifier));
    return result;
   }
   var _bindingActivation = function(context, binding, previousResult) {
    return "function" == typeof binding.onActivation ? binding.onActivation(context, previousResult) : previousResult;
   }, _activateContainer = function(activationsIterator, context, result) {
    for (var activation = activationsIterator.next(); !activation.done; ) {
     if (isPromise(result = activation.value(context, result))) return _activateContainerAsync(activationsIterator, context, result);
     activation = activationsIterator.next();
    }
    return result;
   }, _activateContainerAsync = function(activationsIterator, context, resultPromise) {
    return resolver_awaiter(void 0, void 0, void 0, (function() {
     var result, activation;
     return resolver_generator(this, (function(_a) {
      switch (_a.label) {
      case 0:
       return [ 4, resultPromise ];

      case 1:
       result = _a.sent(), activation = activationsIterator.next(), _a.label = 2;

      case 2:
       return activation.done ? [ 3, 4 ] : [ 4, activation.value(context, result) ];

      case 3:
       return result = _a.sent(), activation = activationsIterator.next(), [ 3, 2 ];

      case 4:
       return [ 2, result ];
      }
     }));
    }));
   }, _getContainerActivationsForService = function(container, serviceIdentifier) {
    var activations = container._activations;
    return activations.hasKey(serviceIdentifier) ? activations.get(serviceIdentifier).values() : [].values();
   }, _getContainersIterator = function(container) {
    for (var containersStack = [ container ], parent = container.parent; null !== parent; ) containersStack.push(parent), 
    parent = parent.parent;
    return {
     next: function() {
      var nextContainer = containersStack.pop();
      return void 0 !== nextContainer ? {
       done: !1,
       value: nextContainer
      } : {
       done: !0,
       value: void 0
      };
     }
    };
   };
   var traverseAncerstors = function(request, constraint) {
    var parent = request.parentRequest;
    return null !== parent && (!!constraint(parent) || traverseAncerstors(parent, constraint));
   }, taggedConstraint = function(key) {
    return function(value) {
     var constraint = function(request) {
      return null !== request && null !== request.target && request.target.matchesTag(key)(value);
     };
     return constraint.metaData = new Metadata(key, value), constraint;
    };
   }, namedConstraint = taggedConstraint(NAMED_TAG), typeConstraint = function(type) {
    return function(request) {
     var binding = null;
     if (null !== request) {
      if (binding = request.bindings[0], "string" == typeof type) return binding.serviceIdentifier === type;
      var constructor = request.bindings[0].implementationType;
      return type === constructor;
     }
     return !1;
    };
   }, BindingWhenSyntax = function() {
    function BindingWhenSyntax(binding) {
     this._binding = binding;
    }
    return BindingWhenSyntax.prototype.when = function(constraint) {
     return this._binding.constraint = constraint, new BindingOnSyntax(this._binding);
    }, BindingWhenSyntax.prototype.whenTargetNamed = function(name) {
     return this._binding.constraint = namedConstraint(name), new BindingOnSyntax(this._binding);
    }, BindingWhenSyntax.prototype.whenTargetIsDefault = function() {
     return this._binding.constraint = function(request) {
      return null !== request && (null !== request.target && !request.target.isNamed() && !request.target.isTagged());
     }, new BindingOnSyntax(this._binding);
    }, BindingWhenSyntax.prototype.whenTargetTagged = function(tag, value) {
     return this._binding.constraint = taggedConstraint(tag)(value), new BindingOnSyntax(this._binding);
    }, BindingWhenSyntax.prototype.whenInjectedInto = function(parent) {
     return this._binding.constraint = function(request) {
      return null !== request && typeConstraint(parent)(request.parentRequest);
     }, new BindingOnSyntax(this._binding);
    }, BindingWhenSyntax.prototype.whenParentNamed = function(name) {
     return this._binding.constraint = function(request) {
      return null !== request && namedConstraint(name)(request.parentRequest);
     }, new BindingOnSyntax(this._binding);
    }, BindingWhenSyntax.prototype.whenParentTagged = function(tag, value) {
     return this._binding.constraint = function(request) {
      return null !== request && taggedConstraint(tag)(value)(request.parentRequest);
     }, new BindingOnSyntax(this._binding);
    }, BindingWhenSyntax.prototype.whenAnyAncestorIs = function(ancestor) {
     return this._binding.constraint = function(request) {
      return null !== request && traverseAncerstors(request, typeConstraint(ancestor));
     }, new BindingOnSyntax(this._binding);
    }, BindingWhenSyntax.prototype.whenNoAncestorIs = function(ancestor) {
     return this._binding.constraint = function(request) {
      return null !== request && !traverseAncerstors(request, typeConstraint(ancestor));
     }, new BindingOnSyntax(this._binding);
    }, BindingWhenSyntax.prototype.whenAnyAncestorNamed = function(name) {
     return this._binding.constraint = function(request) {
      return null !== request && traverseAncerstors(request, namedConstraint(name));
     }, new BindingOnSyntax(this._binding);
    }, BindingWhenSyntax.prototype.whenNoAncestorNamed = function(name) {
     return this._binding.constraint = function(request) {
      return null !== request && !traverseAncerstors(request, namedConstraint(name));
     }, new BindingOnSyntax(this._binding);
    }, BindingWhenSyntax.prototype.whenAnyAncestorTagged = function(tag, value) {
     return this._binding.constraint = function(request) {
      return null !== request && traverseAncerstors(request, taggedConstraint(tag)(value));
     }, new BindingOnSyntax(this._binding);
    }, BindingWhenSyntax.prototype.whenNoAncestorTagged = function(tag, value) {
     return this._binding.constraint = function(request) {
      return null !== request && !traverseAncerstors(request, taggedConstraint(tag)(value));
     }, new BindingOnSyntax(this._binding);
    }, BindingWhenSyntax.prototype.whenAnyAncestorMatches = function(constraint) {
     return this._binding.constraint = function(request) {
      return null !== request && traverseAncerstors(request, constraint);
     }, new BindingOnSyntax(this._binding);
    }, BindingWhenSyntax.prototype.whenNoAncestorMatches = function(constraint) {
     return this._binding.constraint = function(request) {
      return null !== request && !traverseAncerstors(request, constraint);
     }, new BindingOnSyntax(this._binding);
    }, BindingWhenSyntax;
   }(), BindingOnSyntax = function() {
    function BindingOnSyntax(binding) {
     this._binding = binding;
    }
    return BindingOnSyntax.prototype.onActivation = function(handler) {
     return this._binding.onActivation = handler, new BindingWhenSyntax(this._binding);
    }, BindingOnSyntax.prototype.onDeactivation = function(handler) {
     return this._binding.onDeactivation = handler, new BindingWhenSyntax(this._binding);
    }, BindingOnSyntax;
   }(), BindingWhenOnSyntax = function() {
    function BindingWhenOnSyntax(binding) {
     this._binding = binding, this._bindingWhenSyntax = new BindingWhenSyntax(this._binding), 
     this._bindingOnSyntax = new BindingOnSyntax(this._binding);
    }
    return BindingWhenOnSyntax.prototype.when = function(constraint) {
     return this._bindingWhenSyntax.when(constraint);
    }, BindingWhenOnSyntax.prototype.whenTargetNamed = function(name) {
     return this._bindingWhenSyntax.whenTargetNamed(name);
    }, BindingWhenOnSyntax.prototype.whenTargetIsDefault = function() {
     return this._bindingWhenSyntax.whenTargetIsDefault();
    }, BindingWhenOnSyntax.prototype.whenTargetTagged = function(tag, value) {
     return this._bindingWhenSyntax.whenTargetTagged(tag, value);
    }, BindingWhenOnSyntax.prototype.whenInjectedInto = function(parent) {
     return this._bindingWhenSyntax.whenInjectedInto(parent);
    }, BindingWhenOnSyntax.prototype.whenParentNamed = function(name) {
     return this._bindingWhenSyntax.whenParentNamed(name);
    }, BindingWhenOnSyntax.prototype.whenParentTagged = function(tag, value) {
     return this._bindingWhenSyntax.whenParentTagged(tag, value);
    }, BindingWhenOnSyntax.prototype.whenAnyAncestorIs = function(ancestor) {
     return this._bindingWhenSyntax.whenAnyAncestorIs(ancestor);
    }, BindingWhenOnSyntax.prototype.whenNoAncestorIs = function(ancestor) {
     return this._bindingWhenSyntax.whenNoAncestorIs(ancestor);
    }, BindingWhenOnSyntax.prototype.whenAnyAncestorNamed = function(name) {
     return this._bindingWhenSyntax.whenAnyAncestorNamed(name);
    }, BindingWhenOnSyntax.prototype.whenAnyAncestorTagged = function(tag, value) {
     return this._bindingWhenSyntax.whenAnyAncestorTagged(tag, value);
    }, BindingWhenOnSyntax.prototype.whenNoAncestorNamed = function(name) {
     return this._bindingWhenSyntax.whenNoAncestorNamed(name);
    }, BindingWhenOnSyntax.prototype.whenNoAncestorTagged = function(tag, value) {
     return this._bindingWhenSyntax.whenNoAncestorTagged(tag, value);
    }, BindingWhenOnSyntax.prototype.whenAnyAncestorMatches = function(constraint) {
     return this._bindingWhenSyntax.whenAnyAncestorMatches(constraint);
    }, BindingWhenOnSyntax.prototype.whenNoAncestorMatches = function(constraint) {
     return this._bindingWhenSyntax.whenNoAncestorMatches(constraint);
    }, BindingWhenOnSyntax.prototype.onActivation = function(handler) {
     return this._bindingOnSyntax.onActivation(handler);
    }, BindingWhenOnSyntax.prototype.onDeactivation = function(handler) {
     return this._bindingOnSyntax.onDeactivation(handler);
    }, BindingWhenOnSyntax;
   }(), BindingInSyntax = function() {
    function BindingInSyntax(binding) {
     this._binding = binding;
    }
    return BindingInSyntax.prototype.inRequestScope = function() {
     return this._binding.scope = BindingScopeEnum.Request, new BindingWhenOnSyntax(this._binding);
    }, BindingInSyntax.prototype.inSingletonScope = function() {
     return this._binding.scope = BindingScopeEnum.Singleton, new BindingWhenOnSyntax(this._binding);
    }, BindingInSyntax.prototype.inTransientScope = function() {
     return this._binding.scope = BindingScopeEnum.Transient, new BindingWhenOnSyntax(this._binding);
    }, BindingInSyntax;
   }(), BindingInWhenOnSyntax = function() {
    function BindingInWhenOnSyntax(binding) {
     this._binding = binding, this._bindingWhenSyntax = new BindingWhenSyntax(this._binding), 
     this._bindingOnSyntax = new BindingOnSyntax(this._binding), this._bindingInSyntax = new BindingInSyntax(binding);
    }
    return BindingInWhenOnSyntax.prototype.inRequestScope = function() {
     return this._bindingInSyntax.inRequestScope();
    }, BindingInWhenOnSyntax.prototype.inSingletonScope = function() {
     return this._bindingInSyntax.inSingletonScope();
    }, BindingInWhenOnSyntax.prototype.inTransientScope = function() {
     return this._bindingInSyntax.inTransientScope();
    }, BindingInWhenOnSyntax.prototype.when = function(constraint) {
     return this._bindingWhenSyntax.when(constraint);
    }, BindingInWhenOnSyntax.prototype.whenTargetNamed = function(name) {
     return this._bindingWhenSyntax.whenTargetNamed(name);
    }, BindingInWhenOnSyntax.prototype.whenTargetIsDefault = function() {
     return this._bindingWhenSyntax.whenTargetIsDefault();
    }, BindingInWhenOnSyntax.prototype.whenTargetTagged = function(tag, value) {
     return this._bindingWhenSyntax.whenTargetTagged(tag, value);
    }, BindingInWhenOnSyntax.prototype.whenInjectedInto = function(parent) {
     return this._bindingWhenSyntax.whenInjectedInto(parent);
    }, BindingInWhenOnSyntax.prototype.whenParentNamed = function(name) {
     return this._bindingWhenSyntax.whenParentNamed(name);
    }, BindingInWhenOnSyntax.prototype.whenParentTagged = function(tag, value) {
     return this._bindingWhenSyntax.whenParentTagged(tag, value);
    }, BindingInWhenOnSyntax.prototype.whenAnyAncestorIs = function(ancestor) {
     return this._bindingWhenSyntax.whenAnyAncestorIs(ancestor);
    }, BindingInWhenOnSyntax.prototype.whenNoAncestorIs = function(ancestor) {
     return this._bindingWhenSyntax.whenNoAncestorIs(ancestor);
    }, BindingInWhenOnSyntax.prototype.whenAnyAncestorNamed = function(name) {
     return this._bindingWhenSyntax.whenAnyAncestorNamed(name);
    }, BindingInWhenOnSyntax.prototype.whenAnyAncestorTagged = function(tag, value) {
     return this._bindingWhenSyntax.whenAnyAncestorTagged(tag, value);
    }, BindingInWhenOnSyntax.prototype.whenNoAncestorNamed = function(name) {
     return this._bindingWhenSyntax.whenNoAncestorNamed(name);
    }, BindingInWhenOnSyntax.prototype.whenNoAncestorTagged = function(tag, value) {
     return this._bindingWhenSyntax.whenNoAncestorTagged(tag, value);
    }, BindingInWhenOnSyntax.prototype.whenAnyAncestorMatches = function(constraint) {
     return this._bindingWhenSyntax.whenAnyAncestorMatches(constraint);
    }, BindingInWhenOnSyntax.prototype.whenNoAncestorMatches = function(constraint) {
     return this._bindingWhenSyntax.whenNoAncestorMatches(constraint);
    }, BindingInWhenOnSyntax.prototype.onActivation = function(handler) {
     return this._bindingOnSyntax.onActivation(handler);
    }, BindingInWhenOnSyntax.prototype.onDeactivation = function(handler) {
     return this._bindingOnSyntax.onDeactivation(handler);
    }, BindingInWhenOnSyntax;
   }(), BindingToSyntax = function() {
    function BindingToSyntax(binding) {
     this._binding = binding;
    }
    return BindingToSyntax.prototype.to = function(constructor) {
     return this._binding.type = BindingTypeEnum.Instance, this._binding.implementationType = constructor, 
     new BindingInWhenOnSyntax(this._binding);
    }, BindingToSyntax.prototype.toSelf = function() {
     if ("function" != typeof this._binding.serviceIdentifier) throw new Error("The toSelf function can only be applied when a constructor is used as service identifier");
     var self = this._binding.serviceIdentifier;
     return this.to(self);
    }, BindingToSyntax.prototype.toConstantValue = function(value) {
     return this._binding.type = BindingTypeEnum.ConstantValue, this._binding.cache = value, 
     this._binding.dynamicValue = null, this._binding.implementationType = null, this._binding.scope = BindingScopeEnum.Singleton, 
     new BindingWhenOnSyntax(this._binding);
    }, BindingToSyntax.prototype.toDynamicValue = function(func) {
     return this._binding.type = BindingTypeEnum.DynamicValue, this._binding.cache = null, 
     this._binding.dynamicValue = func, this._binding.implementationType = null, new BindingInWhenOnSyntax(this._binding);
    }, BindingToSyntax.prototype.toConstructor = function(constructor) {
     return this._binding.type = BindingTypeEnum.Constructor, this._binding.implementationType = constructor, 
     this._binding.scope = BindingScopeEnum.Singleton, new BindingWhenOnSyntax(this._binding);
    }, BindingToSyntax.prototype.toFactory = function(factory) {
     return this._binding.type = BindingTypeEnum.Factory, this._binding.factory = factory, 
     this._binding.scope = BindingScopeEnum.Singleton, new BindingWhenOnSyntax(this._binding);
    }, BindingToSyntax.prototype.toFunction = function(func) {
     if ("function" != typeof func) throw new Error("Value provided to function binding must be a function!");
     var bindingWhenOnSyntax = this.toConstantValue(func);
     return this._binding.type = BindingTypeEnum.Function, this._binding.scope = BindingScopeEnum.Singleton, 
     bindingWhenOnSyntax;
    }, BindingToSyntax.prototype.toAutoFactory = function(serviceIdentifier) {
     return this._binding.type = BindingTypeEnum.Factory, this._binding.factory = function(context) {
      return function() {
       return context.container.get(serviceIdentifier);
      };
     }, this._binding.scope = BindingScopeEnum.Singleton, new BindingWhenOnSyntax(this._binding);
    }, BindingToSyntax.prototype.toAutoNamedFactory = function(serviceIdentifier) {
     return this._binding.type = BindingTypeEnum.Factory, this._binding.factory = function(context) {
      return function(named) {
       return context.container.getNamed(serviceIdentifier, named);
      };
     }, new BindingWhenOnSyntax(this._binding);
    }, BindingToSyntax.prototype.toProvider = function(provider) {
     return this._binding.type = BindingTypeEnum.Provider, this._binding.provider = provider, 
     this._binding.scope = BindingScopeEnum.Singleton, new BindingWhenOnSyntax(this._binding);
    }, BindingToSyntax.prototype.toService = function(service) {
     this.toDynamicValue((function(context) {
      return context.container.get(service);
     }));
    }, BindingToSyntax;
   }(), ContainerSnapshot = function() {
    function ContainerSnapshot() {}
    return ContainerSnapshot.of = function(bindings, middleware, activations, deactivations, moduleActivationStore) {
     var snapshot = new ContainerSnapshot;
     return snapshot.bindings = bindings, snapshot.middleware = middleware, snapshot.deactivations = deactivations, 
     snapshot.activations = activations, snapshot.moduleActivationStore = moduleActivationStore, 
     snapshot;
    }, ContainerSnapshot;
   }();
   var Lookup = function() {
    function Lookup() {
     this._map = new Map;
    }
    return Lookup.prototype.getMap = function() {
     return this._map;
    }, Lookup.prototype.add = function(serviceIdentifier, value) {
     if (null == serviceIdentifier) throw new Error("NULL argument");
     if (null == value) throw new Error("NULL argument");
     var entry = this._map.get(serviceIdentifier);
     void 0 !== entry ? entry.push(value) : this._map.set(serviceIdentifier, [ value ]);
    }, Lookup.prototype.get = function(serviceIdentifier) {
     if (null == serviceIdentifier) throw new Error("NULL argument");
     var entry = this._map.get(serviceIdentifier);
     if (void 0 !== entry) return entry;
     throw new Error("Key Not Found");
    }, Lookup.prototype.remove = function(serviceIdentifier) {
     if (null == serviceIdentifier) throw new Error("NULL argument");
     if (!this._map.delete(serviceIdentifier)) throw new Error("Key Not Found");
    }, Lookup.prototype.removeIntersection = function(lookup) {
     var _this = this;
     this.traverse((function(serviceIdentifier, value) {
      var lookupActivations = lookup.hasKey(serviceIdentifier) ? lookup.get(serviceIdentifier) : void 0;
      if (void 0 !== lookupActivations) {
       var filteredValues = value.filter((function(lookupValue) {
        return !lookupActivations.some((function(moduleActivation) {
         return lookupValue === moduleActivation;
        }));
       }));
       _this._setValue(serviceIdentifier, filteredValues);
      }
     }));
    }, Lookup.prototype.removeByCondition = function(condition) {
     var _this = this, removals = [];
     return this._map.forEach((function(entries, key) {
      for (var updatedEntries = [], _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {
       var entry = entries_1[_i];
       condition(entry) ? removals.push(entry) : updatedEntries.push(entry);
      }
      _this._setValue(key, updatedEntries);
     })), removals;
    }, Lookup.prototype.hasKey = function(serviceIdentifier) {
     if (null == serviceIdentifier) throw new Error("NULL argument");
     return this._map.has(serviceIdentifier);
    }, Lookup.prototype.clone = function() {
     var copy = new Lookup;
     return this._map.forEach((function(value, key) {
      value.forEach((function(b) {
       return copy.add(key, "object" == typeof (obj = b) && null !== obj && "clone" in obj && "function" == typeof obj.clone ? b.clone() : b);
       var obj;
      }));
     })), copy;
    }, Lookup.prototype.traverse = function(func) {
     this._map.forEach((function(value, key) {
      func(key, value);
     }));
    }, Lookup.prototype._setValue = function(serviceIdentifier, value) {
     value.length > 0 ? this._map.set(serviceIdentifier, value) : this._map.delete(serviceIdentifier);
    }, Lookup;
   }(), ModuleActivationStore = function() {
    function ModuleActivationStore() {
     this._map = new Map;
    }
    return ModuleActivationStore.prototype.remove = function(moduleId) {
     if (this._map.has(moduleId)) {
      var handlers = this._map.get(moduleId);
      return this._map.delete(moduleId), handlers;
     }
     return this._getEmptyHandlersStore();
    }, ModuleActivationStore.prototype.addDeactivation = function(moduleId, serviceIdentifier, onDeactivation) {
     this._getModuleActivationHandlers(moduleId).onDeactivations.add(serviceIdentifier, onDeactivation);
    }, ModuleActivationStore.prototype.addActivation = function(moduleId, serviceIdentifier, onActivation) {
     this._getModuleActivationHandlers(moduleId).onActivations.add(serviceIdentifier, onActivation);
    }, ModuleActivationStore.prototype.clone = function() {
     var clone = new ModuleActivationStore;
     return this._map.forEach((function(handlersStore, moduleId) {
      clone._map.set(moduleId, {
       onActivations: handlersStore.onActivations.clone(),
       onDeactivations: handlersStore.onDeactivations.clone()
      });
     })), clone;
    }, ModuleActivationStore.prototype._getModuleActivationHandlers = function(moduleId) {
     var moduleActivationHandlers = this._map.get(moduleId);
     return void 0 === moduleActivationHandlers && (moduleActivationHandlers = this._getEmptyHandlersStore(), 
     this._map.set(moduleId, moduleActivationHandlers)), moduleActivationHandlers;
    }, ModuleActivationStore.prototype._getEmptyHandlersStore = function() {
     return {
      onActivations: new Lookup,
      onDeactivations: new Lookup
     };
    }, ModuleActivationStore;
   }(), container_assign = function() {
    return container_assign = Object.assign || function(t) {
     for (var s, i = 1, n = arguments.length; i < n; i++) for (var p in s = arguments[i]) Object.prototype.hasOwnProperty.call(s, p) && (t[p] = s[p]);
     return t;
    }, container_assign.apply(this, arguments);
   }, container_awaiter = function(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))((function(resolve, reject) {
     function fulfilled(value) {
      try {
       step(generator.next(value));
      } catch (e) {
       reject(e);
      }
     }
     function rejected(value) {
      try {
       step(generator.throw(value));
      } catch (e) {
       reject(e);
      }
     }
     function step(result) {
      var value;
      result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P((function(resolve) {
       resolve(value);
      }))).then(fulfilled, rejected);
     }
     step((generator = generator.apply(thisArg, _arguments || [])).next());
    }));
   }, container_generator = function(thisArg, body) {
    var f, y, t, g, _ = {
     label: 0,
     sent: function() {
      if (1 & t[0]) throw t[1];
      return t[1];
     },
     trys: [],
     ops: []
    };
    return g = {
     next: verb(0),
     throw: verb(1),
     return: verb(2)
    }, "function" == typeof Symbol && (g[Symbol.iterator] = function() {
     return this;
    }), g;
    function verb(n) {
     return function(v) {
      return function(op) {
       if (f) throw new TypeError("Generator is already executing.");
       for (;_; ) try {
        if (f = 1, y && (t = 2 & op[0] ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 
        0) : y.next) && !(t = t.call(y, op[1])).done) return t;
        switch (y = 0, t && (op = [ 2 & op[0], t.value ]), op[0]) {
        case 0:
        case 1:
         t = op;
         break;

        case 4:
         return _.label++, {
          value: op[1],
          done: !1
         };

        case 5:
         _.label++, y = op[1], op = [ 0 ];
         continue;

        case 7:
         op = _.ops.pop(), _.trys.pop();
         continue;

        default:
         if (!(t = _.trys, (t = t.length > 0 && t[t.length - 1]) || 6 !== op[0] && 2 !== op[0])) {
          _ = 0;
          continue;
         }
         if (3 === op[0] && (!t || op[1] > t[0] && op[1] < t[3])) {
          _.label = op[1];
          break;
         }
         if (6 === op[0] && _.label < t[1]) {
          _.label = t[1], t = op;
          break;
         }
         if (t && _.label < t[2]) {
          _.label = t[2], _.ops.push(op);
          break;
         }
         t[2] && _.ops.pop(), _.trys.pop();
         continue;
        }
        op = body.call(thisArg, _);
       } catch (e) {
        op = [ 6, e ], y = 0;
       } finally {
        f = t = 0;
       }
       if (5 & op[0]) throw op[1];
       return {
        value: op[0] ? op[1] : void 0,
        done: !0
       };
      }([ n, v ]);
     };
    }
   }, container_spreadArray = function(to, from, pack) {
    if (pack || 2 === arguments.length) for (var ar, i = 0, l = from.length; i < l; i++) !ar && i in from || (ar || (ar = Array.prototype.slice.call(from, 0, i)), 
    ar[i] = from[i]);
    return to.concat(ar || Array.prototype.slice.call(from));
   }, Container = function() {
    function Container(containerOptions) {
     var options = containerOptions || {};
     if ("object" != typeof options) throw new Error("Invalid Container constructor argument. Container options must be an object.");
     if (void 0 === options.defaultScope) options.defaultScope = BindingScopeEnum.Transient; else if (options.defaultScope !== BindingScopeEnum.Singleton && options.defaultScope !== BindingScopeEnum.Transient && options.defaultScope !== BindingScopeEnum.Request) throw new Error('Invalid Container option. Default scope must be a string ("singleton" or "transient").');
     if (void 0 === options.autoBindInjectable) options.autoBindInjectable = !1; else if ("boolean" != typeof options.autoBindInjectable) throw new Error("Invalid Container option. Auto bind injectable must be a boolean");
     if (void 0 === options.skipBaseClassChecks) options.skipBaseClassChecks = !1; else if ("boolean" != typeof options.skipBaseClassChecks) throw new Error("Invalid Container option. Skip base check must be a boolean");
     this.options = {
      autoBindInjectable: options.autoBindInjectable,
      defaultScope: options.defaultScope,
      skipBaseClassChecks: options.skipBaseClassChecks
     }, this.id = id(), this._bindingDictionary = new Lookup, this._snapshots = [], this._middleware = null, 
     this._activations = new Lookup, this._deactivations = new Lookup, this.parent = null, 
     this._metadataReader = new MetadataReader, this._moduleActivationStore = new ModuleActivationStore;
    }
    return Container.merge = function(container1, container2) {
     for (var containers = [], _i = 2; _i < arguments.length; _i++) containers[_i - 2] = arguments[_i];
     var container = new Container, targetContainers = container_spreadArray([ container1, container2 ], containers, !0).map((function(targetContainer) {
      return getBindingDictionary(targetContainer);
     })), bindingDictionary = getBindingDictionary(container);
     return targetContainers.forEach((function(targetBindingDictionary) {
      var destination;
      destination = bindingDictionary, targetBindingDictionary.traverse((function(_key, value) {
       value.forEach((function(binding) {
        destination.add(binding.serviceIdentifier, binding.clone());
       }));
      }));
     })), container;
    }, Container.prototype.load = function() {
     for (var modules = [], _i = 0; _i < arguments.length; _i++) modules[_i] = arguments[_i];
     for (var getHelpers = this._getContainerModuleHelpersFactory(), _a = 0, modules_1 = modules; _a < modules_1.length; _a++) {
      var currentModule = modules_1[_a], containerModuleHelpers = getHelpers(currentModule.id);
      currentModule.registry(containerModuleHelpers.bindFunction, containerModuleHelpers.unbindFunction, containerModuleHelpers.isboundFunction, containerModuleHelpers.rebindFunction, containerModuleHelpers.unbindAsyncFunction, containerModuleHelpers.onActivationFunction, containerModuleHelpers.onDeactivationFunction);
     }
    }, Container.prototype.loadAsync = function() {
     for (var modules = [], _i = 0; _i < arguments.length; _i++) modules[_i] = arguments[_i];
     return container_awaiter(this, void 0, void 0, (function() {
      var getHelpers, _a, modules_2, currentModule, containerModuleHelpers;
      return container_generator(this, (function(_b) {
       switch (_b.label) {
       case 0:
        getHelpers = this._getContainerModuleHelpersFactory(), _a = 0, modules_2 = modules, 
        _b.label = 1;

       case 1:
        return _a < modules_2.length ? (currentModule = modules_2[_a], containerModuleHelpers = getHelpers(currentModule.id), 
        [ 4, currentModule.registry(containerModuleHelpers.bindFunction, containerModuleHelpers.unbindFunction, containerModuleHelpers.isboundFunction, containerModuleHelpers.rebindFunction, containerModuleHelpers.unbindAsyncFunction, containerModuleHelpers.onActivationFunction, containerModuleHelpers.onDeactivationFunction) ]) : [ 3, 4 ];

       case 2:
        _b.sent(), _b.label = 3;

       case 3:
        return _a++, [ 3, 1 ];

       case 4:
        return [ 2 ];
       }
      }));
     }));
    }, Container.prototype.unload = function() {
     for (var _this = this, modules = [], _i = 0; _i < arguments.length; _i++) modules[_i] = arguments[_i];
     modules.forEach((function(module) {
      var deactivations = _this._removeModuleBindings(module.id);
      _this._deactivateSingletons(deactivations), _this._removeModuleHandlers(module.id);
     }));
    }, Container.prototype.unloadAsync = function() {
     for (var modules = [], _i = 0; _i < arguments.length; _i++) modules[_i] = arguments[_i];
     return container_awaiter(this, void 0, void 0, (function() {
      var _a, modules_3, module_1, deactivations;
      return container_generator(this, (function(_b) {
       switch (_b.label) {
       case 0:
        _a = 0, modules_3 = modules, _b.label = 1;

       case 1:
        return _a < modules_3.length ? (module_1 = modules_3[_a], deactivations = this._removeModuleBindings(module_1.id), 
        [ 4, this._deactivateSingletonsAsync(deactivations) ]) : [ 3, 4 ];

       case 2:
        _b.sent(), this._removeModuleHandlers(module_1.id), _b.label = 3;

       case 3:
        return _a++, [ 3, 1 ];

       case 4:
        return [ 2 ];
       }
      }));
     }));
    }, Container.prototype.bind = function(serviceIdentifier) {
     var scope = this.options.defaultScope || BindingScopeEnum.Transient, binding = new Binding(serviceIdentifier, scope);
     return this._bindingDictionary.add(serviceIdentifier, binding), new BindingToSyntax(binding);
    }, Container.prototype.rebind = function(serviceIdentifier) {
     return this.unbind(serviceIdentifier), this.bind(serviceIdentifier);
    }, Container.prototype.rebindAsync = function(serviceIdentifier) {
     return container_awaiter(this, void 0, void 0, (function() {
      return container_generator(this, (function(_a) {
       switch (_a.label) {
       case 0:
        return [ 4, this.unbindAsync(serviceIdentifier) ];

       case 1:
        return _a.sent(), [ 2, this.bind(serviceIdentifier) ];
       }
      }));
     }));
    }, Container.prototype.unbind = function(serviceIdentifier) {
     if (this._bindingDictionary.hasKey(serviceIdentifier)) {
      var bindings = this._bindingDictionary.get(serviceIdentifier);
      this._deactivateSingletons(bindings);
     }
     this._removeServiceFromDictionary(serviceIdentifier);
    }, Container.prototype.unbindAsync = function(serviceIdentifier) {
     return container_awaiter(this, void 0, void 0, (function() {
      var bindings;
      return container_generator(this, (function(_a) {
       switch (_a.label) {
       case 0:
        return this._bindingDictionary.hasKey(serviceIdentifier) ? (bindings = this._bindingDictionary.get(serviceIdentifier), 
        [ 4, this._deactivateSingletonsAsync(bindings) ]) : [ 3, 2 ];

       case 1:
        _a.sent(), _a.label = 2;

       case 2:
        return this._removeServiceFromDictionary(serviceIdentifier), [ 2 ];
       }
      }));
     }));
    }, Container.prototype.unbindAll = function() {
     var _this = this;
     this._bindingDictionary.traverse((function(_key, value) {
      _this._deactivateSingletons(value);
     })), this._bindingDictionary = new Lookup;
    }, Container.prototype.unbindAllAsync = function() {
     return container_awaiter(this, void 0, void 0, (function() {
      var promises, _this = this;
      return container_generator(this, (function(_a) {
       switch (_a.label) {
       case 0:
        return promises = [], this._bindingDictionary.traverse((function(_key, value) {
         promises.push(_this._deactivateSingletonsAsync(value));
        })), [ 4, Promise.all(promises) ];

       case 1:
        return _a.sent(), this._bindingDictionary = new Lookup, [ 2 ];
       }
      }));
     }));
    }, Container.prototype.onActivation = function(serviceIdentifier, onActivation) {
     this._activations.add(serviceIdentifier, onActivation);
    }, Container.prototype.onDeactivation = function(serviceIdentifier, onDeactivation) {
     this._deactivations.add(serviceIdentifier, onDeactivation);
    }, Container.prototype.isBound = function(serviceIdentifier) {
     var bound = this._bindingDictionary.hasKey(serviceIdentifier);
     return !bound && this.parent && (bound = this.parent.isBound(serviceIdentifier)), 
     bound;
    }, Container.prototype.isCurrentBound = function(serviceIdentifier) {
     return this._bindingDictionary.hasKey(serviceIdentifier);
    }, Container.prototype.isBoundNamed = function(serviceIdentifier, named) {
     return this.isBoundTagged(serviceIdentifier, NAMED_TAG, named);
    }, Container.prototype.isBoundTagged = function(serviceIdentifier, key, value) {
     var bound = !1;
     if (this._bindingDictionary.hasKey(serviceIdentifier)) {
      var bindings = this._bindingDictionary.get(serviceIdentifier), request_1 = function(container, serviceIdentifier, key, value) {
       var target = new Target(TargetTypeEnum.Variable, "", serviceIdentifier, new Metadata(key, value)), context = new Context(container);
       return new Request(serviceIdentifier, context, null, [], target);
      }(this, serviceIdentifier, key, value);
      bound = bindings.some((function(b) {
       return b.constraint(request_1);
      }));
     }
     return !bound && this.parent && (bound = this.parent.isBoundTagged(serviceIdentifier, key, value)), 
     bound;
    }, Container.prototype.snapshot = function() {
     this._snapshots.push(ContainerSnapshot.of(this._bindingDictionary.clone(), this._middleware, this._activations.clone(), this._deactivations.clone(), this._moduleActivationStore.clone()));
    }, Container.prototype.restore = function() {
     var snapshot = this._snapshots.pop();
     if (void 0 === snapshot) throw new Error("No snapshot available to restore.");
     this._bindingDictionary = snapshot.bindings, this._activations = snapshot.activations, 
     this._deactivations = snapshot.deactivations, this._middleware = snapshot.middleware, 
     this._moduleActivationStore = snapshot.moduleActivationStore;
    }, Container.prototype.createChild = function(containerOptions) {
     var child = new Container(containerOptions || this.options);
     return child.parent = this, child;
    }, Container.prototype.applyMiddleware = function() {
     for (var middlewares = [], _i = 0; _i < arguments.length; _i++) middlewares[_i] = arguments[_i];
     var initial = this._middleware ? this._middleware : this._planAndResolve();
     this._middleware = middlewares.reduce((function(prev, curr) {
      return curr(prev);
     }), initial);
    }, Container.prototype.applyCustomMetadataReader = function(metadataReader) {
     this._metadataReader = metadataReader;
    }, Container.prototype.get = function(serviceIdentifier) {
     var getArgs = this._getNotAllArgs(serviceIdentifier, !1);
     return this._getButThrowIfAsync(getArgs);
    }, Container.prototype.getAsync = function(serviceIdentifier) {
     return container_awaiter(this, void 0, void 0, (function() {
      var getArgs;
      return container_generator(this, (function(_a) {
       return getArgs = this._getNotAllArgs(serviceIdentifier, !1), [ 2, this._get(getArgs) ];
      }));
     }));
    }, Container.prototype.getTagged = function(serviceIdentifier, key, value) {
     var getArgs = this._getNotAllArgs(serviceIdentifier, !1, key, value);
     return this._getButThrowIfAsync(getArgs);
    }, Container.prototype.getTaggedAsync = function(serviceIdentifier, key, value) {
     return container_awaiter(this, void 0, void 0, (function() {
      var getArgs;
      return container_generator(this, (function(_a) {
       return getArgs = this._getNotAllArgs(serviceIdentifier, !1, key, value), [ 2, this._get(getArgs) ];
      }));
     }));
    }, Container.prototype.getNamed = function(serviceIdentifier, named) {
     return this.getTagged(serviceIdentifier, NAMED_TAG, named);
    }, Container.prototype.getNamedAsync = function(serviceIdentifier, named) {
     return this.getTaggedAsync(serviceIdentifier, NAMED_TAG, named);
    }, Container.prototype.getAll = function(serviceIdentifier) {
     var getArgs = this._getAllArgs(serviceIdentifier);
     return this._getButThrowIfAsync(getArgs);
    }, Container.prototype.getAllAsync = function(serviceIdentifier) {
     var getArgs = this._getAllArgs(serviceIdentifier);
     return this._getAll(getArgs);
    }, Container.prototype.getAllTagged = function(serviceIdentifier, key, value) {
     var getArgs = this._getNotAllArgs(serviceIdentifier, !0, key, value);
     return this._getButThrowIfAsync(getArgs);
    }, Container.prototype.getAllTaggedAsync = function(serviceIdentifier, key, value) {
     var getArgs = this._getNotAllArgs(serviceIdentifier, !0, key, value);
     return this._getAll(getArgs);
    }, Container.prototype.getAllNamed = function(serviceIdentifier, named) {
     return this.getAllTagged(serviceIdentifier, NAMED_TAG, named);
    }, Container.prototype.getAllNamedAsync = function(serviceIdentifier, named) {
     return this.getAllTaggedAsync(serviceIdentifier, NAMED_TAG, named);
    }, Container.prototype.resolve = function(constructorFunction) {
     var isBound = this.isBound(constructorFunction);
     isBound || this.bind(constructorFunction).toSelf();
     var resolved = this.get(constructorFunction);
     return isBound || this.unbind(constructorFunction), resolved;
    }, Container.prototype._preDestroy = function(constructor, instance) {
     var _a, _b;
     if (Reflect.hasMetadata(PRE_DESTROY, constructor)) return null === (_b = (_a = instance)[Reflect.getMetadata(PRE_DESTROY, constructor).value]) || void 0 === _b ? void 0 : _b.call(_a);
    }, Container.prototype._removeModuleHandlers = function(moduleId) {
     var moduleActivationsHandlers = this._moduleActivationStore.remove(moduleId);
     this._activations.removeIntersection(moduleActivationsHandlers.onActivations), this._deactivations.removeIntersection(moduleActivationsHandlers.onDeactivations);
    }, Container.prototype._removeModuleBindings = function(moduleId) {
     return this._bindingDictionary.removeByCondition((function(binding) {
      return binding.moduleId === moduleId;
     }));
    }, Container.prototype._deactivate = function(binding, instance) {
     var _this = this, constructor = Object.getPrototypeOf(instance).constructor;
     try {
      if (this._deactivations.hasKey(binding.serviceIdentifier)) {
       var result = this._deactivateContainer(instance, this._deactivations.get(binding.serviceIdentifier).values());
       if (isPromise(result)) return this._handleDeactivationError(result.then((function() {
        return _this._propagateContainerDeactivationThenBindingAndPreDestroyAsync(binding, instance, constructor);
       })), constructor);
      }
      var propagateDeactivationResult = this._propagateContainerDeactivationThenBindingAndPreDestroy(binding, instance, constructor);
      if (isPromise(propagateDeactivationResult)) return this._handleDeactivationError(propagateDeactivationResult, constructor);
     } catch (ex) {
      if (ex instanceof Error) throw new Error(ON_DEACTIVATION_ERROR(constructor.name, ex.message));
     }
    }, Container.prototype._handleDeactivationError = function(asyncResult, constructor) {
     return container_awaiter(this, void 0, void 0, (function() {
      var ex_1;
      return container_generator(this, (function(_a) {
       switch (_a.label) {
       case 0:
        return _a.trys.push([ 0, 2, , 3 ]), [ 4, asyncResult ];

       case 1:
        return _a.sent(), [ 3, 3 ];

       case 2:
        if ((ex_1 = _a.sent()) instanceof Error) throw new Error(ON_DEACTIVATION_ERROR(constructor.name, ex_1.message));
        return [ 3, 3 ];

       case 3:
        return [ 2 ];
       }
      }));
     }));
    }, Container.prototype._deactivateContainer = function(instance, deactivationsIterator) {
     for (var _this = this, deactivation = deactivationsIterator.next(); deactivation.value; ) {
      var result = deactivation.value(instance);
      if (isPromise(result)) return result.then((function() {
       return _this._deactivateContainerAsync(instance, deactivationsIterator);
      }));
      deactivation = deactivationsIterator.next();
     }
    }, Container.prototype._deactivateContainerAsync = function(instance, deactivationsIterator) {
     return container_awaiter(this, void 0, void 0, (function() {
      var deactivation;
      return container_generator(this, (function(_a) {
       switch (_a.label) {
       case 0:
        deactivation = deactivationsIterator.next(), _a.label = 1;

       case 1:
        return deactivation.value ? [ 4, deactivation.value(instance) ] : [ 3, 3 ];

       case 2:
        return _a.sent(), deactivation = deactivationsIterator.next(), [ 3, 1 ];

       case 3:
        return [ 2 ];
       }
      }));
     }));
    }, Container.prototype._getContainerModuleHelpersFactory = function() {
     var _this = this, setModuleId = function(bindingToSyntax, moduleId) {
      bindingToSyntax._binding.moduleId = moduleId;
     }, getRebindFunction = function(moduleId) {
      return function(serviceIdentifier) {
       var bindingToSyntax = _this.rebind(serviceIdentifier);
       return setModuleId(bindingToSyntax, moduleId), bindingToSyntax;
      };
     }, getOnActivationFunction = function(moduleId) {
      return function(serviceIdentifier, onActivation) {
       _this._moduleActivationStore.addActivation(moduleId, serviceIdentifier, onActivation), 
       _this.onActivation(serviceIdentifier, onActivation);
      };
     }, getOnDeactivationFunction = function(moduleId) {
      return function(serviceIdentifier, onDeactivation) {
       _this._moduleActivationStore.addDeactivation(moduleId, serviceIdentifier, onDeactivation), 
       _this.onDeactivation(serviceIdentifier, onDeactivation);
      };
     };
     return function(mId) {
      return {
       bindFunction: (moduleId = mId, function(serviceIdentifier) {
        var bindingToSyntax = _this.bind(serviceIdentifier);
        return setModuleId(bindingToSyntax, moduleId), bindingToSyntax;
       }),
       isboundFunction: function(serviceIdentifier) {
        return _this.isBound(serviceIdentifier);
       },
       onActivationFunction: getOnActivationFunction(mId),
       onDeactivationFunction: getOnDeactivationFunction(mId),
       rebindFunction: getRebindFunction(mId),
       unbindFunction: function(serviceIdentifier) {
        return _this.unbind(serviceIdentifier);
       },
       unbindAsyncFunction: function(serviceIdentifier) {
        return _this.unbindAsync(serviceIdentifier);
       }
      };
      var moduleId;
     };
    }, Container.prototype._getAll = function(getArgs) {
     return Promise.all(this._get(getArgs));
    }, Container.prototype._get = function(getArgs) {
     var planAndResolveArgs = container_assign(container_assign({}, getArgs), {
      contextInterceptor: function(context) {
       return context;
      },
      targetType: TargetTypeEnum.Variable
     });
     if (this._middleware) {
      var middlewareResult = this._middleware(planAndResolveArgs);
      if (null == middlewareResult) throw new Error("Invalid return type in middleware. Middleware must return!");
      return middlewareResult;
     }
     return this._planAndResolve()(planAndResolveArgs);
    }, Container.prototype._getButThrowIfAsync = function(getArgs) {
     var result = this._get(getArgs);
     if (isPromiseOrContainsPromise(result)) throw new Error("You are attempting to construct '" + getArgs.serviceIdentifier + "' in a synchronous way\n but it has asynchronous dependencies.");
     return result;
    }, Container.prototype._getAllArgs = function(serviceIdentifier) {
     return {
      avoidConstraints: !0,
      isMultiInject: !0,
      serviceIdentifier
     };
    }, Container.prototype._getNotAllArgs = function(serviceIdentifier, isMultiInject, key, value) {
     return {
      avoidConstraints: !1,
      isMultiInject,
      serviceIdentifier,
      key,
      value
     };
    }, Container.prototype._planAndResolve = function() {
     var _this = this;
     return function(args) {
      var context = plan(_this._metadataReader, _this, args.isMultiInject, args.targetType, args.serviceIdentifier, args.key, args.value, args.avoidConstraints);
      return function(context) {
       return _resolveRequest(context.plan.rootRequest.requestScope)(context.plan.rootRequest);
      }(context = args.contextInterceptor(context));
     };
    }, Container.prototype._deactivateIfSingleton = function(binding) {
     var _this = this;
     if (binding.activated) return isPromise(binding.cache) ? binding.cache.then((function(resolved) {
      return _this._deactivate(binding, resolved);
     })) : this._deactivate(binding, binding.cache);
    }, Container.prototype._deactivateSingletons = function(bindings) {
     for (var _i = 0, bindings_1 = bindings; _i < bindings_1.length; _i++) {
      var binding = bindings_1[_i];
      if (isPromise(this._deactivateIfSingleton(binding))) throw new Error("Attempting to unbind dependency with asynchronous destruction (@preDestroy or onDeactivation)");
     }
    }, Container.prototype._deactivateSingletonsAsync = function(bindings) {
     return container_awaiter(this, void 0, void 0, (function() {
      var _this = this;
      return container_generator(this, (function(_a) {
       switch (_a.label) {
       case 0:
        return [ 4, Promise.all(bindings.map((function(b) {
         return _this._deactivateIfSingleton(b);
        }))) ];

       case 1:
        return _a.sent(), [ 2 ];
       }
      }));
     }));
    }, Container.prototype._propagateContainerDeactivationThenBindingAndPreDestroy = function(binding, instance, constructor) {
     return this.parent ? this._deactivate.bind(this.parent)(binding, instance) : this._bindingDeactivationAndPreDestroy(binding, instance, constructor);
    }, Container.prototype._propagateContainerDeactivationThenBindingAndPreDestroyAsync = function(binding, instance, constructor) {
     return container_awaiter(this, void 0, void 0, (function() {
      return container_generator(this, (function(_a) {
       switch (_a.label) {
       case 0:
        return this.parent ? [ 4, this._deactivate.bind(this.parent)(binding, instance) ] : [ 3, 2 ];

       case 1:
        return _a.sent(), [ 3, 4 ];

       case 2:
        return [ 4, this._bindingDeactivationAndPreDestroyAsync(binding, instance, constructor) ];

       case 3:
        _a.sent(), _a.label = 4;

       case 4:
        return [ 2 ];
       }
      }));
     }));
    }, Container.prototype._removeServiceFromDictionary = function(serviceIdentifier) {
     try {
      this._bindingDictionary.remove(serviceIdentifier);
     } catch (e) {
      throw new Error("Could not unbind serviceIdentifier: " + getServiceIdentifierAsString(serviceIdentifier));
     }
    }, Container.prototype._bindingDeactivationAndPreDestroy = function(binding, instance, constructor) {
     var _this = this;
     if ("function" == typeof binding.onDeactivation) {
      var result = binding.onDeactivation(instance);
      if (isPromise(result)) return result.then((function() {
       return _this._preDestroy(constructor, instance);
      }));
     }
     return this._preDestroy(constructor, instance);
    }, Container.prototype._bindingDeactivationAndPreDestroyAsync = function(binding, instance, constructor) {
     return container_awaiter(this, void 0, void 0, (function() {
      return container_generator(this, (function(_a) {
       switch (_a.label) {
       case 0:
        return "function" != typeof binding.onDeactivation ? [ 3, 2 ] : [ 4, binding.onDeactivation(instance) ];

       case 1:
        _a.sent(), _a.label = 2;

       case 2:
        return [ 4, this._preDestroy(constructor, instance) ];

       case 3:
        return _a.sent(), [ 2 ];
       }
      }));
     }));
    }, Container;
   }(), ContainerModule = function(registry) {
    this.id = id(), this.registry = registry;
   }, AsyncContainerModule = function(registry) {
    this.id = id(), this.registry = registry;
   };
   function tagParameter(annotationTarget, parameterName, parameterIndex, metadata) {
    !function(parameterName) {
     if (void 0 !== parameterName) throw new Error(INVALID_DECORATOR_OPERATION);
    }(parameterName), _tagParameterOrProperty(TAGGED, annotationTarget, parameterIndex.toString(), metadata);
   }
   function _ensureNoMetadataKeyDuplicates(metadata) {
    var metadatas = [];
    if (Array.isArray(metadata)) {
     var duplicate = function(array) {
      for (var seenValues = new Set, _i = 0, array_1 = array; _i < array_1.length; _i++) {
       var entry = array_1[_i];
       if (seenValues.has(entry)) return entry;
       seenValues.add(entry);
      }
     }((metadatas = metadata).map((function(md) {
      return md.key;
     })));
     if (void 0 !== duplicate) throw new Error(DUPLICATED_METADATA + " " + duplicate.toString());
    } else metadatas = [ metadata ];
    return metadatas;
   }
   function _tagParameterOrProperty(metadataKey, annotationTarget, key, metadata) {
    var metadatas = _ensureNoMetadataKeyDuplicates(metadata), paramsOrPropertiesMetadata = {};
    Reflect.hasOwnMetadata(metadataKey, annotationTarget) && (paramsOrPropertiesMetadata = Reflect.getMetadata(metadataKey, annotationTarget));
    var paramOrPropertyMetadata = paramsOrPropertiesMetadata[key];
    if (void 0 === paramOrPropertyMetadata) paramOrPropertyMetadata = []; else for (var _loop_1 = function(m) {
     if (metadatas.some((function(md) {
      return md.key === m.key;
     }))) throw new Error(DUPLICATED_METADATA + " " + m.key.toString());
    }, _i = 0, paramOrPropertyMetadata_1 = paramOrPropertyMetadata; _i < paramOrPropertyMetadata_1.length; _i++) {
     _loop_1(paramOrPropertyMetadata_1[_i]);
    }
    paramOrPropertyMetadata.push.apply(paramOrPropertyMetadata, metadatas), paramsOrPropertiesMetadata[key] = paramOrPropertyMetadata, 
    Reflect.defineMetadata(metadataKey, paramsOrPropertiesMetadata, annotationTarget);
   }
   function createTaggedDecorator(metadata) {
    return function(target, targetKey, indexOrPropertyDescriptor) {
     "number" == typeof indexOrPropertyDescriptor ? tagParameter(target, targetKey, indexOrPropertyDescriptor, metadata) : function(annotationTarget, propertyName, metadata) {
      if (void 0 !== annotationTarget.prototype) throw new Error(INVALID_DECORATOR_OPERATION);
      _tagParameterOrProperty(TAGGED_PROP, annotationTarget.constructor, propertyName, metadata);
     }(target, targetKey, metadata);
    };
   }
   function _decorate(decorators, target) {
    Reflect.decorate(decorators, target);
   }
   function _param(paramIndex, decorator) {
    return function(target, key) {
     decorator(target, key, paramIndex);
    };
   }
   function decorate(decorator, target, parameterIndexOrProperty) {
    "number" == typeof parameterIndexOrProperty ? _decorate([ _param(parameterIndexOrProperty, decorator) ], target) : "string" == typeof parameterIndexOrProperty ? Reflect.decorate([ decorator ], target, parameterIndexOrProperty) : _decorate([ decorator ], target);
   }
   function injectable() {
    return function(target) {
     if (Reflect.hasOwnMetadata(PARAM_TYPES, target)) throw new Error(DUPLICATED_INJECTABLE_DECORATOR);
     var types = Reflect.getMetadata(DESIGN_PARAM_TYPES, target) || [];
     return Reflect.defineMetadata(PARAM_TYPES, types, target), target;
    };
   }
   function tagged(metadataKey, metadataValue) {
    return createTaggedDecorator(new Metadata(metadataKey, metadataValue));
   }
   function named(name) {
    return createTaggedDecorator(new Metadata(NAMED_TAG, name));
   }
   function injectBase(metadataKey) {
    return function(serviceIdentifier) {
     return function(target, targetKey, indexOrPropertyDescriptor) {
      if (void 0 === serviceIdentifier) {
       var className = "function" == typeof target ? target.name : target.constructor.name;
       throw new Error("@inject called with undefined this could mean that the class " + className + " has a circular dependency problem. You can use a LazyServiceIdentifier to  overcome this limitation.");
      }
      return createTaggedDecorator(new Metadata(metadataKey, serviceIdentifier))(target, targetKey, indexOrPropertyDescriptor);
     };
    };
   }
   var inject = injectBase(INJECT_TAG);
   function optional() {
    return createTaggedDecorator(new Metadata(OPTIONAL_TAG, !0));
   }
   function unmanaged() {
    return function(target, targetKey, index) {
     tagParameter(target, targetKey, index, new Metadata(UNMANAGED_TAG, !0));
    };
   }
   var multiInject = injectBase(MULTI_INJECT_TAG);
   function targetName(name) {
    return function(target, targetKey, index) {
     tagParameter(target, targetKey, index, new Metadata(NAME_TAG, name));
    };
   }
   function propertyEventDecorator(eventKey, errorMessage) {
    return function() {
     return function(target, propertyKey) {
      var metadata = new Metadata(eventKey, propertyKey);
      if (Reflect.hasOwnMetadata(eventKey, target.constructor)) throw new Error(errorMessage);
      Reflect.defineMetadata(eventKey, metadata, target.constructor);
     };
    };
   }
   var interfaces, postConstruct = propertyEventDecorator(POST_CONSTRUCT, "Cannot apply @postConstruct decorator multiple times in the same class"), preDestroy = propertyEventDecorator(PRE_DESTROY, "Cannot apply @preDestroy decorator multiple times in the same class");
   interfaces || (interfaces = {});
   var METADATA_KEY = metadata_keys_namespaceObject;
  },
  89031: module => {
   "use strict";
   function isNumber(x) {
    return "number" == typeof x || (!!/^0x[0-9a-f]+$/i.test(x) || /^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(x));
   }
   function isConstructorOrProto(obj, key) {
    return "constructor" === key && "function" == typeof obj[key] || "__proto__" === key;
   }
   module.exports = function(args, opts) {
    opts || (opts = {});
    var flags = {
     bools: {},
     strings: {},
     unknownFn: null
    };
    "function" == typeof opts.unknown && (flags.unknownFn = opts.unknown), "boolean" == typeof opts.boolean && opts.boolean ? flags.allBools = !0 : [].concat(opts.boolean).filter(Boolean).forEach((function(key) {
     flags.bools[key] = !0;
    }));
    var aliases = {};
    function aliasIsBoolean(key) {
     return aliases[key].some((function(x) {
      return flags.bools[x];
     }));
    }
    Object.keys(opts.alias || {}).forEach((function(key) {
     aliases[key] = [].concat(opts.alias[key]), aliases[key].forEach((function(x) {
      aliases[x] = [ key ].concat(aliases[key].filter((function(y) {
       return x !== y;
      })));
     }));
    })), [].concat(opts.string).filter(Boolean).forEach((function(key) {
     flags.strings[key] = !0, aliases[key] && [].concat(aliases[key]).forEach((function(k) {
      flags.strings[k] = !0;
     }));
    }));
    var defaults = opts.default || {}, argv = {
     _: []
    };
    function setKey(obj, keys, value) {
     for (var o = obj, i = 0; i < keys.length - 1; i++) {
      var key = keys[i];
      if (isConstructorOrProto(o, key)) return;
      void 0 === o[key] && (o[key] = {}), o[key] !== Object.prototype && o[key] !== Number.prototype && o[key] !== String.prototype || (o[key] = {}), 
      o[key] === Array.prototype && (o[key] = []), o = o[key];
     }
     var lastKey = keys[keys.length - 1];
     isConstructorOrProto(o, lastKey) || (o !== Object.prototype && o !== Number.prototype && o !== String.prototype || (o = {}), 
     o === Array.prototype && (o = []), void 0 === o[lastKey] || flags.bools[lastKey] || "boolean" == typeof o[lastKey] ? o[lastKey] = value : Array.isArray(o[lastKey]) ? o[lastKey].push(value) : o[lastKey] = [ o[lastKey], value ]);
    }
    function setArg(key, val, arg) {
     if (!arg || !flags.unknownFn || function(key, arg) {
      return flags.allBools && /^--[^=]+$/.test(arg) || flags.strings[key] || flags.bools[key] || aliases[key];
     }(key, arg) || !1 !== flags.unknownFn(arg)) {
      var value = !flags.strings[key] && isNumber(val) ? Number(val) : val;
      setKey(argv, key.split("."), value), (aliases[key] || []).forEach((function(x) {
       setKey(argv, x.split("."), value);
      }));
     }
    }
    Object.keys(flags.bools).forEach((function(key) {
     setArg(key, void 0 !== defaults[key] && defaults[key]);
    }));
    var notFlags = [];
    -1 !== args.indexOf("--") && (notFlags = args.slice(args.indexOf("--") + 1), args = args.slice(0, args.indexOf("--")));
    for (var i = 0; i < args.length; i++) {
     var key, next, arg = args[i];
     if (/^--.+=/.test(arg)) {
      var m = arg.match(/^--([^=]+)=([\s\S]*)$/);
      key = m[1];
      var value = m[2];
      flags.bools[key] && (value = "false" !== value), setArg(key, value, arg);
     } else if (/^--no-.+/.test(arg)) setArg(key = arg.match(/^--no-(.+)/)[1], !1, arg); else if (/^--.+/.test(arg)) key = arg.match(/^--(.+)/)[1], 
     void 0 === (next = args[i + 1]) || /^(-|--)[^-]/.test(next) || flags.bools[key] || flags.allBools || aliases[key] && aliasIsBoolean(key) ? /^(true|false)$/.test(next) ? (setArg(key, "true" === next, arg), 
     i += 1) : setArg(key, !flags.strings[key] || "", arg) : (setArg(key, next, arg), 
     i += 1); else if (/^-[^-]+/.test(arg)) {
      for (var letters = arg.slice(1, -1).split(""), broken = !1, j = 0; j < letters.length; j++) if ("-" !== (next = arg.slice(j + 2))) {
       if (/[A-Za-z]/.test(letters[j]) && "=" === next[0]) {
        setArg(letters[j], next.slice(1), arg), broken = !0;
        break;
       }
       if (/[A-Za-z]/.test(letters[j]) && /-?\d+(\.\d*)?(e-?\d+)?$/.test(next)) {
        setArg(letters[j], next, arg), broken = !0;
        break;
       }
       if (letters[j + 1] && letters[j + 1].match(/\W/)) {
        setArg(letters[j], arg.slice(j + 2), arg), broken = !0;
        break;
       }
       setArg(letters[j], !flags.strings[letters[j]] || "", arg);
      } else setArg(letters[j], next, arg);
      key = arg.slice(-1)[0], broken || "-" === key || (!args[i + 1] || /^(-|--)[^-]/.test(args[i + 1]) || flags.bools[key] || aliases[key] && aliasIsBoolean(key) ? args[i + 1] && /^(true|false)$/.test(args[i + 1]) ? (setArg(key, "true" === args[i + 1], arg), 
      i += 1) : setArg(key, !flags.strings[key] || "", arg) : (setArg(key, args[i + 1], arg), 
      i += 1));
     } else if (flags.unknownFn && !1 === flags.unknownFn(arg) || argv._.push(flags.strings._ || !isNumber(arg) ? arg : Number(arg)), 
     opts.stopEarly) {
      argv._.push.apply(argv._, args.slice(i + 1));
      break;
     }
    }
    return Object.keys(defaults).forEach((function(k) {
     var obj, keys, o;
     obj = argv, keys = k.split("."), o = obj, keys.slice(0, -1).forEach((function(key) {
      o = o[key] || {};
     })), keys[keys.length - 1] in o || (setKey(argv, k.split("."), defaults[k]), (aliases[k] || []).forEach((function(x) {
      setKey(argv, x.split("."), defaults[k]);
     })));
    })), opts["--"] ? argv["--"] = notFlags.slice() : notFlags.forEach((function(k) {
     argv._.push(k);
    })), argv;
   };
  },
  25177: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    moment.defineLocale("af", {
     months: "Januarie_Februarie_Maart_April_Mei_Junie_Julie_Augustus_September_Oktober_November_Desember".split("_"),
     monthsShort: "Jan_Feb_Mrt_Apr_Mei_Jun_Jul_Aug_Sep_Okt_Nov_Des".split("_"),
     weekdays: "Sondag_Maandag_Dinsdag_Woensdag_Donderdag_Vrydag_Saterdag".split("_"),
     weekdaysShort: "Son_Maa_Din_Woe_Don_Vry_Sat".split("_"),
     weekdaysMin: "So_Ma_Di_Wo_Do_Vr_Sa".split("_"),
     meridiemParse: /vm|nm/i,
     isPM: function(input) {
      return /^nm$/i.test(input);
     },
     meridiem: function(hours, minutes, isLower) {
      return hours < 12 ? isLower ? "vm" : "VM" : isLower ? "nm" : "NM";
     },
     longDateFormat: {
      LT: "HH:mm",
      LTS: "HH:mm:ss",
      L: "DD/MM/YYYY",
      LL: "D MMMM YYYY",
      LLL: "D MMMM YYYY HH:mm",
      LLLL: "dddd, D MMMM YYYY HH:mm"
     },
     calendar: {
      sameDay: "[Vandag om] LT",
      nextDay: "[Môre om] LT",
      nextWeek: "dddd [om] LT",
      lastDay: "[Gister om] LT",
      lastWeek: "[Laas] dddd [om] LT",
      sameElse: "L"
     },
     relativeTime: {
      future: "oor %s",
      past: "%s gelede",
      s: "'n paar sekondes",
      ss: "%d sekondes",
      m: "'n minuut",
      mm: "%d minute",
      h: "'n uur",
      hh: "%d ure",
      d: "'n dag",
      dd: "%d dae",
      M: "'n maand",
      MM: "%d maande",
      y: "'n jaar",
      yy: "%d jaar"
     },
     dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
     ordinal: function(number) {
      return number + (1 === number || 8 === number || number >= 20 ? "ste" : "de");
     },
     week: {
      dow: 1,
      doy: 4
     }
    });
   }(__webpack_require__(95093));
  },
  41488: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    var pluralForm = function(n) {
     return 0 === n ? 0 : 1 === n ? 1 : 2 === n ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5;
    }, plurals = {
     s: [ "أقل من ثانية", "ثانية واحدة", [ "ثانيتان", "ثانيتين" ], "%d ثوان", "%d ثانية", "%d ثانية" ],
     m: [ "أقل من دقيقة", "دقيقة واحدة", [ "دقيقتان", "دقيقتين" ], "%d دقائق", "%d دقيقة", "%d دقيقة" ],
     h: [ "أقل من ساعة", "ساعة واحدة", [ "ساعتان", "ساعتين" ], "%d ساعات", "%d ساعة", "%d ساعة" ],
     d: [ "أقل من يوم", "يوم واحد", [ "يومان", "يومين" ], "%d أيام", "%d يومًا", "%d يوم" ],
     M: [ "أقل من شهر", "شهر واحد", [ "شهران", "شهرين" ], "%d أشهر", "%d شهرا", "%d شهر" ],
     y: [ "أقل من عام", "عام واحد", [ "عامان", "عامين" ], "%d أعوام", "%d عامًا", "%d عام" ]
    }, pluralize = function(u) {
     return function(number, withoutSuffix, string, isFuture) {
      var f = pluralForm(number), str = plurals[u][pluralForm(number)];
      return 2 === f && (str = str[withoutSuffix ? 0 : 1]), str.replace(/%d/i, number);
     };
    }, months = [ "جانفي", "فيفري", "مارس", "أفريل", "ماي", "جوان", "جويلية", "أوت", "سبتمبر", "أكتوبر", "نوفمبر", "ديسمبر" ];
    moment.defineLocale("ar-dz", {
     months,
     monthsShort: months,
     weekdays: "الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت".split("_"),
     weekdaysShort: "أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت".split("_"),
     weekdaysMin: "ح_ن_ث_ر_خ_ج_س".split("_"),
     weekdaysParseExact: !0,
     longDateFormat: {
      LT: "HH:mm",
      LTS: "HH:mm:ss",
      L: "D/‏M/‏YYYY",
      LL: "D MMMM YYYY",
      LLL: "D MMMM YYYY HH:mm",
      LLLL: "dddd D MMMM YYYY HH:mm"
     },
     meridiemParse: /ص|م/,
     isPM: function(input) {
      return "م" === input;
     },
     meridiem: function(hour, minute, isLower) {
      return hour < 12 ? "ص" : "م";
     },
     calendar: {
      sameDay: "[اليوم عند الساعة] LT",
      nextDay: "[غدًا عند الساعة] LT",
      nextWeek: "dddd [عند الساعة] LT",
      lastDay: "[أمس عند الساعة] LT",
      lastWeek: "dddd [عند الساعة] LT",
      sameElse: "L"
     },
     relativeTime: {
      future: "بعد %s",
      past: "منذ %s",
      s: pluralize("s"),
      ss: pluralize("s"),
      m: pluralize("m"),
      mm: pluralize("m"),
      h: pluralize("h"),
      hh: pluralize("h"),
      d: pluralize("d"),
      dd: pluralize("d"),
      M: pluralize("M"),
      MM: pluralize("M"),
      y: pluralize("y"),
      yy: pluralize("y")
     },
     postformat: function(string) {
      return string.replace(/,/g, "،");
     },
     week: {
      dow: 0,
      doy: 4
     }
    });
   }(__webpack_require__(95093));
  },
  58676: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    moment.defineLocale("ar-kw", {
     months: "يناير_فبراير_مارس_أبريل_ماي_يونيو_يوليوز_غشت_شتنبر_أكتوبر_نونبر_دجنبر".split("_"),
     monthsShort: "يناير_فبراير_مارس_أبريل_ماي_يونيو_يوليوز_غشت_شتنبر_أكتوبر_نونبر_دجنبر".split("_"),
     weekdays: "الأحد_الإتنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت".split("_"),
     weekdaysShort: "احد_اتنين_ثلاثاء_اربعاء_خميس_جمعة_سبت".split("_"),
     weekdaysMin: "ح_ن_ث_ر_خ_ج_س".split("_"),
     weekdaysParseExact: !0,
     longDateFormat: {
      LT: "HH:mm",
      LTS: "HH:mm:ss",
      L: "DD/MM/YYYY",
      LL: "D MMMM YYYY",
      LLL: "D MMMM YYYY HH:mm",
      LLLL: "dddd D MMMM YYYY HH:mm"
     },
     calendar: {
      sameDay: "[اليوم على الساعة] LT",
      nextDay: "[غدا على الساعة] LT",
      nextWeek: "dddd [على الساعة] LT",
      lastDay: "[أمس على الساعة] LT",
      lastWeek: "dddd [على الساعة] LT",
      sameElse: "L"
     },
     relativeTime: {
      future: "في %s",
      past: "منذ %s",
      s: "ثوان",
      ss: "%d ثانية",
      m: "دقيقة",
      mm: "%d دقائق",
      h: "ساعة",
      hh: "%d ساعات",
      d: "يوم",
      dd: "%d أيام",
      M: "شهر",
      MM: "%d أشهر",
      y: "سنة",
      yy: "%d سنوات"
     },
     week: {
      dow: 0,
      doy: 12
     }
    });
   }(__webpack_require__(95093));
  },
  42353: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    var symbolMap = {
     1: "1",
     2: "2",
     3: "3",
     4: "4",
     5: "5",
     6: "6",
     7: "7",
     8: "8",
     9: "9",
     0: "0"
    }, pluralForm = function(n) {
     return 0 === n ? 0 : 1 === n ? 1 : 2 === n ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5;
    }, plurals = {
     s: [ "أقل من ثانية", "ثانية واحدة", [ "ثانيتان", "ثانيتين" ], "%d ثوان", "%d ثانية", "%d ثانية" ],
     m: [ "أقل من دقيقة", "دقيقة واحدة", [ "دقيقتان", "دقيقتين" ], "%d دقائق", "%d دقيقة", "%d دقيقة" ],
     h: [ "أقل من ساعة", "ساعة واحدة", [ "ساعتان", "ساعتين" ], "%d ساعات", "%d ساعة", "%d ساعة" ],
     d: [ "أقل من يوم", "يوم واحد", [ "يومان", "يومين" ], "%d أيام", "%d يومًا", "%d يوم" ],
     M: [ "أقل من شهر", "شهر واحد", [ "شهران", "شهرين" ], "%d أشهر", "%d شهرا", "%d شهر" ],
     y: [ "أقل من عام", "عام واحد", [ "عامان", "عامين" ], "%d أعوام", "%d عامًا", "%d عام" ]
    }, pluralize = function(u) {
     return function(number, withoutSuffix, string, isFuture) {
      var f = pluralForm(number), str = plurals[u][pluralForm(number)];
      return 2 === f && (str = str[withoutSuffix ? 0 : 1]), str.replace(/%d/i, number);
     };
    }, months = [ "يناير", "فبراير", "مارس", "أبريل", "مايو", "يونيو", "يوليو", "أغسطس", "سبتمبر", "أكتوبر", "نوفمبر", "ديسمبر" ];
    moment.defineLocale("ar-ly", {
     months,
     monthsShort: months,
     weekdays: "الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت".split("_"),
     weekdaysShort: "أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت".split("_"),
     weekdaysMin: "ح_ن_ث_ر_خ_ج_س".split("_"),
     weekdaysParseExact: !0,
     longDateFormat: {
      LT: "HH:mm",
      LTS: "HH:mm:ss",
      L: "D/‏M/‏YYYY",
      LL: "D MMMM YYYY",
      LLL: "D MMMM YYYY HH:mm",
      LLLL: "dddd D MMMM YYYY HH:mm"
     },
     meridiemParse: /ص|م/,
     isPM: function(input) {
      return "م" === input;
     },
     meridiem: function(hour, minute, isLower) {
      return hour < 12 ? "ص" : "م";
     },
     calendar: {
      sameDay: "[اليوم عند الساعة] LT",
      nextDay: "[غدًا عند الساعة] LT",
      nextWeek: "dddd [عند الساعة] LT",
      lastDay: "[أمس عند الساعة] LT",
      lastWeek: "dddd [عند الساعة] LT",
      sameElse: "L"
     },
     relativeTime: {
      future: "بعد %s",
      past: "منذ %s",
      s: pluralize("s"),
      ss: pluralize("s"),
      m: pluralize("m"),
      mm: pluralize("m"),
      h: pluralize("h"),
      hh: pluralize("h"),
      d: pluralize("d"),
      dd: pluralize("d"),
      M: pluralize("M"),
      MM: pluralize("M"),
      y: pluralize("y"),
      yy: pluralize("y")
     },
     preparse: function(string) {
      return string.replace(/،/g, ",");
     },
     postformat: function(string) {
      return string.replace(/\d/g, (function(match) {
       return symbolMap[match];
      })).replace(/,/g, "،");
     },
     week: {
      dow: 6,
      doy: 12
     }
    });
   }(__webpack_require__(95093));
  },
  24496: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    moment.defineLocale("ar-ma", {
     months: "يناير_فبراير_مارس_أبريل_ماي_يونيو_يوليوز_غشت_شتنبر_أكتوبر_نونبر_دجنبر".split("_"),
     monthsShort: "يناير_فبراير_مارس_أبريل_ماي_يونيو_يوليوز_غشت_شتنبر_أكتوبر_نونبر_دجنبر".split("_"),
     weekdays: "الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت".split("_"),
     weekdaysShort: "احد_اثنين_ثلاثاء_اربعاء_خميس_جمعة_سبت".split("_"),
     weekdaysMin: "ح_ن_ث_ر_خ_ج_س".split("_"),
     weekdaysParseExact: !0,
     longDateFormat: {
      LT: "HH:mm",
      LTS: "HH:mm:ss",
      L: "DD/MM/YYYY",
      LL: "D MMMM YYYY",
      LLL: "D MMMM YYYY HH:mm",
      LLLL: "dddd D MMMM YYYY HH:mm"
     },
     calendar: {
      sameDay: "[اليوم على الساعة] LT",
      nextDay: "[غدا على الساعة] LT",
      nextWeek: "dddd [على الساعة] LT",
      lastDay: "[أمس على الساعة] LT",
      lastWeek: "dddd [على الساعة] LT",
      sameElse: "L"
     },
     relativeTime: {
      future: "في %s",
      past: "منذ %s",
      s: "ثوان",
      ss: "%d ثانية",
      m: "دقيقة",
      mm: "%d دقائق",
      h: "ساعة",
      hh: "%d ساعات",
      d: "يوم",
      dd: "%d أيام",
      M: "شهر",
      MM: "%d أشهر",
      y: "سنة",
      yy: "%d سنوات"
     },
     week: {
      dow: 1,
      doy: 4
     }
    });
   }(__webpack_require__(95093));
  },
  6947: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    var symbolMap = {
     1: "١",
     2: "٢",
     3: "٣",
     4: "٤",
     5: "٥",
     6: "٦",
     7: "٧",
     8: "٨",
     9: "٩",
     0: "٠"
    }, numberMap = {
     "١": "1",
     "٢": "2",
     "٣": "3",
     "٤": "4",
     "٥": "5",
     "٦": "6",
     "٧": "7",
     "٨": "8",
     "٩": "9",
     "٠": "0"
    };
    moment.defineLocale("ar-ps", {
     months: "كانون الثاني_شباط_آذار_نيسان_أيّار_حزيران_تمّوز_آب_أيلول_تشري الأوّل_تشرين الثاني_كانون الأوّل".split("_"),
     monthsShort: "ك٢_شباط_آذار_نيسان_أيّار_حزيران_تمّوز_آب_أيلول_ت١_ت٢_ك١".split("_"),
     weekdays: "الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت".split("_"),
     weekdaysShort: "أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت".split("_"),
     weekdaysMin: "ح_ن_ث_ر_خ_ج_س".split("_"),
     weekdaysParseExact: !0,
     longDateFormat: {
      LT: "HH:mm",
      LTS: "HH:mm:ss",
      L: "DD/MM/YYYY",
      LL: "D MMMM YYYY",
      LLL: "D MMMM YYYY HH:mm",
      LLLL: "dddd D MMMM YYYY HH:mm"
     },
     meridiemParse: /ص|م/,
     isPM: function(input) {
      return "م" === input;
     },
     meridiem: function(hour, minute, isLower) {
      return hour < 12 ? "ص" : "م";
     },
     calendar: {
      sameDay: "[اليوم على الساعة] LT",
      nextDay: "[غدا على الساعة] LT",
      nextWeek: "dddd [على الساعة] LT",
      lastDay: "[أمس على الساعة] LT",
      lastWeek: "dddd [على الساعة] LT",
      sameElse: "L"
     },
     relativeTime: {
      future: "في %s",
      past: "منذ %s",
      s: "ثوان",
      ss: "%d ثانية",
      m: "دقيقة",
      mm: "%d دقائق",
      h: "ساعة",
      hh: "%d ساعات",
      d: "يوم",
      dd: "%d أيام",
      M: "شهر",
      MM: "%d أشهر",
      y: "سنة",
      yy: "%d سنوات"
     },
     preparse: function(string) {
      return string.replace(/[٣٤٥٦٧٨٩٠]/g, (function(match) {
       return numberMap[match];
      })).split("").reverse().join("").replace(/[١٢](?![\u062a\u0643])/g, (function(match) {
       return numberMap[match];
      })).split("").reverse().join("").replace(/،/g, ",");
     },
     postformat: function(string) {
      return string.replace(/\d/g, (function(match) {
       return symbolMap[match];
      })).replace(/,/g, "،");
     },
     week: {
      dow: 0,
      doy: 6
     }
    });
   }(__webpack_require__(95093));
  },
  82682: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    var symbolMap = {
     1: "١",
     2: "٢",
     3: "٣",
     4: "٤",
     5: "٥",
     6: "٦",
     7: "٧",
     8: "٨",
     9: "٩",
     0: "٠"
    }, numberMap = {
     "١": "1",
     "٢": "2",
     "٣": "3",
     "٤": "4",
     "٥": "5",
     "٦": "6",
     "٧": "7",
     "٨": "8",
     "٩": "9",
     "٠": "0"
    };
    moment.defineLocale("ar-sa", {
     months: "يناير_فبراير_مارس_أبريل_مايو_يونيو_يوليو_أغسطس_سبتمبر_أكتوبر_نوفمبر_ديسمبر".split("_"),
     monthsShort: "يناير_فبراير_مارس_أبريل_مايو_يونيو_يوليو_أغسطس_سبتمبر_أكتوبر_نوفمبر_ديسمبر".split("_"),
     weekdays: "الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت".split("_"),
     weekdaysShort: "أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت".split("_"),
     weekdaysMin: "ح_ن_ث_ر_خ_ج_س".split("_"),
     weekdaysParseExact: !0,
     longDateFormat: {
      LT: "HH:mm",
      LTS: "HH:mm:ss",
      L: "DD/MM/YYYY",
      LL: "D MMMM YYYY",
      LLL: "D MMMM YYYY HH:mm",
      LLLL: "dddd D MMMM YYYY HH:mm"
     },
     meridiemParse: /ص|م/,
     isPM: function(input) {
      return "م" === input;
     },
     meridiem: function(hour, minute, isLower) {
      return hour < 12 ? "ص" : "م";
     },
     calendar: {
      sameDay: "[اليوم على الساعة] LT",
      nextDay: "[غدا على الساعة] LT",
      nextWeek: "dddd [على الساعة] LT",
      lastDay: "[أمس على الساعة] LT",
      lastWeek: "dddd [على الساعة] LT",
      sameElse: "L"
     },
     relativeTime: {
      future: "في %s",
      past: "منذ %s",
      s: "ثوان",
      ss: "%d ثانية",
      m: "دقيقة",
      mm: "%d دقائق",
      h: "ساعة",
      hh: "%d ساعات",
      d: "يوم",
      dd: "%d أيام",
      M: "شهر",
      MM: "%d أشهر",
      y: "سنة",
      yy: "%d سنوات"
     },
     preparse: function(string) {
      return string.replace(/[١٢٣٤٥٦٧٨٩٠]/g, (function(match) {
       return numberMap[match];
      })).replace(/،/g, ",");
     },
     postformat: function(string) {
      return string.replace(/\d/g, (function(match) {
       return symbolMap[match];
      })).replace(/,/g, "،");
     },
     week: {
      dow: 0,
      doy: 6
     }
    });
   }(__webpack_require__(95093));
  },
  89756: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    moment.defineLocale("ar-tn", {
     months: "جانفي_فيفري_مارس_أفريل_ماي_جوان_جويلية_أوت_سبتمبر_أكتوبر_نوفمبر_ديسمبر".split("_"),
     monthsShort: "جانفي_فيفري_مارس_أفريل_ماي_جوان_جويلية_أوت_سبتمبر_أكتوبر_نوفمبر_ديسمبر".split("_"),
     weekdays: "الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت".split("_"),
     weekdaysShort: "أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت".split("_"),
     weekdaysMin: "ح_ن_ث_ر_خ_ج_س".split("_"),
     weekdaysParseExact: !0,
     longDateFormat: {
      LT: "HH:mm",
      LTS: "HH:mm:ss",
      L: "DD/MM/YYYY",
      LL: "D MMMM YYYY",
      LLL: "D MMMM YYYY HH:mm",
      LLLL: "dddd D MMMM YYYY HH:mm"
     },
     calendar: {
      sameDay: "[اليوم على الساعة] LT",
      nextDay: "[غدا على الساعة] LT",
      nextWeek: "dddd [على الساعة] LT",
      lastDay: "[أمس على الساعة] LT",
      lastWeek: "dddd [على الساعة] LT",
      sameElse: "L"
     },
     relativeTime: {
      future: "في %s",
      past: "منذ %s",
      s: "ثوان",
      ss: "%d ثانية",
      m: "دقيقة",
      mm: "%d دقائق",
      h: "ساعة",
      hh: "%d ساعات",
      d: "يوم",
      dd: "%d أيام",
      M: "شهر",
      MM: "%d أشهر",
      y: "سنة",
      yy: "%d سنوات"
     },
     week: {
      dow: 1,
      doy: 4
     }
    });
   }(__webpack_require__(95093));
  },
  61509: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    var symbolMap = {
     1: "١",
     2: "٢",
     3: "٣",
     4: "٤",
     5: "٥",
     6: "٦",
     7: "٧",
     8: "٨",
     9: "٩",
     0: "٠"
    }, numberMap = {
     "١": "1",
     "٢": "2",
     "٣": "3",
     "٤": "4",
     "٥": "5",
     "٦": "6",
     "٧": "7",
     "٨": "8",
     "٩": "9",
     "٠": "0"
    }, pluralForm = function(n) {
     return 0 === n ? 0 : 1 === n ? 1 : 2 === n ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5;
    }, plurals = {
     s: [ "أقل من ثانية", "ثانية واحدة", [ "ثانيتان", "ثانيتين" ], "%d ثوان", "%d ثانية", "%d ثانية" ],
     m: [ "أقل من دقيقة", "دقيقة واحدة", [ "دقيقتان", "دقيقتين" ], "%d دقائق", "%d دقيقة", "%d دقيقة" ],
     h: [ "أقل من ساعة", "ساعة واحدة", [ "ساعتان", "ساعتين" ], "%d ساعات", "%d ساعة", "%d ساعة" ],
     d: [ "أقل من يوم", "يوم واحد", [ "يومان", "يومين" ], "%d أيام", "%d يومًا", "%d يوم" ],
     M: [ "أقل من شهر", "شهر واحد", [ "شهران", "شهرين" ], "%d أشهر", "%d شهرا", "%d شهر" ],
     y: [ "أقل من عام", "عام واحد", [ "عامان", "عامين" ], "%d أعوام", "%d عامًا", "%d عام" ]
    }, pluralize = function(u) {
     return function(number, withoutSuffix, string, isFuture) {
      var f = pluralForm(number), str = plurals[u][pluralForm(number)];
      return 2 === f && (str = str[withoutSuffix ? 0 : 1]), str.replace(/%d/i, number);
     };
    }, months = [ "يناير", "فبراير", "مارس", "أبريل", "مايو", "يونيو", "يوليو", "أغسطس", "سبتمبر", "أكتوبر", "نوفمبر", "ديسمبر" ];
    moment.defineLocale("ar", {
     months,
     monthsShort: months,
     weekdays: "الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت".split("_"),
     weekdaysShort: "أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت".split("_"),
     weekdaysMin: "ح_ن_ث_ر_خ_ج_س".split("_"),
     weekdaysParseExact: !0,
     longDateFormat: {
      LT: "HH:mm",
      LTS: "HH:mm:ss",
      L: "D/‏M/‏YYYY",
      LL: "D MMMM YYYY",
      LLL: "D MMMM YYYY HH:mm",
      LLLL: "dddd D MMMM YYYY HH:mm"
     },
     meridiemParse: /ص|م/,
     isPM: function(input) {
      return "م" === input;
     },
     meridiem: function(hour, minute, isLower) {
      return hour < 12 ? "ص" : "م";
     },
     calendar: {
      sameDay: "[اليوم عند الساعة] LT",
      nextDay: "[غدًا عند الساعة] LT",
      nextWeek: "dddd [عند الساعة] LT",
      lastDay: "[أمس عند الساعة] LT",
      lastWeek: "dddd [عند الساعة] LT",
      sameElse: "L"
     },
     relativeTime: {
      future: "بعد %s",
      past: "منذ %s",
      s: pluralize("s"),
      ss: pluralize("s"),
      m: pluralize("m"),
      mm: pluralize("m"),
      h: pluralize("h"),
      hh: pluralize("h"),
      d: pluralize("d"),
      dd: pluralize("d"),
      M: pluralize("M"),
      MM: pluralize("M"),
      y: pluralize("y"),
      yy: pluralize("y")
     },
     preparse: function(string) {
      return string.replace(/[١٢٣٤٥٦٧٨٩٠]/g, (function(match) {
       return numberMap[match];
      })).replace(/،/g, ",");
     },
     postformat: function(string) {
      return string.replace(/\d/g, (function(match) {
       return symbolMap[match];
      })).replace(/,/g, "،");
     },
     week: {
      dow: 6,
      doy: 12
     }
    });
   }(__webpack_require__(95093));
  },
  95533: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    var suffixes = {
     1: "-inci",
     5: "-inci",
     8: "-inci",
     70: "-inci",
     80: "-inci",
     2: "-nci",
     7: "-nci",
     20: "-nci",
     50: "-nci",
     3: "-üncü",
     4: "-üncü",
     100: "-üncü",
     6: "-ncı",
     9: "-uncu",
     10: "-uncu",
     30: "-uncu",
     60: "-ıncı",
     90: "-ıncı"
    };
    moment.defineLocale("az", {
     months: "yanvar_fevral_mart_aprel_may_iyun_iyul_avqust_sentyabr_oktyabr_noyabr_dekabr".split("_"),
     monthsShort: "yan_fev_mar_apr_may_iyn_iyl_avq_sen_okt_noy_dek".split("_"),
     weekdays: "Bazar_Bazar ertəsi_Çərşənbə axşamı_Çərşənbə_Cümə axşamı_Cümə_Şənbə".split("_"),
     weekdaysShort: "Baz_BzE_ÇAx_Çər_CAx_Cüm_Şən".split("_"),
     weekdaysMin: "Bz_BE_ÇA_Çə_CA_Cü_Şə".split("_"),
     weekdaysParseExact: !0,
     longDateFormat: {
      LT: "HH:mm",
      LTS: "HH:mm:ss",
      L: "DD.MM.YYYY",
      LL: "D MMMM YYYY",
      LLL: "D MMMM YYYY HH:mm",
      LLLL: "dddd, D MMMM YYYY HH:mm"
     },
     calendar: {
      sameDay: "[bugün saat] LT",
      nextDay: "[sabah saat] LT",
      nextWeek: "[gələn həftə] dddd [saat] LT",
      lastDay: "[dünən] LT",
      lastWeek: "[keçən həftə] dddd [saat] LT",
      sameElse: "L"
     },
     relativeTime: {
      future: "%s sonra",
      past: "%s əvvəl",
      s: "bir neçə saniyə",
      ss: "%d saniyə",
      m: "bir dəqiqə",
      mm: "%d dəqiqə",
      h: "bir saat",
      hh: "%d saat",
      d: "bir gün",
      dd: "%d gün",
      M: "bir ay",
      MM: "%d ay",
      y: "bir il",
      yy: "%d il"
     },
     meridiemParse: /gecə|səhər|gündüz|axşam/,
     isPM: function(input) {
      return /^(gündüz|axşam)$/.test(input);
     },
     meridiem: function(hour, minute, isLower) {
      return hour < 4 ? "gecə" : hour < 12 ? "səhər" : hour < 17 ? "gündüz" : "axşam";
     },
     dayOfMonthOrdinalParse: /\d{1,2}-(ıncı|inci|nci|üncü|ncı|uncu)/,
     ordinal: function(number) {
      if (0 === number) return number + "-ıncı";
      var a = number % 10, b = number % 100 - a, c = number >= 100 ? 100 : null;
      return number + (suffixes[a] || suffixes[b] || suffixes[c]);
     },
     week: {
      dow: 1,
      doy: 7
     }
    });
   }(__webpack_require__(95093));
  },
  28959: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    function plural(word, num) {
     var forms = word.split("_");
     return num % 10 == 1 && num % 100 != 11 ? forms[0] : num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2];
    }
    function relativeTimeWithPlural(number, withoutSuffix, key) {
     return "m" === key ? withoutSuffix ? "хвіліна" : "хвіліну" : "h" === key ? withoutSuffix ? "гадзіна" : "гадзіну" : number + " " + plural({
      ss: withoutSuffix ? "секунда_секунды_секунд" : "секунду_секунды_секунд",
      mm: withoutSuffix ? "хвіліна_хвіліны_хвілін" : "хвіліну_хвіліны_хвілін",
      hh: withoutSuffix ? "гадзіна_гадзіны_гадзін" : "гадзіну_гадзіны_гадзін",
      dd: "дзень_дні_дзён",
      MM: "месяц_месяцы_месяцаў",
      yy: "год_гады_гадоў"
     }[key], +number);
    }
    moment.defineLocale("be", {
     months: {
      format: "студзеня_лютага_сакавіка_красавіка_траўня_чэрвеня_ліпеня_жніўня_верасня_кастрычніка_лістапада_снежня".split("_"),
      standalone: "студзень_люты_сакавік_красавік_травень_чэрвень_ліпень_жнівень_верасень_кастрычнік_лістапад_снежань".split("_")
     },
     monthsShort: "студ_лют_сак_крас_трав_чэрв_ліп_жнів_вер_каст_ліст_снеж".split("_"),
     weekdays: {
      format: "нядзелю_панядзелак_аўторак_сераду_чацвер_пятніцу_суботу".split("_"),
      standalone: "нядзеля_панядзелак_аўторак_серада_чацвер_пятніца_субота".split("_"),
      isFormat: /\[ ?[Ууў] ?(?:мінулую|наступную)? ?\] ?dddd/
     },
     weekdaysShort: "нд_пн_ат_ср_чц_пт_сб".split("_"),
     weekdaysMin: "нд_пн_ат_ср_чц_пт_сб".split("_"),
     longDateFormat: {
      LT: "HH:mm",
      LTS: "HH:mm:ss",
      L: "DD.MM.YYYY",
      LL: "D MMMM YYYY г.",
      LLL: "D MMMM YYYY г., HH:mm",
      LLLL: "dddd, D MMMM YYYY г., HH:mm"
     },
     calendar: {
      sameDay: "[Сёння ў] LT",
      nextDay: "[Заўтра ў] LT",
      lastDay: "[Учора ў] LT",
      nextWeek: function() {
       return "[У] dddd [ў] LT";
      },
      lastWeek: function() {
       switch (this.day()) {
       case 0:
       case 3:
       case 5:
       case 6:
        return "[У мінулую] dddd [ў] LT";

       case 1:
       case 2:
       case 4:
        return "[У мінулы] dddd [ў] LT";
       }
      },
      sameElse: "L"
     },
     relativeTime: {
      future: "праз %s",
      past: "%s таму",
      s: "некалькі секунд",
      m: relativeTimeWithPlural,
      mm: relativeTimeWithPlural,
      h: relativeTimeWithPlural,
      hh: relativeTimeWithPlural,
      d: "дзень",
      dd: relativeTimeWithPlural,
      M: "месяц",
      MM: relativeTimeWithPlural,
      y: "год",
      yy: relativeTimeWithPlural
     },
     meridiemParse: /ночы|раніцы|дня|вечара/,
     isPM: function(input) {
      return /^(дня|вечара)$/.test(input);
     },
     meridiem: function(hour, minute, isLower) {
      return hour < 4 ? "ночы" : hour < 12 ? "раніцы" : hour < 17 ? "дня" : "вечара";
     },
     dayOfMonthOrdinalParse: /\d{1,2}-(і|ы|га)/,
     ordinal: function(number, period) {
      switch (period) {
      case "M":
      case "d":
      case "DDD":
      case "w":
      case "W":
       return number % 10 != 2 && number % 10 != 3 || number % 100 == 12 || number % 100 == 13 ? number + "-ы" : number + "-і";

      case "D":
       return number + "-га";

      default:
       return number;
      }
     },
     week: {
      dow: 1,
      doy: 7
     }
    });
   }(__webpack_require__(95093));
  },
  47777: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    moment.defineLocale("bg", {
     months: "януари_февруари_март_април_май_юни_юли_август_септември_октомври_ноември_декември".split("_"),
     monthsShort: "яну_фев_мар_апр_май_юни_юли_авг_сеп_окт_ное_дек".split("_"),
     weekdays: "неделя_понеделник_вторник_сряда_четвъртък_петък_събота".split("_"),
     weekdaysShort: "нед_пон_вто_сря_чет_пет_съб".split("_"),
     weekdaysMin: "нд_пн_вт_ср_чт_пт_сб".split("_"),
     longDateFormat: {
      LT: "H:mm",
      LTS: "H:mm:ss",
      L: "D.MM.YYYY",
      LL: "D MMMM YYYY",
      LLL: "D MMMM YYYY H:mm",
      LLLL: "dddd, D MMMM YYYY H:mm"
     },
     calendar: {
      sameDay: "[Днес в] LT",
      nextDay: "[Утре в] LT",
      nextWeek: "dddd [в] LT",
      lastDay: "[Вчера в] LT",
      lastWeek: function() {
       switch (this.day()) {
       case 0:
       case 3:
       case 6:
        return "[Миналата] dddd [в] LT";

       case 1:
       case 2:
       case 4:
       case 5:
        return "[Миналия] dddd [в] LT";
       }
      },
      sameElse: "L"
     },
     relativeTime: {
      future: "след %s",
      past: "преди %s",
      s: "няколко секунди",
      ss: "%d секунди",
      m: "минута",
      mm: "%d минути",
      h: "час",
      hh: "%d часа",
      d: "ден",
      dd: "%d дена",
      w: "седмица",
      ww: "%d седмици",
      M: "месец",
      MM: "%d месеца",
      y: "година",
      yy: "%d години"
     },
     dayOfMonthOrdinalParse: /\d{1,2}-(ев|ен|ти|ви|ри|ми)/,
     ordinal: function(number) {
      var lastDigit = number % 10, last2Digits = number % 100;
      return 0 === number ? number + "-ев" : 0 === last2Digits ? number + "-ен" : last2Digits > 10 && last2Digits < 20 ? number + "-ти" : 1 === lastDigit ? number + "-ви" : 2 === lastDigit ? number + "-ри" : 7 === lastDigit || 8 === lastDigit ? number + "-ми" : number + "-ти";
     },
     week: {
      dow: 1,
      doy: 7
     }
    });
   }(__webpack_require__(95093));
  },
  54903: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    moment.defineLocale("bm", {
     months: "Zanwuyekalo_Fewuruyekalo_Marisikalo_Awirilikalo_Mɛkalo_Zuwɛnkalo_Zuluyekalo_Utikalo_Sɛtanburukalo_ɔkutɔburukalo_Nowanburukalo_Desanburukalo".split("_"),
     monthsShort: "Zan_Few_Mar_Awi_Mɛ_Zuw_Zul_Uti_Sɛt_ɔku_Now_Des".split("_"),
     weekdays: "Kari_Ntɛnɛn_Tarata_Araba_Alamisa_Juma_Sibiri".split("_"),
     weekdaysShort: "Kar_Ntɛ_Tar_Ara_Ala_Jum_Sib".split("_"),
     weekdaysMin: "Ka_Nt_Ta_Ar_Al_Ju_Si".split("_"),
     longDateFormat: {
      LT: "HH:mm",
      LTS: "HH:mm:ss",
      L: "DD/MM/YYYY",
      LL: "MMMM [tile] D [san] YYYY",
      LLL: "MMMM [tile] D [san] YYYY [lɛrɛ] HH:mm",
      LLLL: "dddd MMMM [tile] D [san] YYYY [lɛrɛ] HH:mm"
     },
     calendar: {
      sameDay: "[Bi lɛrɛ] LT",
      nextDay: "[Sini lɛrɛ] LT",
      nextWeek: "dddd [don lɛrɛ] LT",
      lastDay: "[Kunu lɛrɛ] LT",
      lastWeek: "dddd [tɛmɛnen lɛrɛ] LT",
      sameElse: "L"
     },
     relativeTime: {
      future: "%s kɔnɔ",
      past: "a bɛ %s bɔ",
      s: "sanga dama dama",
      ss: "sekondi %d",
      m: "miniti kelen",
      mm: "miniti %d",
      h: "lɛrɛ kelen",
      hh: "lɛrɛ %d",
      d: "tile kelen",
      dd: "tile %d",
      M: "kalo kelen",
      MM: "kalo %d",
      y: "san kelen",
      yy: "san %d"
     },
     week: {
      dow: 1,
      doy: 4
     }
    });
   }(__webpack_require__(95093));
  },
  17357: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    var symbolMap = {
     1: "১",
     2: "২",
     3: "৩",
     4: "৪",
     5: "৫",
     6: "৬",
     7: "৭",
     8: "৮",
     9: "৯",
     0: "০"
    }, numberMap = {
     "১": "1",
     "২": "2",
     "৩": "3",
     "৪": "4",
     "৫": "5",
     "৬": "6",
     "৭": "7",
     "৮": "8",
     "৯": "9",
     "০": "0"
    };
    moment.defineLocale("bn-bd", {
     months: "জানুয়ারি_ফেব্রুয়ারি_মার্চ_এপ্রিল_মে_জুন_জুলাই_আগস্ট_সেপ্টেম্বর_অক্টোবর_নভেম্বর_ডিসেম্বর".split("_"),
     monthsShort: "জানু_ফেব্রু_মার্চ_এপ্রিল_মে_জুন_জুলাই_আগস্ট_সেপ্ট_অক্টো_নভে_ডিসে".split("_"),
     weekdays: "রবিবার_সোমবার_মঙ্গলবার_বুধবার_বৃহস্পতিবার_শুক্রবার_শনিবার".split("_"),
     weekdaysShort: "রবি_সোম_মঙ্গল_বুধ_বৃহস্পতি_শুক্র_শনি".split("_"),
     weekdaysMin: "রবি_সোম_মঙ্গল_বুধ_বৃহ_শুক্র_শনি".split("_"),
     longDateFormat: {
      LT: "A h:mm সময়",
      LTS: "A h:mm:ss সময়",
      L: "DD/MM/YYYY",
      LL: "D MMMM YYYY",
      LLL: "D MMMM YYYY, A h:mm সময়",
      LLLL: "dddd, D MMMM YYYY, A h:mm সময়"
     },
     calendar: {
      sameDay: "[আজ] LT",
      nextDay: "[আগামীকাল] LT",
      nextWeek: "dddd, LT",
      lastDay: "[গতকাল] LT",
      lastWeek: "[গত] dddd, LT",
      sameElse: "L"
     },
     relativeTime: {
      future: "%s পরে",
      past: "%s আগে",
      s: "কয়েক সেকেন্ড",
      ss: "%d সেকেন্ড",
      m: "এক মিনিট",
      mm: "%d মিনিট",
      h: "এক ঘন্টা",
      hh: "%d ঘন্টা",
      d: "এক দিন",
      dd: "%d দিন",
      M: "এক মাস",
      MM: "%d মাস",
      y: "এক বছর",
      yy: "%d বছর"
     },
     preparse: function(string) {
      return string.replace(/[১২৩৪৫৬৭৮৯০]/g, (function(match) {
       return numberMap[match];
      }));
     },
     postformat: function(string) {
      return string.replace(/\d/g, (function(match) {
       return symbolMap[match];
      }));
     },
     meridiemParse: /রাত|ভোর|সকাল|দুপুর|বিকাল|সন্ধ্যা|রাত/,
     meridiemHour: function(hour, meridiem) {
      return 12 === hour && (hour = 0), "রাত" === meridiem ? hour < 4 ? hour : hour + 12 : "ভোর" === meridiem || "সকাল" === meridiem ? hour : "দুপুর" === meridiem ? hour >= 3 ? hour : hour + 12 : "বিকাল" === meridiem || "সন্ধ্যা" === meridiem ? hour + 12 : void 0;
     },
     meridiem: function(hour, minute, isLower) {
      return hour < 4 ? "রাত" : hour < 6 ? "ভোর" : hour < 12 ? "সকাল" : hour < 15 ? "দুপুর" : hour < 18 ? "বিকাল" : hour < 20 ? "সন্ধ্যা" : "রাত";
     },
     week: {
      dow: 0,
      doy: 6
     }
    });
   }(__webpack_require__(95093));
  },
  61290: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    var symbolMap = {
     1: "১",
     2: "২",
     3: "৩",
     4: "৪",
     5: "৫",
     6: "৬",
     7: "৭",
     8: "৮",
     9: "৯",
     0: "০"
    }, numberMap = {
     "১": "1",
     "২": "2",
     "৩": "3",
     "৪": "4",
     "৫": "5",
     "৬": "6",
     "৭": "7",
     "৮": "8",
     "৯": "9",
     "০": "0"
    };
    moment.defineLocale("bn", {
     months: "জানুয়ারি_ফেব্রুয়ারি_মার্চ_এপ্রিল_মে_জুন_জুলাই_আগস্ট_সেপ্টেম্বর_অক্টোবর_নভেম্বর_ডিসেম্বর".split("_"),
     monthsShort: "জানু_ফেব্রু_মার্চ_এপ্রিল_মে_জুন_জুলাই_আগস্ট_সেপ্ট_অক্টো_নভে_ডিসে".split("_"),
     weekdays: "রবিবার_সোমবার_মঙ্গলবার_বুধবার_বৃহস্পতিবার_শুক্রবার_শনিবার".split("_"),
     weekdaysShort: "রবি_সোম_মঙ্গল_বুধ_বৃহস্পতি_শুক্র_শনি".split("_"),
     weekdaysMin: "রবি_সোম_মঙ্গল_বুধ_বৃহ_শুক্র_শনি".split("_"),
     longDateFormat: {
      LT: "A h:mm সময়",
      LTS: "A h:mm:ss সময়",
      L: "DD/MM/YYYY",
      LL: "D MMMM YYYY",
      LLL: "D MMMM YYYY, A h:mm সময়",
      LLLL: "dddd, D MMMM YYYY, A h:mm সময়"
     },
     calendar: {
      sameDay: "[আজ] LT",
      nextDay: "[আগামীকাল] LT",
      nextWeek: "dddd, LT",
      lastDay: "[গতকাল] LT",
      lastWeek: "[গত] dddd, LT",
      sameElse: "L"
     },
     relativeTime: {
      future: "%s পরে",
      past: "%s আগে",
      s: "কয়েক সেকেন্ড",
      ss: "%d সেকেন্ড",
      m: "এক মিনিট",
      mm: "%d মিনিট",
      h: "এক ঘন্টা",
      hh: "%d ঘন্টা",
      d: "এক দিন",
      dd: "%d দিন",
      M: "এক মাস",
      MM: "%d মাস",
      y: "এক বছর",
      yy: "%d বছর"
     },
     preparse: function(string) {
      return string.replace(/[১২৩৪৫৬৭৮৯০]/g, (function(match) {
       return numberMap[match];
      }));
     },
     postformat: function(string) {
      return string.replace(/\d/g, (function(match) {
       return symbolMap[match];
      }));
     },
     meridiemParse: /রাত|সকাল|দুপুর|বিকাল|রাত/,
     meridiemHour: function(hour, meridiem) {
      return 12 === hour && (hour = 0), "রাত" === meridiem && hour >= 4 || "দুপুর" === meridiem && hour < 5 || "বিকাল" === meridiem ? hour + 12 : hour;
     },
     meridiem: function(hour, minute, isLower) {
      return hour < 4 ? "রাত" : hour < 10 ? "সকাল" : hour < 17 ? "দুপুর" : hour < 20 ? "বিকাল" : "রাত";
     },
     week: {
      dow: 0,
      doy: 6
     }
    });
   }(__webpack_require__(95093));
  },
  31545: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    var symbolMap = {
     1: "༡",
     2: "༢",
     3: "༣",
     4: "༤",
     5: "༥",
     6: "༦",
     7: "༧",
     8: "༨",
     9: "༩",
     0: "༠"
    }, numberMap = {
     "༡": "1",
     "༢": "2",
     "༣": "3",
     "༤": "4",
     "༥": "5",
     "༦": "6",
     "༧": "7",
     "༨": "8",
     "༩": "9",
     "༠": "0"
    };
    moment.defineLocale("bo", {
     months: "ཟླ་བ་དང་པོ_ཟླ་བ་གཉིས་པ_ཟླ་བ་གསུམ་པ_ཟླ་བ་བཞི་པ_ཟླ་བ་ལྔ་པ_ཟླ་བ་དྲུག་པ_ཟླ་བ་བདུན་པ_ཟླ་བ་བརྒྱད་པ_ཟླ་བ་དགུ་པ_ཟླ་བ་བཅུ་པ_ཟླ་བ་བཅུ་གཅིག་པ_ཟླ་བ་བཅུ་གཉིས་པ".split("_"),
     monthsShort: "ཟླ་1_ཟླ་2_ཟླ་3_ཟླ་4_ཟླ་5_ཟླ་6_ཟླ་7_ཟླ་8_ཟླ་9_ཟླ་10_ཟླ་11_ཟླ་12".split("_"),
     monthsShortRegex: /^(ཟླ་\d{1,2})/,
     monthsParseExact: !0,
     weekdays: "གཟའ་ཉི་མ་_གཟའ་ཟླ་བ་_གཟའ་མིག་དམར་_གཟའ་ལྷག་པ་_གཟའ་ཕུར་བུ_གཟའ་པ་སངས་_གཟའ་སྤེན་པ་".split("_"),
     weekdaysShort: "ཉི་མ་_ཟླ་བ་_མིག་དམར་_ལྷག་པ་_ཕུར་བུ_པ་སངས་_སྤེན་པ་".split("_"),
     weekdaysMin: "ཉི_ཟླ_མིག_ལྷག_ཕུར_སངས_སྤེན".split("_"),
     longDateFormat: {
      LT: "A h:mm",
      LTS: "A h:mm:ss",
      L: "DD/MM/YYYY",
      LL: "D MMMM YYYY",
      LLL: "D MMMM YYYY, A h:mm",
      LLLL: "dddd, D MMMM YYYY, A h:mm"
     },
     calendar: {
      sameDay: "[དི་རིང] LT",
      nextDay: "[སང་ཉིན] LT",
      nextWeek: "[བདུན་ཕྲག་རྗེས་མ], LT",
      lastDay: "[ཁ་སང] LT",
      lastWeek: "[བདུན་ཕྲག་མཐའ་མ] dddd, LT",
      sameElse: "L"
     },
     relativeTime: {
      future: "%s ལ་",
      past: "%s སྔན་ལ",
      s: "ལམ་སང",
      ss: "%d སྐར་ཆ།",
      m: "སྐར་མ་གཅིག",
      mm: "%d སྐར་མ",
      h: "ཆུ་ཚོད་གཅིག",
      hh: "%d ཆུ་ཚོད",
      d: "ཉིན་གཅིག",
      dd: "%d ཉིན་",
      M: "ཟླ་བ་གཅིག",
      MM: "%d ཟླ་བ",
      y: "ལོ་གཅིག",
      yy: "%d ལོ"
     },
     preparse: function(string) {
      return string.replace(/[༡༢༣༤༥༦༧༨༩༠]/g, (function(match) {
       return numberMap[match];
      }));
     },
     postformat: function(string) {
      return string.replace(/\d/g, (function(match) {
       return symbolMap[match];
      }));
     },
     meridiemParse: /མཚན་མོ|ཞོགས་ཀས|ཉིན་གུང|དགོང་དག|མཚན་མོ/,
     meridiemHour: function(hour, meridiem) {
      return 12 === hour && (hour = 0), "མཚན་མོ" === meridiem && hour >= 4 || "ཉིན་གུང" === meridiem && hour < 5 || "དགོང་དག" === meridiem ? hour + 12 : hour;
     },
     meridiem: function(hour, minute, isLower) {
      return hour < 4 ? "མཚན་མོ" : hour < 10 ? "ཞོགས་ཀས" : hour < 17 ? "ཉིན་གུང" : hour < 20 ? "དགོང་དག" : "མཚན་མོ";
     },
     week: {
      dow: 0,
      doy: 6
     }
    });
   }(__webpack_require__(95093));
  },
  11470: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    function relativeTimeWithMutation(number, withoutSuffix, key) {
     return number + " " + mutation({
      mm: "munutenn",
      MM: "miz",
      dd: "devezh"
     }[key], number);
    }
    function specialMutationForYears(number) {
     switch (lastNumber(number)) {
     case 1:
     case 3:
     case 4:
     case 5:
     case 9:
      return number + " bloaz";

     default:
      return number + " vloaz";
     }
    }
    function lastNumber(number) {
     return number > 9 ? lastNumber(number % 10) : number;
    }
    function mutation(text, number) {
     return 2 === number ? softMutation(text) : text;
    }
    function softMutation(text) {
     var mutationTable = {
      m: "v",
      b: "v",
      d: "z"
     };
     return void 0 === mutationTable[text.charAt(0)] ? text : mutationTable[text.charAt(0)] + text.substring(1);
    }
    var monthsParse = [ /^gen/i, /^c[ʼ\']hwe/i, /^meu/i, /^ebr/i, /^mae/i, /^(mez|eve)/i, /^gou/i, /^eos/i, /^gwe/i, /^her/i, /^du/i, /^ker/i ], monthsRegex = /^(genver|c[ʼ\']hwevrer|meurzh|ebrel|mae|mezheven|gouere|eost|gwengolo|here|du|kerzu|gen|c[ʼ\']hwe|meu|ebr|mae|eve|gou|eos|gwe|her|du|ker)/i, monthsStrictRegex = /^(genver|c[ʼ\']hwevrer|meurzh|ebrel|mae|mezheven|gouere|eost|gwengolo|here|du|kerzu)/i, monthsShortStrictRegex = /^(gen|c[ʼ\']hwe|meu|ebr|mae|eve|gou|eos|gwe|her|du|ker)/i, fullWeekdaysParse = [ /^sul/i, /^lun/i, /^meurzh/i, /^merc[ʼ\']her/i, /^yaou/i, /^gwener/i, /^sadorn/i ], shortWeekdaysParse = [ /^Sul/i, /^Lun/i, /^Meu/i, /^Mer/i, /^Yao/i, /^Gwe/i, /^Sad/i ], minWeekdaysParse = [ /^Su/i, /^Lu/i, /^Me([^r]|$)/i, /^Mer/i, /^Ya/i, /^Gw/i, /^Sa/i ];
    moment.defineLocale("br", {
     months: "Genver_Cʼhwevrer_Meurzh_Ebrel_Mae_Mezheven_Gouere_Eost_Gwengolo_Here_Du_Kerzu".split("_"),
     monthsShort: "Gen_Cʼhwe_Meu_Ebr_Mae_Eve_Gou_Eos_Gwe_Her_Du_Ker".split("_"),
     weekdays: "Sul_Lun_Meurzh_Mercʼher_Yaou_Gwener_Sadorn".split("_"),
     weekdaysShort: "Sul_Lun_Meu_Mer_Yao_Gwe_Sad".split("_"),
     weekdaysMin: "Su_Lu_Me_Mer_Ya_Gw_Sa".split("_"),
     weekdaysParse: minWeekdaysParse,
     fullWeekdaysParse,
     shortWeekdaysParse,
     minWeekdaysParse,
     monthsRegex,
     monthsShortRegex: monthsRegex,
     monthsStrictRegex,
     monthsShortStrictRegex,
     monthsParse,
     longMonthsParse: monthsParse,
     shortMonthsParse: monthsParse,
     longDateFormat: {
      LT: "HH:mm",
      LTS: "HH:mm:ss",
      L: "DD/MM/YYYY",
      LL: "D [a viz] MMMM YYYY",
      LLL: "D [a viz] MMMM YYYY HH:mm",
      LLLL: "dddd, D [a viz] MMMM YYYY HH:mm"
     },
     calendar: {
      sameDay: "[Hiziv da] LT",
      nextDay: "[Warcʼhoazh da] LT",
      nextWeek: "dddd [da] LT",
      lastDay: "[Decʼh da] LT",
      lastWeek: "dddd [paset da] LT",
      sameElse: "L"
     },
     relativeTime: {
      future: "a-benn %s",
      past: "%s ʼzo",
      s: "un nebeud segondennoù",
      ss: "%d eilenn",
      m: "ur vunutenn",
      mm: relativeTimeWithMutation,
      h: "un eur",
      hh: "%d eur",
      d: "un devezh",
      dd: relativeTimeWithMutation,
      M: "ur miz",
      MM: relativeTimeWithMutation,
      y: "ur bloaz",
      yy: specialMutationForYears
     },
     dayOfMonthOrdinalParse: /\d{1,2}(añ|vet)/,
     ordinal: function(number) {
      return number + (1 === number ? "añ" : "vet");
     },
     week: {
      dow: 1,
      doy: 4
     },
     meridiemParse: /a.m.|g.m./,
     isPM: function(token) {
      return "g.m." === token;
     },
     meridiem: function(hour, minute, isLower) {
      return hour < 12 ? "a.m." : "g.m.";
     }
    });
   }(__webpack_require__(95093));
  },
  44429: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    function processRelativeTime(number, withoutSuffix, key, isFuture) {
     if ("m" === key) return withoutSuffix ? "jedna minuta" : isFuture ? "jednu minutu" : "jedne minute";
    }
    function translate(number, withoutSuffix, key) {
     var result = number + " ";
     switch (key) {
     case "ss":
      return result += 1 === number ? "sekunda" : 2 === number || 3 === number || 4 === number ? "sekunde" : "sekundi";

     case "mm":
      return result += 1 === number ? "minuta" : 2 === number || 3 === number || 4 === number ? "minute" : "minuta";

     case "h":
      return "jedan sat";

     case "hh":
      return result += 1 === number ? "sat" : 2 === number || 3 === number || 4 === number ? "sata" : "sati";

     case "dd":
      return result += 1 === number ? "dan" : "dana";

     case "MM":
      return result += 1 === number ? "mjesec" : 2 === number || 3 === number || 4 === number ? "mjeseca" : "mjeseci";

     case "yy":
      return result += 1 === number ? "godina" : 2 === number || 3 === number || 4 === number ? "godine" : "godina";
     }
    }
    moment.defineLocale("bs", {
     months: "januar_februar_mart_april_maj_juni_juli_august_septembar_oktobar_novembar_decembar".split("_"),
     monthsShort: "jan._feb._mar._apr._maj._jun._jul._aug._sep._okt._nov._dec.".split("_"),
     monthsParseExact: !0,
     weekdays: "nedjelja_ponedjeljak_utorak_srijeda_četvrtak_petak_subota".split("_"),
     weekdaysShort: "ned._pon._uto._sri._čet._pet._sub.".split("_"),
     weekdaysMin: "ne_po_ut_sr_če_pe_su".split("_"),
     weekdaysParseExact: !0,
     longDateFormat: {
      LT: "H:mm",
      LTS: "H:mm:ss",
      L: "DD.MM.YYYY",
      LL: "D. MMMM YYYY",
      LLL: "D. MMMM YYYY H:mm",
      LLLL: "dddd, D. MMMM YYYY H:mm"
     },
     calendar: {
      sameDay: "[danas u] LT",
      nextDay: "[sutra u] LT",
      nextWeek: function() {
       switch (this.day()) {
       case 0:
        return "[u] [nedjelju] [u] LT";

       case 3:
        return "[u] [srijedu] [u] LT";

       case 6:
        return "[u] [subotu] [u] LT";

       case 1:
       case 2:
       case 4:
       case 5:
        return "[u] dddd [u] LT";
       }
      },
      lastDay: "[jučer u] LT",
      lastWeek: function() {
       switch (this.day()) {
       case 0:
       case 3:
        return "[prošlu] dddd [u] LT";

       case 6:
        return "[prošle] [subote] [u] LT";

       case 1:
       case 2:
       case 4:
       case 5:
        return "[prošli] dddd [u] LT";
       }
      },
      sameElse: "L"
     },
     relativeTime: {
      future: "za %s",
      past: "prije %s",
      s: "par sekundi",
      ss: translate,
      m: processRelativeTime,
      mm: translate,
      h: translate,
      hh: translate,
      d: "dan",
      dd: translate,
      M: "mjesec",
      MM: translate,
      y: "godinu",
      yy: translate
     },
     dayOfMonthOrdinalParse: /\d{1,2}\./,
     ordinal: "%d.",
     week: {
      dow: 1,
      doy: 7
     }
    });
   }(__webpack_require__(95093));
  },
  7306: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    moment.defineLocale("ca", {
     months: {
      standalone: "gener_febrer_març_abril_maig_juny_juliol_agost_setembre_octubre_novembre_desembre".split("_"),
      format: "de gener_de febrer_de març_d'abril_de maig_de juny_de juliol_d'agost_de setembre_d'octubre_de novembre_de desembre".split("_"),
      isFormat: /D[oD]?(\s)+MMMM/
     },
     monthsShort: "gen._febr._març_abr._maig_juny_jul._ag._set._oct._nov._des.".split("_"),
     monthsParseExact: !0,
     weekdays: "diumenge_dilluns_dimarts_dimecres_dijous_divendres_dissabte".split("_"),
     weekdaysShort: "dg._dl._dt._dc._dj._dv._ds.".split("_"),
     weekdaysMin: "dg_dl_dt_dc_dj_dv_ds".split("_"),
     weekdaysParseExact: !0,
     longDateFormat: {
      LT: "H:mm",
      LTS: "H:mm:ss",
      L: "DD/MM/YYYY",
      LL: "D MMMM [de] YYYY",
      ll: "D MMM YYYY",
      LLL: "D MMMM [de] YYYY [a les] H:mm",
      lll: "D MMM YYYY, H:mm",
      LLLL: "dddd D MMMM [de] YYYY [a les] H:mm",
      llll: "ddd D MMM YYYY, H:mm"
     },
     calendar: {
      sameDay: function() {
       return "[avui a " + (1 !== this.hours() ? "les" : "la") + "] LT";
      },
      nextDay: function() {
       return "[demà a " + (1 !== this.hours() ? "les" : "la") + "] LT";
      },
      nextWeek: function() {
       return "dddd [a " + (1 !== this.hours() ? "les" : "la") + "] LT";
      },
      lastDay: function() {
       return "[ahir a " + (1 !== this.hours() ? "les" : "la") + "] LT";
      },
      lastWeek: function() {
       return "[el] dddd [passat a " + (1 !== this.hours() ? "les" : "la") + "] LT";
      },
      sameElse: "L"
     },
     relativeTime: {
      future: "d'aquí %s",
      past: "fa %s",
      s: "uns segons",
      ss: "%d segons",
      m: "un minut",
      mm: "%d minuts",
      h: "una hora",
      hh: "%d hores",
      d: "un dia",
      dd: "%d dies",
      M: "un mes",
      MM: "%d mesos",
      y: "un any",
      yy: "%d anys"
     },
     dayOfMonthOrdinalParse: /\d{1,2}(r|n|t|è|a)/,
     ordinal: function(number, period) {
      var output = 1 === number ? "r" : 2 === number ? "n" : 3 === number ? "r" : 4 === number ? "t" : "è";
      return "w" !== period && "W" !== period || (output = "a"), number + output;
     },
     week: {
      dow: 1,
      doy: 4
     }
    });
   }(__webpack_require__(95093));
  },
  56464: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    var months = {
     standalone: "leden_únor_březen_duben_květen_červen_červenec_srpen_září_říjen_listopad_prosinec".split("_"),
     format: "ledna_února_března_dubna_května_června_července_srpna_září_října_listopadu_prosince".split("_"),
     isFormat: /DD?[o.]?(\[[^\[\]]*\]|\s)+MMMM/
    }, monthsShort = "led_úno_bře_dub_kvě_čvn_čvc_srp_zář_říj_lis_pro".split("_"), monthsParse = [ /^led/i, /^úno/i, /^bře/i, /^dub/i, /^kvě/i, /^(čvn|červen$|června)/i, /^(čvc|červenec|července)/i, /^srp/i, /^zář/i, /^říj/i, /^lis/i, /^pro/i ], monthsRegex = /^(leden|únor|březen|duben|květen|červenec|července|červen|června|srpen|září|říjen|listopad|prosinec|led|úno|bře|dub|kvě|čvn|čvc|srp|zář|říj|lis|pro)/i;
    function plural(n) {
     return n > 1 && n < 5 && 1 != ~~(n / 10);
    }
    function translate(number, withoutSuffix, key, isFuture) {
     var result = number + " ";
     switch (key) {
     case "s":
      return withoutSuffix || isFuture ? "pár sekund" : "pár sekundami";

     case "ss":
      return withoutSuffix || isFuture ? result + (plural(number) ? "sekundy" : "sekund") : result + "sekundami";

     case "m":
      return withoutSuffix ? "minuta" : isFuture ? "minutu" : "minutou";

     case "mm":
      return withoutSuffix || isFuture ? result + (plural(number) ? "minuty" : "minut") : result + "minutami";

     case "h":
      return withoutSuffix ? "hodina" : isFuture ? "hodinu" : "hodinou";

     case "hh":
      return withoutSuffix || isFuture ? result + (plural(number) ? "hodiny" : "hodin") : result + "hodinami";

     case "d":
      return withoutSuffix || isFuture ? "den" : "dnem";

     case "dd":
      return withoutSuffix || isFuture ? result + (plural(number) ? "dny" : "dní") : result + "dny";

     case "M":
      return withoutSuffix || isFuture ? "měsíc" : "měsícem";

     case "MM":
      return withoutSuffix || isFuture ? result + (plural(number) ? "měsíce" : "měsíců") : result + "měsíci";

     case "y":
      return withoutSuffix || isFuture ? "rok" : "rokem";

     case "yy":
      return withoutSuffix || isFuture ? result + (plural(number) ? "roky" : "let") : result + "lety";
     }
    }
    moment.defineLocale("cs", {
     months,
     monthsShort,
     monthsRegex,
     monthsShortRegex: monthsRegex,
     monthsStrictRegex: /^(leden|ledna|února|únor|březen|března|duben|dubna|květen|května|červenec|července|červen|června|srpen|srpna|září|říjen|října|listopadu|listopad|prosinec|prosince)/i,
     monthsShortStrictRegex: /^(led|úno|bře|dub|kvě|čvn|čvc|srp|zář|říj|lis|pro)/i,
     monthsParse,
     longMonthsParse: monthsParse,
     shortMonthsParse: monthsParse,
     weekdays: "neděle_pondělí_úterý_středa_čtvrtek_pátek_sobota".split("_"),
     weekdaysShort: "ne_po_út_st_čt_pá_so".split("_"),
     weekdaysMin: "ne_po_út_st_čt_pá_so".split("_"),
     longDateFormat: {
      LT: "H:mm",
      LTS: "H:mm:ss",
      L: "DD.MM.YYYY",
      LL: "D. MMMM YYYY",
      LLL: "D. MMMM YYYY H:mm",
      LLLL: "dddd D. MMMM YYYY H:mm",
      l: "D. M. YYYY"
     },
     calendar: {
      sameDay: "[dnes v] LT",
      nextDay: "[zítra v] LT",
      nextWeek: function() {
       switch (this.day()) {
       case 0:
        return "[v neděli v] LT";

       case 1:
       case 2:
        return "[v] dddd [v] LT";

       case 3:
        return "[ve středu v] LT";

       case 4:
        return "[ve čtvrtek v] LT";

       case 5:
        return "[v pátek v] LT";

       case 6:
        return "[v sobotu v] LT";
       }
      },
      lastDay: "[včera v] LT",
      lastWeek: function() {
       switch (this.day()) {
       case 0:
        return "[minulou neděli v] LT";

       case 1:
       case 2:
        return "[minulé] dddd [v] LT";

       case 3:
        return "[minulou středu v] LT";

       case 4:
       case 5:
        return "[minulý] dddd [v] LT";

       case 6:
        return "[minulou sobotu v] LT";
       }
      },
      sameElse: "L"
     },
     relativeTime: {
      future: "za %s",
      past: "před %s",
      s: translate,
      ss: translate,
      m: translate,
      mm: translate,
      h: translate,
      hh: translate,
      d: translate,
      dd: translate,
      M: translate,
      MM: translate,
      y: translate,
      yy: translate
     },
     dayOfMonthOrdinalParse: /\d{1,2}\./,
     ordinal: "%d.",
     week: {
      dow: 1,
      doy: 4
     }
    });
   }(__webpack_require__(95093));
  },
  73635: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    moment.defineLocale("cv", {
     months: "кӑрлач_нарӑс_пуш_ака_май_ҫӗртме_утӑ_ҫурла_авӑн_юпа_чӳк_раштав".split("_"),
     monthsShort: "кӑр_нар_пуш_ака_май_ҫӗр_утӑ_ҫур_авн_юпа_чӳк_раш".split("_"),
     weekdays: "вырсарникун_тунтикун_ытларикун_юнкун_кӗҫнерникун_эрнекун_шӑматкун".split("_"),
     weekdaysShort: "выр_тун_ытл_юн_кӗҫ_эрн_шӑм".split("_"),
     weekdaysMin: "вр_тн_ыт_юн_кҫ_эр_шм".split("_"),
     longDateFormat: {
      LT: "HH:mm",
      LTS: "HH:mm:ss",
      L: "DD-MM-YYYY",
      LL: "YYYY [ҫулхи] MMMM [уйӑхӗн] D[-мӗшӗ]",
      LLL: "YYYY [ҫулхи] MMMM [уйӑхӗн] D[-мӗшӗ], HH:mm",
      LLLL: "dddd, YYYY [ҫулхи] MMMM [уйӑхӗн] D[-мӗшӗ], HH:mm"
     },
     calendar: {
      sameDay: "[Паян] LT [сехетре]",
      nextDay: "[Ыран] LT [сехетре]",
      lastDay: "[Ӗнер] LT [сехетре]",
      nextWeek: "[Ҫитес] dddd LT [сехетре]",
      lastWeek: "[Иртнӗ] dddd LT [сехетре]",
      sameElse: "L"
     },
     relativeTime: {
      future: function(output) {
       return output + (/сехет$/i.exec(output) ? "рен" : /ҫул$/i.exec(output) ? "тан" : "ран");
      },
      past: "%s каялла",
      s: "пӗр-ик ҫеккунт",
      ss: "%d ҫеккунт",
      m: "пӗр минут",
      mm: "%d минут",
      h: "пӗр сехет",
      hh: "%d сехет",
      d: "пӗр кун",
      dd: "%d кун",
      M: "пӗр уйӑх",
      MM: "%d уйӑх",
      y: "пӗр ҫул",
      yy: "%d ҫул"
     },
     dayOfMonthOrdinalParse: /\d{1,2}-мӗш/,
     ordinal: "%d-мӗш",
     week: {
      dow: 1,
      doy: 7
     }
    });
   }(__webpack_require__(95093));
  },
  64226: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    moment.defineLocale("cy", {
     months: "Ionawr_Chwefror_Mawrth_Ebrill_Mai_Mehefin_Gorffennaf_Awst_Medi_Hydref_Tachwedd_Rhagfyr".split("_"),
     monthsShort: "Ion_Chwe_Maw_Ebr_Mai_Meh_Gor_Aws_Med_Hyd_Tach_Rhag".split("_"),
     weekdays: "Dydd Sul_Dydd Llun_Dydd Mawrth_Dydd Mercher_Dydd Iau_Dydd Gwener_Dydd Sadwrn".split("_"),
     weekdaysShort: "Sul_Llun_Maw_Mer_Iau_Gwe_Sad".split("_"),
     weekdaysMin: "Su_Ll_Ma_Me_Ia_Gw_Sa".split("_"),
     weekdaysParseExact: !0,
     longDateFormat: {
      LT: "HH:mm",
      LTS: "HH:mm:ss",
      L: "DD/MM/YYYY",
      LL: "D MMMM YYYY",
      LLL: "D MMMM YYYY HH:mm",
      LLLL: "dddd, D MMMM YYYY HH:mm"
     },
     calendar: {
      sameDay: "[Heddiw am] LT",
      nextDay: "[Yfory am] LT",
      nextWeek: "dddd [am] LT",
      lastDay: "[Ddoe am] LT",
      lastWeek: "dddd [diwethaf am] LT",
      sameElse: "L"
     },
     relativeTime: {
      future: "mewn %s",
      past: "%s yn ôl",
      s: "ychydig eiliadau",
      ss: "%d eiliad",
      m: "munud",
      mm: "%d munud",
      h: "awr",
      hh: "%d awr",
      d: "diwrnod",
      dd: "%d diwrnod",
      M: "mis",
      MM: "%d mis",
      y: "blwyddyn",
      yy: "%d flynedd"
     },
     dayOfMonthOrdinalParse: /\d{1,2}(fed|ain|af|il|ydd|ed|eg)/,
     ordinal: function(number) {
      var output = "";
      return number > 20 ? output = 40 === number || 50 === number || 60 === number || 80 === number || 100 === number ? "fed" : "ain" : number > 0 && (output = [ "", "af", "il", "ydd", "ydd", "ed", "ed", "ed", "fed", "fed", "fed", "eg", "fed", "eg", "eg", "fed", "eg", "eg", "fed", "eg", "fed" ][number]), 
      number + output;
     },
     week: {
      dow: 1,
      doy: 4
     }
    });
   }(__webpack_require__(95093));
  },
  93601: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    moment.defineLocale("da", {
     months: "januar_februar_marts_april_maj_juni_juli_august_september_oktober_november_december".split("_"),
     monthsShort: "jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec".split("_"),
     weekdays: "søndag_mandag_tirsdag_onsdag_torsdag_fredag_lørdag".split("_"),
     weekdaysShort: "søn_man_tir_ons_tor_fre_lør".split("_"),
     weekdaysMin: "sø_ma_ti_on_to_fr_lø".split("_"),
     longDateFormat: {
      LT: "HH:mm",
      LTS: "HH:mm:ss",
      L: "DD.MM.YYYY",
      LL: "D. MMMM YYYY",
      LLL: "D. MMMM YYYY HH:mm",
      LLLL: "dddd [d.] D. MMMM YYYY [kl.] HH:mm"
     },
     calendar: {
      sameDay: "[i dag kl.] LT",
      nextDay: "[i morgen kl.] LT",
      nextWeek: "på dddd [kl.] LT",
      lastDay: "[i går kl.] LT",
      lastWeek: "[i] dddd[s kl.] LT",
      sameElse: "L"
     },
     relativeTime: {
      future: "om %s",
      past: "%s siden",
      s: "få sekunder",
      ss: "%d sekunder",
      m: "et minut",
      mm: "%d minutter",
      h: "en time",
      hh: "%d timer",
      d: "en dag",
      dd: "%d dage",
      M: "en måned",
      MM: "%d måneder",
      y: "et år",
      yy: "%d år"
     },
     dayOfMonthOrdinalParse: /\d{1,2}\./,
     ordinal: "%d.",
     week: {
      dow: 1,
      doy: 4
     }
    });
   }(__webpack_require__(95093));
  },
  26111: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    function processRelativeTime(number, withoutSuffix, key, isFuture) {
     var format = {
      m: [ "eine Minute", "einer Minute" ],
      h: [ "eine Stunde", "einer Stunde" ],
      d: [ "ein Tag", "einem Tag" ],
      dd: [ number + " Tage", number + " Tagen" ],
      w: [ "eine Woche", "einer Woche" ],
      M: [ "ein Monat", "einem Monat" ],
      MM: [ number + " Monate", number + " Monaten" ],
      y: [ "ein Jahr", "einem Jahr" ],
      yy: [ number + " Jahre", number + " Jahren" ]
     };
     return withoutSuffix ? format[key][0] : format[key][1];
    }
    moment.defineLocale("de-at", {
     months: "Jänner_Februar_März_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember".split("_"),
     monthsShort: "Jän._Feb._März_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.".split("_"),
     monthsParseExact: !0,
     weekdays: "Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag".split("_"),
     weekdaysShort: "So._Mo._Di._Mi._Do._Fr._Sa.".split("_"),
     weekdaysMin: "So_Mo_Di_Mi_Do_Fr_Sa".split("_"),
     weekdaysParseExact: !0,
     longDateFormat: {
      LT: "HH:mm",
      LTS: "HH:mm:ss",
      L: "DD.MM.YYYY",
      LL: "D. MMMM YYYY",
      LLL: "D. MMMM YYYY HH:mm",
      LLLL: "dddd, D. MMMM YYYY HH:mm"
     },
     calendar: {
      sameDay: "[heute um] LT [Uhr]",
      sameElse: "L",
      nextDay: "[morgen um] LT [Uhr]",
      nextWeek: "dddd [um] LT [Uhr]",
      lastDay: "[gestern um] LT [Uhr]",
      lastWeek: "[letzten] dddd [um] LT [Uhr]"
     },
     relativeTime: {
      future: "in %s",
      past: "vor %s",
      s: "ein paar Sekunden",
      ss: "%d Sekunden",
      m: processRelativeTime,
      mm: "%d Minuten",
      h: processRelativeTime,
      hh: "%d Stunden",
      d: processRelativeTime,
      dd: processRelativeTime,
      w: processRelativeTime,
      ww: "%d Wochen",
      M: processRelativeTime,
      MM: processRelativeTime,
      y: processRelativeTime,
      yy: processRelativeTime
     },
     dayOfMonthOrdinalParse: /\d{1,2}\./,
     ordinal: "%d.",
     week: {
      dow: 1,
      doy: 4
     }
    });
   }(__webpack_require__(95093));
  },
  54697: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    function processRelativeTime(number, withoutSuffix, key, isFuture) {
     var format = {
      m: [ "eine Minute", "einer Minute" ],
      h: [ "eine Stunde", "einer Stunde" ],
      d: [ "ein Tag", "einem Tag" ],
      dd: [ number + " Tage", number + " Tagen" ],
      w: [ "eine Woche", "einer Woche" ],
      M: [ "ein Monat", "einem Monat" ],
      MM: [ number + " Monate", number + " Monaten" ],
      y: [ "ein Jahr", "einem Jahr" ],
      yy: [ number + " Jahre", number + " Jahren" ]
     };
     return withoutSuffix ? format[key][0] : format[key][1];
    }
    moment.defineLocale("de-ch", {
     months: "Januar_Februar_März_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember".split("_"),
     monthsShort: "Jan._Feb._März_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.".split("_"),
     monthsParseExact: !0,
     weekdays: "Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag".split("_"),
     weekdaysShort: "So_Mo_Di_Mi_Do_Fr_Sa".split("_"),
     weekdaysMin: "So_Mo_Di_Mi_Do_Fr_Sa".split("_"),
     weekdaysParseExact: !0,
     longDateFormat: {
      LT: "HH:mm",
      LTS: "HH:mm:ss",
      L: "DD.MM.YYYY",
      LL: "D. MMMM YYYY",
      LLL: "D. MMMM YYYY HH:mm",
      LLLL: "dddd, D. MMMM YYYY HH:mm"
     },
     calendar: {
      sameDay: "[heute um] LT [Uhr]",
      sameElse: "L",
      nextDay: "[morgen um] LT [Uhr]",
      nextWeek: "dddd [um] LT [Uhr]",
      lastDay: "[gestern um] LT [Uhr]",
      lastWeek: "[letzten] dddd [um] LT [Uhr]"
     },
     relativeTime: {
      future: "in %s",
      past: "vor %s",
      s: "ein paar Sekunden",
      ss: "%d Sekunden",
      m: processRelativeTime,
      mm: "%d Minuten",
      h: processRelativeTime,
      hh: "%d Stunden",
      d: processRelativeTime,
      dd: processRelativeTime,
      w: processRelativeTime,
      ww: "%d Wochen",
      M: processRelativeTime,
      MM: processRelativeTime,
      y: processRelativeTime,
      yy: processRelativeTime
     },
     dayOfMonthOrdinalParse: /\d{1,2}\./,
     ordinal: "%d.",
     week: {
      dow: 1,
      doy: 4
     }
    });
   }(__webpack_require__(95093));
  },
  77853: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    function processRelativeTime(number, withoutSuffix, key, isFuture) {
     var format = {
      m: [ "eine Minute", "einer Minute" ],
      h: [ "eine Stunde", "einer Stunde" ],
      d: [ "ein Tag", "einem Tag" ],
      dd: [ number + " Tage", number + " Tagen" ],
      w: [ "eine Woche", "einer Woche" ],
      M: [ "ein Monat", "einem Monat" ],
      MM: [ number + " Monate", number + " Monaten" ],
      y: [ "ein Jahr", "einem Jahr" ],
      yy: [ number + " Jahre", number + " Jahren" ]
     };
     return withoutSuffix ? format[key][0] : format[key][1];
    }
    moment.defineLocale("de", {
     months: "Januar_Februar_März_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember".split("_"),
     monthsShort: "Jan._Feb._März_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.".split("_"),
     monthsParseExact: !0,
     weekdays: "Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag".split("_"),
     weekdaysShort: "So._Mo._Di._Mi._Do._Fr._Sa.".split("_"),
     weekdaysMin: "So_Mo_Di_Mi_Do_Fr_Sa".split("_"),
     weekdaysParseExact: !0,
     longDateFormat: {
      LT: "HH:mm",
      LTS: "HH:mm:ss",
      L: "DD.MM.YYYY",
      LL: "D. MMMM YYYY",
      LLL: "D. MMMM YYYY HH:mm",
      LLLL: "dddd, D. MMMM YYYY HH:mm"
     },
     calendar: {
      sameDay: "[heute um] LT [Uhr]",
      sameElse: "L",
      nextDay: "[morgen um] LT [Uhr]",
      nextWeek: "dddd [um] LT [Uhr]",
      lastDay: "[gestern um] LT [Uhr]",
      lastWeek: "[letzten] dddd [um] LT [Uhr]"
     },
     relativeTime: {
      future: "in %s",
      past: "vor %s",
      s: "ein paar Sekunden",
      ss: "%d Sekunden",
      m: processRelativeTime,
      mm: "%d Minuten",
      h: processRelativeTime,
      hh: "%d Stunden",
      d: processRelativeTime,
      dd: processRelativeTime,
      w: processRelativeTime,
      ww: "%d Wochen",
      M: processRelativeTime,
      MM: processRelativeTime,
      y: processRelativeTime,
      yy: processRelativeTime
     },
     dayOfMonthOrdinalParse: /\d{1,2}\./,
     ordinal: "%d.",
     week: {
      dow: 1,
      doy: 4
     }
    });
   }(__webpack_require__(95093));
  },
  60708: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    var months = [ "ޖެނުއަރީ", "ފެބްރުއަރީ", "މާރިޗު", "އޭޕްރީލު", "މޭ", "ޖޫން", "ޖުލައި", "އޯގަސްޓު", "ސެޕްޓެމްބަރު", "އޮކްޓޯބަރު", "ނޮވެމްބަރު", "ޑިސެމްބަރު" ], weekdays = [ "އާދިއްތަ", "ހޯމަ", "އަންގާރަ", "ބުދަ", "ބުރާސްފަތި", "ހުކުރު", "ހޮނިހިރު" ];
    moment.defineLocale("dv", {
     months,
     monthsShort: months,
     weekdays,
     weekdaysShort: weekdays,
     weekdaysMin: "އާދި_ހޯމަ_އަން_ބުދަ_ބުރާ_ހުކު_ހޮނި".split("_"),
     longDateFormat: {
      LT: "HH:mm",
      LTS: "HH:mm:ss",
      L: "D/M/YYYY",
      LL: "D MMMM YYYY",
      LLL: "D MMMM YYYY HH:mm",
      LLLL: "dddd D MMMM YYYY HH:mm"
     },
     meridiemParse: /މކ|މފ/,
     isPM: function(input) {
      return "މފ" === input;
     },
     meridiem: function(hour, minute, isLower) {
      return hour < 12 ? "މކ" : "މފ";
     },
     calendar: {
      sameDay: "[މިއަދު] LT",
      nextDay: "[މާދަމާ] LT",
      nextWeek: "dddd LT",
      lastDay: "[އިއްޔެ] LT",
      lastWeek: "[ފާއިތުވި] dddd LT",
      sameElse: "L"
     },
     relativeTime: {
      future: "ތެރޭގައި %s",
      past: "ކުރިން %s",
      s: "ސިކުންތުކޮޅެއް",
      ss: "d% ސިކުންތު",
      m: "މިނިޓެއް",
      mm: "މިނިޓު %d",
      h: "ގަޑިއިރެއް",
      hh: "ގަޑިއިރު %d",
      d: "ދުވަހެއް",
      dd: "ދުވަސް %d",
      M: "މަހެއް",
      MM: "މަސް %d",
      y: "އަހަރެއް",
      yy: "އަހަރު %d"
     },
     preparse: function(string) {
      return string.replace(/،/g, ",");
     },
     postformat: function(string) {
      return string.replace(/,/g, "،");
     },
     week: {
      dow: 7,
      doy: 12
     }
    });
   }(__webpack_require__(95093));
  },
  54691: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    function isFunction(input) {
     return "undefined" != typeof Function && input instanceof Function || "[object Function]" === Object.prototype.toString.call(input);
    }
    moment.defineLocale("el", {
     monthsNominativeEl: "Ιανουάριος_Φεβρουάριος_Μάρτιος_Απρίλιος_Μάιος_Ιούνιος_Ιούλιος_Αύγουστος_Σεπτέμβριος_Οκτώβριος_Νοέμβριος_Δεκέμβριος".split("_"),
     monthsGenitiveEl: "Ιανουαρίου_Φεβρουαρίου_Μαρτίου_Απριλίου_Μαΐου_Ιουνίου_Ιουλίου_Αυγούστου_Σεπτεμβρίου_Οκτωβρίου_Νοεμβρίου_Δεκεμβρίου".split("_"),
     months: function(momentToFormat, format) {
      return momentToFormat ? "string" == typeof format && /D/.test(format.substring(0, format.indexOf("MMMM"))) ? this._monthsGenitiveEl[momentToFormat.month()] : this._monthsNominativeEl[momentToFormat.month()] : this._monthsNominativeEl;
     },
     monthsShort: "Ιαν_Φεβ_Μαρ_Απρ_Μαϊ_Ιουν_Ιουλ_Αυγ_Σεπ_Οκτ_Νοε_Δεκ".split("_"),
     weekdays: "Κυριακή_Δευτέρα_Τρίτη_Τετάρτη_Πέμπτη_Παρασκευή_Σάββατο".split("_"),
     weekdaysShort: "Κυρ_Δευ_Τρι_Τετ_Πεμ_Παρ_Σαβ".split("_"),
     weekdaysMin: "Κυ_Δε_Τρ_Τε_Πε_Πα_Σα".split("_"),
     meridiem: function(hours, minutes, isLower) {
      return hours > 11 ? isLower ? "μμ" : "ΜΜ" : isLower ? "πμ" : "ΠΜ";
     },
     isPM: function(input) {
      return "μ" === (input + "").toLowerCase()[0];
     },
     meridiemParse: /[ΠΜ]\.?Μ?\.?/i,
     longDateFormat: {
      LT: "h:mm A",
      LTS: "h:mm:ss A",
      L: "DD/MM/YYYY",
      LL: "D MMMM YYYY",
      LLL: "D MMMM YYYY h:mm A",
      LLLL: "dddd, D MMMM YYYY h:mm A"
     },
     calendarEl: {
      sameDay: "[Σήμερα {}] LT",
      nextDay: "[Αύριο {}] LT",
      nextWeek: "dddd [{}] LT",
      lastDay: "[Χθες {}] LT",
      lastWeek: function() {
       return 6 === this.day() ? "[το προηγούμενο] dddd [{}] LT" : "[την προηγούμενη] dddd [{}] LT";
      },
      sameElse: "L"
     },
     calendar: function(key, mom) {
      var output = this._calendarEl[key], hours = mom && mom.hours();
      return isFunction(output) && (output = output.apply(mom)), output.replace("{}", hours % 12 == 1 ? "στη" : "στις");
     },
     relativeTime: {
      future: "σε %s",
      past: "%s πριν",
      s: "λίγα δευτερόλεπτα",
      ss: "%d δευτερόλεπτα",
      m: "ένα λεπτό",
      mm: "%d λεπτά",
      h: "μία ώρα",
      hh: "%d ώρες",
      d: "μία μέρα",
      dd: "%d μέρες",
      M: "ένας μήνας",
      MM: "%d μήνες",
      y: "ένας χρόνος",
      yy: "%d χρόνια"
     },
     dayOfMonthOrdinalParse: /\d{1,2}η/,
     ordinal: "%dη",
     week: {
      dow: 1,
      doy: 4
     }
    });
   }(__webpack_require__(95093));
  },
  53872: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    moment.defineLocale("en-au", {
     months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
     monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
     weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
     weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
     weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
     longDateFormat: {
      LT: "h:mm A",
      LTS: "h:mm:ss A",
      L: "DD/MM/YYYY",
      LL: "D MMMM YYYY",
      LLL: "D MMMM YYYY h:mm A",
      LLLL: "dddd, D MMMM YYYY h:mm A"
     },
     calendar: {
      sameDay: "[Today at] LT",
      nextDay: "[Tomorrow at] LT",
      nextWeek: "dddd [at] LT",
      lastDay: "[Yesterday at] LT",
      lastWeek: "[Last] dddd [at] LT",
      sameElse: "L"
     },
     relativeTime: {
      future: "in %s",
      past: "%s ago",
      s: "a few seconds",
      ss: "%d seconds",
      m: "a minute",
      mm: "%d minutes",
      h: "an hour",
      hh: "%d hours",
      d: "a day",
      dd: "%d days",
      M: "a month",
      MM: "%d months",
      y: "a year",
      yy: "%d years"
     },
     dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
     ordinal: function(number) {
      var b = number % 10;
      return number + (1 == ~~(number % 100 / 10) ? "th" : 1 === b ? "st" : 2 === b ? "nd" : 3 === b ? "rd" : "th");
     },
     week: {
      dow: 0,
      doy: 4
     }
    });
   }(__webpack_require__(95093));
  },
  28298: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    moment.defineLocale("en-ca", {
     months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
     monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
     weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
     weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
     weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
     longDateFormat: {
      LT: "h:mm A",
      LTS: "h:mm:ss A",
      L: "YYYY-MM-DD",
      LL: "MMMM D, YYYY",
      LLL: "MMMM D, YYYY h:mm A",
      LLLL: "dddd, MMMM D, YYYY h:mm A"
     },
     calendar: {
      sameDay: "[Today at] LT",
      nextDay: "[Tomorrow at] LT",
      nextWeek: "dddd [at] LT",
      lastDay: "[Yesterday at] LT",
      lastWeek: "[Last] dddd [at] LT",
      sameElse: "L"
     },
     relativeTime: {
      future: "in %s",
      past: "%s ago",
      s: "a few seconds",
      ss: "%d seconds",
      m: "a minute",
      mm: "%d minutes",
      h: "an hour",
      hh: "%d hours",
      d: "a day",
      dd: "%d days",
      M: "a month",
      MM: "%d months",
      y: "a year",
      yy: "%d years"
     },
     dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
     ordinal: function(number) {
      var b = number % 10;
      return number + (1 == ~~(number % 100 / 10) ? "th" : 1 === b ? "st" : 2 === b ? "nd" : 3 === b ? "rd" : "th");
     }
    });
   }(__webpack_require__(95093));
  },
  56195: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    moment.defineLocale("en-gb", {
     months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
     monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
     weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
     weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
     weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
     longDateFormat: {
      LT: "HH:mm",
      LTS: "HH:mm:ss",
      L: "DD/MM/YYYY",
      LL: "D MMMM YYYY",
      LLL: "D MMMM YYYY HH:mm",
      LLLL: "dddd, D MMMM YYYY HH:mm"
     },
     calendar: {
      sameDay: "[Today at] LT",
      nextDay: "[Tomorrow at] LT",
      nextWeek: "dddd [at] LT",
      lastDay: "[Yesterday at] LT",
      lastWeek: "[Last] dddd [at] LT",
      sameElse: "L"
     },
     relativeTime: {
      future: "in %s",
      past: "%s ago",
      s: "a few seconds",
      ss: "%d seconds",
      m: "a minute",
      mm: "%d minutes",
      h: "an hour",
      hh: "%d hours",
      d: "a day",
      dd: "%d days",
      M: "a month",
      MM: "%d months",
      y: "a year",
      yy: "%d years"
     },
     dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
     ordinal: function(number) {
      var b = number % 10;
      return number + (1 == ~~(number % 100 / 10) ? "th" : 1 === b ? "st" : 2 === b ? "nd" : 3 === b ? "rd" : "th");
     },
     week: {
      dow: 1,
      doy: 4
     }
    });
   }(__webpack_require__(95093));
  },
  66584: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    moment.defineLocale("en-ie", {
     months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
     monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
     weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
     weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
     weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
     longDateFormat: {
      LT: "HH:mm",
      LTS: "HH:mm:ss",
      L: "DD/MM/YYYY",
      LL: "D MMMM YYYY",
      LLL: "D MMMM YYYY HH:mm",
      LLLL: "dddd D MMMM YYYY HH:mm"
     },
     calendar: {
      sameDay: "[Today at] LT",
      nextDay: "[Tomorrow at] LT",
      nextWeek: "dddd [at] LT",
      lastDay: "[Yesterday at] LT",
      lastWeek: "[Last] dddd [at] LT",
      sameElse: "L"
     },
     relativeTime: {
      future: "in %s",
      past: "%s ago",
      s: "a few seconds",
      ss: "%d seconds",
      m: "a minute",
      mm: "%d minutes",
      h: "an hour",
      hh: "%d hours",
      d: "a day",
      dd: "%d days",
      M: "a month",
      MM: "%d months",
      y: "a year",
      yy: "%d years"
     },
     dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
     ordinal: function(number) {
      var b = number % 10;
      return number + (1 == ~~(number % 100 / 10) ? "th" : 1 === b ? "st" : 2 === b ? "nd" : 3 === b ? "rd" : "th");
     },
     week: {
      dow: 1,
      doy: 4
     }
    });
   }(__webpack_require__(95093));
  },
  65543: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    moment.defineLocale("en-il", {
     months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
     monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
     weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
     weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
     weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
     longDateFormat: {
      LT: "HH:mm",
      LTS: "HH:mm:ss",
      L: "DD/MM/YYYY",
      LL: "D MMMM YYYY",
      LLL: "D MMMM YYYY HH:mm",
      LLLL: "dddd, D MMMM YYYY HH:mm"
     },
     calendar: {
      sameDay: "[Today at] LT",
      nextDay: "[Tomorrow at] LT",
      nextWeek: "dddd [at] LT",
      lastDay: "[Yesterday at] LT",
      lastWeek: "[Last] dddd [at] LT",
      sameElse: "L"
     },
     relativeTime: {
      future: "in %s",
      past: "%s ago",
      s: "a few seconds",
      ss: "%d seconds",
      m: "a minute",
      mm: "%d minutes",
      h: "an hour",
      hh: "%d hours",
      d: "a day",
      dd: "%d days",
      M: "a month",
      MM: "%d months",
      y: "a year",
      yy: "%d years"
     },
     dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
     ordinal: function(number) {
      var b = number % 10;
      return number + (1 == ~~(number % 100 / 10) ? "th" : 1 === b ? "st" : 2 === b ? "nd" : 3 === b ? "rd" : "th");
     }
    });
   }(__webpack_require__(95093));
  },
  9033: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    moment.defineLocale("en-in", {
     months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
     monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
     weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
     weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
     weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
     longDateFormat: {
      LT: "h:mm A",
      LTS: "h:mm:ss A",
      L: "DD/MM/YYYY",
      LL: "D MMMM YYYY",
      LLL: "D MMMM YYYY h:mm A",
      LLLL: "dddd, D MMMM YYYY h:mm A"
     },
     calendar: {
      sameDay: "[Today at] LT",
      nextDay: "[Tomorrow at] LT",
      nextWeek: "dddd [at] LT",
      lastDay: "[Yesterday at] LT",
      lastWeek: "[Last] dddd [at] LT",
      sameElse: "L"
     },
     relativeTime: {
      future: "in %s",
      past: "%s ago",
      s: "a few seconds",
      ss: "%d seconds",
      m: "a minute",
      mm: "%d minutes",
      h: "an hour",
      hh: "%d hours",
      d: "a day",
      dd: "%d days",
      M: "a month",
      MM: "%d months",
      y: "a year",
      yy: "%d years"
     },
     dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
     ordinal: function(number) {
      var b = number % 10;
      return number + (1 == ~~(number % 100 / 10) ? "th" : 1 === b ? "st" : 2 === b ? "nd" : 3 === b ? "rd" : "th");
     },
     week: {
      dow: 0,
      doy: 6
     }
    });
   }(__webpack_require__(95093));
  },
  79402: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    moment.defineLocale("en-nz", {
     months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
     monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
     weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
     weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
     weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
     longDateFormat: {
      LT: "h:mm A",
      LTS: "h:mm:ss A",
      L: "DD/MM/YYYY",
      LL: "D MMMM YYYY",
      LLL: "D MMMM YYYY h:mm A",
      LLLL: "dddd, D MMMM YYYY h:mm A"
     },
     calendar: {
      sameDay: "[Today at] LT",
      nextDay: "[Tomorrow at] LT",
      nextWeek: "dddd [at] LT",
      lastDay: "[Yesterday at] LT",
      lastWeek: "[Last] dddd [at] LT",
      sameElse: "L"
     },
     relativeTime: {
      future: "in %s",
      past: "%s ago",
      s: "a few seconds",
      ss: "%d seconds",
      m: "a minute",
      mm: "%d minutes",
      h: "an hour",
      hh: "%d hours",
      d: "a day",
      dd: "%d days",
      M: "a month",
      MM: "%d months",
      y: "a year",
      yy: "%d years"
     },
     dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
     ordinal: function(number) {
      var b = number % 10;
      return number + (1 == ~~(number % 100 / 10) ? "th" : 1 === b ? "st" : 2 === b ? "nd" : 3 === b ? "rd" : "th");
     },
     week: {
      dow: 1,
      doy: 4
     }
    });
   }(__webpack_require__(95093));
  },
  43004: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    moment.defineLocale("en-sg", {
     months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
     monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
     weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
     weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
     weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
     longDateFormat: {
      LT: "HH:mm",
      LTS: "HH:mm:ss",
      L: "DD/MM/YYYY",
      LL: "D MMMM YYYY",
      LLL: "D MMMM YYYY HH:mm",
      LLLL: "dddd, D MMMM YYYY HH:mm"
     },
     calendar: {
      sameDay: "[Today at] LT",
      nextDay: "[Tomorrow at] LT",
      nextWeek: "dddd [at] LT",
      lastDay: "[Yesterday at] LT",
      lastWeek: "[Last] dddd [at] LT",
      sameElse: "L"
     },
     relativeTime: {
      future: "in %s",
      past: "%s ago",
      s: "a few seconds",
      ss: "%d seconds",
      m: "a minute",
      mm: "%d minutes",
      h: "an hour",
      hh: "%d hours",
      d: "a day",
      dd: "%d days",
      M: "a month",
      MM: "%d months",
      y: "a year",
      yy: "%d years"
     },
     dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
     ordinal: function(number) {
      var b = number % 10;
      return number + (1 == ~~(number % 100 / 10) ? "th" : 1 === b ? "st" : 2 === b ? "nd" : 3 === b ? "rd" : "th");
     },
     week: {
      dow: 1,
      doy: 4
     }
    });
   }(__webpack_require__(95093));
  },
  32934: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    moment.defineLocale("eo", {
     months: "januaro_februaro_marto_aprilo_majo_junio_julio_aŭgusto_septembro_oktobro_novembro_decembro".split("_"),
     monthsShort: "jan_feb_mart_apr_maj_jun_jul_aŭg_sept_okt_nov_dec".split("_"),
     weekdays: "dimanĉo_lundo_mardo_merkredo_ĵaŭdo_vendredo_sabato".split("_"),
     weekdaysShort: "dim_lun_mard_merk_ĵaŭ_ven_sab".split("_"),
     weekdaysMin: "di_lu_ma_me_ĵa_ve_sa".split("_"),
     longDateFormat: {
      LT: "HH:mm",
      LTS: "HH:mm:ss",
      L: "YYYY-MM-DD",
      LL: "[la] D[-an de] MMMM, YYYY",
      LLL: "[la] D[-an de] MMMM, YYYY HH:mm",
      LLLL: "dddd[n], [la] D[-an de] MMMM, YYYY HH:mm",
      llll: "ddd, [la] D[-an de] MMM, YYYY HH:mm"
     },
     meridiemParse: /[ap]\.t\.m/i,
     isPM: function(input) {
      return "p" === input.charAt(0).toLowerCase();
     },
     meridiem: function(hours, minutes, isLower) {
      return hours > 11 ? isLower ? "p.t.m." : "P.T.M." : isLower ? "a.t.m." : "A.T.M.";
     },
     calendar: {
      sameDay: "[Hodiaŭ je] LT",
      nextDay: "[Morgaŭ je] LT",
      nextWeek: "dddd[n je] LT",
      lastDay: "[Hieraŭ je] LT",
      lastWeek: "[pasintan] dddd[n je] LT",
      sameElse: "L"
     },
     relativeTime: {
      future: "post %s",
      past: "antaŭ %s",
      s: "kelkaj sekundoj",
      ss: "%d sekundoj",
      m: "unu minuto",
      mm: "%d minutoj",
      h: "unu horo",
      hh: "%d horoj",
      d: "unu tago",
      dd: "%d tagoj",
      M: "unu monato",
      MM: "%d monatoj",
      y: "unu jaro",
      yy: "%d jaroj"
     },
     dayOfMonthOrdinalParse: /\d{1,2}a/,
     ordinal: "%da",
     week: {
      dow: 1,
      doy: 7
     }
    });
   }(__webpack_require__(95093));
  },
  20838: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    var monthsShortDot = "ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.".split("_"), monthsShort = "ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic".split("_"), monthsParse = [ /^ene/i, /^feb/i, /^mar/i, /^abr/i, /^may/i, /^jun/i, /^jul/i, /^ago/i, /^sep/i, /^oct/i, /^nov/i, /^dic/i ], monthsRegex = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;
    moment.defineLocale("es-do", {
     months: "enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre".split("_"),
     monthsShort: function(m, format) {
      return m ? /-MMM-/.test(format) ? monthsShort[m.month()] : monthsShortDot[m.month()] : monthsShortDot;
     },
     monthsRegex,
     monthsShortRegex: monthsRegex,
     monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
     monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
     monthsParse,
     longMonthsParse: monthsParse,
     shortMonthsParse: monthsParse,
     weekdays: "domingo_lunes_martes_miércoles_jueves_viernes_sábado".split("_"),
     weekdaysShort: "dom._lun._mar._mié._jue._vie._sáb.".split("_"),
     weekdaysMin: "do_lu_ma_mi_ju_vi_sá".split("_"),
     weekdaysParseExact: !0,
     longDateFormat: {
      LT: "h:mm A",
      LTS: "h:mm:ss A",
      L: "DD/MM/YYYY",
      LL: "D [de] MMMM [de] YYYY",
      LLL: "D [de] MMMM [de] YYYY h:mm A",
      LLLL: "dddd, D [de] MMMM [de] YYYY h:mm A"
     },
     calendar: {
      sameDay: function() {
       return "[hoy a la" + (1 !== this.hours() ? "s" : "") + "] LT";
      },
      nextDay: function() {
       return "[mañana a la" + (1 !== this.hours() ? "s" : "") + "] LT";
      },
      nextWeek: function() {
       return "dddd [a la" + (1 !== this.hours() ? "s" : "") + "] LT";
      },
      lastDay: function() {
       return "[ayer a la" + (1 !== this.hours() ? "s" : "") + "] LT";
      },
      lastWeek: function() {
       return "[el] dddd [pasado a la" + (1 !== this.hours() ? "s" : "") + "] LT";
      },
      sameElse: "L"
     },
     relativeTime: {
      future: "en %s",
      past: "hace %s",
      s: "unos segundos",
      ss: "%d segundos",
      m: "un minuto",
      mm: "%d minutos",
      h: "una hora",
      hh: "%d horas",
      d: "un día",
      dd: "%d días",
      w: "una semana",
      ww: "%d semanas",
      M: "un mes",
      MM: "%d meses",
      y: "un año",
      yy: "%d años"
     },
     dayOfMonthOrdinalParse: /\d{1,2}º/,
     ordinal: "%dº",
     week: {
      dow: 1,
      doy: 4
     }
    });
   }(__webpack_require__(95093));
  },
  17730: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    var monthsShortDot = "ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.".split("_"), monthsShort = "ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic".split("_"), monthsParse = [ /^ene/i, /^feb/i, /^mar/i, /^abr/i, /^may/i, /^jun/i, /^jul/i, /^ago/i, /^sep/i, /^oct/i, /^nov/i, /^dic/i ], monthsRegex = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;
    moment.defineLocale("es-mx", {
     months: "enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre".split("_"),
     monthsShort: function(m, format) {
      return m ? /-MMM-/.test(format) ? monthsShort[m.month()] : monthsShortDot[m.month()] : monthsShortDot;
     },
     monthsRegex,
     monthsShortRegex: monthsRegex,
     monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
     monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
     monthsParse,
     longMonthsParse: monthsParse,
     shortMonthsParse: monthsParse,
     weekdays: "domingo_lunes_martes_miércoles_jueves_viernes_sábado".split("_"),
     weekdaysShort: "dom._lun._mar._mié._jue._vie._sáb.".split("_"),
     weekdaysMin: "do_lu_ma_mi_ju_vi_sá".split("_"),
     weekdaysParseExact: !0,
     longDateFormat: {
      LT: "H:mm",
      LTS: "H:mm:ss",
      L: "DD/MM/YYYY",
      LL: "D [de] MMMM [de] YYYY",
      LLL: "D [de] MMMM [de] YYYY H:mm",
      LLLL: "dddd, D [de] MMMM [de] YYYY H:mm"
     },
     calendar: {
      sameDay: function() {
       return "[hoy a la" + (1 !== this.hours() ? "s" : "") + "] LT";
      },
      nextDay: function() {
       return "[mañana a la" + (1 !== this.hours() ? "s" : "") + "] LT";
      },
      nextWeek: function() {
       return "dddd [a la" + (1 !== this.hours() ? "s" : "") + "] LT";
      },
      lastDay: function() {
       return "[ayer a la" + (1 !== this.hours() ? "s" : "") + "] LT";
      },
      lastWeek: function() {
       return "[el] dddd [pasado a la" + (1 !== this.hours() ? "s" : "") + "] LT";
      },
      sameElse: "L"
     },
     relativeTime: {
      future: "en %s",
      past: "hace %s",
      s: "unos segundos",
      ss: "%d segundos",
      m: "un minuto",
      mm: "%d minutos",
      h: "una hora",
      hh: "%d horas",
      d: "un día",
      dd: "%d días",
      w: "una semana",
      ww: "%d semanas",
      M: "un mes",
      MM: "%d meses",
      y: "un año",
      yy: "%d años"
     },
     dayOfMonthOrdinalParse: /\d{1,2}º/,
     ordinal: "%dº",
     week: {
      dow: 0,
      doy: 4
     },
     invalidDate: "Fecha inválida"
    });
   }(__webpack_require__(95093));
  },
  56575: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    var monthsShortDot = "ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.".split("_"), monthsShort = "ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic".split("_"), monthsParse = [ /^ene/i, /^feb/i, /^mar/i, /^abr/i, /^may/i, /^jun/i, /^jul/i, /^ago/i, /^sep/i, /^oct/i, /^nov/i, /^dic/i ], monthsRegex = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;
    moment.defineLocale("es-us", {
     months: "enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre".split("_"),
     monthsShort: function(m, format) {
      return m ? /-MMM-/.test(format) ? monthsShort[m.month()] : monthsShortDot[m.month()] : monthsShortDot;
     },
     monthsRegex,
     monthsShortRegex: monthsRegex,
     monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
     monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
     monthsParse,
     longMonthsParse: monthsParse,
     shortMonthsParse: monthsParse,
     weekdays: "domingo_lunes_martes_miércoles_jueves_viernes_sábado".split("_"),
     weekdaysShort: "dom._lun._mar._mié._jue._vie._sáb.".split("_"),
     weekdaysMin: "do_lu_ma_mi_ju_vi_sá".split("_"),
     weekdaysParseExact: !0,
     longDateFormat: {
      LT: "h:mm A",
      LTS: "h:mm:ss A",
      L: "MM/DD/YYYY",
      LL: "D [de] MMMM [de] YYYY",
      LLL: "D [de] MMMM [de] YYYY h:mm A",
      LLLL: "dddd, D [de] MMMM [de] YYYY h:mm A"
     },
     calendar: {
      sameDay: function() {
       return "[hoy a la" + (1 !== this.hours() ? "s" : "") + "] LT";
      },
      nextDay: function() {
       return "[mañana a la" + (1 !== this.hours() ? "s" : "") + "] LT";
      },
      nextWeek: function() {
       return "dddd [a la" + (1 !== this.hours() ? "s" : "") + "] LT";
      },
      lastDay: function() {
       return "[ayer a la" + (1 !== this.hours() ? "s" : "") + "] LT";
      },
      lastWeek: function() {
       return "[el] dddd [pasado a la" + (1 !== this.hours() ? "s" : "") + "] LT";
      },
      sameElse: "L"
     },
     relativeTime: {
      future: "en %s",
      past: "hace %s",
      s: "unos segundos",
      ss: "%d segundos",
      m: "un minuto",
      mm: "%d minutos",
      h: "una hora",
      hh: "%d horas",
      d: "un día",
      dd: "%d días",
      w: "una semana",
      ww: "%d semanas",
      M: "un mes",
      MM: "%d meses",
      y: "un año",
      yy: "%d años"
     },
     dayOfMonthOrdinalParse: /\d{1,2}º/,
     ordinal: "%dº",
     week: {
      dow: 0,
      doy: 6
     }
    });
   }(__webpack_require__(95093));
  },
  97650: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    var monthsShortDot = "ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.".split("_"), monthsShort = "ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic".split("_"), monthsParse = [ /^ene/i, /^feb/i, /^mar/i, /^abr/i, /^may/i, /^jun/i, /^jul/i, /^ago/i, /^sep/i, /^oct/i, /^nov/i, /^dic/i ], monthsRegex = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;
    moment.defineLocale("es", {
     months: "enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre".split("_"),
     monthsShort: function(m, format) {
      return m ? /-MMM-/.test(format) ? monthsShort[m.month()] : monthsShortDot[m.month()] : monthsShortDot;
     },
     monthsRegex,
     monthsShortRegex: monthsRegex,
     monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
     monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
     monthsParse,
     longMonthsParse: monthsParse,
     shortMonthsParse: monthsParse,
     weekdays: "domingo_lunes_martes_miércoles_jueves_viernes_sábado".split("_"),
     weekdaysShort: "dom._lun._mar._mié._jue._vie._sáb.".split("_"),
     weekdaysMin: "do_lu_ma_mi_ju_vi_sá".split("_"),
     weekdaysParseExact: !0,
     longDateFormat: {
      LT: "H:mm",
      LTS: "H:mm:ss",
      L: "DD/MM/YYYY",
      LL: "D [de] MMMM [de] YYYY",
      LLL: "D [de] MMMM [de] YYYY H:mm",
      LLLL: "dddd, D [de] MMMM [de] YYYY H:mm"
     },
     calendar: {
      sameDay: function() {
       return "[hoy a la" + (1 !== this.hours() ? "s" : "") + "] LT";
      },
      nextDay: function() {
       return "[mañana a la" + (1 !== this.hours() ? "s" : "") + "] LT";
      },
      nextWeek: function() {
       return "dddd [a la" + (1 !== this.hours() ? "s" : "") + "] LT";
      },
      lastDay: function() {
       return "[ayer a la" + (1 !== this.hours() ? "s" : "") + "] LT";
      },
      lastWeek: function() {
       return "[el] dddd [pasado a la" + (1 !== this.hours() ? "s" : "") + "] LT";
      },
      sameElse: "L"
     },
     relativeTime: {
      future: "en %s",
      past: "hace %s",
      s: "unos segundos",
      ss: "%d segundos",
      m: "un minuto",
      mm: "%d minutos",
      h: "una hora",
      hh: "%d horas",
      d: "un día",
      dd: "%d días",
      w: "una semana",
      ww: "%d semanas",
      M: "un mes",
      MM: "%d meses",
      y: "un año",
      yy: "%d años"
     },
     dayOfMonthOrdinalParse: /\d{1,2}º/,
     ordinal: "%dº",
     week: {
      dow: 1,
      doy: 4
     },
     invalidDate: "Fecha inválida"
    });
   }(__webpack_require__(95093));
  },
  3035: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    function processRelativeTime(number, withoutSuffix, key, isFuture) {
     var format = {
      s: [ "mõne sekundi", "mõni sekund", "paar sekundit" ],
      ss: [ number + "sekundi", number + "sekundit" ],
      m: [ "ühe minuti", "üks minut" ],
      mm: [ number + " minuti", number + " minutit" ],
      h: [ "ühe tunni", "tund aega", "üks tund" ],
      hh: [ number + " tunni", number + " tundi" ],
      d: [ "ühe päeva", "üks päev" ],
      M: [ "kuu aja", "kuu aega", "üks kuu" ],
      MM: [ number + " kuu", number + " kuud" ],
      y: [ "ühe aasta", "aasta", "üks aasta" ],
      yy: [ number + " aasta", number + " aastat" ]
     };
     return withoutSuffix ? format[key][2] ? format[key][2] : format[key][1] : isFuture ? format[key][0] : format[key][1];
    }
    moment.defineLocale("et", {
     months: "jaanuar_veebruar_märts_aprill_mai_juuni_juuli_august_september_oktoober_november_detsember".split("_"),
     monthsShort: "jaan_veebr_märts_apr_mai_juuni_juuli_aug_sept_okt_nov_dets".split("_"),
     weekdays: "pühapäev_esmaspäev_teisipäev_kolmapäev_neljapäev_reede_laupäev".split("_"),
     weekdaysShort: "P_E_T_K_N_R_L".split("_"),
     weekdaysMin: "P_E_T_K_N_R_L".split("_"),
     longDateFormat: {
      LT: "H:mm",
      LTS: "H:mm:ss",
      L: "DD.MM.YYYY",
      LL: "D. MMMM YYYY",
      LLL: "D. MMMM YYYY H:mm",
      LLLL: "dddd, D. MMMM YYYY H:mm"
     },
     calendar: {
      sameDay: "[Täna,] LT",
      nextDay: "[Homme,] LT",
      nextWeek: "[Järgmine] dddd LT",
      lastDay: "[Eile,] LT",
      lastWeek: "[Eelmine] dddd LT",
      sameElse: "L"
     },
     relativeTime: {
      future: "%s pärast",
      past: "%s tagasi",
      s: processRelativeTime,
      ss: processRelativeTime,
      m: processRelativeTime,
      mm: processRelativeTime,
      h: processRelativeTime,
      hh: processRelativeTime,
      d: processRelativeTime,
      dd: "%d päeva",
      M: processRelativeTime,
      MM: processRelativeTime,
      y: processRelativeTime,
      yy: processRelativeTime
     },
     dayOfMonthOrdinalParse: /\d{1,2}\./,
     ordinal: "%d.",
     week: {
      dow: 1,
      doy: 4
     }
    });
   }(__webpack_require__(95093));
  },
  3508: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    moment.defineLocale("eu", {
     months: "urtarrila_otsaila_martxoa_apirila_maiatza_ekaina_uztaila_abuztua_iraila_urria_azaroa_abendua".split("_"),
     monthsShort: "urt._ots._mar._api._mai._eka._uzt._abu._ira._urr._aza._abe.".split("_"),
     monthsParseExact: !0,
     weekdays: "igandea_astelehena_asteartea_asteazkena_osteguna_ostirala_larunbata".split("_"),
     weekdaysShort: "ig._al._ar._az._og._ol._lr.".split("_"),
     weekdaysMin: "ig_al_ar_az_og_ol_lr".split("_"),
     weekdaysParseExact: !0,
     longDateFormat: {
      LT: "HH:mm",
      LTS: "HH:mm:ss",
      L: "YYYY-MM-DD",
      LL: "YYYY[ko] MMMM[ren] D[a]",
      LLL: "YYYY[ko] MMMM[ren] D[a] HH:mm",
      LLLL: "dddd, YYYY[ko] MMMM[ren] D[a] HH:mm",
      l: "YYYY-M-D",
      ll: "YYYY[ko] MMM D[a]",
      lll: "YYYY[ko] MMM D[a] HH:mm",
      llll: "ddd, YYYY[ko] MMM D[a] HH:mm"
     },
     calendar: {
      sameDay: "[gaur] LT[etan]",
      nextDay: "[bihar] LT[etan]",
      nextWeek: "dddd LT[etan]",
      lastDay: "[atzo] LT[etan]",
      lastWeek: "[aurreko] dddd LT[etan]",
      sameElse: "L"
     },
     relativeTime: {
      future: "%s barru",
      past: "duela %s",
      s: "segundo batzuk",
      ss: "%d segundo",
      m: "minutu bat",
      mm: "%d minutu",
      h: "ordu bat",
      hh: "%d ordu",
      d: "egun bat",
      dd: "%d egun",
      M: "hilabete bat",
      MM: "%d hilabete",
      y: "urte bat",
      yy: "%d urte"
     },
     dayOfMonthOrdinalParse: /\d{1,2}\./,
     ordinal: "%d.",
     week: {
      dow: 1,
      doy: 7
     }
    });
   }(__webpack_require__(95093));
  },
  119: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    var symbolMap = {
     1: "۱",
     2: "۲",
     3: "۳",
     4: "۴",
     5: "۵",
     6: "۶",
     7: "۷",
     8: "۸",
     9: "۹",
     0: "۰"
    }, numberMap = {
     "۱": "1",
     "۲": "2",
     "۳": "3",
     "۴": "4",
     "۵": "5",
     "۶": "6",
     "۷": "7",
     "۸": "8",
     "۹": "9",
     "۰": "0"
    };
    moment.defineLocale("fa", {
     months: "ژانویه_فوریه_مارس_آوریل_مه_ژوئن_ژوئیه_اوت_سپتامبر_اکتبر_نوامبر_دسامبر".split("_"),
     monthsShort: "ژانویه_فوریه_مارس_آوریل_مه_ژوئن_ژوئیه_اوت_سپتامبر_اکتبر_نوامبر_دسامبر".split("_"),
     weekdays: "یک‌شنبه_دوشنبه_سه‌شنبه_چهارشنبه_پنج‌شنبه_جمعه_شنبه".split("_"),
     weekdaysShort: "یک‌شنبه_دوشنبه_سه‌شنبه_چهارشنبه_پنج‌شنبه_جمعه_شنبه".split("_"),
     weekdaysMin: "ی_د_س_چ_پ_ج_ش".split("_"),
     weekdaysParseExact: !0,
     longDateFormat: {
      LT: "HH:mm",
      LTS: "HH:mm:ss",
      L: "DD/MM/YYYY",
      LL: "D MMMM YYYY",
      LLL: "D MMMM YYYY HH:mm",
      LLLL: "dddd, D MMMM YYYY HH:mm"
     },
     meridiemParse: /قبل از ظهر|بعد از ظهر/,
     isPM: function(input) {
      return /بعد از ظهر/.test(input);
     },
     meridiem: function(hour, minute, isLower) {
      return hour < 12 ? "قبل از ظهر" : "بعد از ظهر";
     },
     calendar: {
      sameDay: "[امروز ساعت] LT",
      nextDay: "[فردا ساعت] LT",
      nextWeek: "dddd [ساعت] LT",
      lastDay: "[دیروز ساعت] LT",
      lastWeek: "dddd [پیش] [ساعت] LT",
      sameElse: "L"
     },
     relativeTime: {
      future: "در %s",
      past: "%s پیش",
      s: "چند ثانیه",
      ss: "%d ثانیه",
      m: "یک دقیقه",
      mm: "%d دقیقه",
      h: "یک ساعت",
      hh: "%d ساعت",
      d: "یک روز",
      dd: "%d روز",
      M: "یک ماه",
      MM: "%d ماه",
      y: "یک سال",
      yy: "%d سال"
     },
     preparse: function(string) {
      return string.replace(/[۰-۹]/g, (function(match) {
       return numberMap[match];
      })).replace(/،/g, ",");
     },
     postformat: function(string) {
      return string.replace(/\d/g, (function(match) {
       return symbolMap[match];
      })).replace(/,/g, "،");
     },
     dayOfMonthOrdinalParse: /\d{1,2}م/,
     ordinal: "%dم",
     week: {
      dow: 6,
      doy: 12
     }
    });
   }(__webpack_require__(95093));
  },
  90527: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    var numbersPast = "nolla yksi kaksi kolme neljä viisi kuusi seitsemän kahdeksan yhdeksän".split(" "), numbersFuture = [ "nolla", "yhden", "kahden", "kolmen", "neljän", "viiden", "kuuden", numbersPast[7], numbersPast[8], numbersPast[9] ];
    function translate(number, withoutSuffix, key, isFuture) {
     var result = "";
     switch (key) {
     case "s":
      return isFuture ? "muutaman sekunnin" : "muutama sekunti";

     case "ss":
      result = isFuture ? "sekunnin" : "sekuntia";
      break;

     case "m":
      return isFuture ? "minuutin" : "minuutti";

     case "mm":
      result = isFuture ? "minuutin" : "minuuttia";
      break;

     case "h":
      return isFuture ? "tunnin" : "tunti";

     case "hh":
      result = isFuture ? "tunnin" : "tuntia";
      break;

     case "d":
      return isFuture ? "päivän" : "päivä";

     case "dd":
      result = isFuture ? "päivän" : "päivää";
      break;

     case "M":
      return isFuture ? "kuukauden" : "kuukausi";

     case "MM":
      result = isFuture ? "kuukauden" : "kuukautta";
      break;

     case "y":
      return isFuture ? "vuoden" : "vuosi";

     case "yy":
      result = isFuture ? "vuoden" : "vuotta";
     }
     return result = verbalNumber(number, isFuture) + " " + result;
    }
    function verbalNumber(number, isFuture) {
     return number < 10 ? isFuture ? numbersFuture[number] : numbersPast[number] : number;
    }
    moment.defineLocale("fi", {
     months: "tammikuu_helmikuu_maaliskuu_huhtikuu_toukokuu_kesäkuu_heinäkuu_elokuu_syyskuu_lokakuu_marraskuu_joulukuu".split("_"),
     monthsShort: "tammi_helmi_maalis_huhti_touko_kesä_heinä_elo_syys_loka_marras_joulu".split("_"),
     weekdays: "sunnuntai_maanantai_tiistai_keskiviikko_torstai_perjantai_lauantai".split("_"),
     weekdaysShort: "su_ma_ti_ke_to_pe_la".split("_"),
     weekdaysMin: "su_ma_ti_ke_to_pe_la".split("_"),
     longDateFormat: {
      LT: "HH.mm",
      LTS: "HH.mm.ss",
      L: "DD.MM.YYYY",
      LL: "Do MMMM[ta] YYYY",
      LLL: "Do MMMM[ta] YYYY, [klo] HH.mm",
      LLLL: "dddd, Do MMMM[ta] YYYY, [klo] HH.mm",
      l: "D.M.YYYY",
      ll: "Do MMM YYYY",
      lll: "Do MMM YYYY, [klo] HH.mm",
      llll: "ddd, Do MMM YYYY, [klo] HH.mm"
     },
     calendar: {
      sameDay: "[tänään] [klo] LT",
      nextDay: "[huomenna] [klo] LT",
      nextWeek: "dddd [klo] LT",
      lastDay: "[eilen] [klo] LT",
      lastWeek: "[viime] dddd[na] [klo] LT",
      sameElse: "L"
     },
     relativeTime: {
      future: "%s päästä",
      past: "%s sitten",
      s: translate,
      ss: translate,
      m: translate,
      mm: translate,
      h: translate,
      hh: translate,
      d: translate,
      dd: translate,
      M: translate,
      MM: translate,
      y: translate,
      yy: translate
     },
     dayOfMonthOrdinalParse: /\d{1,2}\./,
     ordinal: "%d.",
     week: {
      dow: 1,
      doy: 4
     }
    });
   }(__webpack_require__(95093));
  },
  95995: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    moment.defineLocale("fil", {
     months: "Enero_Pebrero_Marso_Abril_Mayo_Hunyo_Hulyo_Agosto_Setyembre_Oktubre_Nobyembre_Disyembre".split("_"),
     monthsShort: "Ene_Peb_Mar_Abr_May_Hun_Hul_Ago_Set_Okt_Nob_Dis".split("_"),
     weekdays: "Linggo_Lunes_Martes_Miyerkules_Huwebes_Biyernes_Sabado".split("_"),
     weekdaysShort: "Lin_Lun_Mar_Miy_Huw_Biy_Sab".split("_"),
     weekdaysMin: "Li_Lu_Ma_Mi_Hu_Bi_Sab".split("_"),
     longDateFormat: {
      LT: "HH:mm",
      LTS: "HH:mm:ss",
      L: "MM/D/YYYY",
      LL: "MMMM D, YYYY",
      LLL: "MMMM D, YYYY HH:mm",
      LLLL: "dddd, MMMM DD, YYYY HH:mm"
     },
     calendar: {
      sameDay: "LT [ngayong araw]",
      nextDay: "[Bukas ng] LT",
      nextWeek: "LT [sa susunod na] dddd",
      lastDay: "LT [kahapon]",
      lastWeek: "LT [noong nakaraang] dddd",
      sameElse: "L"
     },
     relativeTime: {
      future: "sa loob ng %s",
      past: "%s ang nakalipas",
      s: "ilang segundo",
      ss: "%d segundo",
      m: "isang minuto",
      mm: "%d minuto",
      h: "isang oras",
      hh: "%d oras",
      d: "isang araw",
      dd: "%d araw",
      M: "isang buwan",
      MM: "%d buwan",
      y: "isang taon",
      yy: "%d taon"
     },
     dayOfMonthOrdinalParse: /\d{1,2}/,
     ordinal: function(number) {
      return number;
     },
     week: {
      dow: 1,
      doy: 4
     }
    });
   }(__webpack_require__(95093));
  },
  52477: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    moment.defineLocale("fo", {
     months: "januar_februar_mars_apríl_mai_juni_juli_august_september_oktober_november_desember".split("_"),
     monthsShort: "jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des".split("_"),
     weekdays: "sunnudagur_mánadagur_týsdagur_mikudagur_hósdagur_fríggjadagur_leygardagur".split("_"),
     weekdaysShort: "sun_mán_týs_mik_hós_frí_ley".split("_"),
     weekdaysMin: "su_má_tý_mi_hó_fr_le".split("_"),
     longDateFormat: {
      LT: "HH:mm",
      LTS: "HH:mm:ss",
      L: "DD/MM/YYYY",
      LL: "D MMMM YYYY",
      LLL: "D MMMM YYYY HH:mm",
      LLLL: "dddd D. MMMM, YYYY HH:mm"
     },
     calendar: {
      sameDay: "[Í dag kl.] LT",
      nextDay: "[Í morgin kl.] LT",
      nextWeek: "dddd [kl.] LT",
      lastDay: "[Í gjár kl.] LT",
      lastWeek: "[síðstu] dddd [kl] LT",
      sameElse: "L"
     },
     relativeTime: {
      future: "um %s",
      past: "%s síðani",
      s: "fá sekund",
      ss: "%d sekundir",
      m: "ein minuttur",
      mm: "%d minuttir",
      h: "ein tími",
      hh: "%d tímar",
      d: "ein dagur",
      dd: "%d dagar",
      M: "ein mánaður",
      MM: "%d mánaðir",
      y: "eitt ár",
      yy: "%d ár"
     },
     dayOfMonthOrdinalParse: /\d{1,2}\./,
     ordinal: "%d.",
     week: {
      dow: 1,
      doy: 4
     }
    });
   }(__webpack_require__(95093));
  },
  26435: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    moment.defineLocale("fr-ca", {
     months: "janvier_février_mars_avril_mai_juin_juillet_août_septembre_octobre_novembre_décembre".split("_"),
     monthsShort: "janv._févr._mars_avr._mai_juin_juil._août_sept._oct._nov._déc.".split("_"),
     monthsParseExact: !0,
     weekdays: "dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi".split("_"),
     weekdaysShort: "dim._lun._mar._mer._jeu._ven._sam.".split("_"),
     weekdaysMin: "di_lu_ma_me_je_ve_sa".split("_"),
     weekdaysParseExact: !0,
     longDateFormat: {
      LT: "HH:mm",
      LTS: "HH:mm:ss",
      L: "YYYY-MM-DD",
      LL: "D MMMM YYYY",
      LLL: "D MMMM YYYY HH:mm",
      LLLL: "dddd D MMMM YYYY HH:mm"
     },
     calendar: {
      sameDay: "[Aujourd’hui à] LT",
      nextDay: "[Demain à] LT",
      nextWeek: "dddd [à] LT",
      lastDay: "[Hier à] LT",
      lastWeek: "dddd [dernier à] LT",
      sameElse: "L"
     },
     relativeTime: {
      future: "dans %s",
      past: "il y a %s",
      s: "quelques secondes",
      ss: "%d secondes",
      m: "une minute",
      mm: "%d minutes",
      h: "une heure",
      hh: "%d heures",
      d: "un jour",
      dd: "%d jours",
      M: "un mois",
      MM: "%d mois",
      y: "un an",
      yy: "%d ans"
     },
     dayOfMonthOrdinalParse: /\d{1,2}(er|e)/,
     ordinal: function(number, period) {
      switch (period) {
      default:
      case "M":
      case "Q":
      case "D":
      case "DDD":
      case "d":
       return number + (1 === number ? "er" : "e");

      case "w":
      case "W":
       return number + (1 === number ? "re" : "e");
      }
     }
    });
   }(__webpack_require__(95093));
  },
  37892: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    moment.defineLocale("fr-ch", {
     months: "janvier_février_mars_avril_mai_juin_juillet_août_septembre_octobre_novembre_décembre".split("_"),
     monthsShort: "janv._févr._mars_avr._mai_juin_juil._août_sept._oct._nov._déc.".split("_"),
     monthsParseExact: !0,
     weekdays: "dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi".split("_"),
     weekdaysShort: "dim._lun._mar._mer._jeu._ven._sam.".split("_"),
     weekdaysMin: "di_lu_ma_me_je_ve_sa".split("_"),
     weekdaysParseExact: !0,
     longDateFormat: {
      LT: "HH:mm",
      LTS: "HH:mm:ss",
      L: "DD.MM.YYYY",
      LL: "D MMMM YYYY",
      LLL: "D MMMM YYYY HH:mm",
      LLLL: "dddd D MMMM YYYY HH:mm"
     },
     calendar: {
      sameDay: "[Aujourd’hui à] LT",
      nextDay: "[Demain à] LT",
      nextWeek: "dddd [à] LT",
      lastDay: "[Hier à] LT",
      lastWeek: "dddd [dernier à] LT",
      sameElse: "L"
     },
     relativeTime: {
      future: "dans %s",
      past: "il y a %s",
      s: "quelques secondes",
      ss: "%d secondes",
      m: "une minute",
      mm: "%d minutes",
      h: "une heure",
      hh: "%d heures",
      d: "un jour",
      dd: "%d jours",
      M: "un mois",
      MM: "%d mois",
      y: "un an",
      yy: "%d ans"
     },
     dayOfMonthOrdinalParse: /\d{1,2}(er|e)/,
     ordinal: function(number, period) {
      switch (period) {
      default:
      case "M":
      case "Q":
      case "D":
      case "DDD":
      case "d":
       return number + (1 === number ? "er" : "e");

      case "w":
      case "W":
       return number + (1 === number ? "re" : "e");
      }
     },
     week: {
      dow: 1,
      doy: 4
     }
    });
   }(__webpack_require__(95093));
  },
  85498: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    var monthsStrictRegex = /^(janvier|février|mars|avril|mai|juin|juillet|août|septembre|octobre|novembre|décembre)/i, monthsShortStrictRegex = /(janv\.?|févr\.?|mars|avr\.?|mai|juin|juil\.?|août|sept\.?|oct\.?|nov\.?|déc\.?)/i, monthsRegex = /(janv\.?|févr\.?|mars|avr\.?|mai|juin|juil\.?|août|sept\.?|oct\.?|nov\.?|déc\.?|janvier|février|mars|avril|mai|juin|juillet|août|septembre|octobre|novembre|décembre)/i, monthsParse = [ /^janv/i, /^févr/i, /^mars/i, /^avr/i, /^mai/i, /^juin/i, /^juil/i, /^août/i, /^sept/i, /^oct/i, /^nov/i, /^déc/i ];
    moment.defineLocale("fr", {
     months: "janvier_février_mars_avril_mai_juin_juillet_août_septembre_octobre_novembre_décembre".split("_"),
     monthsShort: "janv._févr._mars_avr._mai_juin_juil._août_sept._oct._nov._déc.".split("_"),
     monthsRegex,
     monthsShortRegex: monthsRegex,
     monthsStrictRegex,
     monthsShortStrictRegex,
     monthsParse,
     longMonthsParse: monthsParse,
     shortMonthsParse: monthsParse,
     weekdays: "dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi".split("_"),
     weekdaysShort: "dim._lun._mar._mer._jeu._ven._sam.".split("_"),
     weekdaysMin: "di_lu_ma_me_je_ve_sa".split("_"),
     weekdaysParseExact: !0,
     longDateFormat: {
      LT: "HH:mm",
      LTS: "HH:mm:ss",
      L: "DD/MM/YYYY",
      LL: "D MMMM YYYY",
      LLL: "D MMMM YYYY HH:mm",
      LLLL: "dddd D MMMM YYYY HH:mm"
     },
     calendar: {
      sameDay: "[Aujourd’hui à] LT",
      nextDay: "[Demain à] LT",
      nextWeek: "dddd [à] LT",
      lastDay: "[Hier à] LT",
      lastWeek: "dddd [dernier à] LT",
      sameElse: "L"
     },
     relativeTime: {
      future: "dans %s",
      past: "il y a %s",
      s: "quelques secondes",
      ss: "%d secondes",
      m: "une minute",
      mm: "%d minutes",
      h: "une heure",
      hh: "%d heures",
      d: "un jour",
      dd: "%d jours",
      w: "une semaine",
      ww: "%d semaines",
      M: "un mois",
      MM: "%d mois",
      y: "un an",
      yy: "%d ans"
     },
     dayOfMonthOrdinalParse: /\d{1,2}(er|)/,
     ordinal: function(number, period) {
      switch (period) {
      case "D":
       return number + (1 === number ? "er" : "");

      default:
      case "M":
      case "Q":
      case "DDD":
      case "d":
       return number + (1 === number ? "er" : "e");

      case "w":
      case "W":
       return number + (1 === number ? "re" : "e");
      }
     },
     week: {
      dow: 1,
      doy: 4
     }
    });
   }(__webpack_require__(95093));
  },
  37071: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    var monthsShortWithDots = "jan._feb._mrt._apr._mai_jun._jul._aug._sep._okt._nov._des.".split("_"), monthsShortWithoutDots = "jan_feb_mrt_apr_mai_jun_jul_aug_sep_okt_nov_des".split("_");
    moment.defineLocale("fy", {
     months: "jannewaris_febrewaris_maart_april_maaie_juny_july_augustus_septimber_oktober_novimber_desimber".split("_"),
     monthsShort: function(m, format) {
      return m ? /-MMM-/.test(format) ? monthsShortWithoutDots[m.month()] : monthsShortWithDots[m.month()] : monthsShortWithDots;
     },
     monthsParseExact: !0,
     weekdays: "snein_moandei_tiisdei_woansdei_tongersdei_freed_sneon".split("_"),
     weekdaysShort: "si._mo._ti._wo._to._fr._so.".split("_"),
     weekdaysMin: "Si_Mo_Ti_Wo_To_Fr_So".split("_"),
     weekdaysParseExact: !0,
     longDateFormat: {
      LT: "HH:mm",
      LTS: "HH:mm:ss",
      L: "DD-MM-YYYY",
      LL: "D MMMM YYYY",
      LLL: "D MMMM YYYY HH:mm",
      LLLL: "dddd D MMMM YYYY HH:mm"
     },
     calendar: {
      sameDay: "[hjoed om] LT",
      nextDay: "[moarn om] LT",
      nextWeek: "dddd [om] LT",
      lastDay: "[juster om] LT",
      lastWeek: "[ôfrûne] dddd [om] LT",
      sameElse: "L"
     },
     relativeTime: {
      future: "oer %s",
      past: "%s lyn",
      s: "in pear sekonden",
      ss: "%d sekonden",
      m: "ien minút",
      mm: "%d minuten",
      h: "ien oere",
      hh: "%d oeren",
      d: "ien dei",
      dd: "%d dagen",
      M: "ien moanne",
      MM: "%d moannen",
      y: "ien jier",
      yy: "%d jierren"
     },
     dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
     ordinal: function(number) {
      return number + (1 === number || 8 === number || number >= 20 ? "ste" : "de");
     },
     week: {
      dow: 1,
      doy: 4
     }
    });
   }(__webpack_require__(95093));
  },
  41734: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    var months = [ "Eanáir", "Feabhra", "Márta", "Aibreán", "Bealtaine", "Meitheamh", "Iúil", "Lúnasa", "Meán Fómhair", "Deireadh Fómhair", "Samhain", "Nollaig" ], monthsShort = [ "Ean", "Feabh", "Márt", "Aib", "Beal", "Meith", "Iúil", "Lún", "M.F.", "D.F.", "Samh", "Noll" ], weekdays = [ "Dé Domhnaigh", "Dé Luain", "Dé Máirt", "Dé Céadaoin", "Déardaoin", "Dé hAoine", "Dé Sathairn" ], weekdaysShort = [ "Domh", "Luan", "Máirt", "Céad", "Déar", "Aoine", "Sath" ], weekdaysMin = [ "Do", "Lu", "Má", "Cé", "Dé", "A", "Sa" ];
    moment.defineLocale("ga", {
     months,
     monthsShort,
     monthsParseExact: !0,
     weekdays,
     weekdaysShort,
     weekdaysMin,
     longDateFormat: {
      LT: "HH:mm",
      LTS: "HH:mm:ss",
      L: "DD/MM/YYYY",
      LL: "D MMMM YYYY",
      LLL: "D MMMM YYYY HH:mm",
      LLLL: "dddd, D MMMM YYYY HH:mm"
     },
     calendar: {
      sameDay: "[Inniu ag] LT",
      nextDay: "[Amárach ag] LT",
      nextWeek: "dddd [ag] LT",
      lastDay: "[Inné ag] LT",
      lastWeek: "dddd [seo caite] [ag] LT",
      sameElse: "L"
     },
     relativeTime: {
      future: "i %s",
      past: "%s ó shin",
      s: "cúpla soicind",
      ss: "%d soicind",
      m: "nóiméad",
      mm: "%d nóiméad",
      h: "uair an chloig",
      hh: "%d uair an chloig",
      d: "lá",
      dd: "%d lá",
      M: "mí",
      MM: "%d míonna",
      y: "bliain",
      yy: "%d bliain"
     },
     dayOfMonthOrdinalParse: /\d{1,2}(d|na|mh)/,
     ordinal: function(number) {
      return number + (1 === number ? "d" : number % 10 == 2 ? "na" : "mh");
     },
     week: {
      dow: 1,
      doy: 4
     }
    });
   }(__webpack_require__(95093));
  },
  70217: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    var months = [ "Am Faoilleach", "An Gearran", "Am Màrt", "An Giblean", "An Cèitean", "An t-Ògmhios", "An t-Iuchar", "An Lùnastal", "An t-Sultain", "An Dàmhair", "An t-Samhain", "An Dùbhlachd" ], monthsShort = [ "Faoi", "Gear", "Màrt", "Gibl", "Cèit", "Ògmh", "Iuch", "Lùn", "Sult", "Dàmh", "Samh", "Dùbh" ], weekdays = [ "Didòmhnaich", "Diluain", "Dimàirt", "Diciadain", "Diardaoin", "Dihaoine", "Disathairne" ], weekdaysShort = [ "Did", "Dil", "Dim", "Dic", "Dia", "Dih", "Dis" ], weekdaysMin = [ "Dò", "Lu", "Mà", "Ci", "Ar", "Ha", "Sa" ];
    moment.defineLocale("gd", {
     months,
     monthsShort,
     monthsParseExact: !0,
     weekdays,
     weekdaysShort,
     weekdaysMin,
     longDateFormat: {
      LT: "HH:mm",
      LTS: "HH:mm:ss",
      L: "DD/MM/YYYY",
      LL: "D MMMM YYYY",
      LLL: "D MMMM YYYY HH:mm",
      LLLL: "dddd, D MMMM YYYY HH:mm"
     },
     calendar: {
      sameDay: "[An-diugh aig] LT",
      nextDay: "[A-màireach aig] LT",
      nextWeek: "dddd [aig] LT",
      lastDay: "[An-dè aig] LT",
      lastWeek: "dddd [seo chaidh] [aig] LT",
      sameElse: "L"
     },
     relativeTime: {
      future: "ann an %s",
      past: "bho chionn %s",
      s: "beagan diogan",
      ss: "%d diogan",
      m: "mionaid",
      mm: "%d mionaidean",
      h: "uair",
      hh: "%d uairean",
      d: "latha",
      dd: "%d latha",
      M: "mìos",
      MM: "%d mìosan",
      y: "bliadhna",
      yy: "%d bliadhna"
     },
     dayOfMonthOrdinalParse: /\d{1,2}(d|na|mh)/,
     ordinal: function(number) {
      return number + (1 === number ? "d" : number % 10 == 2 ? "na" : "mh");
     },
     week: {
      dow: 1,
      doy: 4
     }
    });
   }(__webpack_require__(95093));
  },
  77329: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    moment.defineLocale("gl", {
     months: "xaneiro_febreiro_marzo_abril_maio_xuño_xullo_agosto_setembro_outubro_novembro_decembro".split("_"),
     monthsShort: "xan._feb._mar._abr._mai._xuñ._xul._ago._set._out._nov._dec.".split("_"),
     monthsParseExact: !0,
     weekdays: "domingo_luns_martes_mércores_xoves_venres_sábado".split("_"),
     weekdaysShort: "dom._lun._mar._mér._xov._ven._sáb.".split("_"),
     weekdaysMin: "do_lu_ma_mé_xo_ve_sá".split("_"),
     weekdaysParseExact: !0,
     longDateFormat: {
      LT: "H:mm",
      LTS: "H:mm:ss",
      L: "DD/MM/YYYY",
      LL: "D [de] MMMM [de] YYYY",
      LLL: "D [de] MMMM [de] YYYY H:mm",
      LLLL: "dddd, D [de] MMMM [de] YYYY H:mm"
     },
     calendar: {
      sameDay: function() {
       return "[hoxe " + (1 !== this.hours() ? "ás" : "á") + "] LT";
      },
      nextDay: function() {
       return "[mañá " + (1 !== this.hours() ? "ás" : "á") + "] LT";
      },
      nextWeek: function() {
       return "dddd [" + (1 !== this.hours() ? "ás" : "a") + "] LT";
      },
      lastDay: function() {
       return "[onte " + (1 !== this.hours() ? "á" : "a") + "] LT";
      },
      lastWeek: function() {
       return "[o] dddd [pasado " + (1 !== this.hours() ? "ás" : "a") + "] LT";
      },
      sameElse: "L"
     },
     relativeTime: {
      future: function(str) {
       return 0 === str.indexOf("un") ? "n" + str : "en " + str;
      },
      past: "hai %s",
      s: "uns segundos",
      ss: "%d segundos",
      m: "un minuto",
      mm: "%d minutos",
      h: "unha hora",
      hh: "%d horas",
      d: "un día",
      dd: "%d días",
      M: "un mes",
      MM: "%d meses",
      y: "un ano",
      yy: "%d anos"
     },
     dayOfMonthOrdinalParse: /\d{1,2}º/,
     ordinal: "%dº",
     week: {
      dow: 1,
      doy: 4
     }
    });
   }(__webpack_require__(95093));
  },
  32124: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    function processRelativeTime(number, withoutSuffix, key, isFuture) {
     var format = {
      s: [ "थोडया सॅकंडांनी", "थोडे सॅकंड" ],
      ss: [ number + " सॅकंडांनी", number + " सॅकंड" ],
      m: [ "एका मिणटान", "एक मिनूट" ],
      mm: [ number + " मिणटांनी", number + " मिणटां" ],
      h: [ "एका वरान", "एक वर" ],
      hh: [ number + " वरांनी", number + " वरां" ],
      d: [ "एका दिसान", "एक दीस" ],
      dd: [ number + " दिसांनी", number + " दीस" ],
      M: [ "एका म्हयन्यान", "एक म्हयनो" ],
      MM: [ number + " म्हयन्यानी", number + " म्हयने" ],
      y: [ "एका वर्सान", "एक वर्स" ],
      yy: [ number + " वर्सांनी", number + " वर्सां" ]
     };
     return isFuture ? format[key][0] : format[key][1];
    }
    moment.defineLocale("gom-deva", {
     months: {
      standalone: "जानेवारी_फेब्रुवारी_मार्च_एप्रील_मे_जून_जुलय_ऑगस्ट_सप्टेंबर_ऑक्टोबर_नोव्हेंबर_डिसेंबर".split("_"),
      format: "जानेवारीच्या_फेब्रुवारीच्या_मार्चाच्या_एप्रीलाच्या_मेयाच्या_जूनाच्या_जुलयाच्या_ऑगस्टाच्या_सप्टेंबराच्या_ऑक्टोबराच्या_नोव्हेंबराच्या_डिसेंबराच्या".split("_"),
      isFormat: /MMMM(\s)+D[oD]?/
     },
     monthsShort: "जाने._फेब्रु._मार्च_एप्री._मे_जून_जुल._ऑग._सप्टें._ऑक्टो._नोव्हें._डिसें.".split("_"),
     monthsParseExact: !0,
     weekdays: "आयतार_सोमार_मंगळार_बुधवार_बिरेस्तार_सुक्रार_शेनवार".split("_"),
     weekdaysShort: "आयत._सोम._मंगळ._बुध._ब्रेस्त._सुक्र._शेन.".split("_"),
     weekdaysMin: "आ_सो_मं_बु_ब्रे_सु_शे".split("_"),
     weekdaysParseExact: !0,
     longDateFormat: {
      LT: "A h:mm [वाजतां]",
      LTS: "A h:mm:ss [वाजतां]",
      L: "DD-MM-YYYY",
      LL: "D MMMM YYYY",
      LLL: "D MMMM YYYY A h:mm [वाजतां]",
      LLLL: "dddd, MMMM Do, YYYY, A h:mm [वाजतां]",
      llll: "ddd, D MMM YYYY, A h:mm [वाजतां]"
     },
     calendar: {
      sameDay: "[आयज] LT",
      nextDay: "[फाल्यां] LT",
      nextWeek: "[फुडलो] dddd[,] LT",
      lastDay: "[काल] LT",
      lastWeek: "[फाटलो] dddd[,] LT",
      sameElse: "L"
     },
     relativeTime: {
      future: "%s",
      past: "%s आदीं",
      s: processRelativeTime,
      ss: processRelativeTime,
      m: processRelativeTime,
      mm: processRelativeTime,
      h: processRelativeTime,
      hh: processRelativeTime,
      d: processRelativeTime,
      dd: processRelativeTime,
      M: processRelativeTime,
      MM: processRelativeTime,
      y: processRelativeTime,
      yy: processRelativeTime
     },
     dayOfMonthOrdinalParse: /\d{1,2}(वेर)/,
     ordinal: function(number, period) {
      return "D" === period ? number + "वेर" : number;
     },
     week: {
      dow: 0,
      doy: 3
     },
     meridiemParse: /राती|सकाळीं|दनपारां|सांजे/,
     meridiemHour: function(hour, meridiem) {
      return 12 === hour && (hour = 0), "राती" === meridiem ? hour < 4 ? hour : hour + 12 : "सकाळीं" === meridiem ? hour : "दनपारां" === meridiem ? hour > 12 ? hour : hour + 12 : "सांजे" === meridiem ? hour + 12 : void 0;
     },
     meridiem: function(hour, minute, isLower) {
      return hour < 4 ? "राती" : hour < 12 ? "सकाळीं" : hour < 16 ? "दनपारां" : hour < 20 ? "सांजे" : "राती";
     }
    });
   }(__webpack_require__(95093));
  },
  93383: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    function processRelativeTime(number, withoutSuffix, key, isFuture) {
     var format = {
      s: [ "thoddea sekondamni", "thodde sekond" ],
      ss: [ number + " sekondamni", number + " sekond" ],
      m: [ "eka mintan", "ek minut" ],
      mm: [ number + " mintamni", number + " mintam" ],
      h: [ "eka voran", "ek vor" ],
      hh: [ number + " voramni", number + " voram" ],
      d: [ "eka disan", "ek dis" ],
      dd: [ number + " disamni", number + " dis" ],
      M: [ "eka mhoinean", "ek mhoino" ],
      MM: [ number + " mhoineamni", number + " mhoine" ],
      y: [ "eka vorsan", "ek voros" ],
      yy: [ number + " vorsamni", number + " vorsam" ]
     };
     return isFuture ? format[key][0] : format[key][1];
    }
    moment.defineLocale("gom-latn", {
     months: {
      standalone: "Janer_Febrer_Mars_Abril_Mai_Jun_Julai_Agost_Setembr_Otubr_Novembr_Dezembr".split("_"),
      format: "Janerachea_Febrerachea_Marsachea_Abrilachea_Maiachea_Junachea_Julaiachea_Agostachea_Setembrachea_Otubrachea_Novembrachea_Dezembrachea".split("_"),
      isFormat: /MMMM(\s)+D[oD]?/
     },
     monthsShort: "Jan._Feb._Mars_Abr._Mai_Jun_Jul._Ago._Set._Otu._Nov._Dez.".split("_"),
     monthsParseExact: !0,
     weekdays: "Aitar_Somar_Mongllar_Budhvar_Birestar_Sukrar_Son'var".split("_"),
     weekdaysShort: "Ait._Som._Mon._Bud._Bre._Suk._Son.".split("_"),
     weekdaysMin: "Ai_Sm_Mo_Bu_Br_Su_Sn".split("_"),
     weekdaysParseExact: !0,
     longDateFormat: {
      LT: "A h:mm [vazta]",
      LTS: "A h:mm:ss [vazta]",
      L: "DD-MM-YYYY",
      LL: "D MMMM YYYY",
      LLL: "D MMMM YYYY A h:mm [vazta]",
      LLLL: "dddd, MMMM Do, YYYY, A h:mm [vazta]",
      llll: "ddd, D MMM YYYY, A h:mm [vazta]"
     },
     calendar: {
      sameDay: "[Aiz] LT",
      nextDay: "[Faleam] LT",
      nextWeek: "[Fuddlo] dddd[,] LT",
      lastDay: "[Kal] LT",
      lastWeek: "[Fattlo] dddd[,] LT",
      sameElse: "L"
     },
     relativeTime: {
      future: "%s",
      past: "%s adim",
      s: processRelativeTime,
      ss: processRelativeTime,
      m: processRelativeTime,
      mm: processRelativeTime,
      h: processRelativeTime,
      hh: processRelativeTime,
      d: processRelativeTime,
      dd: processRelativeTime,
      M: processRelativeTime,
      MM: processRelativeTime,
      y: processRelativeTime,
      yy: processRelativeTime
     },
     dayOfMonthOrdinalParse: /\d{1,2}(er)/,
     ordinal: function(number, period) {
      return "D" === period ? number + "er" : number;
     },
     week: {
      dow: 0,
      doy: 3
     },
     meridiemParse: /rati|sokallim|donparam|sanje/,
     meridiemHour: function(hour, meridiem) {
      return 12 === hour && (hour = 0), "rati" === meridiem ? hour < 4 ? hour : hour + 12 : "sokallim" === meridiem ? hour : "donparam" === meridiem ? hour > 12 ? hour : hour + 12 : "sanje" === meridiem ? hour + 12 : void 0;
     },
     meridiem: function(hour, minute, isLower) {
      return hour < 4 ? "rati" : hour < 12 ? "sokallim" : hour < 16 ? "donparam" : hour < 20 ? "sanje" : "rati";
     }
    });
   }(__webpack_require__(95093));
  },
  95050: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    var symbolMap = {
     1: "૧",
     2: "૨",
     3: "૩",
     4: "૪",
     5: "૫",
     6: "૬",
     7: "૭",
     8: "૮",
     9: "૯",
     0: "૦"
    }, numberMap = {
     "૧": "1",
     "૨": "2",
     "૩": "3",
     "૪": "4",
     "૫": "5",
     "૬": "6",
     "૭": "7",
     "૮": "8",
     "૯": "9",
     "૦": "0"
    };
    moment.defineLocale("gu", {
     months: "જાન્યુઆરી_ફેબ્રુઆરી_માર્ચ_એપ્રિલ_મે_જૂન_જુલાઈ_ઑગસ્ટ_સપ્ટેમ્બર_ઑક્ટ્બર_નવેમ્બર_ડિસેમ્બર".split("_"),
     monthsShort: "જાન્યુ._ફેબ્રુ._માર્ચ_એપ્રિ._મે_જૂન_જુલા._ઑગ._સપ્ટે._ઑક્ટ્._નવે._ડિસે.".split("_"),
     monthsParseExact: !0,
     weekdays: "રવિવાર_સોમવાર_મંગળવાર_બુધ્વાર_ગુરુવાર_શુક્રવાર_શનિવાર".split("_"),
     weekdaysShort: "રવિ_સોમ_મંગળ_બુધ્_ગુરુ_શુક્ર_શનિ".split("_"),
     weekdaysMin: "ર_સો_મં_બુ_ગુ_શુ_શ".split("_"),
     longDateFormat: {
      LT: "A h:mm વાગ્યે",
      LTS: "A h:mm:ss વાગ્યે",
      L: "DD/MM/YYYY",
      LL: "D MMMM YYYY",
      LLL: "D MMMM YYYY, A h:mm વાગ્યે",
      LLLL: "dddd, D MMMM YYYY, A h:mm વાગ્યે"
     },
     calendar: {
      sameDay: "[આજ] LT",
      nextDay: "[કાલે] LT",
      nextWeek: "dddd, LT",
      lastDay: "[ગઇકાલે] LT",
      lastWeek: "[પાછલા] dddd, LT",
      sameElse: "L"
     },
     relativeTime: {
      future: "%s મા",
      past: "%s પહેલા",
      s: "અમુક પળો",
      ss: "%d સેકંડ",
      m: "એક મિનિટ",
      mm: "%d મિનિટ",
      h: "એક કલાક",
      hh: "%d કલાક",
      d: "એક દિવસ",
      dd: "%d દિવસ",
      M: "એક મહિનો",
      MM: "%d મહિનો",
      y: "એક વર્ષ",
      yy: "%d વર્ષ"
     },
     preparse: function(string) {
      return string.replace(/[૧૨૩૪૫૬૭૮૯૦]/g, (function(match) {
       return numberMap[match];
      }));
     },
     postformat: function(string) {
      return string.replace(/\d/g, (function(match) {
       return symbolMap[match];
      }));
     },
     meridiemParse: /રાત|બપોર|સવાર|સાંજ/,
     meridiemHour: function(hour, meridiem) {
      return 12 === hour && (hour = 0), "રાત" === meridiem ? hour < 4 ? hour : hour + 12 : "સવાર" === meridiem ? hour : "બપોર" === meridiem ? hour >= 10 ? hour : hour + 12 : "સાંજ" === meridiem ? hour + 12 : void 0;
     },
     meridiem: function(hour, minute, isLower) {
      return hour < 4 ? "રાત" : hour < 10 ? "સવાર" : hour < 17 ? "બપોર" : hour < 20 ? "સાંજ" : "રાત";
     },
     week: {
      dow: 0,
      doy: 6
     }
    });
   }(__webpack_require__(95093));
  },
  11713: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    moment.defineLocale("he", {
     months: "ינואר_פברואר_מרץ_אפריל_מאי_יוני_יולי_אוגוסט_ספטמבר_אוקטובר_נובמבר_דצמבר".split("_"),
     monthsShort: "ינו׳_פבר׳_מרץ_אפר׳_מאי_יוני_יולי_אוג׳_ספט׳_אוק׳_נוב׳_דצמ׳".split("_"),
     weekdays: "ראשון_שני_שלישי_רביעי_חמישי_שישי_שבת".split("_"),
     weekdaysShort: "א׳_ב׳_ג׳_ד׳_ה׳_ו׳_ש׳".split("_"),
     weekdaysMin: "א_ב_ג_ד_ה_ו_ש".split("_"),
     longDateFormat: {
      LT: "HH:mm",
      LTS: "HH:mm:ss",
      L: "DD/MM/YYYY",
      LL: "D [ב]MMMM YYYY",
      LLL: "D [ב]MMMM YYYY HH:mm",
      LLLL: "dddd, D [ב]MMMM YYYY HH:mm",
      l: "D/M/YYYY",
      ll: "D MMM YYYY",
      lll: "D MMM YYYY HH:mm",
      llll: "ddd, D MMM YYYY HH:mm"
     },
     calendar: {
      sameDay: "[היום ב־]LT",
      nextDay: "[מחר ב־]LT",
      nextWeek: "dddd [בשעה] LT",
      lastDay: "[אתמול ב־]LT",
      lastWeek: "[ביום] dddd [האחרון בשעה] LT",
      sameElse: "L"
     },
     relativeTime: {
      future: "בעוד %s",
      past: "לפני %s",
      s: "מספר שניות",
      ss: "%d שניות",
      m: "דקה",
      mm: "%d דקות",
      h: "שעה",
      hh: function(number) {
       return 2 === number ? "שעתיים" : number + " שעות";
      },
      d: "יום",
      dd: function(number) {
       return 2 === number ? "יומיים" : number + " ימים";
      },
      M: "חודש",
      MM: function(number) {
       return 2 === number ? "חודשיים" : number + " חודשים";
      },
      y: "שנה",
      yy: function(number) {
       return 2 === number ? "שנתיים" : number % 10 == 0 && 10 !== number ? number + " שנה" : number + " שנים";
      }
     },
     meridiemParse: /אחה"צ|לפנה"צ|אחרי הצהריים|לפני הצהריים|לפנות בוקר|בבוקר|בערב/i,
     isPM: function(input) {
      return /^(אחה"צ|אחרי הצהריים|בערב)$/.test(input);
     },
     meridiem: function(hour, minute, isLower) {
      return hour < 5 ? "לפנות בוקר" : hour < 10 ? "בבוקר" : hour < 12 ? isLower ? 'לפנה"צ' : "לפני הצהריים" : hour < 18 ? isLower ? 'אחה"צ' : "אחרי הצהריים" : "בערב";
     }
    });
   }(__webpack_require__(95093));
  },
  43861: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    var symbolMap = {
     1: "१",
     2: "२",
     3: "३",
     4: "४",
     5: "५",
     6: "६",
     7: "७",
     8: "८",
     9: "९",
     0: "०"
    }, numberMap = {
     "१": "1",
     "२": "2",
     "३": "3",
     "४": "4",
     "५": "5",
     "६": "6",
     "७": "7",
     "८": "8",
     "९": "9",
     "०": "0"
    }, monthsParse = [ /^जन/i, /^फ़र|फर/i, /^मार्च/i, /^अप्रै/i, /^मई/i, /^जून/i, /^जुल/i, /^अग/i, /^सितं|सित/i, /^अक्टू/i, /^नव|नवं/i, /^दिसं|दिस/i ], shortMonthsParse = [ /^जन/i, /^फ़र/i, /^मार्च/i, /^अप्रै/i, /^मई/i, /^जून/i, /^जुल/i, /^अग/i, /^सित/i, /^अक्टू/i, /^नव/i, /^दिस/i ];
    moment.defineLocale("hi", {
     months: {
      format: "जनवरी_फ़रवरी_मार्च_अप्रैल_मई_जून_जुलाई_अगस्त_सितम्बर_अक्टूबर_नवम्बर_दिसम्बर".split("_"),
      standalone: "जनवरी_फरवरी_मार्च_अप्रैल_मई_जून_जुलाई_अगस्त_सितंबर_अक्टूबर_नवंबर_दिसंबर".split("_")
     },
     monthsShort: "जन._फ़र._मार्च_अप्रै._मई_जून_जुल._अग._सित._अक्टू._नव._दिस.".split("_"),
     weekdays: "रविवार_सोमवार_मंगलवार_बुधवार_गुरूवार_शुक्रवार_शनिवार".split("_"),
     weekdaysShort: "रवि_सोम_मंगल_बुध_गुरू_शुक्र_शनि".split("_"),
     weekdaysMin: "र_सो_मं_बु_गु_शु_श".split("_"),
     longDateFormat: {
      LT: "A h:mm बजे",
      LTS: "A h:mm:ss बजे",
      L: "DD/MM/YYYY",
      LL: "D MMMM YYYY",
      LLL: "D MMMM YYYY, A h:mm बजे",
      LLLL: "dddd, D MMMM YYYY, A h:mm बजे"
     },
     monthsParse,
     longMonthsParse: monthsParse,
     shortMonthsParse,
     monthsRegex: /^(जनवरी|जन\.?|फ़रवरी|फरवरी|फ़र\.?|मार्च?|अप्रैल|अप्रै\.?|मई?|जून?|जुलाई|जुल\.?|अगस्त|अग\.?|सितम्बर|सितंबर|सित\.?|अक्टूबर|अक्टू\.?|नवम्बर|नवंबर|नव\.?|दिसम्बर|दिसंबर|दिस\.?)/i,
     monthsShortRegex: /^(जनवरी|जन\.?|फ़रवरी|फरवरी|फ़र\.?|मार्च?|अप्रैल|अप्रै\.?|मई?|जून?|जुलाई|जुल\.?|अगस्त|अग\.?|सितम्बर|सितंबर|सित\.?|अक्टूबर|अक्टू\.?|नवम्बर|नवंबर|नव\.?|दिसम्बर|दिसंबर|दिस\.?)/i,
     monthsStrictRegex: /^(जनवरी?|फ़रवरी|फरवरी?|मार्च?|अप्रैल?|मई?|जून?|जुलाई?|अगस्त?|सितम्बर|सितंबर|सित?\.?|अक्टूबर|अक्टू\.?|नवम्बर|नवंबर?|दिसम्बर|दिसंबर?)/i,
     monthsShortStrictRegex: /^(जन\.?|फ़र\.?|मार्च?|अप्रै\.?|मई?|जून?|जुल\.?|अग\.?|सित\.?|अक्टू\.?|नव\.?|दिस\.?)/i,
     calendar: {
      sameDay: "[आज] LT",
      nextDay: "[कल] LT",
      nextWeek: "dddd, LT",
      lastDay: "[कल] LT",
      lastWeek: "[पिछले] dddd, LT",
      sameElse: "L"
     },
     relativeTime: {
      future: "%s में",
      past: "%s पहले",
      s: "कुछ ही क्षण",
      ss: "%d सेकंड",
      m: "एक मिनट",
      mm: "%d मिनट",
      h: "एक घंटा",
      hh: "%d घंटे",
      d: "एक दिन",
      dd: "%d दिन",
      M: "एक महीने",
      MM: "%d महीने",
      y: "एक वर्ष",
      yy: "%d वर्ष"
     },
     preparse: function(string) {
      return string.replace(/[१२३४५६७८९०]/g, (function(match) {
       return numberMap[match];
      }));
     },
     postformat: function(string) {
      return string.replace(/\d/g, (function(match) {
       return symbolMap[match];
      }));
     },
     meridiemParse: /रात|सुबह|दोपहर|शाम/,
     meridiemHour: function(hour, meridiem) {
      return 12 === hour && (hour = 0), "रात" === meridiem ? hour < 4 ? hour : hour + 12 : "सुबह" === meridiem ? hour : "दोपहर" === meridiem ? hour >= 10 ? hour : hour + 12 : "शाम" === meridiem ? hour + 12 : void 0;
     },
     meridiem: function(hour, minute, isLower) {
      return hour < 4 ? "रात" : hour < 10 ? "सुबह" : hour < 17 ? "दोपहर" : hour < 20 ? "शाम" : "रात";
     },
     week: {
      dow: 0,
      doy: 6
     }
    });
   }(__webpack_require__(95093));
  },
  26308: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    function translate(number, withoutSuffix, key) {
     var result = number + " ";
     switch (key) {
     case "ss":
      return result += 1 === number ? "sekunda" : 2 === number || 3 === number || 4 === number ? "sekunde" : "sekundi";

     case "m":
      return withoutSuffix ? "jedna minuta" : "jedne minute";

     case "mm":
      return result += 1 === number ? "minuta" : 2 === number || 3 === number || 4 === number ? "minute" : "minuta";

     case "h":
      return withoutSuffix ? "jedan sat" : "jednog sata";

     case "hh":
      return result += 1 === number ? "sat" : 2 === number || 3 === number || 4 === number ? "sata" : "sati";

     case "dd":
      return result += 1 === number ? "dan" : "dana";

     case "MM":
      return result += 1 === number ? "mjesec" : 2 === number || 3 === number || 4 === number ? "mjeseca" : "mjeseci";

     case "yy":
      return result += 1 === number ? "godina" : 2 === number || 3 === number || 4 === number ? "godine" : "godina";
     }
    }
    moment.defineLocale("hr", {
     months: {
      format: "siječnja_veljače_ožujka_travnja_svibnja_lipnja_srpnja_kolovoza_rujna_listopada_studenoga_prosinca".split("_"),
      standalone: "siječanj_veljača_ožujak_travanj_svibanj_lipanj_srpanj_kolovoz_rujan_listopad_studeni_prosinac".split("_")
     },
     monthsShort: "sij._velj._ožu._tra._svi._lip._srp._kol._ruj._lis._stu._pro.".split("_"),
     monthsParseExact: !0,
     weekdays: "nedjelja_ponedjeljak_utorak_srijeda_četvrtak_petak_subota".split("_"),
     weekdaysShort: "ned._pon._uto._sri._čet._pet._sub.".split("_"),
     weekdaysMin: "ne_po_ut_sr_če_pe_su".split("_"),
     weekdaysParseExact: !0,
     longDateFormat: {
      LT: "H:mm",
      LTS: "H:mm:ss",
      L: "DD.MM.YYYY",
      LL: "Do MMMM YYYY",
      LLL: "Do MMMM YYYY H:mm",
      LLLL: "dddd, Do MMMM YYYY H:mm"
     },
     calendar: {
      sameDay: "[danas u] LT",
      nextDay: "[sutra u] LT",
      nextWeek: function() {
       switch (this.day()) {
       case 0:
        return "[u] [nedjelju] [u] LT";

       case 3:
        return "[u] [srijedu] [u] LT";

       case 6:
        return "[u] [subotu] [u] LT";

       case 1:
       case 2:
       case 4:
       case 5:
        return "[u] dddd [u] LT";
       }
      },
      lastDay: "[jučer u] LT",
      lastWeek: function() {
       switch (this.day()) {
       case 0:
        return "[prošlu] [nedjelju] [u] LT";

       case 3:
        return "[prošlu] [srijedu] [u] LT";

       case 6:
        return "[prošle] [subote] [u] LT";

       case 1:
       case 2:
       case 4:
       case 5:
        return "[prošli] dddd [u] LT";
       }
      },
      sameElse: "L"
     },
     relativeTime: {
      future: "za %s",
      past: "prije %s",
      s: "par sekundi",
      ss: translate,
      m: translate,
      mm: translate,
      h: translate,
      hh: translate,
      d: "dan",
      dd: translate,
      M: "mjesec",
      MM: translate,
      y: "godinu",
      yy: translate
     },
     dayOfMonthOrdinalParse: /\d{1,2}\./,
     ordinal: "%d.",
     week: {
      dow: 1,
      doy: 7
     }
    });
   }(__webpack_require__(95093));
  },
  90609: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    var weekEndings = "vasárnap hétfőn kedden szerdán csütörtökön pénteken szombaton".split(" ");
    function translate(number, withoutSuffix, key, isFuture) {
     var num = number;
     switch (key) {
     case "s":
      return isFuture || withoutSuffix ? "néhány másodperc" : "néhány másodperce";

     case "ss":
      return num + (isFuture || withoutSuffix) ? " másodperc" : " másodperce";

     case "m":
      return "egy" + (isFuture || withoutSuffix ? " perc" : " perce");

     case "mm":
      return num + (isFuture || withoutSuffix ? " perc" : " perce");

     case "h":
      return "egy" + (isFuture || withoutSuffix ? " óra" : " órája");

     case "hh":
      return num + (isFuture || withoutSuffix ? " óra" : " órája");

     case "d":
      return "egy" + (isFuture || withoutSuffix ? " nap" : " napja");

     case "dd":
      return num + (isFuture || withoutSuffix ? " nap" : " napja");

     case "M":
      return "egy" + (isFuture || withoutSuffix ? " hónap" : " hónapja");

     case "MM":
      return num + (isFuture || withoutSuffix ? " hónap" : " hónapja");

     case "y":
      return "egy" + (isFuture || withoutSuffix ? " év" : " éve");

     case "yy":
      return num + (isFuture || withoutSuffix ? " év" : " éve");
     }
     return "";
    }
    function week(isFuture) {
     return (isFuture ? "" : "[múlt] ") + "[" + weekEndings[this.day()] + "] LT[-kor]";
    }
    moment.defineLocale("hu", {
     months: "január_február_március_április_május_június_július_augusztus_szeptember_október_november_december".split("_"),
     monthsShort: "jan._feb._márc._ápr._máj._jún._júl._aug._szept._okt._nov._dec.".split("_"),
     monthsParseExact: !0,
     weekdays: "vasárnap_hétfő_kedd_szerda_csütörtök_péntek_szombat".split("_"),
     weekdaysShort: "vas_hét_kedd_sze_csüt_pén_szo".split("_"),
     weekdaysMin: "v_h_k_sze_cs_p_szo".split("_"),
     longDateFormat: {
      LT: "H:mm",
      LTS: "H:mm:ss",
      L: "YYYY.MM.DD.",
      LL: "YYYY. MMMM D.",
      LLL: "YYYY. MMMM D. H:mm",
      LLLL: "YYYY. MMMM D., dddd H:mm"
     },
     meridiemParse: /de|du/i,
     isPM: function(input) {
      return "u" === input.charAt(1).toLowerCase();
     },
     meridiem: function(hours, minutes, isLower) {
      return hours < 12 ? !0 === isLower ? "de" : "DE" : !0 === isLower ? "du" : "DU";
     },
     calendar: {
      sameDay: "[ma] LT[-kor]",
      nextDay: "[holnap] LT[-kor]",
      nextWeek: function() {
       return week.call(this, !0);
      },
      lastDay: "[tegnap] LT[-kor]",
      lastWeek: function() {
       return week.call(this, !1);
      },
      sameElse: "L"
     },
     relativeTime: {
      future: "%s múlva",
      past: "%s",
      s: translate,
      ss: translate,
      m: translate,
      mm: translate,
      h: translate,
      hh: translate,
      d: translate,
      dd: translate,
      M: translate,
      MM: translate,
      y: translate,
      yy: translate
     },
     dayOfMonthOrdinalParse: /\d{1,2}\./,
     ordinal: "%d.",
     week: {
      dow: 1,
      doy: 4
     }
    });
   }(__webpack_require__(95093));
  },
  17160: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    moment.defineLocale("hy-am", {
     months: {
      format: "հունվարի_փետրվարի_մարտի_ապրիլի_մայիսի_հունիսի_հուլիսի_օգոստոսի_սեպտեմբերի_հոկտեմբերի_նոյեմբերի_դեկտեմբերի".split("_"),
      standalone: "հունվար_փետրվար_մարտ_ապրիլ_մայիս_հունիս_հուլիս_օգոստոս_սեպտեմբեր_հոկտեմբեր_նոյեմբեր_դեկտեմբեր".split("_")
     },
     monthsShort: "հնվ_փտր_մրտ_ապր_մյս_հնս_հլս_օգս_սպտ_հկտ_նմբ_դկտ".split("_"),
     weekdays: "կիրակի_երկուշաբթի_երեքշաբթի_չորեքշաբթի_հինգշաբթի_ուրբաթ_շաբաթ".split("_"),
     weekdaysShort: "կրկ_երկ_երք_չրք_հնգ_ուրբ_շբթ".split("_"),
     weekdaysMin: "կրկ_երկ_երք_չրք_հնգ_ուրբ_շբթ".split("_"),
     longDateFormat: {
      LT: "HH:mm",
      LTS: "HH:mm:ss",
      L: "DD.MM.YYYY",
      LL: "D MMMM YYYY թ.",
      LLL: "D MMMM YYYY թ., HH:mm",
      LLLL: "dddd, D MMMM YYYY թ., HH:mm"
     },
     calendar: {
      sameDay: "[այսօր] LT",
      nextDay: "[վաղը] LT",
      lastDay: "[երեկ] LT",
      nextWeek: function() {
       return "dddd [օրը ժամը] LT";
      },
      lastWeek: function() {
       return "[անցած] dddd [օրը ժամը] LT";
      },
      sameElse: "L"
     },
     relativeTime: {
      future: "%s հետո",
      past: "%s առաջ",
      s: "մի քանի վայրկյան",
      ss: "%d վայրկյան",
      m: "րոպե",
      mm: "%d րոպե",
      h: "ժամ",
      hh: "%d ժամ",
      d: "օր",
      dd: "%d օր",
      M: "ամիս",
      MM: "%d ամիս",
      y: "տարի",
      yy: "%d տարի"
     },
     meridiemParse: /գիշերվա|առավոտվա|ցերեկվա|երեկոյան/,
     isPM: function(input) {
      return /^(ցերեկվա|երեկոյան)$/.test(input);
     },
     meridiem: function(hour) {
      return hour < 4 ? "գիշերվա" : hour < 12 ? "առավոտվա" : hour < 17 ? "ցերեկվա" : "երեկոյան";
     },
     dayOfMonthOrdinalParse: /\d{1,2}|\d{1,2}-(ին|րդ)/,
     ordinal: function(number, period) {
      switch (period) {
      case "DDD":
      case "w":
      case "W":
      case "DDDo":
       return 1 === number ? number + "-ին" : number + "-րդ";

      default:
       return number;
      }
     },
     week: {
      dow: 1,
      doy: 7
     }
    });
   }(__webpack_require__(95093));
  },
  74063: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    moment.defineLocale("id", {
     months: "Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_November_Desember".split("_"),
     monthsShort: "Jan_Feb_Mar_Apr_Mei_Jun_Jul_Agt_Sep_Okt_Nov_Des".split("_"),
     weekdays: "Minggu_Senin_Selasa_Rabu_Kamis_Jumat_Sabtu".split("_"),
     weekdaysShort: "Min_Sen_Sel_Rab_Kam_Jum_Sab".split("_"),
     weekdaysMin: "Mg_Sn_Sl_Rb_Km_Jm_Sb".split("_"),
     longDateFormat: {
      LT: "HH.mm",
      LTS: "HH.mm.ss",
      L: "DD/MM/YYYY",
      LL: "D MMMM YYYY",
      LLL: "D MMMM YYYY [pukul] HH.mm",
      LLLL: "dddd, D MMMM YYYY [pukul] HH.mm"
     },
     meridiemParse: /pagi|siang|sore|malam/,
     meridiemHour: function(hour, meridiem) {
      return 12 === hour && (hour = 0), "pagi" === meridiem ? hour : "siang" === meridiem ? hour >= 11 ? hour : hour + 12 : "sore" === meridiem || "malam" === meridiem ? hour + 12 : void 0;
     },
     meridiem: function(hours, minutes, isLower) {
      return hours < 11 ? "pagi" : hours < 15 ? "siang" : hours < 19 ? "sore" : "malam";
     },
     calendar: {
      sameDay: "[Hari ini pukul] LT",
      nextDay: "[Besok pukul] LT",
      nextWeek: "dddd [pukul] LT",
      lastDay: "[Kemarin pukul] LT",
      lastWeek: "dddd [lalu pukul] LT",
      sameElse: "L"
     },
     relativeTime: {
      future: "dalam %s",
      past: "%s yang lalu",
      s: "beberapa detik",
      ss: "%d detik",
      m: "semenit",
      mm: "%d menit",
      h: "sejam",
      hh: "%d jam",
      d: "sehari",
      dd: "%d hari",
      M: "sebulan",
      MM: "%d bulan",
      y: "setahun",
      yy: "%d tahun"
     },
     week: {
      dow: 0,
      doy: 6
     }
    });
   }(__webpack_require__(95093));
  },
  89374: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    function plural(n) {
     return n % 100 == 11 || n % 10 != 1;
    }
    function translate(number, withoutSuffix, key, isFuture) {
     var result = number + " ";
     switch (key) {
     case "s":
      return withoutSuffix || isFuture ? "nokkrar sekúndur" : "nokkrum sekúndum";

     case "ss":
      return plural(number) ? result + (withoutSuffix || isFuture ? "sekúndur" : "sekúndum") : result + "sekúnda";

     case "m":
      return withoutSuffix ? "mínúta" : "mínútu";

     case "mm":
      return plural(number) ? result + (withoutSuffix || isFuture ? "mínútur" : "mínútum") : withoutSuffix ? result + "mínúta" : result + "mínútu";

     case "hh":
      return plural(number) ? result + (withoutSuffix || isFuture ? "klukkustundir" : "klukkustundum") : result + "klukkustund";

     case "d":
      return withoutSuffix ? "dagur" : isFuture ? "dag" : "degi";

     case "dd":
      return plural(number) ? withoutSuffix ? result + "dagar" : result + (isFuture ? "daga" : "dögum") : withoutSuffix ? result + "dagur" : result + (isFuture ? "dag" : "degi");

     case "M":
      return withoutSuffix ? "mánuður" : isFuture ? "mánuð" : "mánuði";

     case "MM":
      return plural(number) ? withoutSuffix ? result + "mánuðir" : result + (isFuture ? "mánuði" : "mánuðum") : withoutSuffix ? result + "mánuður" : result + (isFuture ? "mánuð" : "mánuði");

     case "y":
      return withoutSuffix || isFuture ? "ár" : "ári";

     case "yy":
      return plural(number) ? result + (withoutSuffix || isFuture ? "ár" : "árum") : result + (withoutSuffix || isFuture ? "ár" : "ári");
     }
    }
    moment.defineLocale("is", {
     months: "janúar_febrúar_mars_apríl_maí_júní_júlí_ágúst_september_október_nóvember_desember".split("_"),
     monthsShort: "jan_feb_mar_apr_maí_jún_júl_ágú_sep_okt_nóv_des".split("_"),
     weekdays: "sunnudagur_mánudagur_þriðjudagur_miðvikudagur_fimmtudagur_föstudagur_laugardagur".split("_"),
     weekdaysShort: "sun_mán_þri_mið_fim_fös_lau".split("_"),
     weekdaysMin: "Su_Má_Þr_Mi_Fi_Fö_La".split("_"),
     longDateFormat: {
      LT: "H:mm",
      LTS: "H:mm:ss",
      L: "DD.MM.YYYY",
      LL: "D. MMMM YYYY",
      LLL: "D. MMMM YYYY [kl.] H:mm",
      LLLL: "dddd, D. MMMM YYYY [kl.] H:mm"
     },
     calendar: {
      sameDay: "[í dag kl.] LT",
      nextDay: "[á morgun kl.] LT",
      nextWeek: "dddd [kl.] LT",
      lastDay: "[í gær kl.] LT",
      lastWeek: "[síðasta] dddd [kl.] LT",
      sameElse: "L"
     },
     relativeTime: {
      future: "eftir %s",
      past: "fyrir %s síðan",
      s: translate,
      ss: translate,
      m: translate,
      mm: translate,
      h: "klukkustund",
      hh: translate,
      d: translate,
      dd: translate,
      M: translate,
      MM: translate,
      y: translate,
      yy: translate
     },
     dayOfMonthOrdinalParse: /\d{1,2}\./,
     ordinal: "%d.",
     week: {
      dow: 1,
      doy: 4
     }
    });
   }(__webpack_require__(95093));
  },
  21827: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    moment.defineLocale("it-ch", {
     months: "gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre".split("_"),
     monthsShort: "gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic".split("_"),
     weekdays: "domenica_lunedì_martedì_mercoledì_giovedì_venerdì_sabato".split("_"),
     weekdaysShort: "dom_lun_mar_mer_gio_ven_sab".split("_"),
     weekdaysMin: "do_lu_ma_me_gi_ve_sa".split("_"),
     longDateFormat: {
      LT: "HH:mm",
      LTS: "HH:mm:ss",
      L: "DD.MM.YYYY",
      LL: "D MMMM YYYY",
      LLL: "D MMMM YYYY HH:mm",
      LLLL: "dddd D MMMM YYYY HH:mm"
     },
     calendar: {
      sameDay: "[Oggi alle] LT",
      nextDay: "[Domani alle] LT",
      nextWeek: "dddd [alle] LT",
      lastDay: "[Ieri alle] LT",
      lastWeek: function() {
       return 0 === this.day() ? "[la scorsa] dddd [alle] LT" : "[lo scorso] dddd [alle] LT";
      },
      sameElse: "L"
     },
     relativeTime: {
      future: function(s) {
       return (/^[0-9].+$/.test(s) ? "tra" : "in") + " " + s;
      },
      past: "%s fa",
      s: "alcuni secondi",
      ss: "%d secondi",
      m: "un minuto",
      mm: "%d minuti",
      h: "un'ora",
      hh: "%d ore",
      d: "un giorno",
      dd: "%d giorni",
      M: "un mese",
      MM: "%d mesi",
      y: "un anno",
      yy: "%d anni"
     },
     dayOfMonthOrdinalParse: /\d{1,2}º/,
     ordinal: "%dº",
     week: {
      dow: 1,
      doy: 4
     }
    });
   }(__webpack_require__(95093));
  },
  88383: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    moment.defineLocale("it", {
     months: "gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre".split("_"),
     monthsShort: "gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic".split("_"),
     weekdays: "domenica_lunedì_martedì_mercoledì_giovedì_venerdì_sabato".split("_"),
     weekdaysShort: "dom_lun_mar_mer_gio_ven_sab".split("_"),
     weekdaysMin: "do_lu_ma_me_gi_ve_sa".split("_"),
     longDateFormat: {
      LT: "HH:mm",
      LTS: "HH:mm:ss",
      L: "DD/MM/YYYY",
      LL: "D MMMM YYYY",
      LLL: "D MMMM YYYY HH:mm",
      LLLL: "dddd D MMMM YYYY HH:mm"
     },
     calendar: {
      sameDay: function() {
       return "[Oggi a" + (this.hours() > 1 ? "lle " : 0 === this.hours() ? " " : "ll'") + "]LT";
      },
      nextDay: function() {
       return "[Domani a" + (this.hours() > 1 ? "lle " : 0 === this.hours() ? " " : "ll'") + "]LT";
      },
      nextWeek: function() {
       return "dddd [a" + (this.hours() > 1 ? "lle " : 0 === this.hours() ? " " : "ll'") + "]LT";
      },
      lastDay: function() {
       return "[Ieri a" + (this.hours() > 1 ? "lle " : 0 === this.hours() ? " " : "ll'") + "]LT";
      },
      lastWeek: function() {
       return 0 === this.day() ? "[La scorsa] dddd [a" + (this.hours() > 1 ? "lle " : 0 === this.hours() ? " " : "ll'") + "]LT" : "[Lo scorso] dddd [a" + (this.hours() > 1 ? "lle " : 0 === this.hours() ? " " : "ll'") + "]LT";
      },
      sameElse: "L"
     },
     relativeTime: {
      future: "tra %s",
      past: "%s fa",
      s: "alcuni secondi",
      ss: "%d secondi",
      m: "un minuto",
      mm: "%d minuti",
      h: "un'ora",
      hh: "%d ore",
      d: "un giorno",
      dd: "%d giorni",
      w: "una settimana",
      ww: "%d settimane",
      M: "un mese",
      MM: "%d mesi",
      y: "un anno",
      yy: "%d anni"
     },
     dayOfMonthOrdinalParse: /\d{1,2}º/,
     ordinal: "%dº",
     week: {
      dow: 1,
      doy: 4
     }
    });
   }(__webpack_require__(95093));
  },
  23827: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    moment.defineLocale("ja", {
     eras: [ {
      since: "2019-05-01",
      offset: 1,
      name: "令和",
      narrow: "㋿",
      abbr: "R"
     }, {
      since: "1989-01-08",
      until: "2019-04-30",
      offset: 1,
      name: "平成",
      narrow: "㍻",
      abbr: "H"
     }, {
      since: "1926-12-25",
      until: "1989-01-07",
      offset: 1,
      name: "昭和",
      narrow: "㍼",
      abbr: "S"
     }, {
      since: "1912-07-30",
      until: "1926-12-24",
      offset: 1,
      name: "大正",
      narrow: "㍽",
      abbr: "T"
     }, {
      since: "1873-01-01",
      until: "1912-07-29",
      offset: 6,
      name: "明治",
      narrow: "㍾",
      abbr: "M"
     }, {
      since: "0001-01-01",
      until: "1873-12-31",
      offset: 1,
      name: "西暦",
      narrow: "AD",
      abbr: "AD"
     }, {
      since: "0000-12-31",
      until: -1 / 0,
      offset: 1,
      name: "紀元前",
      narrow: "BC",
      abbr: "BC"
     } ],
     eraYearOrdinalRegex: /(元|\d+)年/,
     eraYearOrdinalParse: function(input, match) {
      return "元" === match[1] ? 1 : parseInt(match[1] || input, 10);
     },
     months: "1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月".split("_"),
     monthsShort: "1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月".split("_"),
     weekdays: "日曜日_月曜日_火曜日_水曜日_木曜日_金曜日_土曜日".split("_"),
     weekdaysShort: "日_月_火_水_木_金_土".split("_"),
     weekdaysMin: "日_月_火_水_木_金_土".split("_"),
     longDateFormat: {
      LT: "HH:mm",
      LTS: "HH:mm:ss",
      L: "YYYY/MM/DD",
      LL: "YYYY年M月D日",
      LLL: "YYYY年M月D日 HH:mm",
      LLLL: "YYYY年M月D日 dddd HH:mm",
      l: "YYYY/MM/DD",
      ll: "YYYY年M月D日",
      lll: "YYYY年M月D日 HH:mm",
      llll: "YYYY年M月D日(ddd) HH:mm"
     },
     meridiemParse: /午前|午後/i,
     isPM: function(input) {
      return "午後" === input;
     },
     meridiem: function(hour, minute, isLower) {
      return hour < 12 ? "午前" : "午後";
     },
     calendar: {
      sameDay: "[今日] LT",
      nextDay: "[明日] LT",
      nextWeek: function(now) {
       return now.week() !== this.week() ? "[来週]dddd LT" : "dddd LT";
      },
      lastDay: "[昨日] LT",
      lastWeek: function(now) {
       return this.week() !== now.week() ? "[先週]dddd LT" : "dddd LT";
      },
      sameElse: "L"
     },
     dayOfMonthOrdinalParse: /\d{1,2}日/,
     ordinal: function(number, period) {
      switch (period) {
      case "y":
       return 1 === number ? "元年" : number + "年";

      case "d":
      case "D":
      case "DDD":
       return number + "日";

      default:
       return number;
      }
     },
     relativeTime: {
      future: "%s後",
      past: "%s前",
      s: "数秒",
      ss: "%d秒",
      m: "1分",
      mm: "%d分",
      h: "1時間",
      hh: "%d時間",
      d: "1日",
      dd: "%d日",
      M: "1ヶ月",
      MM: "%dヶ月",
      y: "1年",
      yy: "%d年"
     }
    });
   }(__webpack_require__(95093));
  },
  89722: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    moment.defineLocale("jv", {
     months: "Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_Nopember_Desember".split("_"),
     monthsShort: "Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nop_Des".split("_"),
     weekdays: "Minggu_Senen_Seloso_Rebu_Kemis_Jemuwah_Septu".split("_"),
     weekdaysShort: "Min_Sen_Sel_Reb_Kem_Jem_Sep".split("_"),
     weekdaysMin: "Mg_Sn_Sl_Rb_Km_Jm_Sp".split("_"),
     longDateFormat: {
      LT: "HH.mm",
      LTS: "HH.mm.ss",
      L: "DD/MM/YYYY",
      LL: "D MMMM YYYY",
      LLL: "D MMMM YYYY [pukul] HH.mm",
      LLLL: "dddd, D MMMM YYYY [pukul] HH.mm"
     },
     meridiemParse: /enjing|siyang|sonten|ndalu/,
     meridiemHour: function(hour, meridiem) {
      return 12 === hour && (hour = 0), "enjing" === meridiem ? hour : "siyang" === meridiem ? hour >= 11 ? hour : hour + 12 : "sonten" === meridiem || "ndalu" === meridiem ? hour + 12 : void 0;
     },
     meridiem: function(hours, minutes, isLower) {
      return hours < 11 ? "enjing" : hours < 15 ? "siyang" : hours < 19 ? "sonten" : "ndalu";
     },
     calendar: {
      sameDay: "[Dinten puniko pukul] LT",
      nextDay: "[Mbenjang pukul] LT",
      nextWeek: "dddd [pukul] LT",
      lastDay: "[Kala wingi pukul] LT",
      lastWeek: "dddd [kepengker pukul] LT",
      sameElse: "L"
     },
     relativeTime: {
      future: "wonten ing %s",
      past: "%s ingkang kepengker",
      s: "sawetawis detik",
      ss: "%d detik",
      m: "setunggal menit",
      mm: "%d menit",
      h: "setunggal jam",
      hh: "%d jam",
      d: "sedinten",
      dd: "%d dinten",
      M: "sewulan",
      MM: "%d wulan",
      y: "setaun",
      yy: "%d taun"
     },
     week: {
      dow: 1,
      doy: 7
     }
    });
   }(__webpack_require__(95093));
  },
  41794: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    moment.defineLocale("ka", {
     months: "იანვარი_თებერვალი_მარტი_აპრილი_მაისი_ივნისი_ივლისი_აგვისტო_სექტემბერი_ოქტომბერი_ნოემბერი_დეკემბერი".split("_"),
     monthsShort: "იან_თებ_მარ_აპრ_მაი_ივნ_ივლ_აგვ_სექ_ოქტ_ნოე_დეკ".split("_"),
     weekdays: {
      standalone: "კვირა_ორშაბათი_სამშაბათი_ოთხშაბათი_ხუთშაბათი_პარასკევი_შაბათი".split("_"),
      format: "კვირას_ორშაბათს_სამშაბათს_ოთხშაბათს_ხუთშაბათს_პარასკევს_შაბათს".split("_"),
      isFormat: /(წინა|შემდეგ)/
     },
     weekdaysShort: "კვი_ორშ_სამ_ოთხ_ხუთ_პარ_შაბ".split("_"),
     weekdaysMin: "კვ_ორ_სა_ოთ_ხუ_პა_შა".split("_"),
     longDateFormat: {
      LT: "HH:mm",
      LTS: "HH:mm:ss",
      L: "DD/MM/YYYY",
      LL: "D MMMM YYYY",
      LLL: "D MMMM YYYY HH:mm",
      LLLL: "dddd, D MMMM YYYY HH:mm"
     },
     calendar: {
      sameDay: "[დღეს] LT[-ზე]",
      nextDay: "[ხვალ] LT[-ზე]",
      lastDay: "[გუშინ] LT[-ზე]",
      nextWeek: "[შემდეგ] dddd LT[-ზე]",
      lastWeek: "[წინა] dddd LT-ზე",
      sameElse: "L"
     },
     relativeTime: {
      future: function(s) {
       return s.replace(/(წამ|წუთ|საათ|წელ|დღ|თვ)(ი|ე)/, (function($0, $1, $2) {
        return "ი" === $2 ? $1 + "ში" : $1 + $2 + "ში";
       }));
      },
      past: function(s) {
       return /(წამი|წუთი|საათი|დღე|თვე)/.test(s) ? s.replace(/(ი|ე)$/, "ის წინ") : /წელი/.test(s) ? s.replace(/წელი$/, "წლის წინ") : s;
      },
      s: "რამდენიმე წამი",
      ss: "%d წამი",
      m: "წუთი",
      mm: "%d წუთი",
      h: "საათი",
      hh: "%d საათი",
      d: "დღე",
      dd: "%d დღე",
      M: "თვე",
      MM: "%d თვე",
      y: "წელი",
      yy: "%d წელი"
     },
     dayOfMonthOrdinalParse: /0|1-ლი|მე-\d{1,2}|\d{1,2}-ე/,
     ordinal: function(number) {
      return 0 === number ? number : 1 === number ? number + "-ლი" : number < 20 || number <= 100 && number % 20 == 0 || number % 100 == 0 ? "მე-" + number : number + "-ე";
     },
     week: {
      dow: 1,
      doy: 7
     }
    });
   }(__webpack_require__(95093));
  },
  27088: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    var suffixes = {
     0: "-ші",
     1: "-ші",
     2: "-ші",
     3: "-ші",
     4: "-ші",
     5: "-ші",
     6: "-шы",
     7: "-ші",
     8: "-ші",
     9: "-шы",
     10: "-шы",
     20: "-шы",
     30: "-шы",
     40: "-шы",
     50: "-ші",
     60: "-шы",
     70: "-ші",
     80: "-ші",
     90: "-шы",
     100: "-ші"
    };
    moment.defineLocale("kk", {
     months: "қаңтар_ақпан_наурыз_сәуір_мамыр_маусым_шілде_тамыз_қыркүйек_қазан_қараша_желтоқсан".split("_"),
     monthsShort: "қаң_ақп_нау_сәу_мам_мау_шіл_там_қыр_қаз_қар_жел".split("_"),
     weekdays: "жексенбі_дүйсенбі_сейсенбі_сәрсенбі_бейсенбі_жұма_сенбі".split("_"),
     weekdaysShort: "жек_дүй_сей_сәр_бей_жұм_сен".split("_"),
     weekdaysMin: "жк_дй_сй_ср_бй_жм_сн".split("_"),
     longDateFormat: {
      LT: "HH:mm",
      LTS: "HH:mm:ss",
      L: "DD.MM.YYYY",
      LL: "D MMMM YYYY",
      LLL: "D MMMM YYYY HH:mm",
      LLLL: "dddd, D MMMM YYYY HH:mm"
     },
     calendar: {
      sameDay: "[Бүгін сағат] LT",
      nextDay: "[Ертең сағат] LT",
      nextWeek: "dddd [сағат] LT",
      lastDay: "[Кеше сағат] LT",
      lastWeek: "[Өткен аптаның] dddd [сағат] LT",
      sameElse: "L"
     },
     relativeTime: {
      future: "%s ішінде",
      past: "%s бұрын",
      s: "бірнеше секунд",
      ss: "%d секунд",
      m: "бір минут",
      mm: "%d минут",
      h: "бір сағат",
      hh: "%d сағат",
      d: "бір күн",
      dd: "%d күн",
      M: "бір ай",
      MM: "%d ай",
      y: "бір жыл",
      yy: "%d жыл"
     },
     dayOfMonthOrdinalParse: /\d{1,2}-(ші|шы)/,
     ordinal: function(number) {
      var a = number % 10, b = number >= 100 ? 100 : null;
      return number + (suffixes[number] || suffixes[a] || suffixes[b]);
     },
     week: {
      dow: 1,
      doy: 7
     }
    });
   }(__webpack_require__(95093));
  },
  96870: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    var symbolMap = {
     1: "១",
     2: "២",
     3: "៣",
     4: "៤",
     5: "៥",
     6: "៦",
     7: "៧",
     8: "៨",
     9: "៩",
     0: "០"
    }, numberMap = {
     "១": "1",
     "២": "2",
     "៣": "3",
     "៤": "4",
     "៥": "5",
     "៦": "6",
     "៧": "7",
     "៨": "8",
     "៩": "9",
     "០": "0"
    };
    moment.defineLocale("km", {
     months: "មករា_កុម្ភៈ_មីនា_មេសា_ឧសភា_មិថុនា_កក្កដា_សីហា_កញ្ញា_តុលា_វិច្ឆិកា_ធ្នូ".split("_"),
     monthsShort: "មករា_កុម្ភៈ_មីនា_មេសា_ឧសភា_មិថុនា_កក្កដា_សីហា_កញ្ញា_តុលា_វិច្ឆិកា_ធ្នូ".split("_"),
     weekdays: "អាទិត្យ_ច័ន្ទ_អង្គារ_ពុធ_ព្រហស្បតិ៍_សុក្រ_សៅរ៍".split("_"),
     weekdaysShort: "អា_ច_អ_ព_ព្រ_សុ_ស".split("_"),
     weekdaysMin: "អា_ច_អ_ព_ព្រ_សុ_ស".split("_"),
     weekdaysParseExact: !0,
     longDateFormat: {
      LT: "HH:mm",
      LTS: "HH:mm:ss",
      L: "DD/MM/YYYY",
      LL: "D MMMM YYYY",
      LLL: "D MMMM YYYY HH:mm",
      LLLL: "dddd, D MMMM YYYY HH:mm"
     },
     meridiemParse: /ព្រឹក|ល្ងាច/,
     isPM: function(input) {
      return "ល្ងាច" === input;
     },
     meridiem: function(hour, minute, isLower) {
      return hour < 12 ? "ព្រឹក" : "ល្ងាច";
     },
     calendar: {
      sameDay: "[ថ្ងៃនេះ ម៉ោង] LT",
      nextDay: "[ស្អែក ម៉ោង] LT",
      nextWeek: "dddd [ម៉ោង] LT",
      lastDay: "[ម្សិលមិញ ម៉ោង] LT",
      lastWeek: "dddd [សប្តាហ៍មុន] [ម៉ោង] LT",
      sameElse: "L"
     },
     relativeTime: {
      future: "%sទៀត",
      past: "%sមុន",
      s: "ប៉ុន្មានវិនាទី",
      ss: "%d វិនាទី",
      m: "មួយនាទី",
      mm: "%d នាទី",
      h: "មួយម៉ោង",
      hh: "%d ម៉ោង",
      d: "មួយថ្ងៃ",
      dd: "%d ថ្ងៃ",
      M: "មួយខែ",
      MM: "%d ខែ",
      y: "មួយឆ្នាំ",
      yy: "%d ឆ្នាំ"
     },
     dayOfMonthOrdinalParse: /ទី\d{1,2}/,
     ordinal: "ទី%d",
     preparse: function(string) {
      return string.replace(/[១២៣៤៥៦៧៨៩០]/g, (function(match) {
       return numberMap[match];
      }));
     },
     postformat: function(string) {
      return string.replace(/\d/g, (function(match) {
       return symbolMap[match];
      }));
     },
     week: {
      dow: 1,
      doy: 4
     }
    });
   }(__webpack_require__(95093));
  },
  84451: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    var symbolMap = {
     1: "೧",
     2: "೨",
     3: "೩",
     4: "೪",
     5: "೫",
     6: "೬",
     7: "೭",
     8: "೮",
     9: "೯",
     0: "೦"
    }, numberMap = {
     "೧": "1",
     "೨": "2",
     "೩": "3",
     "೪": "4",
     "೫": "5",
     "೬": "6",
     "೭": "7",
     "೮": "8",
     "೯": "9",
     "೦": "0"
    };
    moment.defineLocale("kn", {
     months: "ಜನವರಿ_ಫೆಬ್ರವರಿ_ಮಾರ್ಚ್_ಏಪ್ರಿಲ್_ಮೇ_ಜೂನ್_ಜುಲೈ_ಆಗಸ್ಟ್_ಸೆಪ್ಟೆಂಬರ್_ಅಕ್ಟೋಬರ್_ನವೆಂಬರ್_ಡಿಸೆಂಬರ್".split("_"),
     monthsShort: "ಜನ_ಫೆಬ್ರ_ಮಾರ್ಚ್_ಏಪ್ರಿಲ್_ಮೇ_ಜೂನ್_ಜುಲೈ_ಆಗಸ್ಟ್_ಸೆಪ್ಟೆಂ_ಅಕ್ಟೋ_ನವೆಂ_ಡಿಸೆಂ".split("_"),
     monthsParseExact: !0,
     weekdays: "ಭಾನುವಾರ_ಸೋಮವಾರ_ಮಂಗಳವಾರ_ಬುಧವಾರ_ಗುರುವಾರ_ಶುಕ್ರವಾರ_ಶನಿವಾರ".split("_"),
     weekdaysShort: "ಭಾನು_ಸೋಮ_ಮಂಗಳ_ಬುಧ_ಗುರು_ಶುಕ್ರ_ಶನಿ".split("_"),
     weekdaysMin: "ಭಾ_ಸೋ_ಮಂ_ಬು_ಗು_ಶು_ಶ".split("_"),
     longDateFormat: {
      LT: "A h:mm",
      LTS: "A h:mm:ss",
      L: "DD/MM/YYYY",
      LL: "D MMMM YYYY",
      LLL: "D MMMM YYYY, A h:mm",
      LLLL: "dddd, D MMMM YYYY, A h:mm"
     },
     calendar: {
      sameDay: "[ಇಂದು] LT",
      nextDay: "[ನಾಳೆ] LT",
      nextWeek: "dddd, LT",
      lastDay: "[ನಿನ್ನೆ] LT",
      lastWeek: "[ಕೊನೆಯ] dddd, LT",
      sameElse: "L"
     },
     relativeTime: {
      future: "%s ನಂತರ",
      past: "%s ಹಿಂದೆ",
      s: "ಕೆಲವು ಕ್ಷಣಗಳು",
      ss: "%d ಸೆಕೆಂಡುಗಳು",
      m: "ಒಂದು ನಿಮಿಷ",
      mm: "%d ನಿಮಿಷ",
      h: "ಒಂದು ಗಂಟೆ",
      hh: "%d ಗಂಟೆ",
      d: "ಒಂದು ದಿನ",
      dd: "%d ದಿನ",
      M: "ಒಂದು ತಿಂಗಳು",
      MM: "%d ತಿಂಗಳು",
      y: "ಒಂದು ವರ್ಷ",
      yy: "%d ವರ್ಷ"
     },
     preparse: function(string) {
      return string.replace(/[೧೨೩೪೫೬೭೮೯೦]/g, (function(match) {
       return numberMap[match];
      }));
     },
     postformat: function(string) {
      return string.replace(/\d/g, (function(match) {
       return symbolMap[match];
      }));
     },
     meridiemParse: /ರಾತ್ರಿ|ಬೆಳಿಗ್ಗೆ|ಮಧ್ಯಾಹ್ನ|ಸಂಜೆ/,
     meridiemHour: function(hour, meridiem) {
      return 12 === hour && (hour = 0), "ರಾತ್ರಿ" === meridiem ? hour < 4 ? hour : hour + 12 : "ಬೆಳಿಗ್ಗೆ" === meridiem ? hour : "ಮಧ್ಯಾಹ್ನ" === meridiem ? hour >= 10 ? hour : hour + 12 : "ಸಂಜೆ" === meridiem ? hour + 12 : void 0;
     },
     meridiem: function(hour, minute, isLower) {
      return hour < 4 ? "ರಾತ್ರಿ" : hour < 10 ? "ಬೆಳಿಗ್ಗೆ" : hour < 17 ? "ಮಧ್ಯಾಹ್ನ" : hour < 20 ? "ಸಂಜೆ" : "ರಾತ್ರಿ";
     },
     dayOfMonthOrdinalParse: /\d{1,2}(ನೇ)/,
     ordinal: function(number) {
      return number + "ನೇ";
     },
     week: {
      dow: 0,
      doy: 6
     }
    });
   }(__webpack_require__(95093));
  },
  63164: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    moment.defineLocale("ko", {
     months: "1월_2월_3월_4월_5월_6월_7월_8월_9월_10월_11월_12월".split("_"),
     monthsShort: "1월_2월_3월_4월_5월_6월_7월_8월_9월_10월_11월_12월".split("_"),
     weekdays: "일요일_월요일_화요일_수요일_목요일_금요일_토요일".split("_"),
     weekdaysShort: "일_월_화_수_목_금_토".split("_"),
     weekdaysMin: "일_월_화_수_목_금_토".split("_"),
     longDateFormat: {
      LT: "A h:mm",
      LTS: "A h:mm:ss",
      L: "YYYY.MM.DD.",
      LL: "YYYY년 MMMM D일",
      LLL: "YYYY년 MMMM D일 A h:mm",
      LLLL: "YYYY년 MMMM D일 dddd A h:mm",
      l: "YYYY.MM.DD.",
      ll: "YYYY년 MMMM D일",
      lll: "YYYY년 MMMM D일 A h:mm",
      llll: "YYYY년 MMMM D일 dddd A h:mm"
     },
     calendar: {
      sameDay: "오늘 LT",
      nextDay: "내일 LT",
      nextWeek: "dddd LT",
      lastDay: "어제 LT",
      lastWeek: "지난주 dddd LT",
      sameElse: "L"
     },
     relativeTime: {
      future: "%s 후",
      past: "%s 전",
      s: "몇 초",
      ss: "%d초",
      m: "1분",
      mm: "%d분",
      h: "한 시간",
      hh: "%d시간",
      d: "하루",
      dd: "%d일",
      M: "한 달",
      MM: "%d달",
      y: "일 년",
      yy: "%d년"
     },
     dayOfMonthOrdinalParse: /\d{1,2}(일|월|주)/,
     ordinal: function(number, period) {
      switch (period) {
      case "d":
      case "D":
      case "DDD":
       return number + "일";

      case "M":
       return number + "월";

      case "w":
      case "W":
       return number + "주";

      default:
       return number;
      }
     },
     meridiemParse: /오전|오후/,
     isPM: function(token) {
      return "오후" === token;
     },
     meridiem: function(hour, minute, isUpper) {
      return hour < 12 ? "오전" : "오후";
     }
    });
   }(__webpack_require__(95093));
  },
  6181: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    function processRelativeTime(num, withoutSuffix, key, isFuture) {
     var format = {
      s: [ "çend sanîye", "çend sanîyeyan" ],
      ss: [ num + " sanîye", num + " sanîyeyan" ],
      m: [ "deqîqeyek", "deqîqeyekê" ],
      mm: [ num + " deqîqe", num + " deqîqeyan" ],
      h: [ "saetek", "saetekê" ],
      hh: [ num + " saet", num + " saetan" ],
      d: [ "rojek", "rojekê" ],
      dd: [ num + " roj", num + " rojan" ],
      w: [ "hefteyek", "hefteyekê" ],
      ww: [ num + " hefte", num + " hefteyan" ],
      M: [ "mehek", "mehekê" ],
      MM: [ num + " meh", num + " mehan" ],
      y: [ "salek", "salekê" ],
      yy: [ num + " sal", num + " salan" ]
     };
     return withoutSuffix ? format[key][0] : format[key][1];
    }
    function ezafeNumSuffix(num) {
     var l = (num = "" + num).substring(num.length - 1), ll = num.length > 1 ? num.substring(num.length - 2) : "";
     return 12 == ll || 13 == ll || "2" != l && "3" != l && "50" != ll && "70" != l && "80" != l ? "ê" : "yê";
    }
    moment.defineLocale("ku-kmr", {
     months: "Rêbendan_Sibat_Adar_Nîsan_Gulan_Hezîran_Tîrmeh_Tebax_Îlon_Cotmeh_Mijdar_Berfanbar".split("_"),
     monthsShort: "Rêb_Sib_Ada_Nîs_Gul_Hez_Tîr_Teb_Îlo_Cot_Mij_Ber".split("_"),
     monthsParseExact: !0,
     weekdays: "Yekşem_Duşem_Sêşem_Çarşem_Pêncşem_În_Şemî".split("_"),
     weekdaysShort: "Yek_Du_Sê_Çar_Pên_În_Şem".split("_"),
     weekdaysMin: "Ye_Du_Sê_Ça_Pê_În_Şe".split("_"),
     meridiem: function(hours, minutes, isLower) {
      return hours < 12 ? isLower ? "bn" : "BN" : isLower ? "pn" : "PN";
     },
     meridiemParse: /bn|BN|pn|PN/,
     longDateFormat: {
      LT: "HH:mm",
      LTS: "HH:mm:ss",
      L: "DD.MM.YYYY",
      LL: "Do MMMM[a] YYYY[an]",
      LLL: "Do MMMM[a] YYYY[an] HH:mm",
      LLLL: "dddd, Do MMMM[a] YYYY[an] HH:mm",
      ll: "Do MMM[.] YYYY[an]",
      lll: "Do MMM[.] YYYY[an] HH:mm",
      llll: "ddd[.], Do MMM[.] YYYY[an] HH:mm"
     },
     calendar: {
      sameDay: "[Îro di saet] LT [de]",
      nextDay: "[Sibê di saet] LT [de]",
      nextWeek: "dddd [di saet] LT [de]",
      lastDay: "[Duh di saet] LT [de]",
      lastWeek: "dddd[a borî di saet] LT [de]",
      sameElse: "L"
     },
     relativeTime: {
      future: "di %s de",
      past: "berî %s",
      s: processRelativeTime,
      ss: processRelativeTime,
      m: processRelativeTime,
      mm: processRelativeTime,
      h: processRelativeTime,
      hh: processRelativeTime,
      d: processRelativeTime,
      dd: processRelativeTime,
      w: processRelativeTime,
      ww: processRelativeTime,
      M: processRelativeTime,
      MM: processRelativeTime,
      y: processRelativeTime,
      yy: processRelativeTime
     },
     dayOfMonthOrdinalParse: /\d{1,2}(?:yê|ê|\.)/,
     ordinal: function(num, period) {
      var p = period.toLowerCase();
      return p.includes("w") || p.includes("m") ? num + "." : num + ezafeNumSuffix(num);
     },
     week: {
      dow: 1,
      doy: 4
     }
    });
   }(__webpack_require__(95093));
  },
  98174: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    var symbolMap = {
     1: "١",
     2: "٢",
     3: "٣",
     4: "٤",
     5: "٥",
     6: "٦",
     7: "٧",
     8: "٨",
     9: "٩",
     0: "٠"
    }, numberMap = {
     "١": "1",
     "٢": "2",
     "٣": "3",
     "٤": "4",
     "٥": "5",
     "٦": "6",
     "٧": "7",
     "٨": "8",
     "٩": "9",
     "٠": "0"
    }, months = [ "کانونی دووەم", "شوبات", "ئازار", "نیسان", "ئایار", "حوزەیران", "تەمموز", "ئاب", "ئەیلوول", "تشرینی یەكەم", "تشرینی دووەم", "كانونی یەکەم" ];
    moment.defineLocale("ku", {
     months,
     monthsShort: months,
     weekdays: "یه‌كشه‌ممه‌_دووشه‌ممه‌_سێشه‌ممه‌_چوارشه‌ممه‌_پێنجشه‌ممه‌_هه‌ینی_شه‌ممه‌".split("_"),
     weekdaysShort: "یه‌كشه‌م_دووشه‌م_سێشه‌م_چوارشه‌م_پێنجشه‌م_هه‌ینی_شه‌ممه‌".split("_"),
     weekdaysMin: "ی_د_س_چ_پ_ه_ش".split("_"),
     weekdaysParseExact: !0,
     longDateFormat: {
      LT: "HH:mm",
      LTS: "HH:mm:ss",
      L: "DD/MM/YYYY",
      LL: "D MMMM YYYY",
      LLL: "D MMMM YYYY HH:mm",
      LLLL: "dddd, D MMMM YYYY HH:mm"
     },
     meridiemParse: /ئێواره‌|به‌یانی/,
     isPM: function(input) {
      return /ئێواره‌/.test(input);
     },
     meridiem: function(hour, minute, isLower) {
      return hour < 12 ? "به‌یانی" : "ئێواره‌";
     },
     calendar: {
      sameDay: "[ئه‌مرۆ كاتژمێر] LT",
      nextDay: "[به‌یانی كاتژمێر] LT",
      nextWeek: "dddd [كاتژمێر] LT",
      lastDay: "[دوێنێ كاتژمێر] LT",
      lastWeek: "dddd [كاتژمێر] LT",
      sameElse: "L"
     },
     relativeTime: {
      future: "له‌ %s",
      past: "%s",
      s: "چه‌ند چركه‌یه‌ك",
      ss: "چركه‌ %d",
      m: "یه‌ك خوله‌ك",
      mm: "%d خوله‌ك",
      h: "یه‌ك كاتژمێر",
      hh: "%d كاتژمێر",
      d: "یه‌ك ڕۆژ",
      dd: "%d ڕۆژ",
      M: "یه‌ك مانگ",
      MM: "%d مانگ",
      y: "یه‌ك ساڵ",
      yy: "%d ساڵ"
     },
     preparse: function(string) {
      return string.replace(/[١٢٣٤٥٦٧٨٩٠]/g, (function(match) {
       return numberMap[match];
      })).replace(/،/g, ",");
     },
     postformat: function(string) {
      return string.replace(/\d/g, (function(match) {
       return symbolMap[match];
      })).replace(/,/g, "،");
     },
     week: {
      dow: 6,
      doy: 12
     }
    });
   }(__webpack_require__(95093));
  },
  78474: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    var suffixes = {
     0: "-чү",
     1: "-чи",
     2: "-чи",
     3: "-чү",
     4: "-чү",
     5: "-чи",
     6: "-чы",
     7: "-чи",
     8: "-чи",
     9: "-чу",
     10: "-чу",
     20: "-чы",
     30: "-чу",
     40: "-чы",
     50: "-чү",
     60: "-чы",
     70: "-чи",
     80: "-чи",
     90: "-чу",
     100: "-чү"
    };
    moment.defineLocale("ky", {
     months: "январь_февраль_март_апрель_май_июнь_июль_август_сентябрь_октябрь_ноябрь_декабрь".split("_"),
     monthsShort: "янв_фев_март_апр_май_июнь_июль_авг_сен_окт_ноя_дек".split("_"),
     weekdays: "Жекшемби_Дүйшөмбү_Шейшемби_Шаршемби_Бейшемби_Жума_Ишемби".split("_"),
     weekdaysShort: "Жек_Дүй_Шей_Шар_Бей_Жум_Ише".split("_"),
     weekdaysMin: "Жк_Дй_Шй_Шр_Бй_Жм_Иш".split("_"),
     longDateFormat: {
      LT: "HH:mm",
      LTS: "HH:mm:ss",
      L: "DD.MM.YYYY",
      LL: "D MMMM YYYY",
      LLL: "D MMMM YYYY HH:mm",
      LLLL: "dddd, D MMMM YYYY HH:mm"
     },
     calendar: {
      sameDay: "[Бүгүн саат] LT",
      nextDay: "[Эртең саат] LT",
      nextWeek: "dddd [саат] LT",
      lastDay: "[Кечээ саат] LT",
      lastWeek: "[Өткөн аптанын] dddd [күнү] [саат] LT",
      sameElse: "L"
     },
     relativeTime: {
      future: "%s ичинде",
      past: "%s мурун",
      s: "бирнече секунд",
      ss: "%d секунд",
      m: "бир мүнөт",
      mm: "%d мүнөт",
      h: "бир саат",
      hh: "%d саат",
      d: "бир күн",
      dd: "%d күн",
      M: "бир ай",
      MM: "%d ай",
      y: "бир жыл",
      yy: "%d жыл"
     },
     dayOfMonthOrdinalParse: /\d{1,2}-(чи|чы|чү|чу)/,
     ordinal: function(number) {
      var a = number % 10, b = number >= 100 ? 100 : null;
      return number + (suffixes[number] || suffixes[a] || suffixes[b]);
     },
     week: {
      dow: 1,
      doy: 7
     }
    });
   }(__webpack_require__(95093));
  },
  79680: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    function processRelativeTime(number, withoutSuffix, key, isFuture) {
     var format = {
      m: [ "eng Minutt", "enger Minutt" ],
      h: [ "eng Stonn", "enger Stonn" ],
      d: [ "een Dag", "engem Dag" ],
      M: [ "ee Mount", "engem Mount" ],
      y: [ "ee Joer", "engem Joer" ]
     };
     return withoutSuffix ? format[key][0] : format[key][1];
    }
    function processFutureTime(string) {
     return eifelerRegelAppliesToNumber(string.substr(0, string.indexOf(" "))) ? "a " + string : "an " + string;
    }
    function processPastTime(string) {
     return eifelerRegelAppliesToNumber(string.substr(0, string.indexOf(" "))) ? "viru " + string : "virun " + string;
    }
    function eifelerRegelAppliesToNumber(number) {
     if (number = parseInt(number, 10), isNaN(number)) return !1;
     if (number < 0) return !0;
     if (number < 10) return 4 <= number && number <= 7;
     if (number < 100) {
      var lastDigit = number % 10;
      return eifelerRegelAppliesToNumber(0 === lastDigit ? number / 10 : lastDigit);
     }
     if (number < 1e4) {
      for (;number >= 10; ) number /= 10;
      return eifelerRegelAppliesToNumber(number);
     }
     return eifelerRegelAppliesToNumber(number /= 1e3);
    }
    moment.defineLocale("lb", {
     months: "Januar_Februar_Mäerz_Abrëll_Mee_Juni_Juli_August_September_Oktober_November_Dezember".split("_"),
     monthsShort: "Jan._Febr._Mrz._Abr._Mee_Jun._Jul._Aug._Sept._Okt._Nov._Dez.".split("_"),
     monthsParseExact: !0,
     weekdays: "Sonndeg_Méindeg_Dënschdeg_Mëttwoch_Donneschdeg_Freideg_Samschdeg".split("_"),
     weekdaysShort: "So._Mé._Dë._Më._Do._Fr._Sa.".split("_"),
     weekdaysMin: "So_Mé_Dë_Më_Do_Fr_Sa".split("_"),
     weekdaysParseExact: !0,
     longDateFormat: {
      LT: "H:mm [Auer]",
      LTS: "H:mm:ss [Auer]",
      L: "DD.MM.YYYY",
      LL: "D. MMMM YYYY",
      LLL: "D. MMMM YYYY H:mm [Auer]",
      LLLL: "dddd, D. MMMM YYYY H:mm [Auer]"
     },
     calendar: {
      sameDay: "[Haut um] LT",
      sameElse: "L",
      nextDay: "[Muer um] LT",
      nextWeek: "dddd [um] LT",
      lastDay: "[Gëschter um] LT",
      lastWeek: function() {
       switch (this.day()) {
       case 2:
       case 4:
        return "[Leschten] dddd [um] LT";

       default:
        return "[Leschte] dddd [um] LT";
       }
      }
     },
     relativeTime: {
      future: processFutureTime,
      past: processPastTime,
      s: "e puer Sekonnen",
      ss: "%d Sekonnen",
      m: processRelativeTime,
      mm: "%d Minutten",
      h: processRelativeTime,
      hh: "%d Stonnen",
      d: processRelativeTime,
      dd: "%d Deeg",
      M: processRelativeTime,
      MM: "%d Méint",
      y: processRelativeTime,
      yy: "%d Joer"
     },
     dayOfMonthOrdinalParse: /\d{1,2}\./,
     ordinal: "%d.",
     week: {
      dow: 1,
      doy: 4
     }
    });
   }(__webpack_require__(95093));
  },
  15867: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    moment.defineLocale("lo", {
     months: "ມັງກອນ_ກຸມພາ_ມີນາ_ເມສາ_ພຶດສະພາ_ມິຖຸນາ_ກໍລະກົດ_ສິງຫາ_ກັນຍາ_ຕຸລາ_ພະຈິກ_ທັນວາ".split("_"),
     monthsShort: "ມັງກອນ_ກຸມພາ_ມີນາ_ເມສາ_ພຶດສະພາ_ມິຖຸນາ_ກໍລະກົດ_ສິງຫາ_ກັນຍາ_ຕຸລາ_ພະຈິກ_ທັນວາ".split("_"),
     weekdays: "ອາທິດ_ຈັນ_ອັງຄານ_ພຸດ_ພະຫັດ_ສຸກ_ເສົາ".split("_"),
     weekdaysShort: "ທິດ_ຈັນ_ອັງຄານ_ພຸດ_ພະຫັດ_ສຸກ_ເສົາ".split("_"),
     weekdaysMin: "ທ_ຈ_ອຄ_ພ_ພຫ_ສກ_ສ".split("_"),
     weekdaysParseExact: !0,
     longDateFormat: {
      LT: "HH:mm",
      LTS: "HH:mm:ss",
      L: "DD/MM/YYYY",
      LL: "D MMMM YYYY",
      LLL: "D MMMM YYYY HH:mm",
      LLLL: "ວັນdddd D MMMM YYYY HH:mm"
     },
     meridiemParse: /ຕອນເຊົ້າ|ຕອນແລງ/,
     isPM: function(input) {
      return "ຕອນແລງ" === input;
     },
     meridiem: function(hour, minute, isLower) {
      return hour < 12 ? "ຕອນເຊົ້າ" : "ຕອນແລງ";
     },
     calendar: {
      sameDay: "[ມື້ນີ້ເວລາ] LT",
      nextDay: "[ມື້ອື່ນເວລາ] LT",
      nextWeek: "[ວັນ]dddd[ໜ້າເວລາ] LT",
      lastDay: "[ມື້ວານນີ້ເວລາ] LT",
      lastWeek: "[ວັນ]dddd[ແລ້ວນີ້ເວລາ] LT",
      sameElse: "L"
     },
     relativeTime: {
      future: "ອີກ %s",
      past: "%sຜ່ານມາ",
      s: "ບໍ່ເທົ່າໃດວິນາທີ",
      ss: "%d ວິນາທີ",
      m: "1 ນາທີ",
      mm: "%d ນາທີ",
      h: "1 ຊົ່ວໂມງ",
      hh: "%d ຊົ່ວໂມງ",
      d: "1 ມື້",
      dd: "%d ມື້",
      M: "1 ເດືອນ",
      MM: "%d ເດືອນ",
      y: "1 ປີ",
      yy: "%d ປີ"
     },
     dayOfMonthOrdinalParse: /(ທີ່)\d{1,2}/,
     ordinal: function(number) {
      return "ທີ່" + number;
     }
    });
   }(__webpack_require__(95093));
  },
  45766: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    var units = {
     ss: "sekundė_sekundžių_sekundes",
     m: "minutė_minutės_minutę",
     mm: "minutės_minučių_minutes",
     h: "valanda_valandos_valandą",
     hh: "valandos_valandų_valandas",
     d: "diena_dienos_dieną",
     dd: "dienos_dienų_dienas",
     M: "mėnuo_mėnesio_mėnesį",
     MM: "mėnesiai_mėnesių_mėnesius",
     y: "metai_metų_metus",
     yy: "metai_metų_metus"
    };
    function translateSeconds(number, withoutSuffix, key, isFuture) {
     return withoutSuffix ? "kelios sekundės" : isFuture ? "kelių sekundžių" : "kelias sekundes";
    }
    function translateSingular(number, withoutSuffix, key, isFuture) {
     return withoutSuffix ? forms(key)[0] : isFuture ? forms(key)[1] : forms(key)[2];
    }
    function special(number) {
     return number % 10 == 0 || number > 10 && number < 20;
    }
    function forms(key) {
     return units[key].split("_");
    }
    function translate(number, withoutSuffix, key, isFuture) {
     var result = number + " ";
     return 1 === number ? result + translateSingular(number, withoutSuffix, key[0], isFuture) : withoutSuffix ? result + (special(number) ? forms(key)[1] : forms(key)[0]) : isFuture ? result + forms(key)[1] : result + (special(number) ? forms(key)[1] : forms(key)[2]);
    }
    moment.defineLocale("lt", {
     months: {
      format: "sausio_vasario_kovo_balandžio_gegužės_birželio_liepos_rugpjūčio_rugsėjo_spalio_lapkričio_gruodžio".split("_"),
      standalone: "sausis_vasaris_kovas_balandis_gegužė_birželis_liepa_rugpjūtis_rugsėjis_spalis_lapkritis_gruodis".split("_"),
      isFormat: /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?|MMMM?(\[[^\[\]]*\]|\s)+D[oD]?/
     },
     monthsShort: "sau_vas_kov_bal_geg_bir_lie_rgp_rgs_spa_lap_grd".split("_"),
     weekdays: {
      format: "sekmadienį_pirmadienį_antradienį_trečiadienį_ketvirtadienį_penktadienį_šeštadienį".split("_"),
      standalone: "sekmadienis_pirmadienis_antradienis_trečiadienis_ketvirtadienis_penktadienis_šeštadienis".split("_"),
      isFormat: /dddd HH:mm/
     },
     weekdaysShort: "Sek_Pir_Ant_Tre_Ket_Pen_Šeš".split("_"),
     weekdaysMin: "S_P_A_T_K_Pn_Š".split("_"),
     weekdaysParseExact: !0,
     longDateFormat: {
      LT: "HH:mm",
      LTS: "HH:mm:ss",
      L: "YYYY-MM-DD",
      LL: "YYYY [m.] MMMM D [d.]",
      LLL: "YYYY [m.] MMMM D [d.], HH:mm [val.]",
      LLLL: "YYYY [m.] MMMM D [d.], dddd, HH:mm [val.]",
      l: "YYYY-MM-DD",
      ll: "YYYY [m.] MMMM D [d.]",
      lll: "YYYY [m.] MMMM D [d.], HH:mm [val.]",
      llll: "YYYY [m.] MMMM D [d.], ddd, HH:mm [val.]"
     },
     calendar: {
      sameDay: "[Šiandien] LT",
      nextDay: "[Rytoj] LT",
      nextWeek: "dddd LT",
      lastDay: "[Vakar] LT",
      lastWeek: "[Praėjusį] dddd LT",
      sameElse: "L"
     },
     relativeTime: {
      future: "po %s",
      past: "prieš %s",
      s: translateSeconds,
      ss: translate,
      m: translateSingular,
      mm: translate,
      h: translateSingular,
      hh: translate,
      d: translateSingular,
      dd: translate,
      M: translateSingular,
      MM: translate,
      y: translateSingular,
      yy: translate
     },
     dayOfMonthOrdinalParse: /\d{1,2}-oji/,
     ordinal: function(number) {
      return number + "-oji";
     },
     week: {
      dow: 1,
      doy: 4
     }
    });
   }(__webpack_require__(95093));
  },
  69532: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    var units = {
     ss: "sekundes_sekundēm_sekunde_sekundes".split("_"),
     m: "minūtes_minūtēm_minūte_minūtes".split("_"),
     mm: "minūtes_minūtēm_minūte_minūtes".split("_"),
     h: "stundas_stundām_stunda_stundas".split("_"),
     hh: "stundas_stundām_stunda_stundas".split("_"),
     d: "dienas_dienām_diena_dienas".split("_"),
     dd: "dienas_dienām_diena_dienas".split("_"),
     M: "mēneša_mēnešiem_mēnesis_mēneši".split("_"),
     MM: "mēneša_mēnešiem_mēnesis_mēneši".split("_"),
     y: "gada_gadiem_gads_gadi".split("_"),
     yy: "gada_gadiem_gads_gadi".split("_")
    };
    function format(forms, number, withoutSuffix) {
     return withoutSuffix ? number % 10 == 1 && number % 100 != 11 ? forms[2] : forms[3] : number % 10 == 1 && number % 100 != 11 ? forms[0] : forms[1];
    }
    function relativeTimeWithPlural(number, withoutSuffix, key) {
     return number + " " + format(units[key], number, withoutSuffix);
    }
    function relativeTimeWithSingular(number, withoutSuffix, key) {
     return format(units[key], number, withoutSuffix);
    }
    function relativeSeconds(number, withoutSuffix) {
     return withoutSuffix ? "dažas sekundes" : "dažām sekundēm";
    }
    moment.defineLocale("lv", {
     months: "janvāris_februāris_marts_aprīlis_maijs_jūnijs_jūlijs_augusts_septembris_oktobris_novembris_decembris".split("_"),
     monthsShort: "jan_feb_mar_apr_mai_jūn_jūl_aug_sep_okt_nov_dec".split("_"),
     weekdays: "svētdiena_pirmdiena_otrdiena_trešdiena_ceturtdiena_piektdiena_sestdiena".split("_"),
     weekdaysShort: "Sv_P_O_T_C_Pk_S".split("_"),
     weekdaysMin: "Sv_P_O_T_C_Pk_S".split("_"),
     weekdaysParseExact: !0,
     longDateFormat: {
      LT: "HH:mm",
      LTS: "HH:mm:ss",
      L: "DD.MM.YYYY.",
      LL: "YYYY. [gada] D. MMMM",
      LLL: "YYYY. [gada] D. MMMM, HH:mm",
      LLLL: "YYYY. [gada] D. MMMM, dddd, HH:mm"
     },
     calendar: {
      sameDay: "[Šodien pulksten] LT",
      nextDay: "[Rīt pulksten] LT",
      nextWeek: "dddd [pulksten] LT",
      lastDay: "[Vakar pulksten] LT",
      lastWeek: "[Pagājušā] dddd [pulksten] LT",
      sameElse: "L"
     },
     relativeTime: {
      future: "pēc %s",
      past: "pirms %s",
      s: relativeSeconds,
      ss: relativeTimeWithPlural,
      m: relativeTimeWithSingular,
      mm: relativeTimeWithPlural,
      h: relativeTimeWithSingular,
      hh: relativeTimeWithPlural,
      d: relativeTimeWithSingular,
      dd: relativeTimeWithPlural,
      M: relativeTimeWithSingular,
      MM: relativeTimeWithPlural,
      y: relativeTimeWithSingular,
      yy: relativeTimeWithPlural
     },
     dayOfMonthOrdinalParse: /\d{1,2}\./,
     ordinal: "%d.",
     week: {
      dow: 1,
      doy: 4
     }
    });
   }(__webpack_require__(95093));
  },
  58076: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    var translator = {
     words: {
      ss: [ "sekund", "sekunda", "sekundi" ],
      m: [ "jedan minut", "jednog minuta" ],
      mm: [ "minut", "minuta", "minuta" ],
      h: [ "jedan sat", "jednog sata" ],
      hh: [ "sat", "sata", "sati" ],
      dd: [ "dan", "dana", "dana" ],
      MM: [ "mjesec", "mjeseca", "mjeseci" ],
      yy: [ "godina", "godine", "godina" ]
     },
     correctGrammaticalCase: function(number, wordKey) {
      return 1 === number ? wordKey[0] : number >= 2 && number <= 4 ? wordKey[1] : wordKey[2];
     },
     translate: function(number, withoutSuffix, key) {
      var wordKey = translator.words[key];
      return 1 === key.length ? withoutSuffix ? wordKey[0] : wordKey[1] : number + " " + translator.correctGrammaticalCase(number, wordKey);
     }
    };
    moment.defineLocale("me", {
     months: "januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar".split("_"),
     monthsShort: "jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.".split("_"),
     monthsParseExact: !0,
     weekdays: "nedjelja_ponedjeljak_utorak_srijeda_četvrtak_petak_subota".split("_"),
     weekdaysShort: "ned._pon._uto._sri._čet._pet._sub.".split("_"),
     weekdaysMin: "ne_po_ut_sr_če_pe_su".split("_"),
     weekdaysParseExact: !0,
     longDateFormat: {
      LT: "H:mm",
      LTS: "H:mm:ss",
      L: "DD.MM.YYYY",
      LL: "D. MMMM YYYY",
      LLL: "D. MMMM YYYY H:mm",
      LLLL: "dddd, D. MMMM YYYY H:mm"
     },
     calendar: {
      sameDay: "[danas u] LT",
      nextDay: "[sjutra u] LT",
      nextWeek: function() {
       switch (this.day()) {
       case 0:
        return "[u] [nedjelju] [u] LT";

       case 3:
        return "[u] [srijedu] [u] LT";

       case 6:
        return "[u] [subotu] [u] LT";

       case 1:
       case 2:
       case 4:
       case 5:
        return "[u] dddd [u] LT";
       }
      },
      lastDay: "[juče u] LT",
      lastWeek: function() {
       return [ "[prošle] [nedjelje] [u] LT", "[prošlog] [ponedjeljka] [u] LT", "[prošlog] [utorka] [u] LT", "[prošle] [srijede] [u] LT", "[prošlog] [četvrtka] [u] LT", "[prošlog] [petka] [u] LT", "[prošle] [subote] [u] LT" ][this.day()];
      },
      sameElse: "L"
     },
     relativeTime: {
      future: "za %s",
      past: "prije %s",
      s: "nekoliko sekundi",
      ss: translator.translate,
      m: translator.translate,
      mm: translator.translate,
      h: translator.translate,
      hh: translator.translate,
      d: "dan",
      dd: translator.translate,
      M: "mjesec",
      MM: translator.translate,
      y: "godinu",
      yy: translator.translate
     },
     dayOfMonthOrdinalParse: /\d{1,2}\./,
     ordinal: "%d.",
     week: {
      dow: 1,
      doy: 7
     }
    });
   }(__webpack_require__(95093));
  },
  41848: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    moment.defineLocale("mi", {
     months: "Kohi-tāte_Hui-tanguru_Poutū-te-rangi_Paenga-whāwhā_Haratua_Pipiri_Hōngoingoi_Here-turi-kōkā_Mahuru_Whiringa-ā-nuku_Whiringa-ā-rangi_Hakihea".split("_"),
     monthsShort: "Kohi_Hui_Pou_Pae_Hara_Pipi_Hōngoi_Here_Mahu_Whi-nu_Whi-ra_Haki".split("_"),
     monthsRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
     monthsStrictRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
     monthsShortRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
     monthsShortStrictRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,2}/i,
     weekdays: "Rātapu_Mane_Tūrei_Wenerei_Tāite_Paraire_Hātarei".split("_"),
     weekdaysShort: "Ta_Ma_Tū_We_Tāi_Pa_Hā".split("_"),
     weekdaysMin: "Ta_Ma_Tū_We_Tāi_Pa_Hā".split("_"),
     longDateFormat: {
      LT: "HH:mm",
      LTS: "HH:mm:ss",
      L: "DD/MM/YYYY",
      LL: "D MMMM YYYY",
      LLL: "D MMMM YYYY [i] HH:mm",
      LLLL: "dddd, D MMMM YYYY [i] HH:mm"
     },
     calendar: {
      sameDay: "[i teie mahana, i] LT",
      nextDay: "[apopo i] LT",
      nextWeek: "dddd [i] LT",
      lastDay: "[inanahi i] LT",
      lastWeek: "dddd [whakamutunga i] LT",
      sameElse: "L"
     },
     relativeTime: {
      future: "i roto i %s",
      past: "%s i mua",
      s: "te hēkona ruarua",
      ss: "%d hēkona",
      m: "he meneti",
      mm: "%d meneti",
      h: "te haora",
      hh: "%d haora",
      d: "he ra",
      dd: "%d ra",
      M: "he marama",
      MM: "%d marama",
      y: "he tau",
      yy: "%d tau"
     },
     dayOfMonthOrdinalParse: /\d{1,2}º/,
     ordinal: "%dº",
     week: {
      dow: 1,
      doy: 4
     }
    });
   }(__webpack_require__(95093));
  },
  30306: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    moment.defineLocale("mk", {
     months: "јануари_февруари_март_април_мај_јуни_јули_август_септември_октомври_ноември_декември".split("_"),
     monthsShort: "јан_фев_мар_апр_мај_јун_јул_авг_сеп_окт_ное_дек".split("_"),
     weekdays: "недела_понеделник_вторник_среда_четврток_петок_сабота".split("_"),
     weekdaysShort: "нед_пон_вто_сре_чет_пет_саб".split("_"),
     weekdaysMin: "нe_пo_вт_ср_че_пе_сa".split("_"),
     longDateFormat: {
      LT: "H:mm",
      LTS: "H:mm:ss",
      L: "D.MM.YYYY",
      LL: "D MMMM YYYY",
      LLL: "D MMMM YYYY H:mm",
      LLLL: "dddd, D MMMM YYYY H:mm"
     },
     calendar: {
      sameDay: "[Денес во] LT",
      nextDay: "[Утре во] LT",
      nextWeek: "[Во] dddd [во] LT",
      lastDay: "[Вчера во] LT",
      lastWeek: function() {
       switch (this.day()) {
       case 0:
       case 3:
       case 6:
        return "[Изминатата] dddd [во] LT";

       case 1:
       case 2:
       case 4:
       case 5:
        return "[Изминатиот] dddd [во] LT";
       }
      },
      sameElse: "L"
     },
     relativeTime: {
      future: "за %s",
      past: "пред %s",
      s: "неколку секунди",
      ss: "%d секунди",
      m: "една минута",
      mm: "%d минути",
      h: "еден час",
      hh: "%d часа",
      d: "еден ден",
      dd: "%d дена",
      M: "еден месец",
      MM: "%d месеци",
      y: "една година",
      yy: "%d години"
     },
     dayOfMonthOrdinalParse: /\d{1,2}-(ев|ен|ти|ви|ри|ми)/,
     ordinal: function(number) {
      var lastDigit = number % 10, last2Digits = number % 100;
      return 0 === number ? number + "-ев" : 0 === last2Digits ? number + "-ен" : last2Digits > 10 && last2Digits < 20 ? number + "-ти" : 1 === lastDigit ? number + "-ви" : 2 === lastDigit ? number + "-ри" : 7 === lastDigit || 8 === lastDigit ? number + "-ми" : number + "-ти";
     },
     week: {
      dow: 1,
      doy: 7
     }
    });
   }(__webpack_require__(95093));
  },
  73739: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    moment.defineLocale("ml", {
     months: "ജനുവരി_ഫെബ്രുവരി_മാർച്ച്_ഏപ്രിൽ_മേയ്_ജൂൺ_ജൂലൈ_ഓഗസ്റ്റ്_സെപ്റ്റംബർ_ഒക്ടോബർ_നവംബർ_ഡിസംബർ".split("_"),
     monthsShort: "ജനു._ഫെബ്രു._മാർ._ഏപ്രി._മേയ്_ജൂൺ_ജൂലൈ._ഓഗ._സെപ്റ്റ._ഒക്ടോ._നവം._ഡിസം.".split("_"),
     monthsParseExact: !0,
     weekdays: "ഞായറാഴ്ച_തിങ്കളാഴ്ച_ചൊവ്വാഴ്ച_ബുധനാഴ്ച_വ്യാഴാഴ്ച_വെള്ളിയാഴ്ച_ശനിയാഴ്ച".split("_"),
     weekdaysShort: "ഞായർ_തിങ്കൾ_ചൊവ്വ_ബുധൻ_വ്യാഴം_വെള്ളി_ശനി".split("_"),
     weekdaysMin: "ഞാ_തി_ചൊ_ബു_വ്യാ_വെ_ശ".split("_"),
     longDateFormat: {
      LT: "A h:mm -നു",
      LTS: "A h:mm:ss -നു",
      L: "DD/MM/YYYY",
      LL: "D MMMM YYYY",
      LLL: "D MMMM YYYY, A h:mm -നു",
      LLLL: "dddd, D MMMM YYYY, A h:mm -നു"
     },
     calendar: {
      sameDay: "[ഇന്ന്] LT",
      nextDay: "[നാളെ] LT",
      nextWeek: "dddd, LT",
      lastDay: "[ഇന്നലെ] LT",
      lastWeek: "[കഴിഞ്ഞ] dddd, LT",
      sameElse: "L"
     },
     relativeTime: {
      future: "%s കഴിഞ്ഞ്",
      past: "%s മുൻപ്",
      s: "അൽപ നിമിഷങ്ങൾ",
      ss: "%d സെക്കൻഡ്",
      m: "ഒരു മിനിറ്റ്",
      mm: "%d മിനിറ്റ്",
      h: "ഒരു മണിക്കൂർ",
      hh: "%d മണിക്കൂർ",
      d: "ഒരു ദിവസം",
      dd: "%d ദിവസം",
      M: "ഒരു മാസം",
      MM: "%d മാസം",
      y: "ഒരു വർഷം",
      yy: "%d വർഷം"
     },
     meridiemParse: /രാത്രി|രാവിലെ|ഉച്ച കഴിഞ്ഞ്|വൈകുന്നേരം|രാത്രി/i,
     meridiemHour: function(hour, meridiem) {
      return 12 === hour && (hour = 0), "രാത്രി" === meridiem && hour >= 4 || "ഉച്ച കഴിഞ്ഞ്" === meridiem || "വൈകുന്നേരം" === meridiem ? hour + 12 : hour;
     },
     meridiem: function(hour, minute, isLower) {
      return hour < 4 ? "രാത്രി" : hour < 12 ? "രാവിലെ" : hour < 17 ? "ഉച്ച കഴിഞ്ഞ്" : hour < 20 ? "വൈകുന്നേരം" : "രാത്രി";
     }
    });
   }(__webpack_require__(95093));
  },
  99053: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    function translate(number, withoutSuffix, key, isFuture) {
     switch (key) {
     case "s":
      return withoutSuffix ? "хэдхэн секунд" : "хэдхэн секундын";

     case "ss":
      return number + (withoutSuffix ? " секунд" : " секундын");

     case "m":
     case "mm":
      return number + (withoutSuffix ? " минут" : " минутын");

     case "h":
     case "hh":
      return number + (withoutSuffix ? " цаг" : " цагийн");

     case "d":
     case "dd":
      return number + (withoutSuffix ? " өдөр" : " өдрийн");

     case "M":
     case "MM":
      return number + (withoutSuffix ? " сар" : " сарын");

     case "y":
     case "yy":
      return number + (withoutSuffix ? " жил" : " жилийн");

     default:
      return number;
     }
    }
    moment.defineLocale("mn", {
     months: "Нэгдүгээр сар_Хоёрдугаар сар_Гуравдугаар сар_Дөрөвдүгээр сар_Тавдугаар сар_Зургадугаар сар_Долдугаар сар_Наймдугаар сар_Есдүгээр сар_Аравдугаар сар_Арван нэгдүгээр сар_Арван хоёрдугаар сар".split("_"),
     monthsShort: "1 сар_2 сар_3 сар_4 сар_5 сар_6 сар_7 сар_8 сар_9 сар_10 сар_11 сар_12 сар".split("_"),
     monthsParseExact: !0,
     weekdays: "Ням_Даваа_Мягмар_Лхагва_Пүрэв_Баасан_Бямба".split("_"),
     weekdaysShort: "Ням_Дав_Мяг_Лха_Пүр_Баа_Бям".split("_"),
     weekdaysMin: "Ня_Да_Мя_Лх_Пү_Ба_Бя".split("_"),
     weekdaysParseExact: !0,
     longDateFormat: {
      LT: "HH:mm",
      LTS: "HH:mm:ss",
      L: "YYYY-MM-DD",
      LL: "YYYY оны MMMMын D",
      LLL: "YYYY оны MMMMын D HH:mm",
      LLLL: "dddd, YYYY оны MMMMын D HH:mm"
     },
     meridiemParse: /ҮӨ|ҮХ/i,
     isPM: function(input) {
      return "ҮХ" === input;
     },
     meridiem: function(hour, minute, isLower) {
      return hour < 12 ? "ҮӨ" : "ҮХ";
     },
     calendar: {
      sameDay: "[Өнөөдөр] LT",
      nextDay: "[Маргааш] LT",
      nextWeek: "[Ирэх] dddd LT",
      lastDay: "[Өчигдөр] LT",
      lastWeek: "[Өнгөрсөн] dddd LT",
      sameElse: "L"
     },
     relativeTime: {
      future: "%s дараа",
      past: "%s өмнө",
      s: translate,
      ss: translate,
      m: translate,
      mm: translate,
      h: translate,
      hh: translate,
      d: translate,
      dd: translate,
      M: translate,
      MM: translate,
      y: translate,
      yy: translate
     },
     dayOfMonthOrdinalParse: /\d{1,2} өдөр/,
     ordinal: function(number, period) {
      switch (period) {
      case "d":
      case "D":
      case "DDD":
       return number + " өдөр";

      default:
       return number;
      }
     }
    });
   }(__webpack_require__(95093));
  },
  86169: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    var symbolMap = {
     1: "१",
     2: "२",
     3: "३",
     4: "४",
     5: "५",
     6: "६",
     7: "७",
     8: "८",
     9: "९",
     0: "०"
    }, numberMap = {
     "१": "1",
     "२": "2",
     "३": "3",
     "४": "4",
     "५": "5",
     "६": "6",
     "७": "7",
     "८": "8",
     "९": "9",
     "०": "0"
    };
    function relativeTimeMr(number, withoutSuffix, string, isFuture) {
     var output = "";
     if (withoutSuffix) switch (string) {
     case "s":
      output = "काही सेकंद";
      break;

     case "ss":
      output = "%d सेकंद";
      break;

     case "m":
      output = "एक मिनिट";
      break;

     case "mm":
      output = "%d मिनिटे";
      break;

     case "h":
      output = "एक तास";
      break;

     case "hh":
      output = "%d तास";
      break;

     case "d":
      output = "एक दिवस";
      break;

     case "dd":
      output = "%d दिवस";
      break;

     case "M":
      output = "एक महिना";
      break;

     case "MM":
      output = "%d महिने";
      break;

     case "y":
      output = "एक वर्ष";
      break;

     case "yy":
      output = "%d वर्षे";
     } else switch (string) {
     case "s":
      output = "काही सेकंदां";
      break;

     case "ss":
      output = "%d सेकंदां";
      break;

     case "m":
      output = "एका मिनिटा";
      break;

     case "mm":
      output = "%d मिनिटां";
      break;

     case "h":
      output = "एका तासा";
      break;

     case "hh":
      output = "%d तासां";
      break;

     case "d":
      output = "एका दिवसा";
      break;

     case "dd":
      output = "%d दिवसां";
      break;

     case "M":
      output = "एका महिन्या";
      break;

     case "MM":
      output = "%d महिन्यां";
      break;

     case "y":
      output = "एका वर्षा";
      break;

     case "yy":
      output = "%d वर्षां";
     }
     return output.replace(/%d/i, number);
    }
    moment.defineLocale("mr", {
     months: "जानेवारी_फेब्रुवारी_मार्च_एप्रिल_मे_जून_जुलै_ऑगस्ट_सप्टेंबर_ऑक्टोबर_नोव्हेंबर_डिसेंबर".split("_"),
     monthsShort: "जाने._फेब्रु._मार्च._एप्रि._मे._जून._जुलै._ऑग._सप्टें._ऑक्टो._नोव्हें._डिसें.".split("_"),
     monthsParseExact: !0,
     weekdays: "रविवार_सोमवार_मंगळवार_बुधवार_गुरूवार_शुक्रवार_शनिवार".split("_"),
     weekdaysShort: "रवि_सोम_मंगळ_बुध_गुरू_शुक्र_शनि".split("_"),
     weekdaysMin: "र_सो_मं_बु_गु_शु_श".split("_"),
     longDateFormat: {
      LT: "A h:mm वाजता",
      LTS: "A h:mm:ss वाजता",
      L: "DD/MM/YYYY",
      LL: "D MMMM YYYY",
      LLL: "D MMMM YYYY, A h:mm वाजता",
      LLLL: "dddd, D MMMM YYYY, A h:mm वाजता"
     },
     calendar: {
      sameDay: "[आज] LT",
      nextDay: "[उद्या] LT",
      nextWeek: "dddd, LT",
      lastDay: "[काल] LT",
      lastWeek: "[मागील] dddd, LT",
      sameElse: "L"
     },
     relativeTime: {
      future: "%sमध्ये",
      past: "%sपूर्वी",
      s: relativeTimeMr,
      ss: relativeTimeMr,
      m: relativeTimeMr,
      mm: relativeTimeMr,
      h: relativeTimeMr,
      hh: relativeTimeMr,
      d: relativeTimeMr,
      dd: relativeTimeMr,
      M: relativeTimeMr,
      MM: relativeTimeMr,
      y: relativeTimeMr,
      yy: relativeTimeMr
     },
     preparse: function(string) {
      return string.replace(/[१२३४५६७८९०]/g, (function(match) {
       return numberMap[match];
      }));
     },
     postformat: function(string) {
      return string.replace(/\d/g, (function(match) {
       return symbolMap[match];
      }));
     },
     meridiemParse: /पहाटे|सकाळी|दुपारी|सायंकाळी|रात्री/,
     meridiemHour: function(hour, meridiem) {
      return 12 === hour && (hour = 0), "पहाटे" === meridiem || "सकाळी" === meridiem ? hour : "दुपारी" === meridiem || "सायंकाळी" === meridiem || "रात्री" === meridiem ? hour >= 12 ? hour : hour + 12 : void 0;
     },
     meridiem: function(hour, minute, isLower) {
      return hour >= 0 && hour < 6 ? "पहाटे" : hour < 12 ? "सकाळी" : hour < 17 ? "दुपारी" : hour < 20 ? "सायंकाळी" : "रात्री";
     },
     week: {
      dow: 0,
      doy: 6
     }
    });
   }(__webpack_require__(95093));
  },
  92297: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    moment.defineLocale("ms-my", {
     months: "Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember".split("_"),
     monthsShort: "Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis".split("_"),
     weekdays: "Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu".split("_"),
     weekdaysShort: "Ahd_Isn_Sel_Rab_Kha_Jum_Sab".split("_"),
     weekdaysMin: "Ah_Is_Sl_Rb_Km_Jm_Sb".split("_"),
     longDateFormat: {
      LT: "HH.mm",
      LTS: "HH.mm.ss",
      L: "DD/MM/YYYY",
      LL: "D MMMM YYYY",
      LLL: "D MMMM YYYY [pukul] HH.mm",
      LLLL: "dddd, D MMMM YYYY [pukul] HH.mm"
     },
     meridiemParse: /pagi|tengahari|petang|malam/,
     meridiemHour: function(hour, meridiem) {
      return 12 === hour && (hour = 0), "pagi" === meridiem ? hour : "tengahari" === meridiem ? hour >= 11 ? hour : hour + 12 : "petang" === meridiem || "malam" === meridiem ? hour + 12 : void 0;
     },
     meridiem: function(hours, minutes, isLower) {
      return hours < 11 ? "pagi" : hours < 15 ? "tengahari" : hours < 19 ? "petang" : "malam";
     },
     calendar: {
      sameDay: "[Hari ini pukul] LT",
      nextDay: "[Esok pukul] LT",
      nextWeek: "dddd [pukul] LT",
      lastDay: "[Kelmarin pukul] LT",
      lastWeek: "dddd [lepas pukul] LT",
      sameElse: "L"
     },
     relativeTime: {
      future: "dalam %s",
      past: "%s yang lepas",
      s: "beberapa saat",
      ss: "%d saat",
      m: "seminit",
      mm: "%d minit",
      h: "sejam",
      hh: "%d jam",
      d: "sehari",
      dd: "%d hari",
      M: "sebulan",
      MM: "%d bulan",
      y: "setahun",
      yy: "%d tahun"
     },
     week: {
      dow: 1,
      doy: 7
     }
    });
   }(__webpack_require__(95093));
  },
  73386: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    moment.defineLocale("ms", {
     months: "Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember".split("_"),
     monthsShort: "Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis".split("_"),
     weekdays: "Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu".split("_"),
     weekdaysShort: "Ahd_Isn_Sel_Rab_Kha_Jum_Sab".split("_"),
     weekdaysMin: "Ah_Is_Sl_Rb_Km_Jm_Sb".split("_"),
     longDateFormat: {
      LT: "HH.mm",
      LTS: "HH.mm.ss",
      L: "DD/MM/YYYY",
      LL: "D MMMM YYYY",
      LLL: "D MMMM YYYY [pukul] HH.mm",
      LLLL: "dddd, D MMMM YYYY [pukul] HH.mm"
     },
     meridiemParse: /pagi|tengahari|petang|malam/,
     meridiemHour: function(hour, meridiem) {
      return 12 === hour && (hour = 0), "pagi" === meridiem ? hour : "tengahari" === meridiem ? hour >= 11 ? hour : hour + 12 : "petang" === meridiem || "malam" === meridiem ? hour + 12 : void 0;
     },
     meridiem: function(hours, minutes, isLower) {
      return hours < 11 ? "pagi" : hours < 15 ? "tengahari" : hours < 19 ? "petang" : "malam";
     },
     calendar: {
      sameDay: "[Hari ini pukul] LT",
      nextDay: "[Esok pukul] LT",
      nextWeek: "dddd [pukul] LT",
      lastDay: "[Kelmarin pukul] LT",
      lastWeek: "dddd [lepas pukul] LT",
      sameElse: "L"
     },
     relativeTime: {
      future: "dalam %s",
      past: "%s yang lepas",
      s: "beberapa saat",
      ss: "%d saat",
      m: "seminit",
      mm: "%d minit",
      h: "sejam",
      hh: "%d jam",
      d: "sehari",
      dd: "%d hari",
      M: "sebulan",
      MM: "%d bulan",
      y: "setahun",
      yy: "%d tahun"
     },
     week: {
      dow: 1,
      doy: 7
     }
    });
   }(__webpack_require__(95093));
  },
  77075: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    moment.defineLocale("mt", {
     months: "Jannar_Frar_Marzu_April_Mejju_Ġunju_Lulju_Awwissu_Settembru_Ottubru_Novembru_Diċembru".split("_"),
     monthsShort: "Jan_Fra_Mar_Apr_Mej_Ġun_Lul_Aww_Set_Ott_Nov_Diċ".split("_"),
     weekdays: "Il-Ħadd_It-Tnejn_It-Tlieta_L-Erbgħa_Il-Ħamis_Il-Ġimgħa_Is-Sibt".split("_"),
     weekdaysShort: "Ħad_Tne_Tli_Erb_Ħam_Ġim_Sib".split("_"),
     weekdaysMin: "Ħa_Tn_Tl_Er_Ħa_Ġi_Si".split("_"),
     longDateFormat: {
      LT: "HH:mm",
      LTS: "HH:mm:ss",
      L: "DD/MM/YYYY",
      LL: "D MMMM YYYY",
      LLL: "D MMMM YYYY HH:mm",
      LLLL: "dddd, D MMMM YYYY HH:mm"
     },
     calendar: {
      sameDay: "[Illum fil-]LT",
      nextDay: "[Għada fil-]LT",
      nextWeek: "dddd [fil-]LT",
      lastDay: "[Il-bieraħ fil-]LT",
      lastWeek: "dddd [li għadda] [fil-]LT",
      sameElse: "L"
     },
     relativeTime: {
      future: "f’ %s",
      past: "%s ilu",
      s: "ftit sekondi",
      ss: "%d sekondi",
      m: "minuta",
      mm: "%d minuti",
      h: "siegħa",
      hh: "%d siegħat",
      d: "ġurnata",
      dd: "%d ġranet",
      M: "xahar",
      MM: "%d xhur",
      y: "sena",
      yy: "%d sni"
     },
     dayOfMonthOrdinalParse: /\d{1,2}º/,
     ordinal: "%dº",
     week: {
      dow: 1,
      doy: 4
     }
    });
   }(__webpack_require__(95093));
  },
  72264: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    var symbolMap = {
     1: "၁",
     2: "၂",
     3: "၃",
     4: "၄",
     5: "၅",
     6: "၆",
     7: "၇",
     8: "၈",
     9: "၉",
     0: "၀"
    }, numberMap = {
     "၁": "1",
     "၂": "2",
     "၃": "3",
     "၄": "4",
     "၅": "5",
     "၆": "6",
     "၇": "7",
     "၈": "8",
     "၉": "9",
     "၀": "0"
    };
    moment.defineLocale("my", {
     months: "ဇန်နဝါရီ_ဖေဖော်ဝါရီ_မတ်_ဧပြီ_မေ_ဇွန်_ဇူလိုင်_သြဂုတ်_စက်တင်ဘာ_အောက်တိုဘာ_နိုဝင်ဘာ_ဒီဇင်ဘာ".split("_"),
     monthsShort: "ဇန်_ဖေ_မတ်_ပြီ_မေ_ဇွန်_လိုင်_သြ_စက်_အောက်_နို_ဒီ".split("_"),
     weekdays: "တနင်္ဂနွေ_တနင်္လာ_အင်္ဂါ_ဗုဒ္ဓဟူး_ကြာသပတေး_သောကြာ_စနေ".split("_"),
     weekdaysShort: "နွေ_လာ_ဂါ_ဟူး_ကြာ_သော_နေ".split("_"),
     weekdaysMin: "နွေ_လာ_ဂါ_ဟူး_ကြာ_သော_နေ".split("_"),
     longDateFormat: {
      LT: "HH:mm",
      LTS: "HH:mm:ss",
      L: "DD/MM/YYYY",
      LL: "D MMMM YYYY",
      LLL: "D MMMM YYYY HH:mm",
      LLLL: "dddd D MMMM YYYY HH:mm"
     },
     calendar: {
      sameDay: "[ယနေ.] LT [မှာ]",
      nextDay: "[မနက်ဖြန်] LT [မှာ]",
      nextWeek: "dddd LT [မှာ]",
      lastDay: "[မနေ.က] LT [မှာ]",
      lastWeek: "[ပြီးခဲ့သော] dddd LT [မှာ]",
      sameElse: "L"
     },
     relativeTime: {
      future: "လာမည့် %s မှာ",
      past: "လွန်ခဲ့သော %s က",
      s: "စက္ကန်.အနည်းငယ်",
      ss: "%d စက္ကန့်",
      m: "တစ်မိနစ်",
      mm: "%d မိနစ်",
      h: "တစ်နာရီ",
      hh: "%d နာရီ",
      d: "တစ်ရက်",
      dd: "%d ရက်",
      M: "တစ်လ",
      MM: "%d လ",
      y: "တစ်နှစ်",
      yy: "%d နှစ်"
     },
     preparse: function(string) {
      return string.replace(/[၁၂၃၄၅၆၇၈၉၀]/g, (function(match) {
       return numberMap[match];
      }));
     },
     postformat: function(string) {
      return string.replace(/\d/g, (function(match) {
       return symbolMap[match];
      }));
     },
     week: {
      dow: 1,
      doy: 4
     }
    });
   }(__webpack_require__(95093));
  },
  22274: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    moment.defineLocale("nb", {
     months: "januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember".split("_"),
     monthsShort: "jan._feb._mars_apr._mai_juni_juli_aug._sep._okt._nov._des.".split("_"),
     monthsParseExact: !0,
     weekdays: "søndag_mandag_tirsdag_onsdag_torsdag_fredag_lørdag".split("_"),
     weekdaysShort: "sø._ma._ti._on._to._fr._lø.".split("_"),
     weekdaysMin: "sø_ma_ti_on_to_fr_lø".split("_"),
     weekdaysParseExact: !0,
     longDateFormat: {
      LT: "HH:mm",
      LTS: "HH:mm:ss",
      L: "DD.MM.YYYY",
      LL: "D. MMMM YYYY",
      LLL: "D. MMMM YYYY [kl.] HH:mm",
      LLLL: "dddd D. MMMM YYYY [kl.] HH:mm"
     },
     calendar: {
      sameDay: "[i dag kl.] LT",
      nextDay: "[i morgen kl.] LT",
      nextWeek: "dddd [kl.] LT",
      lastDay: "[i går kl.] LT",
      lastWeek: "[forrige] dddd [kl.] LT",
      sameElse: "L"
     },
     relativeTime: {
      future: "om %s",
      past: "%s siden",
      s: "noen sekunder",
      ss: "%d sekunder",
      m: "ett minutt",
      mm: "%d minutter",
      h: "én time",
      hh: "%d timer",
      d: "én dag",
      dd: "%d dager",
      w: "én uke",
      ww: "%d uker",
      M: "én måned",
      MM: "%d måneder",
      y: "ett år",
      yy: "%d år"
     },
     dayOfMonthOrdinalParse: /\d{1,2}\./,
     ordinal: "%d.",
     week: {
      dow: 1,
      doy: 4
     }
    });
   }(__webpack_require__(95093));
  },
  8235: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    var symbolMap = {
     1: "१",
     2: "२",
     3: "३",
     4: "४",
     5: "५",
     6: "६",
     7: "७",
     8: "८",
     9: "९",
     0: "०"
    }, numberMap = {
     "१": "1",
     "२": "2",
     "३": "3",
     "४": "4",
     "५": "5",
     "६": "6",
     "७": "7",
     "८": "8",
     "९": "9",
     "०": "0"
    };
    moment.defineLocale("ne", {
     months: "जनवरी_फेब्रुवरी_मार्च_अप्रिल_मई_जुन_जुलाई_अगष्ट_सेप्टेम्बर_अक्टोबर_नोभेम्बर_डिसेम्बर".split("_"),
     monthsShort: "जन._फेब्रु._मार्च_अप्रि._मई_जुन_जुलाई._अग._सेप्ट._अक्टो._नोभे._डिसे.".split("_"),
     monthsParseExact: !0,
     weekdays: "आइतबार_सोमबार_मङ्गलबार_बुधबार_बिहिबार_शुक्रबार_शनिबार".split("_"),
     weekdaysShort: "आइत._सोम._मङ्गल._बुध._बिहि._शुक्र._शनि.".split("_"),
     weekdaysMin: "आ._सो._मं._बु._बि._शु._श.".split("_"),
     weekdaysParseExact: !0,
     longDateFormat: {
      LT: "Aको h:mm बजे",
      LTS: "Aको h:mm:ss बजे",
      L: "DD/MM/YYYY",
      LL: "D MMMM YYYY",
      LLL: "D MMMM YYYY, Aको h:mm बजे",
      LLLL: "dddd, D MMMM YYYY, Aको h:mm बजे"
     },
     preparse: function(string) {
      return string.replace(/[१२३४५६७८९०]/g, (function(match) {
       return numberMap[match];
      }));
     },
     postformat: function(string) {
      return string.replace(/\d/g, (function(match) {
       return symbolMap[match];
      }));
     },
     meridiemParse: /राति|बिहान|दिउँसो|साँझ/,
     meridiemHour: function(hour, meridiem) {
      return 12 === hour && (hour = 0), "राति" === meridiem ? hour < 4 ? hour : hour + 12 : "बिहान" === meridiem ? hour : "दिउँसो" === meridiem ? hour >= 10 ? hour : hour + 12 : "साँझ" === meridiem ? hour + 12 : void 0;
     },
     meridiem: function(hour, minute, isLower) {
      return hour < 3 ? "राति" : hour < 12 ? "बिहान" : hour < 16 ? "दिउँसो" : hour < 20 ? "साँझ" : "राति";
     },
     calendar: {
      sameDay: "[आज] LT",
      nextDay: "[भोलि] LT",
      nextWeek: "[आउँदो] dddd[,] LT",
      lastDay: "[हिजो] LT",
      lastWeek: "[गएको] dddd[,] LT",
      sameElse: "L"
     },
     relativeTime: {
      future: "%sमा",
      past: "%s अगाडि",
      s: "केही क्षण",
      ss: "%d सेकेण्ड",
      m: "एक मिनेट",
      mm: "%d मिनेट",
      h: "एक घण्टा",
      hh: "%d घण्टा",
      d: "एक दिन",
      dd: "%d दिन",
      M: "एक महिना",
      MM: "%d महिना",
      y: "एक बर्ष",
      yy: "%d बर्ष"
     },
     week: {
      dow: 0,
      doy: 6
     }
    });
   }(__webpack_require__(95093));
  },
  43784: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    var monthsShortWithDots = "jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.".split("_"), monthsShortWithoutDots = "jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec".split("_"), monthsParse = [ /^jan/i, /^feb/i, /^(maart|mrt\.?)$/i, /^apr/i, /^mei$/i, /^jun[i.]?$/i, /^jul[i.]?$/i, /^aug/i, /^sep/i, /^okt/i, /^nov/i, /^dec/i ], monthsRegex = /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;
    moment.defineLocale("nl-be", {
     months: "januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december".split("_"),
     monthsShort: function(m, format) {
      return m ? /-MMM-/.test(format) ? monthsShortWithoutDots[m.month()] : monthsShortWithDots[m.month()] : monthsShortWithDots;
     },
     monthsRegex,
     monthsShortRegex: monthsRegex,
     monthsStrictRegex: /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december)/i,
     monthsShortStrictRegex: /^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,
     monthsParse,
     longMonthsParse: monthsParse,
     shortMonthsParse: monthsParse,
     weekdays: "zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag".split("_"),
     weekdaysShort: "zo._ma._di._wo._do._vr._za.".split("_"),
     weekdaysMin: "zo_ma_di_wo_do_vr_za".split("_"),
     weekdaysParseExact: !0,
     longDateFormat: {
      LT: "HH:mm",
      LTS: "HH:mm:ss",
      L: "DD/MM/YYYY",
      LL: "D MMMM YYYY",
      LLL: "D MMMM YYYY HH:mm",
      LLLL: "dddd D MMMM YYYY HH:mm"
     },
     calendar: {
      sameDay: "[vandaag om] LT",
      nextDay: "[morgen om] LT",
      nextWeek: "dddd [om] LT",
      lastDay: "[gisteren om] LT",
      lastWeek: "[afgelopen] dddd [om] LT",
      sameElse: "L"
     },
     relativeTime: {
      future: "over %s",
      past: "%s geleden",
      s: "een paar seconden",
      ss: "%d seconden",
      m: "één minuut",
      mm: "%d minuten",
      h: "één uur",
      hh: "%d uur",
      d: "één dag",
      dd: "%d dagen",
      M: "één maand",
      MM: "%d maanden",
      y: "één jaar",
      yy: "%d jaar"
     },
     dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
     ordinal: function(number) {
      return number + (1 === number || 8 === number || number >= 20 ? "ste" : "de");
     },
     week: {
      dow: 1,
      doy: 4
     }
    });
   }(__webpack_require__(95093));
  },
  92572: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    var monthsShortWithDots = "jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.".split("_"), monthsShortWithoutDots = "jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec".split("_"), monthsParse = [ /^jan/i, /^feb/i, /^(maart|mrt\.?)$/i, /^apr/i, /^mei$/i, /^jun[i.]?$/i, /^jul[i.]?$/i, /^aug/i, /^sep/i, /^okt/i, /^nov/i, /^dec/i ], monthsRegex = /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;
    moment.defineLocale("nl", {
     months: "januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december".split("_"),
     monthsShort: function(m, format) {
      return m ? /-MMM-/.test(format) ? monthsShortWithoutDots[m.month()] : monthsShortWithDots[m.month()] : monthsShortWithDots;
     },
     monthsRegex,
     monthsShortRegex: monthsRegex,
     monthsStrictRegex: /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december)/i,
     monthsShortStrictRegex: /^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,
     monthsParse,
     longMonthsParse: monthsParse,
     shortMonthsParse: monthsParse,
     weekdays: "zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag".split("_"),
     weekdaysShort: "zo._ma._di._wo._do._vr._za.".split("_"),
     weekdaysMin: "zo_ma_di_wo_do_vr_za".split("_"),
     weekdaysParseExact: !0,
     longDateFormat: {
      LT: "HH:mm",
      LTS: "HH:mm:ss",
      L: "DD-MM-YYYY",
      LL: "D MMMM YYYY",
      LLL: "D MMMM YYYY HH:mm",
      LLLL: "dddd D MMMM YYYY HH:mm"
     },
     calendar: {
      sameDay: "[vandaag om] LT",
      nextDay: "[morgen om] LT",
      nextWeek: "dddd [om] LT",
      lastDay: "[gisteren om] LT",
      lastWeek: "[afgelopen] dddd [om] LT",
      sameElse: "L"
     },
     relativeTime: {
      future: "over %s",
      past: "%s geleden",
      s: "een paar seconden",
      ss: "%d seconden",
      m: "één minuut",
      mm: "%d minuten",
      h: "één uur",
      hh: "%d uur",
      d: "één dag",
      dd: "%d dagen",
      w: "één week",
      ww: "%d weken",
      M: "één maand",
      MM: "%d maanden",
      y: "één jaar",
      yy: "%d jaar"
     },
     dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
     ordinal: function(number) {
      return number + (1 === number || 8 === number || number >= 20 ? "ste" : "de");
     },
     week: {
      dow: 1,
      doy: 4
     }
    });
   }(__webpack_require__(95093));
  },
  54566: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    moment.defineLocale("nn", {
     months: "januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember".split("_"),
     monthsShort: "jan._feb._mars_apr._mai_juni_juli_aug._sep._okt._nov._des.".split("_"),
     monthsParseExact: !0,
     weekdays: "sundag_måndag_tysdag_onsdag_torsdag_fredag_laurdag".split("_"),
     weekdaysShort: "su._må._ty._on._to._fr._lau.".split("_"),
     weekdaysMin: "su_må_ty_on_to_fr_la".split("_"),
     weekdaysParseExact: !0,
     longDateFormat: {
      LT: "HH:mm",
      LTS: "HH:mm:ss",
      L: "DD.MM.YYYY",
      LL: "D. MMMM YYYY",
      LLL: "D. MMMM YYYY [kl.] H:mm",
      LLLL: "dddd D. MMMM YYYY [kl.] HH:mm"
     },
     calendar: {
      sameDay: "[I dag klokka] LT",
      nextDay: "[I morgon klokka] LT",
      nextWeek: "dddd [klokka] LT",
      lastDay: "[I går klokka] LT",
      lastWeek: "[Føregåande] dddd [klokka] LT",
      sameElse: "L"
     },
     relativeTime: {
      future: "om %s",
      past: "%s sidan",
      s: "nokre sekund",
      ss: "%d sekund",
      m: "eit minutt",
      mm: "%d minutt",
      h: "ein time",
      hh: "%d timar",
      d: "ein dag",
      dd: "%d dagar",
      w: "ei veke",
      ww: "%d veker",
      M: "ein månad",
      MM: "%d månader",
      y: "eit år",
      yy: "%d år"
     },
     dayOfMonthOrdinalParse: /\d{1,2}\./,
     ordinal: "%d.",
     week: {
      dow: 1,
      doy: 4
     }
    });
   }(__webpack_require__(95093));
  },
  69330: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    moment.defineLocale("oc-lnc", {
     months: {
      standalone: "genièr_febrièr_març_abril_mai_junh_julhet_agost_setembre_octòbre_novembre_decembre".split("_"),
      format: "de genièr_de febrièr_de març_d'abril_de mai_de junh_de julhet_d'agost_de setembre_d'octòbre_de novembre_de decembre".split("_"),
      isFormat: /D[oD]?(\s)+MMMM/
     },
     monthsShort: "gen._febr._març_abr._mai_junh_julh._ago._set._oct._nov._dec.".split("_"),
     monthsParseExact: !0,
     weekdays: "dimenge_diluns_dimars_dimècres_dijòus_divendres_dissabte".split("_"),
     weekdaysShort: "dg._dl._dm._dc._dj._dv._ds.".split("_"),
     weekdaysMin: "dg_dl_dm_dc_dj_dv_ds".split("_"),
     weekdaysParseExact: !0,
     longDateFormat: {
      LT: "H:mm",
      LTS: "H:mm:ss",
      L: "DD/MM/YYYY",
      LL: "D MMMM [de] YYYY",
      ll: "D MMM YYYY",
      LLL: "D MMMM [de] YYYY [a] H:mm",
      lll: "D MMM YYYY, H:mm",
      LLLL: "dddd D MMMM [de] YYYY [a] H:mm",
      llll: "ddd D MMM YYYY, H:mm"
     },
     calendar: {
      sameDay: "[uèi a] LT",
      nextDay: "[deman a] LT",
      nextWeek: "dddd [a] LT",
      lastDay: "[ièr a] LT",
      lastWeek: "dddd [passat a] LT",
      sameElse: "L"
     },
     relativeTime: {
      future: "d'aquí %s",
      past: "fa %s",
      s: "unas segondas",
      ss: "%d segondas",
      m: "una minuta",
      mm: "%d minutas",
      h: "una ora",
      hh: "%d oras",
      d: "un jorn",
      dd: "%d jorns",
      M: "un mes",
      MM: "%d meses",
      y: "un an",
      yy: "%d ans"
     },
     dayOfMonthOrdinalParse: /\d{1,2}(r|n|t|è|a)/,
     ordinal: function(number, period) {
      var output = 1 === number ? "r" : 2 === number ? "n" : 3 === number ? "r" : 4 === number ? "t" : "è";
      return "w" !== period && "W" !== period || (output = "a"), number + output;
     },
     week: {
      dow: 1,
      doy: 4
     }
    });
   }(__webpack_require__(95093));
  },
  29849: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    var symbolMap = {
     1: "੧",
     2: "੨",
     3: "੩",
     4: "੪",
     5: "੫",
     6: "੬",
     7: "੭",
     8: "੮",
     9: "੯",
     0: "੦"
    }, numberMap = {
     "੧": "1",
     "੨": "2",
     "੩": "3",
     "੪": "4",
     "੫": "5",
     "੬": "6",
     "੭": "7",
     "੮": "8",
     "੯": "9",
     "੦": "0"
    };
    moment.defineLocale("pa-in", {
     months: "ਜਨਵਰੀ_ਫ਼ਰਵਰੀ_ਮਾਰਚ_ਅਪ੍ਰੈਲ_ਮਈ_ਜੂਨ_ਜੁਲਾਈ_ਅਗਸਤ_ਸਤੰਬਰ_ਅਕਤੂਬਰ_ਨਵੰਬਰ_ਦਸੰਬਰ".split("_"),
     monthsShort: "ਜਨਵਰੀ_ਫ਼ਰਵਰੀ_ਮਾਰਚ_ਅਪ੍ਰੈਲ_ਮਈ_ਜੂਨ_ਜੁਲਾਈ_ਅਗਸਤ_ਸਤੰਬਰ_ਅਕਤੂਬਰ_ਨਵੰਬਰ_ਦਸੰਬਰ".split("_"),
     weekdays: "ਐਤਵਾਰ_ਸੋਮਵਾਰ_ਮੰਗਲਵਾਰ_ਬੁਧਵਾਰ_ਵੀਰਵਾਰ_ਸ਼ੁੱਕਰਵਾਰ_ਸ਼ਨੀਚਰਵਾਰ".split("_"),
     weekdaysShort: "ਐਤ_ਸੋਮ_ਮੰਗਲ_ਬੁਧ_ਵੀਰ_ਸ਼ੁਕਰ_ਸ਼ਨੀ".split("_"),
     weekdaysMin: "ਐਤ_ਸੋਮ_ਮੰਗਲ_ਬੁਧ_ਵੀਰ_ਸ਼ੁਕਰ_ਸ਼ਨੀ".split("_"),
     longDateFormat: {
      LT: "A h:mm ਵਜੇ",
      LTS: "A h:mm:ss ਵਜੇ",
      L: "DD/MM/YYYY",
      LL: "D MMMM YYYY",
      LLL: "D MMMM YYYY, A h:mm ਵਜੇ",
      LLLL: "dddd, D MMMM YYYY, A h:mm ਵਜੇ"
     },
     calendar: {
      sameDay: "[ਅਜ] LT",
      nextDay: "[ਕਲ] LT",
      nextWeek: "[ਅਗਲਾ] dddd, LT",
      lastDay: "[ਕਲ] LT",
      lastWeek: "[ਪਿਛਲੇ] dddd, LT",
      sameElse: "L"
     },
     relativeTime: {
      future: "%s ਵਿੱਚ",
      past: "%s ਪਿਛਲੇ",
      s: "ਕੁਝ ਸਕਿੰਟ",
      ss: "%d ਸਕਿੰਟ",
      m: "ਇਕ ਮਿੰਟ",
      mm: "%d ਮਿੰਟ",
      h: "ਇੱਕ ਘੰਟਾ",
      hh: "%d ਘੰਟੇ",
      d: "ਇੱਕ ਦਿਨ",
      dd: "%d ਦਿਨ",
      M: "ਇੱਕ ਮਹੀਨਾ",
      MM: "%d ਮਹੀਨੇ",
      y: "ਇੱਕ ਸਾਲ",
      yy: "%d ਸਾਲ"
     },
     preparse: function(string) {
      return string.replace(/[੧੨੩੪੫੬੭੮੯੦]/g, (function(match) {
       return numberMap[match];
      }));
     },
     postformat: function(string) {
      return string.replace(/\d/g, (function(match) {
       return symbolMap[match];
      }));
     },
     meridiemParse: /ਰਾਤ|ਸਵੇਰ|ਦੁਪਹਿਰ|ਸ਼ਾਮ/,
     meridiemHour: function(hour, meridiem) {
      return 12 === hour && (hour = 0), "ਰਾਤ" === meridiem ? hour < 4 ? hour : hour + 12 : "ਸਵੇਰ" === meridiem ? hour : "ਦੁਪਹਿਰ" === meridiem ? hour >= 10 ? hour : hour + 12 : "ਸ਼ਾਮ" === meridiem ? hour + 12 : void 0;
     },
     meridiem: function(hour, minute, isLower) {
      return hour < 4 ? "ਰਾਤ" : hour < 10 ? "ਸਵੇਰ" : hour < 17 ? "ਦੁਪਹਿਰ" : hour < 20 ? "ਸ਼ਾਮ" : "ਰਾਤ";
     },
     week: {
      dow: 0,
      doy: 6
     }
    });
   }(__webpack_require__(95093));
  },
  94418: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    var monthsNominative = "styczeń_luty_marzec_kwiecień_maj_czerwiec_lipiec_sierpień_wrzesień_październik_listopad_grudzień".split("_"), monthsSubjective = "stycznia_lutego_marca_kwietnia_maja_czerwca_lipca_sierpnia_września_października_listopada_grudnia".split("_"), monthsParse = [ /^sty/i, /^lut/i, /^mar/i, /^kwi/i, /^maj/i, /^cze/i, /^lip/i, /^sie/i, /^wrz/i, /^paź/i, /^lis/i, /^gru/i ];
    function plural(n) {
     return n % 10 < 5 && n % 10 > 1 && ~~(n / 10) % 10 != 1;
    }
    function translate(number, withoutSuffix, key) {
     var result = number + " ";
     switch (key) {
     case "ss":
      return result + (plural(number) ? "sekundy" : "sekund");

     case "m":
      return withoutSuffix ? "minuta" : "minutę";

     case "mm":
      return result + (plural(number) ? "minuty" : "minut");

     case "h":
      return withoutSuffix ? "godzina" : "godzinę";

     case "hh":
      return result + (plural(number) ? "godziny" : "godzin");

     case "ww":
      return result + (plural(number) ? "tygodnie" : "tygodni");

     case "MM":
      return result + (plural(number) ? "miesiące" : "miesięcy");

     case "yy":
      return result + (plural(number) ? "lata" : "lat");
     }
    }
    moment.defineLocale("pl", {
     months: function(momentToFormat, format) {
      return momentToFormat ? /D MMMM/.test(format) ? monthsSubjective[momentToFormat.month()] : monthsNominative[momentToFormat.month()] : monthsNominative;
     },
     monthsShort: "sty_lut_mar_kwi_maj_cze_lip_sie_wrz_paź_lis_gru".split("_"),
     monthsParse,
     longMonthsParse: monthsParse,
     shortMonthsParse: monthsParse,
     weekdays: "niedziela_poniedziałek_wtorek_środa_czwartek_piątek_sobota".split("_"),
     weekdaysShort: "ndz_pon_wt_śr_czw_pt_sob".split("_"),
     weekdaysMin: "Nd_Pn_Wt_Śr_Cz_Pt_So".split("_"),
     longDateFormat: {
      LT: "HH:mm",
      LTS: "HH:mm:ss",
      L: "DD.MM.YYYY",
      LL: "D MMMM YYYY",
      LLL: "D MMMM YYYY HH:mm",
      LLLL: "dddd, D MMMM YYYY HH:mm"
     },
     calendar: {
      sameDay: "[Dziś o] LT",
      nextDay: "[Jutro o] LT",
      nextWeek: function() {
       switch (this.day()) {
       case 0:
        return "[W niedzielę o] LT";

       case 2:
        return "[We wtorek o] LT";

       case 3:
        return "[W środę o] LT";

       case 6:
        return "[W sobotę o] LT";

       default:
        return "[W] dddd [o] LT";
       }
      },
      lastDay: "[Wczoraj o] LT",
      lastWeek: function() {
       switch (this.day()) {
       case 0:
        return "[W zeszłą niedzielę o] LT";

       case 3:
        return "[W zeszłą środę o] LT";

       case 6:
        return "[W zeszłą sobotę o] LT";

       default:
        return "[W zeszły] dddd [o] LT";
       }
      },
      sameElse: "L"
     },
     relativeTime: {
      future: "za %s",
      past: "%s temu",
      s: "kilka sekund",
      ss: translate,
      m: translate,
      mm: translate,
      h: translate,
      hh: translate,
      d: "1 dzień",
      dd: "%d dni",
      w: "tydzień",
      ww: translate,
      M: "miesiąc",
      MM: translate,
      y: "rok",
      yy: translate
     },
     dayOfMonthOrdinalParse: /\d{1,2}\./,
     ordinal: "%d.",
     week: {
      dow: 1,
      doy: 4
     }
    });
   }(__webpack_require__(95093));
  },
  48303: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    moment.defineLocale("pt-br", {
     months: "janeiro_fevereiro_março_abril_maio_junho_julho_agosto_setembro_outubro_novembro_dezembro".split("_"),
     monthsShort: "jan_fev_mar_abr_mai_jun_jul_ago_set_out_nov_dez".split("_"),
     weekdays: "domingo_segunda-feira_terça-feira_quarta-feira_quinta-feira_sexta-feira_sábado".split("_"),
     weekdaysShort: "dom_seg_ter_qua_qui_sex_sáb".split("_"),
     weekdaysMin: "do_2ª_3ª_4ª_5ª_6ª_sá".split("_"),
     weekdaysParseExact: !0,
     longDateFormat: {
      LT: "HH:mm",
      LTS: "HH:mm:ss",
      L: "DD/MM/YYYY",
      LL: "D [de] MMMM [de] YYYY",
      LLL: "D [de] MMMM [de] YYYY [às] HH:mm",
      LLLL: "dddd, D [de] MMMM [de] YYYY [às] HH:mm"
     },
     calendar: {
      sameDay: "[Hoje às] LT",
      nextDay: "[Amanhã às] LT",
      nextWeek: "dddd [às] LT",
      lastDay: "[Ontem às] LT",
      lastWeek: function() {
       return 0 === this.day() || 6 === this.day() ? "[Último] dddd [às] LT" : "[Última] dddd [às] LT";
      },
      sameElse: "L"
     },
     relativeTime: {
      future: "em %s",
      past: "há %s",
      s: "poucos segundos",
      ss: "%d segundos",
      m: "um minuto",
      mm: "%d minutos",
      h: "uma hora",
      hh: "%d horas",
      d: "um dia",
      dd: "%d dias",
      M: "um mês",
      MM: "%d meses",
      y: "um ano",
      yy: "%d anos"
     },
     dayOfMonthOrdinalParse: /\d{1,2}º/,
     ordinal: "%dº",
     invalidDate: "Data inválida"
    });
   }(__webpack_require__(95093));
  },
  79834: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    moment.defineLocale("pt", {
     months: "janeiro_fevereiro_março_abril_maio_junho_julho_agosto_setembro_outubro_novembro_dezembro".split("_"),
     monthsShort: "jan_fev_mar_abr_mai_jun_jul_ago_set_out_nov_dez".split("_"),
     weekdays: "Domingo_Segunda-feira_Terça-feira_Quarta-feira_Quinta-feira_Sexta-feira_Sábado".split("_"),
     weekdaysShort: "Dom_Seg_Ter_Qua_Qui_Sex_Sáb".split("_"),
     weekdaysMin: "Do_2ª_3ª_4ª_5ª_6ª_Sá".split("_"),
     weekdaysParseExact: !0,
     longDateFormat: {
      LT: "HH:mm",
      LTS: "HH:mm:ss",
      L: "DD/MM/YYYY",
      LL: "D [de] MMMM [de] YYYY",
      LLL: "D [de] MMMM [de] YYYY HH:mm",
      LLLL: "dddd, D [de] MMMM [de] YYYY HH:mm"
     },
     calendar: {
      sameDay: "[Hoje às] LT",
      nextDay: "[Amanhã às] LT",
      nextWeek: "dddd [às] LT",
      lastDay: "[Ontem às] LT",
      lastWeek: function() {
       return 0 === this.day() || 6 === this.day() ? "[Último] dddd [às] LT" : "[Última] dddd [às] LT";
      },
      sameElse: "L"
     },
     relativeTime: {
      future: "em %s",
      past: "há %s",
      s: "segundos",
      ss: "%d segundos",
      m: "um minuto",
      mm: "%d minutos",
      h: "uma hora",
      hh: "%d horas",
      d: "um dia",
      dd: "%d dias",
      w: "uma semana",
      ww: "%d semanas",
      M: "um mês",
      MM: "%d meses",
      y: "um ano",
      yy: "%d anos"
     },
     dayOfMonthOrdinalParse: /\d{1,2}º/,
     ordinal: "%dº",
     week: {
      dow: 1,
      doy: 4
     }
    });
   }(__webpack_require__(95093));
  },
  24457: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    function relativeTimeWithPlural(number, withoutSuffix, key) {
     var separator = " ";
     return (number % 100 >= 20 || number >= 100 && number % 100 == 0) && (separator = " de "), 
     number + separator + {
      ss: "secunde",
      mm: "minute",
      hh: "ore",
      dd: "zile",
      ww: "săptămâni",
      MM: "luni",
      yy: "ani"
     }[key];
    }
    moment.defineLocale("ro", {
     months: "ianuarie_februarie_martie_aprilie_mai_iunie_iulie_august_septembrie_octombrie_noiembrie_decembrie".split("_"),
     monthsShort: "ian._feb._mart._apr._mai_iun._iul._aug._sept._oct._nov._dec.".split("_"),
     monthsParseExact: !0,
     weekdays: "duminică_luni_marți_miercuri_joi_vineri_sâmbătă".split("_"),
     weekdaysShort: "Dum_Lun_Mar_Mie_Joi_Vin_Sâm".split("_"),
     weekdaysMin: "Du_Lu_Ma_Mi_Jo_Vi_Sâ".split("_"),
     longDateFormat: {
      LT: "H:mm",
      LTS: "H:mm:ss",
      L: "DD.MM.YYYY",
      LL: "D MMMM YYYY",
      LLL: "D MMMM YYYY H:mm",
      LLLL: "dddd, D MMMM YYYY H:mm"
     },
     calendar: {
      sameDay: "[azi la] LT",
      nextDay: "[mâine la] LT",
      nextWeek: "dddd [la] LT",
      lastDay: "[ieri la] LT",
      lastWeek: "[fosta] dddd [la] LT",
      sameElse: "L"
     },
     relativeTime: {
      future: "peste %s",
      past: "%s în urmă",
      s: "câteva secunde",
      ss: relativeTimeWithPlural,
      m: "un minut",
      mm: relativeTimeWithPlural,
      h: "o oră",
      hh: relativeTimeWithPlural,
      d: "o zi",
      dd: relativeTimeWithPlural,
      w: "o săptămână",
      ww: relativeTimeWithPlural,
      M: "o lună",
      MM: relativeTimeWithPlural,
      y: "un an",
      yy: relativeTimeWithPlural
     },
     week: {
      dow: 1,
      doy: 7
     }
    });
   }(__webpack_require__(95093));
  },
  82271: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    function plural(word, num) {
     var forms = word.split("_");
     return num % 10 == 1 && num % 100 != 11 ? forms[0] : num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2];
    }
    function relativeTimeWithPlural(number, withoutSuffix, key) {
     return "m" === key ? withoutSuffix ? "минута" : "минуту" : number + " " + plural({
      ss: withoutSuffix ? "секунда_секунды_секунд" : "секунду_секунды_секунд",
      mm: withoutSuffix ? "минута_минуты_минут" : "минуту_минуты_минут",
      hh: "час_часа_часов",
      dd: "день_дня_дней",
      ww: "неделя_недели_недель",
      MM: "месяц_месяца_месяцев",
      yy: "год_года_лет"
     }[key], +number);
    }
    var monthsParse = [ /^янв/i, /^фев/i, /^мар/i, /^апр/i, /^ма[йя]/i, /^июн/i, /^июл/i, /^авг/i, /^сен/i, /^окт/i, /^ноя/i, /^дек/i ];
    moment.defineLocale("ru", {
     months: {
      format: "января_февраля_марта_апреля_мая_июня_июля_августа_сентября_октября_ноября_декабря".split("_"),
      standalone: "январь_февраль_март_апрель_май_июнь_июль_август_сентябрь_октябрь_ноябрь_декабрь".split("_")
     },
     monthsShort: {
      format: "янв._февр._мар._апр._мая_июня_июля_авг._сент._окт._нояб._дек.".split("_"),
      standalone: "янв._февр._март_апр._май_июнь_июль_авг._сент._окт._нояб._дек.".split("_")
     },
     weekdays: {
      standalone: "воскресенье_понедельник_вторник_среда_четверг_пятница_суббота".split("_"),
      format: "воскресенье_понедельник_вторник_среду_четверг_пятницу_субботу".split("_"),
      isFormat: /\[ ?[Вв] ?(?:прошлую|следующую|эту)? ?] ?dddd/
     },
     weekdaysShort: "вс_пн_вт_ср_чт_пт_сб".split("_"),
     weekdaysMin: "вс_пн_вт_ср_чт_пт_сб".split("_"),
     monthsParse,
     longMonthsParse: monthsParse,
     shortMonthsParse: monthsParse,
     monthsRegex: /^(январ[ья]|янв\.?|феврал[ья]|февр?\.?|марта?|мар\.?|апрел[ья]|апр\.?|ма[йя]|июн[ья]|июн\.?|июл[ья]|июл\.?|августа?|авг\.?|сентябр[ья]|сент?\.?|октябр[ья]|окт\.?|ноябр[ья]|нояб?\.?|декабр[ья]|дек\.?)/i,
     monthsShortRegex: /^(январ[ья]|янв\.?|феврал[ья]|февр?\.?|марта?|мар\.?|апрел[ья]|апр\.?|ма[йя]|июн[ья]|июн\.?|июл[ья]|июл\.?|августа?|авг\.?|сентябр[ья]|сент?\.?|октябр[ья]|окт\.?|ноябр[ья]|нояб?\.?|декабр[ья]|дек\.?)/i,
     monthsStrictRegex: /^(январ[яь]|феврал[яь]|марта?|апрел[яь]|ма[яй]|июн[яь]|июл[яь]|августа?|сентябр[яь]|октябр[яь]|ноябр[яь]|декабр[яь])/i,
     monthsShortStrictRegex: /^(янв\.|февр?\.|мар[т.]|апр\.|ма[яй]|июн[ья.]|июл[ья.]|авг\.|сент?\.|окт\.|нояб?\.|дек\.)/i,
     longDateFormat: {
      LT: "H:mm",
      LTS: "H:mm:ss",
      L: "DD.MM.YYYY",
      LL: "D MMMM YYYY г.",
      LLL: "D MMMM YYYY г., H:mm",
      LLLL: "dddd, D MMMM YYYY г., H:mm"
     },
     calendar: {
      sameDay: "[Сегодня, в] LT",
      nextDay: "[Завтра, в] LT",
      lastDay: "[Вчера, в] LT",
      nextWeek: function(now) {
       if (now.week() === this.week()) return 2 === this.day() ? "[Во] dddd, [в] LT" : "[В] dddd, [в] LT";
       switch (this.day()) {
       case 0:
        return "[В следующее] dddd, [в] LT";

       case 1:
       case 2:
       case 4:
        return "[В следующий] dddd, [в] LT";

       case 3:
       case 5:
       case 6:
        return "[В следующую] dddd, [в] LT";
       }
      },
      lastWeek: function(now) {
       if (now.week() === this.week()) return 2 === this.day() ? "[Во] dddd, [в] LT" : "[В] dddd, [в] LT";
       switch (this.day()) {
       case 0:
        return "[В прошлое] dddd, [в] LT";

       case 1:
       case 2:
       case 4:
        return "[В прошлый] dddd, [в] LT";

       case 3:
       case 5:
       case 6:
        return "[В прошлую] dddd, [в] LT";
       }
      },
      sameElse: "L"
     },
     relativeTime: {
      future: "через %s",
      past: "%s назад",
      s: "несколько секунд",
      ss: relativeTimeWithPlural,
      m: relativeTimeWithPlural,
      mm: relativeTimeWithPlural,
      h: "час",
      hh: relativeTimeWithPlural,
      d: "день",
      dd: relativeTimeWithPlural,
      w: "неделя",
      ww: relativeTimeWithPlural,
      M: "месяц",
      MM: relativeTimeWithPlural,
      y: "год",
      yy: relativeTimeWithPlural
     },
     meridiemParse: /ночи|утра|дня|вечера/i,
     isPM: function(input) {
      return /^(дня|вечера)$/.test(input);
     },
     meridiem: function(hour, minute, isLower) {
      return hour < 4 ? "ночи" : hour < 12 ? "утра" : hour < 17 ? "дня" : "вечера";
     },
     dayOfMonthOrdinalParse: /\d{1,2}-(й|го|я)/,
     ordinal: function(number, period) {
      switch (period) {
      case "M":
      case "d":
      case "DDD":
       return number + "-й";

      case "D":
       return number + "-го";

      case "w":
      case "W":
       return number + "-я";

      default:
       return number;
      }
     },
     week: {
      dow: 1,
      doy: 4
     }
    });
   }(__webpack_require__(95093));
  },
  1221: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    var months = [ "جنوري", "فيبروري", "مارچ", "اپريل", "مئي", "جون", "جولاءِ", "آگسٽ", "سيپٽمبر", "آڪٽوبر", "نومبر", "ڊسمبر" ], days = [ "آچر", "سومر", "اڱارو", "اربع", "خميس", "جمع", "ڇنڇر" ];
    moment.defineLocale("sd", {
     months,
     monthsShort: months,
     weekdays: days,
     weekdaysShort: days,
     weekdaysMin: days,
     longDateFormat: {
      LT: "HH:mm",
      LTS: "HH:mm:ss",
      L: "DD/MM/YYYY",
      LL: "D MMMM YYYY",
      LLL: "D MMMM YYYY HH:mm",
      LLLL: "dddd، D MMMM YYYY HH:mm"
     },
     meridiemParse: /صبح|شام/,
     isPM: function(input) {
      return "شام" === input;
     },
     meridiem: function(hour, minute, isLower) {
      return hour < 12 ? "صبح" : "شام";
     },
     calendar: {
      sameDay: "[اڄ] LT",
      nextDay: "[سڀاڻي] LT",
      nextWeek: "dddd [اڳين هفتي تي] LT",
      lastDay: "[ڪالهه] LT",
      lastWeek: "[گزريل هفتي] dddd [تي] LT",
      sameElse: "L"
     },
     relativeTime: {
      future: "%s پوء",
      past: "%s اڳ",
      s: "چند سيڪنڊ",
      ss: "%d سيڪنڊ",
      m: "هڪ منٽ",
      mm: "%d منٽ",
      h: "هڪ ڪلاڪ",
      hh: "%d ڪلاڪ",
      d: "هڪ ڏينهن",
      dd: "%d ڏينهن",
      M: "هڪ مهينو",
      MM: "%d مهينا",
      y: "هڪ سال",
      yy: "%d سال"
     },
     preparse: function(string) {
      return string.replace(/،/g, ",");
     },
     postformat: function(string) {
      return string.replace(/,/g, "،");
     },
     week: {
      dow: 1,
      doy: 4
     }
    });
   }(__webpack_require__(95093));
  },
  33478: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    moment.defineLocale("se", {
     months: "ođđajagemánnu_guovvamánnu_njukčamánnu_cuoŋománnu_miessemánnu_geassemánnu_suoidnemánnu_borgemánnu_čakčamánnu_golggotmánnu_skábmamánnu_juovlamánnu".split("_"),
     monthsShort: "ođđj_guov_njuk_cuo_mies_geas_suoi_borg_čakč_golg_skáb_juov".split("_"),
     weekdays: "sotnabeaivi_vuossárga_maŋŋebárga_gaskavahkku_duorastat_bearjadat_lávvardat".split("_"),
     weekdaysShort: "sotn_vuos_maŋ_gask_duor_bear_láv".split("_"),
     weekdaysMin: "s_v_m_g_d_b_L".split("_"),
     longDateFormat: {
      LT: "HH:mm",
      LTS: "HH:mm:ss",
      L: "DD.MM.YYYY",
      LL: "MMMM D. [b.] YYYY",
      LLL: "MMMM D. [b.] YYYY [ti.] HH:mm",
      LLLL: "dddd, MMMM D. [b.] YYYY [ti.] HH:mm"
     },
     calendar: {
      sameDay: "[otne ti] LT",
      nextDay: "[ihttin ti] LT",
      nextWeek: "dddd [ti] LT",
      lastDay: "[ikte ti] LT",
      lastWeek: "[ovddit] dddd [ti] LT",
      sameElse: "L"
     },
     relativeTime: {
      future: "%s geažes",
      past: "maŋit %s",
      s: "moadde sekunddat",
      ss: "%d sekunddat",
      m: "okta minuhta",
      mm: "%d minuhtat",
      h: "okta diimmu",
      hh: "%d diimmut",
      d: "okta beaivi",
      dd: "%d beaivvit",
      M: "okta mánnu",
      MM: "%d mánut",
      y: "okta jahki",
      yy: "%d jagit"
     },
     dayOfMonthOrdinalParse: /\d{1,2}\./,
     ordinal: "%d.",
     week: {
      dow: 1,
      doy: 4
     }
    });
   }(__webpack_require__(95093));
  },
  17538: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    moment.defineLocale("si", {
     months: "ජනවාරි_පෙබරවාරි_මාර්තු_අප්‍රේල්_මැයි_ජූනි_ජූලි_අගෝස්තු_සැප්තැම්බර්_ඔක්තෝබර්_නොවැම්බර්_දෙසැම්බර්".split("_"),
     monthsShort: "ජන_පෙබ_මාර්_අප්_මැයි_ජූනි_ජූලි_අගෝ_සැප්_ඔක්_නොවැ_දෙසැ".split("_"),
     weekdays: "ඉරිදා_සඳුදා_අඟහරුවාදා_බදාදා_බ්‍රහස්පතින්දා_සිකුරාදා_සෙනසුරාදා".split("_"),
     weekdaysShort: "ඉරි_සඳු_අඟ_බදා_බ්‍රහ_සිකු_සෙන".split("_"),
     weekdaysMin: "ඉ_ස_අ_බ_බ්‍ර_සි_සෙ".split("_"),
     weekdaysParseExact: !0,
     longDateFormat: {
      LT: "a h:mm",
      LTS: "a h:mm:ss",
      L: "YYYY/MM/DD",
      LL: "YYYY MMMM D",
      LLL: "YYYY MMMM D, a h:mm",
      LLLL: "YYYY MMMM D [වැනි] dddd, a h:mm:ss"
     },
     calendar: {
      sameDay: "[අද] LT[ට]",
      nextDay: "[හෙට] LT[ට]",
      nextWeek: "dddd LT[ට]",
      lastDay: "[ඊයේ] LT[ට]",
      lastWeek: "[පසුගිය] dddd LT[ට]",
      sameElse: "L"
     },
     relativeTime: {
      future: "%sකින්",
      past: "%sකට පෙර",
      s: "තත්පර කිහිපය",
      ss: "තත්පර %d",
      m: "මිනිත්තුව",
      mm: "මිනිත්තු %d",
      h: "පැය",
      hh: "පැය %d",
      d: "දිනය",
      dd: "දින %d",
      M: "මාසය",
      MM: "මාස %d",
      y: "වසර",
      yy: "වසර %d"
     },
     dayOfMonthOrdinalParse: /\d{1,2} වැනි/,
     ordinal: function(number) {
      return number + " වැනි";
     },
     meridiemParse: /පෙර වරු|පස් වරු|පෙ.ව|ප.ව./,
     isPM: function(input) {
      return "ප.ව." === input || "පස් වරු" === input;
     },
     meridiem: function(hours, minutes, isLower) {
      return hours > 11 ? isLower ? "ප.ව." : "පස් වරු" : isLower ? "පෙ.ව." : "පෙර වරු";
     }
    });
   }(__webpack_require__(95093));
  },
  5784: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    var months = "január_február_marec_apríl_máj_jún_júl_august_september_október_november_december".split("_"), monthsShort = "jan_feb_mar_apr_máj_jún_júl_aug_sep_okt_nov_dec".split("_");
    function plural(n) {
     return n > 1 && n < 5;
    }
    function translate(number, withoutSuffix, key, isFuture) {
     var result = number + " ";
     switch (key) {
     case "s":
      return withoutSuffix || isFuture ? "pár sekúnd" : "pár sekundami";

     case "ss":
      return withoutSuffix || isFuture ? result + (plural(number) ? "sekundy" : "sekúnd") : result + "sekundami";

     case "m":
      return withoutSuffix ? "minúta" : isFuture ? "minútu" : "minútou";

     case "mm":
      return withoutSuffix || isFuture ? result + (plural(number) ? "minúty" : "minút") : result + "minútami";

     case "h":
      return withoutSuffix ? "hodina" : isFuture ? "hodinu" : "hodinou";

     case "hh":
      return withoutSuffix || isFuture ? result + (plural(number) ? "hodiny" : "hodín") : result + "hodinami";

     case "d":
      return withoutSuffix || isFuture ? "deň" : "dňom";

     case "dd":
      return withoutSuffix || isFuture ? result + (plural(number) ? "dni" : "dní") : result + "dňami";

     case "M":
      return withoutSuffix || isFuture ? "mesiac" : "mesiacom";

     case "MM":
      return withoutSuffix || isFuture ? result + (plural(number) ? "mesiace" : "mesiacov") : result + "mesiacmi";

     case "y":
      return withoutSuffix || isFuture ? "rok" : "rokom";

     case "yy":
      return withoutSuffix || isFuture ? result + (plural(number) ? "roky" : "rokov") : result + "rokmi";
     }
    }
    moment.defineLocale("sk", {
     months,
     monthsShort,
     weekdays: "nedeľa_pondelok_utorok_streda_štvrtok_piatok_sobota".split("_"),
     weekdaysShort: "ne_po_ut_st_št_pi_so".split("_"),
     weekdaysMin: "ne_po_ut_st_št_pi_so".split("_"),
     longDateFormat: {
      LT: "H:mm",
      LTS: "H:mm:ss",
      L: "DD.MM.YYYY",
      LL: "D. MMMM YYYY",
      LLL: "D. MMMM YYYY H:mm",
      LLLL: "dddd D. MMMM YYYY H:mm"
     },
     calendar: {
      sameDay: "[dnes o] LT",
      nextDay: "[zajtra o] LT",
      nextWeek: function() {
       switch (this.day()) {
       case 0:
        return "[v nedeľu o] LT";

       case 1:
       case 2:
        return "[v] dddd [o] LT";

       case 3:
        return "[v stredu o] LT";

       case 4:
        return "[vo štvrtok o] LT";

       case 5:
        return "[v piatok o] LT";

       case 6:
        return "[v sobotu o] LT";
       }
      },
      lastDay: "[včera o] LT",
      lastWeek: function() {
       switch (this.day()) {
       case 0:
        return "[minulú nedeľu o] LT";

       case 1:
       case 2:
       case 4:
       case 5:
        return "[minulý] dddd [o] LT";

       case 3:
        return "[minulú stredu o] LT";

       case 6:
        return "[minulú sobotu o] LT";
       }
      },
      sameElse: "L"
     },
     relativeTime: {
      future: "za %s",
      past: "pred %s",
      s: translate,
      ss: translate,
      m: translate,
      mm: translate,
      h: translate,
      hh: translate,
      d: translate,
      dd: translate,
      M: translate,
      MM: translate,
      y: translate,
      yy: translate
     },
     dayOfMonthOrdinalParse: /\d{1,2}\./,
     ordinal: "%d.",
     week: {
      dow: 1,
      doy: 4
     }
    });
   }(__webpack_require__(95093));
  },
  46637: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    function processRelativeTime(number, withoutSuffix, key, isFuture) {
     var result = number + " ";
     switch (key) {
     case "s":
      return withoutSuffix || isFuture ? "nekaj sekund" : "nekaj sekundami";

     case "ss":
      return result += 1 === number ? withoutSuffix ? "sekundo" : "sekundi" : 2 === number ? withoutSuffix || isFuture ? "sekundi" : "sekundah" : number < 5 ? withoutSuffix || isFuture ? "sekunde" : "sekundah" : "sekund";

     case "m":
      return withoutSuffix ? "ena minuta" : "eno minuto";

     case "mm":
      return result += 1 === number ? withoutSuffix ? "minuta" : "minuto" : 2 === number ? withoutSuffix || isFuture ? "minuti" : "minutama" : number < 5 ? withoutSuffix || isFuture ? "minute" : "minutami" : withoutSuffix || isFuture ? "minut" : "minutami";

     case "h":
      return withoutSuffix ? "ena ura" : "eno uro";

     case "hh":
      return result += 1 === number ? withoutSuffix ? "ura" : "uro" : 2 === number ? withoutSuffix || isFuture ? "uri" : "urama" : number < 5 ? withoutSuffix || isFuture ? "ure" : "urami" : withoutSuffix || isFuture ? "ur" : "urami";

     case "d":
      return withoutSuffix || isFuture ? "en dan" : "enim dnem";

     case "dd":
      return result += 1 === number ? withoutSuffix || isFuture ? "dan" : "dnem" : 2 === number ? withoutSuffix || isFuture ? "dni" : "dnevoma" : withoutSuffix || isFuture ? "dni" : "dnevi";

     case "M":
      return withoutSuffix || isFuture ? "en mesec" : "enim mesecem";

     case "MM":
      return result += 1 === number ? withoutSuffix || isFuture ? "mesec" : "mesecem" : 2 === number ? withoutSuffix || isFuture ? "meseca" : "mesecema" : number < 5 ? withoutSuffix || isFuture ? "mesece" : "meseci" : withoutSuffix || isFuture ? "mesecev" : "meseci";

     case "y":
      return withoutSuffix || isFuture ? "eno leto" : "enim letom";

     case "yy":
      return result += 1 === number ? withoutSuffix || isFuture ? "leto" : "letom" : 2 === number ? withoutSuffix || isFuture ? "leti" : "letoma" : number < 5 ? withoutSuffix || isFuture ? "leta" : "leti" : withoutSuffix || isFuture ? "let" : "leti";
     }
    }
    moment.defineLocale("sl", {
     months: "januar_februar_marec_april_maj_junij_julij_avgust_september_oktober_november_december".split("_"),
     monthsShort: "jan._feb._mar._apr._maj._jun._jul._avg._sep._okt._nov._dec.".split("_"),
     monthsParseExact: !0,
     weekdays: "nedelja_ponedeljek_torek_sreda_četrtek_petek_sobota".split("_"),
     weekdaysShort: "ned._pon._tor._sre._čet._pet._sob.".split("_"),
     weekdaysMin: "ne_po_to_sr_če_pe_so".split("_"),
     weekdaysParseExact: !0,
     longDateFormat: {
      LT: "H:mm",
      LTS: "H:mm:ss",
      L: "DD. MM. YYYY",
      LL: "D. MMMM YYYY",
      LLL: "D. MMMM YYYY H:mm",
      LLLL: "dddd, D. MMMM YYYY H:mm"
     },
     calendar: {
      sameDay: "[danes ob] LT",
      nextDay: "[jutri ob] LT",
      nextWeek: function() {
       switch (this.day()) {
       case 0:
        return "[v] [nedeljo] [ob] LT";

       case 3:
        return "[v] [sredo] [ob] LT";

       case 6:
        return "[v] [soboto] [ob] LT";

       case 1:
       case 2:
       case 4:
       case 5:
        return "[v] dddd [ob] LT";
       }
      },
      lastDay: "[včeraj ob] LT",
      lastWeek: function() {
       switch (this.day()) {
       case 0:
        return "[prejšnjo] [nedeljo] [ob] LT";

       case 3:
        return "[prejšnjo] [sredo] [ob] LT";

       case 6:
        return "[prejšnjo] [soboto] [ob] LT";

       case 1:
       case 2:
       case 4:
       case 5:
        return "[prejšnji] dddd [ob] LT";
       }
      },
      sameElse: "L"
     },
     relativeTime: {
      future: "čez %s",
      past: "pred %s",
      s: processRelativeTime,
      ss: processRelativeTime,
      m: processRelativeTime,
      mm: processRelativeTime,
      h: processRelativeTime,
      hh: processRelativeTime,
      d: processRelativeTime,
      dd: processRelativeTime,
      M: processRelativeTime,
      MM: processRelativeTime,
      y: processRelativeTime,
      yy: processRelativeTime
     },
     dayOfMonthOrdinalParse: /\d{1,2}\./,
     ordinal: "%d.",
     week: {
      dow: 1,
      doy: 7
     }
    });
   }(__webpack_require__(95093));
  },
  86794: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    moment.defineLocale("sq", {
     months: "Janar_Shkurt_Mars_Prill_Maj_Qershor_Korrik_Gusht_Shtator_Tetor_Nëntor_Dhjetor".split("_"),
     monthsShort: "Jan_Shk_Mar_Pri_Maj_Qer_Kor_Gus_Sht_Tet_Nën_Dhj".split("_"),
     weekdays: "E Diel_E Hënë_E Martë_E Mërkurë_E Enjte_E Premte_E Shtunë".split("_"),
     weekdaysShort: "Die_Hën_Mar_Mër_Enj_Pre_Sht".split("_"),
     weekdaysMin: "D_H_Ma_Më_E_P_Sh".split("_"),
     weekdaysParseExact: !0,
     meridiemParse: /PD|MD/,
     isPM: function(input) {
      return "M" === input.charAt(0);
     },
     meridiem: function(hours, minutes, isLower) {
      return hours < 12 ? "PD" : "MD";
     },
     longDateFormat: {
      LT: "HH:mm",
      LTS: "HH:mm:ss",
      L: "DD/MM/YYYY",
      LL: "D MMMM YYYY",
      LLL: "D MMMM YYYY HH:mm",
      LLLL: "dddd, D MMMM YYYY HH:mm"
     },
     calendar: {
      sameDay: "[Sot në] LT",
      nextDay: "[Nesër në] LT",
      nextWeek: "dddd [në] LT",
      lastDay: "[Dje në] LT",
      lastWeek: "dddd [e kaluar në] LT",
      sameElse: "L"
     },
     relativeTime: {
      future: "në %s",
      past: "%s më parë",
      s: "disa sekonda",
      ss: "%d sekonda",
      m: "një minutë",
      mm: "%d minuta",
      h: "një orë",
      hh: "%d orë",
      d: "një ditë",
      dd: "%d ditë",
      M: "një muaj",
      MM: "%d muaj",
      y: "një vit",
      yy: "%d vite"
     },
     dayOfMonthOrdinalParse: /\d{1,2}\./,
     ordinal: "%d.",
     week: {
      dow: 1,
      doy: 4
     }
    });
   }(__webpack_require__(95093));
  },
  3322: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    var translator = {
     words: {
      ss: [ "секунда", "секунде", "секунди" ],
      m: [ "један минут", "једног минута" ],
      mm: [ "минут", "минута", "минута" ],
      h: [ "један сат", "једног сата" ],
      hh: [ "сат", "сата", "сати" ],
      d: [ "један дан", "једног дана" ],
      dd: [ "дан", "дана", "дана" ],
      M: [ "један месец", "једног месеца" ],
      MM: [ "месец", "месеца", "месеци" ],
      y: [ "једну годину", "једне године" ],
      yy: [ "годину", "године", "година" ]
     },
     correctGrammaticalCase: function(number, wordKey) {
      return number % 10 >= 1 && number % 10 <= 4 && (number % 100 < 10 || number % 100 >= 20) ? number % 10 == 1 ? wordKey[0] : wordKey[1] : wordKey[2];
     },
     translate: function(number, withoutSuffix, key, isFuture) {
      var word, wordKey = translator.words[key];
      return 1 === key.length ? "y" === key && withoutSuffix ? "једна година" : isFuture || withoutSuffix ? wordKey[0] : wordKey[1] : (word = translator.correctGrammaticalCase(number, wordKey), 
      "yy" === key && withoutSuffix && "годину" === word ? number + " година" : number + " " + word);
     }
    };
    moment.defineLocale("sr-cyrl", {
     months: "јануар_фебруар_март_април_мај_јун_јул_август_септембар_октобар_новембар_децембар".split("_"),
     monthsShort: "јан._феб._мар._апр._мај_јун_јул_авг._сеп._окт._нов._дец.".split("_"),
     monthsParseExact: !0,
     weekdays: "недеља_понедељак_уторак_среда_четвртак_петак_субота".split("_"),
     weekdaysShort: "нед._пон._уто._сре._чет._пет._суб.".split("_"),
     weekdaysMin: "не_по_ут_ср_че_пе_су".split("_"),
     weekdaysParseExact: !0,
     longDateFormat: {
      LT: "H:mm",
      LTS: "H:mm:ss",
      L: "D. M. YYYY.",
      LL: "D. MMMM YYYY.",
      LLL: "D. MMMM YYYY. H:mm",
      LLLL: "dddd, D. MMMM YYYY. H:mm"
     },
     calendar: {
      sameDay: "[данас у] LT",
      nextDay: "[сутра у] LT",
      nextWeek: function() {
       switch (this.day()) {
       case 0:
        return "[у] [недељу] [у] LT";

       case 3:
        return "[у] [среду] [у] LT";

       case 6:
        return "[у] [суботу] [у] LT";

       case 1:
       case 2:
       case 4:
       case 5:
        return "[у] dddd [у] LT";
       }
      },
      lastDay: "[јуче у] LT",
      lastWeek: function() {
       return [ "[прошле] [недеље] [у] LT", "[прошлог] [понедељка] [у] LT", "[прошлог] [уторка] [у] LT", "[прошле] [среде] [у] LT", "[прошлог] [четвртка] [у] LT", "[прошлог] [петка] [у] LT", "[прошле] [суботе] [у] LT" ][this.day()];
      },
      sameElse: "L"
     },
     relativeTime: {
      future: "за %s",
      past: "пре %s",
      s: "неколико секунди",
      ss: translator.translate,
      m: translator.translate,
      mm: translator.translate,
      h: translator.translate,
      hh: translator.translate,
      d: translator.translate,
      dd: translator.translate,
      M: translator.translate,
      MM: translator.translate,
      y: translator.translate,
      yy: translator.translate
     },
     dayOfMonthOrdinalParse: /\d{1,2}\./,
     ordinal: "%d.",
     week: {
      dow: 1,
      doy: 7
     }
    });
   }(__webpack_require__(95093));
  },
  45719: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    var translator = {
     words: {
      ss: [ "sekunda", "sekunde", "sekundi" ],
      m: [ "jedan minut", "jednog minuta" ],
      mm: [ "minut", "minuta", "minuta" ],
      h: [ "jedan sat", "jednog sata" ],
      hh: [ "sat", "sata", "sati" ],
      d: [ "jedan dan", "jednog dana" ],
      dd: [ "dan", "dana", "dana" ],
      M: [ "jedan mesec", "jednog meseca" ],
      MM: [ "mesec", "meseca", "meseci" ],
      y: [ "jednu godinu", "jedne godine" ],
      yy: [ "godinu", "godine", "godina" ]
     },
     correctGrammaticalCase: function(number, wordKey) {
      return number % 10 >= 1 && number % 10 <= 4 && (number % 100 < 10 || number % 100 >= 20) ? number % 10 == 1 ? wordKey[0] : wordKey[1] : wordKey[2];
     },
     translate: function(number, withoutSuffix, key, isFuture) {
      var word, wordKey = translator.words[key];
      return 1 === key.length ? "y" === key && withoutSuffix ? "jedna godina" : isFuture || withoutSuffix ? wordKey[0] : wordKey[1] : (word = translator.correctGrammaticalCase(number, wordKey), 
      "yy" === key && withoutSuffix && "godinu" === word ? number + " godina" : number + " " + word);
     }
    };
    moment.defineLocale("sr", {
     months: "januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar".split("_"),
     monthsShort: "jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.".split("_"),
     monthsParseExact: !0,
     weekdays: "nedelja_ponedeljak_utorak_sreda_četvrtak_petak_subota".split("_"),
     weekdaysShort: "ned._pon._uto._sre._čet._pet._sub.".split("_"),
     weekdaysMin: "ne_po_ut_sr_če_pe_su".split("_"),
     weekdaysParseExact: !0,
     longDateFormat: {
      LT: "H:mm",
      LTS: "H:mm:ss",
      L: "D. M. YYYY.",
      LL: "D. MMMM YYYY.",
      LLL: "D. MMMM YYYY. H:mm",
      LLLL: "dddd, D. MMMM YYYY. H:mm"
     },
     calendar: {
      sameDay: "[danas u] LT",
      nextDay: "[sutra u] LT",
      nextWeek: function() {
       switch (this.day()) {
       case 0:
        return "[u] [nedelju] [u] LT";

       case 3:
        return "[u] [sredu] [u] LT";

       case 6:
        return "[u] [subotu] [u] LT";

       case 1:
       case 2:
       case 4:
       case 5:
        return "[u] dddd [u] LT";
       }
      },
      lastDay: "[juče u] LT",
      lastWeek: function() {
       return [ "[prošle] [nedelje] [u] LT", "[prošlog] [ponedeljka] [u] LT", "[prošlog] [utorka] [u] LT", "[prošle] [srede] [u] LT", "[prošlog] [četvrtka] [u] LT", "[prošlog] [petka] [u] LT", "[prošle] [subote] [u] LT" ][this.day()];
      },
      sameElse: "L"
     },
     relativeTime: {
      future: "za %s",
      past: "pre %s",
      s: "nekoliko sekundi",
      ss: translator.translate,
      m: translator.translate,
      mm: translator.translate,
      h: translator.translate,
      hh: translator.translate,
      d: translator.translate,
      dd: translator.translate,
      M: translator.translate,
      MM: translator.translate,
      y: translator.translate,
      yy: translator.translate
     },
     dayOfMonthOrdinalParse: /\d{1,2}\./,
     ordinal: "%d.",
     week: {
      dow: 1,
      doy: 7
     }
    });
   }(__webpack_require__(95093));
  },
  56e3: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    moment.defineLocale("ss", {
     months: "Bhimbidvwane_Indlovana_Indlov'lenkhulu_Mabasa_Inkhwekhweti_Inhlaba_Kholwane_Ingci_Inyoni_Imphala_Lweti_Ingongoni".split("_"),
     monthsShort: "Bhi_Ina_Inu_Mab_Ink_Inh_Kho_Igc_Iny_Imp_Lwe_Igo".split("_"),
     weekdays: "Lisontfo_Umsombuluko_Lesibili_Lesitsatfu_Lesine_Lesihlanu_Umgcibelo".split("_"),
     weekdaysShort: "Lis_Umb_Lsb_Les_Lsi_Lsh_Umg".split("_"),
     weekdaysMin: "Li_Us_Lb_Lt_Ls_Lh_Ug".split("_"),
     weekdaysParseExact: !0,
     longDateFormat: {
      LT: "h:mm A",
      LTS: "h:mm:ss A",
      L: "DD/MM/YYYY",
      LL: "D MMMM YYYY",
      LLL: "D MMMM YYYY h:mm A",
      LLLL: "dddd, D MMMM YYYY h:mm A"
     },
     calendar: {
      sameDay: "[Namuhla nga] LT",
      nextDay: "[Kusasa nga] LT",
      nextWeek: "dddd [nga] LT",
      lastDay: "[Itolo nga] LT",
      lastWeek: "dddd [leliphelile] [nga] LT",
      sameElse: "L"
     },
     relativeTime: {
      future: "nga %s",
      past: "wenteka nga %s",
      s: "emizuzwana lomcane",
      ss: "%d mzuzwana",
      m: "umzuzu",
      mm: "%d emizuzu",
      h: "lihora",
      hh: "%d emahora",
      d: "lilanga",
      dd: "%d emalanga",
      M: "inyanga",
      MM: "%d tinyanga",
      y: "umnyaka",
      yy: "%d iminyaka"
     },
     meridiemParse: /ekuseni|emini|entsambama|ebusuku/,
     meridiem: function(hours, minutes, isLower) {
      return hours < 11 ? "ekuseni" : hours < 15 ? "emini" : hours < 19 ? "entsambama" : "ebusuku";
     },
     meridiemHour: function(hour, meridiem) {
      return 12 === hour && (hour = 0), "ekuseni" === meridiem ? hour : "emini" === meridiem ? hour >= 11 ? hour : hour + 12 : "entsambama" === meridiem || "ebusuku" === meridiem ? 0 === hour ? 0 : hour + 12 : void 0;
     },
     dayOfMonthOrdinalParse: /\d{1,2}/,
     ordinal: "%d",
     week: {
      dow: 1,
      doy: 4
     }
    });
   }(__webpack_require__(95093));
  },
  41011: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    moment.defineLocale("sv", {
     months: "januari_februari_mars_april_maj_juni_juli_augusti_september_oktober_november_december".split("_"),
     monthsShort: "jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec".split("_"),
     weekdays: "söndag_måndag_tisdag_onsdag_torsdag_fredag_lördag".split("_"),
     weekdaysShort: "sön_mån_tis_ons_tor_fre_lör".split("_"),
     weekdaysMin: "sö_må_ti_on_to_fr_lö".split("_"),
     longDateFormat: {
      LT: "HH:mm",
      LTS: "HH:mm:ss",
      L: "YYYY-MM-DD",
      LL: "D MMMM YYYY",
      LLL: "D MMMM YYYY [kl.] HH:mm",
      LLLL: "dddd D MMMM YYYY [kl.] HH:mm",
      lll: "D MMM YYYY HH:mm",
      llll: "ddd D MMM YYYY HH:mm"
     },
     calendar: {
      sameDay: "[Idag] LT",
      nextDay: "[Imorgon] LT",
      lastDay: "[Igår] LT",
      nextWeek: "[På] dddd LT",
      lastWeek: "[I] dddd[s] LT",
      sameElse: "L"
     },
     relativeTime: {
      future: "om %s",
      past: "för %s sedan",
      s: "några sekunder",
      ss: "%d sekunder",
      m: "en minut",
      mm: "%d minuter",
      h: "en timme",
      hh: "%d timmar",
      d: "en dag",
      dd: "%d dagar",
      M: "en månad",
      MM: "%d månader",
      y: "ett år",
      yy: "%d år"
     },
     dayOfMonthOrdinalParse: /\d{1,2}(\:e|\:a)/,
     ordinal: function(number) {
      var b = number % 10;
      return number + (1 == ~~(number % 100 / 10) ? ":e" : 1 === b || 2 === b ? ":a" : ":e");
     },
     week: {
      dow: 1,
      doy: 4
     }
    });
   }(__webpack_require__(95093));
  },
  40748: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    moment.defineLocale("sw", {
     months: "Januari_Februari_Machi_Aprili_Mei_Juni_Julai_Agosti_Septemba_Oktoba_Novemba_Desemba".split("_"),
     monthsShort: "Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ago_Sep_Okt_Nov_Des".split("_"),
     weekdays: "Jumapili_Jumatatu_Jumanne_Jumatano_Alhamisi_Ijumaa_Jumamosi".split("_"),
     weekdaysShort: "Jpl_Jtat_Jnne_Jtan_Alh_Ijm_Jmos".split("_"),
     weekdaysMin: "J2_J3_J4_J5_Al_Ij_J1".split("_"),
     weekdaysParseExact: !0,
     longDateFormat: {
      LT: "hh:mm A",
      LTS: "HH:mm:ss",
      L: "DD.MM.YYYY",
      LL: "D MMMM YYYY",
      LLL: "D MMMM YYYY HH:mm",
      LLLL: "dddd, D MMMM YYYY HH:mm"
     },
     calendar: {
      sameDay: "[leo saa] LT",
      nextDay: "[kesho saa] LT",
      nextWeek: "[wiki ijayo] dddd [saat] LT",
      lastDay: "[jana] LT",
      lastWeek: "[wiki iliyopita] dddd [saat] LT",
      sameElse: "L"
     },
     relativeTime: {
      future: "%s baadaye",
      past: "tokea %s",
      s: "hivi punde",
      ss: "sekunde %d",
      m: "dakika moja",
      mm: "dakika %d",
      h: "saa limoja",
      hh: "masaa %d",
      d: "siku moja",
      dd: "siku %d",
      M: "mwezi mmoja",
      MM: "miezi %d",
      y: "mwaka mmoja",
      yy: "miaka %d"
     },
     week: {
      dow: 1,
      doy: 7
     }
    });
   }(__webpack_require__(95093));
  },
  11025: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    var symbolMap = {
     1: "௧",
     2: "௨",
     3: "௩",
     4: "௪",
     5: "௫",
     6: "௬",
     7: "௭",
     8: "௮",
     9: "௯",
     0: "௦"
    }, numberMap = {
     "௧": "1",
     "௨": "2",
     "௩": "3",
     "௪": "4",
     "௫": "5",
     "௬": "6",
     "௭": "7",
     "௮": "8",
     "௯": "9",
     "௦": "0"
    };
    moment.defineLocale("ta", {
     months: "ஜனவரி_பிப்ரவரி_மார்ச்_ஏப்ரல்_மே_ஜூன்_ஜூலை_ஆகஸ்ட்_செப்டெம்பர்_அக்டோபர்_நவம்பர்_டிசம்பர்".split("_"),
     monthsShort: "ஜனவரி_பிப்ரவரி_மார்ச்_ஏப்ரல்_மே_ஜூன்_ஜூலை_ஆகஸ்ட்_செப்டெம்பர்_அக்டோபர்_நவம்பர்_டிசம்பர்".split("_"),
     weekdays: "ஞாயிற்றுக்கிழமை_திங்கட்கிழமை_செவ்வாய்கிழமை_புதன்கிழமை_வியாழக்கிழமை_வெள்ளிக்கிழமை_சனிக்கிழமை".split("_"),
     weekdaysShort: "ஞாயிறு_திங்கள்_செவ்வாய்_புதன்_வியாழன்_வெள்ளி_சனி".split("_"),
     weekdaysMin: "ஞா_தி_செ_பு_வி_வெ_ச".split("_"),
     longDateFormat: {
      LT: "HH:mm",
      LTS: "HH:mm:ss",
      L: "DD/MM/YYYY",
      LL: "D MMMM YYYY",
      LLL: "D MMMM YYYY, HH:mm",
      LLLL: "dddd, D MMMM YYYY, HH:mm"
     },
     calendar: {
      sameDay: "[இன்று] LT",
      nextDay: "[நாளை] LT",
      nextWeek: "dddd, LT",
      lastDay: "[நேற்று] LT",
      lastWeek: "[கடந்த வாரம்] dddd, LT",
      sameElse: "L"
     },
     relativeTime: {
      future: "%s இல்",
      past: "%s முன்",
      s: "ஒரு சில விநாடிகள்",
      ss: "%d விநாடிகள்",
      m: "ஒரு நிமிடம்",
      mm: "%d நிமிடங்கள்",
      h: "ஒரு மணி நேரம்",
      hh: "%d மணி நேரம்",
      d: "ஒரு நாள்",
      dd: "%d நாட்கள்",
      M: "ஒரு மாதம்",
      MM: "%d மாதங்கள்",
      y: "ஒரு வருடம்",
      yy: "%d ஆண்டுகள்"
     },
     dayOfMonthOrdinalParse: /\d{1,2}வது/,
     ordinal: function(number) {
      return number + "வது";
     },
     preparse: function(string) {
      return string.replace(/[௧௨௩௪௫௬௭௮௯௦]/g, (function(match) {
       return numberMap[match];
      }));
     },
     postformat: function(string) {
      return string.replace(/\d/g, (function(match) {
       return symbolMap[match];
      }));
     },
     meridiemParse: /யாமம்|வைகறை|காலை|நண்பகல்|எற்பாடு|மாலை/,
     meridiem: function(hour, minute, isLower) {
      return hour < 2 ? " யாமம்" : hour < 6 ? " வைகறை" : hour < 10 ? " காலை" : hour < 14 ? " நண்பகல்" : hour < 18 ? " எற்பாடு" : hour < 22 ? " மாலை" : " யாமம்";
     },
     meridiemHour: function(hour, meridiem) {
      return 12 === hour && (hour = 0), "யாமம்" === meridiem ? hour < 2 ? hour : hour + 12 : "வைகறை" === meridiem || "காலை" === meridiem || "நண்பகல்" === meridiem && hour >= 10 ? hour : hour + 12;
     },
     week: {
      dow: 0,
      doy: 6
     }
    });
   }(__webpack_require__(95093));
  },
  11885: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    moment.defineLocale("te", {
     months: "జనవరి_ఫిబ్రవరి_మార్చి_ఏప్రిల్_మే_జూన్_జులై_ఆగస్టు_సెప్టెంబర్_అక్టోబర్_నవంబర్_డిసెంబర్".split("_"),
     monthsShort: "జన._ఫిబ్ర._మార్చి_ఏప్రి._మే_జూన్_జులై_ఆగ._సెప్._అక్టో._నవ._డిసె.".split("_"),
     monthsParseExact: !0,
     weekdays: "ఆదివారం_సోమవారం_మంగళవారం_బుధవారం_గురువారం_శుక్రవారం_శనివారం".split("_"),
     weekdaysShort: "ఆది_సోమ_మంగళ_బుధ_గురు_శుక్ర_శని".split("_"),
     weekdaysMin: "ఆ_సో_మం_బు_గు_శు_శ".split("_"),
     longDateFormat: {
      LT: "A h:mm",
      LTS: "A h:mm:ss",
      L: "DD/MM/YYYY",
      LL: "D MMMM YYYY",
      LLL: "D MMMM YYYY, A h:mm",
      LLLL: "dddd, D MMMM YYYY, A h:mm"
     },
     calendar: {
      sameDay: "[నేడు] LT",
      nextDay: "[రేపు] LT",
      nextWeek: "dddd, LT",
      lastDay: "[నిన్న] LT",
      lastWeek: "[గత] dddd, LT",
      sameElse: "L"
     },
     relativeTime: {
      future: "%s లో",
      past: "%s క్రితం",
      s: "కొన్ని క్షణాలు",
      ss: "%d సెకన్లు",
      m: "ఒక నిమిషం",
      mm: "%d నిమిషాలు",
      h: "ఒక గంట",
      hh: "%d గంటలు",
      d: "ఒక రోజు",
      dd: "%d రోజులు",
      M: "ఒక నెల",
      MM: "%d నెలలు",
      y: "ఒక సంవత్సరం",
      yy: "%d సంవత్సరాలు"
     },
     dayOfMonthOrdinalParse: /\d{1,2}వ/,
     ordinal: "%dవ",
     meridiemParse: /రాత్రి|ఉదయం|మధ్యాహ్నం|సాయంత్రం/,
     meridiemHour: function(hour, meridiem) {
      return 12 === hour && (hour = 0), "రాత్రి" === meridiem ? hour < 4 ? hour : hour + 12 : "ఉదయం" === meridiem ? hour : "మధ్యాహ్నం" === meridiem ? hour >= 10 ? hour : hour + 12 : "సాయంత్రం" === meridiem ? hour + 12 : void 0;
     },
     meridiem: function(hour, minute, isLower) {
      return hour < 4 ? "రాత్రి" : hour < 10 ? "ఉదయం" : hour < 17 ? "మధ్యాహ్నం" : hour < 20 ? "సాయంత్రం" : "రాత్రి";
     },
     week: {
      dow: 0,
      doy: 6
     }
    });
   }(__webpack_require__(95093));
  },
  28861: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    moment.defineLocale("tet", {
     months: "Janeiru_Fevereiru_Marsu_Abril_Maiu_Juñu_Jullu_Agustu_Setembru_Outubru_Novembru_Dezembru".split("_"),
     monthsShort: "Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez".split("_"),
     weekdays: "Domingu_Segunda_Tersa_Kuarta_Kinta_Sesta_Sabadu".split("_"),
     weekdaysShort: "Dom_Seg_Ters_Kua_Kint_Sest_Sab".split("_"),
     weekdaysMin: "Do_Seg_Te_Ku_Ki_Ses_Sa".split("_"),
     longDateFormat: {
      LT: "HH:mm",
      LTS: "HH:mm:ss",
      L: "DD/MM/YYYY",
      LL: "D MMMM YYYY",
      LLL: "D MMMM YYYY HH:mm",
      LLLL: "dddd, D MMMM YYYY HH:mm"
     },
     calendar: {
      sameDay: "[Ohin iha] LT",
      nextDay: "[Aban iha] LT",
      nextWeek: "dddd [iha] LT",
      lastDay: "[Horiseik iha] LT",
      lastWeek: "dddd [semana kotuk] [iha] LT",
      sameElse: "L"
     },
     relativeTime: {
      future: "iha %s",
      past: "%s liuba",
      s: "segundu balun",
      ss: "segundu %d",
      m: "minutu ida",
      mm: "minutu %d",
      h: "oras ida",
      hh: "oras %d",
      d: "loron ida",
      dd: "loron %d",
      M: "fulan ida",
      MM: "fulan %d",
      y: "tinan ida",
      yy: "tinan %d"
     },
     dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
     ordinal: function(number) {
      var b = number % 10;
      return number + (1 == ~~(number % 100 / 10) ? "th" : 1 === b ? "st" : 2 === b ? "nd" : 3 === b ? "rd" : "th");
     },
     week: {
      dow: 1,
      doy: 4
     }
    });
   }(__webpack_require__(95093));
  },
  86571: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    var suffixes = {
     0: "-ум",
     1: "-ум",
     2: "-юм",
     3: "-юм",
     4: "-ум",
     5: "-ум",
     6: "-ум",
     7: "-ум",
     8: "-ум",
     9: "-ум",
     10: "-ум",
     12: "-ум",
     13: "-ум",
     20: "-ум",
     30: "-юм",
     40: "-ум",
     50: "-ум",
     60: "-ум",
     70: "-ум",
     80: "-ум",
     90: "-ум",
     100: "-ум"
    };
    moment.defineLocale("tg", {
     months: {
      format: "январи_феврали_марти_апрели_майи_июни_июли_августи_сентябри_октябри_ноябри_декабри".split("_"),
      standalone: "январ_феврал_март_апрел_май_июн_июл_август_сентябр_октябр_ноябр_декабр".split("_")
     },
     monthsShort: "янв_фев_мар_апр_май_июн_июл_авг_сен_окт_ноя_дек".split("_"),
     weekdays: "якшанбе_душанбе_сешанбе_чоршанбе_панҷшанбе_ҷумъа_шанбе".split("_"),
     weekdaysShort: "яшб_дшб_сшб_чшб_пшб_ҷум_шнб".split("_"),
     weekdaysMin: "яш_дш_сш_чш_пш_ҷм_шб".split("_"),
     longDateFormat: {
      LT: "HH:mm",
      LTS: "HH:mm:ss",
      L: "DD.MM.YYYY",
      LL: "D MMMM YYYY",
      LLL: "D MMMM YYYY HH:mm",
      LLLL: "dddd, D MMMM YYYY HH:mm"
     },
     calendar: {
      sameDay: "[Имрӯз соати] LT",
      nextDay: "[Фардо соати] LT",
      lastDay: "[Дирӯз соати] LT",
      nextWeek: "dddd[и] [ҳафтаи оянда соати] LT",
      lastWeek: "dddd[и] [ҳафтаи гузашта соати] LT",
      sameElse: "L"
     },
     relativeTime: {
      future: "баъди %s",
      past: "%s пеш",
      s: "якчанд сония",
      m: "як дақиқа",
      mm: "%d дақиқа",
      h: "як соат",
      hh: "%d соат",
      d: "як рӯз",
      dd: "%d рӯз",
      M: "як моҳ",
      MM: "%d моҳ",
      y: "як сол",
      yy: "%d сол"
     },
     meridiemParse: /шаб|субҳ|рӯз|бегоҳ/,
     meridiemHour: function(hour, meridiem) {
      return 12 === hour && (hour = 0), "шаб" === meridiem ? hour < 4 ? hour : hour + 12 : "субҳ" === meridiem ? hour : "рӯз" === meridiem ? hour >= 11 ? hour : hour + 12 : "бегоҳ" === meridiem ? hour + 12 : void 0;
     },
     meridiem: function(hour, minute, isLower) {
      return hour < 4 ? "шаб" : hour < 11 ? "субҳ" : hour < 16 ? "рӯз" : hour < 19 ? "бегоҳ" : "шаб";
     },
     dayOfMonthOrdinalParse: /\d{1,2}-(ум|юм)/,
     ordinal: function(number) {
      var a = number % 10, b = number >= 100 ? 100 : null;
      return number + (suffixes[number] || suffixes[a] || suffixes[b]);
     },
     week: {
      dow: 1,
      doy: 7
     }
    });
   }(__webpack_require__(95093));
  },
  55802: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    moment.defineLocale("th", {
     months: "มกราคม_กุมภาพันธ์_มีนาคม_เมษายน_พฤษภาคม_มิถุนายน_กรกฎาคม_สิงหาคม_กันยายน_ตุลาคม_พฤศจิกายน_ธันวาคม".split("_"),
     monthsShort: "ม.ค._ก.พ._มี.ค._เม.ย._พ.ค._มิ.ย._ก.ค._ส.ค._ก.ย._ต.ค._พ.ย._ธ.ค.".split("_"),
     monthsParseExact: !0,
     weekdays: "อาทิตย์_จันทร์_อังคาร_พุธ_พฤหัสบดี_ศุกร์_เสาร์".split("_"),
     weekdaysShort: "อาทิตย์_จันทร์_อังคาร_พุธ_พฤหัส_ศุกร์_เสาร์".split("_"),
     weekdaysMin: "อา._จ._อ._พ._พฤ._ศ._ส.".split("_"),
     weekdaysParseExact: !0,
     longDateFormat: {
      LT: "H:mm",
      LTS: "H:mm:ss",
      L: "DD/MM/YYYY",
      LL: "D MMMM YYYY",
      LLL: "D MMMM YYYY เวลา H:mm",
      LLLL: "วันddddที่ D MMMM YYYY เวลา H:mm"
     },
     meridiemParse: /ก่อนเที่ยง|หลังเที่ยง/,
     isPM: function(input) {
      return "หลังเที่ยง" === input;
     },
     meridiem: function(hour, minute, isLower) {
      return hour < 12 ? "ก่อนเที่ยง" : "หลังเที่ยง";
     },
     calendar: {
      sameDay: "[วันนี้ เวลา] LT",
      nextDay: "[พรุ่งนี้ เวลา] LT",
      nextWeek: "dddd[หน้า เวลา] LT",
      lastDay: "[เมื่อวานนี้ เวลา] LT",
      lastWeek: "[วัน]dddd[ที่แล้ว เวลา] LT",
      sameElse: "L"
     },
     relativeTime: {
      future: "อีก %s",
      past: "%sที่แล้ว",
      s: "ไม่กี่วินาที",
      ss: "%d วินาที",
      m: "1 นาที",
      mm: "%d นาที",
      h: "1 ชั่วโมง",
      hh: "%d ชั่วโมง",
      d: "1 วัน",
      dd: "%d วัน",
      w: "1 สัปดาห์",
      ww: "%d สัปดาห์",
      M: "1 เดือน",
      MM: "%d เดือน",
      y: "1 ปี",
      yy: "%d ปี"
     }
    });
   }(__webpack_require__(95093));
  },
  59527: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    var suffixes = {
     1: "'inji",
     5: "'inji",
     8: "'inji",
     70: "'inji",
     80: "'inji",
     2: "'nji",
     7: "'nji",
     20: "'nji",
     50: "'nji",
     3: "'ünji",
     4: "'ünji",
     100: "'ünji",
     6: "'njy",
     9: "'unjy",
     10: "'unjy",
     30: "'unjy",
     60: "'ynjy",
     90: "'ynjy"
    };
    moment.defineLocale("tk", {
     months: "Ýanwar_Fewral_Mart_Aprel_Maý_Iýun_Iýul_Awgust_Sentýabr_Oktýabr_Noýabr_Dekabr".split("_"),
     monthsShort: "Ýan_Few_Mar_Apr_Maý_Iýn_Iýl_Awg_Sen_Okt_Noý_Dek".split("_"),
     weekdays: "Ýekşenbe_Duşenbe_Sişenbe_Çarşenbe_Penşenbe_Anna_Şenbe".split("_"),
     weekdaysShort: "Ýek_Duş_Siş_Çar_Pen_Ann_Şen".split("_"),
     weekdaysMin: "Ýk_Dş_Sş_Çr_Pn_An_Şn".split("_"),
     longDateFormat: {
      LT: "HH:mm",
      LTS: "HH:mm:ss",
      L: "DD.MM.YYYY",
      LL: "D MMMM YYYY",
      LLL: "D MMMM YYYY HH:mm",
      LLLL: "dddd, D MMMM YYYY HH:mm"
     },
     calendar: {
      sameDay: "[bugün sagat] LT",
      nextDay: "[ertir sagat] LT",
      nextWeek: "[indiki] dddd [sagat] LT",
      lastDay: "[düýn] LT",
      lastWeek: "[geçen] dddd [sagat] LT",
      sameElse: "L"
     },
     relativeTime: {
      future: "%s soň",
      past: "%s öň",
      s: "birnäçe sekunt",
      m: "bir minut",
      mm: "%d minut",
      h: "bir sagat",
      hh: "%d sagat",
      d: "bir gün",
      dd: "%d gün",
      M: "bir aý",
      MM: "%d aý",
      y: "bir ýyl",
      yy: "%d ýyl"
     },
     ordinal: function(number, period) {
      switch (period) {
      case "d":
      case "D":
      case "Do":
      case "DD":
       return number;

      default:
       if (0 === number) return number + "'unjy";
       var a = number % 10, b = number % 100 - a, c = number >= 100 ? 100 : null;
       return number + (suffixes[a] || suffixes[b] || suffixes[c]);
      }
     },
     week: {
      dow: 1,
      doy: 7
     }
    });
   }(__webpack_require__(95093));
  },
  29231: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    moment.defineLocale("tl-ph", {
     months: "Enero_Pebrero_Marso_Abril_Mayo_Hunyo_Hulyo_Agosto_Setyembre_Oktubre_Nobyembre_Disyembre".split("_"),
     monthsShort: "Ene_Peb_Mar_Abr_May_Hun_Hul_Ago_Set_Okt_Nob_Dis".split("_"),
     weekdays: "Linggo_Lunes_Martes_Miyerkules_Huwebes_Biyernes_Sabado".split("_"),
     weekdaysShort: "Lin_Lun_Mar_Miy_Huw_Biy_Sab".split("_"),
     weekdaysMin: "Li_Lu_Ma_Mi_Hu_Bi_Sab".split("_"),
     longDateFormat: {
      LT: "HH:mm",
      LTS: "HH:mm:ss",
      L: "MM/D/YYYY",
      LL: "MMMM D, YYYY",
      LLL: "MMMM D, YYYY HH:mm",
      LLLL: "dddd, MMMM DD, YYYY HH:mm"
     },
     calendar: {
      sameDay: "LT [ngayong araw]",
      nextDay: "[Bukas ng] LT",
      nextWeek: "LT [sa susunod na] dddd",
      lastDay: "LT [kahapon]",
      lastWeek: "LT [noong nakaraang] dddd",
      sameElse: "L"
     },
     relativeTime: {
      future: "sa loob ng %s",
      past: "%s ang nakalipas",
      s: "ilang segundo",
      ss: "%d segundo",
      m: "isang minuto",
      mm: "%d minuto",
      h: "isang oras",
      hh: "%d oras",
      d: "isang araw",
      dd: "%d araw",
      M: "isang buwan",
      MM: "%d buwan",
      y: "isang taon",
      yy: "%d taon"
     },
     dayOfMonthOrdinalParse: /\d{1,2}/,
     ordinal: function(number) {
      return number;
     },
     week: {
      dow: 1,
      doy: 4
     }
    });
   }(__webpack_require__(95093));
  },
  31052: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    var numbersNouns = "pagh_wa’_cha’_wej_loS_vagh_jav_Soch_chorgh_Hut".split("_");
    function translateFuture(output) {
     var time = output;
     return time = -1 !== output.indexOf("jaj") ? time.slice(0, -3) + "leS" : -1 !== output.indexOf("jar") ? time.slice(0, -3) + "waQ" : -1 !== output.indexOf("DIS") ? time.slice(0, -3) + "nem" : time + " pIq";
    }
    function translatePast(output) {
     var time = output;
     return time = -1 !== output.indexOf("jaj") ? time.slice(0, -3) + "Hu’" : -1 !== output.indexOf("jar") ? time.slice(0, -3) + "wen" : -1 !== output.indexOf("DIS") ? time.slice(0, -3) + "ben" : time + " ret";
    }
    function translate(number, withoutSuffix, string, isFuture) {
     var numberNoun = numberAsNoun(number);
     switch (string) {
     case "ss":
      return numberNoun + " lup";

     case "mm":
      return numberNoun + " tup";

     case "hh":
      return numberNoun + " rep";

     case "dd":
      return numberNoun + " jaj";

     case "MM":
      return numberNoun + " jar";

     case "yy":
      return numberNoun + " DIS";
     }
    }
    function numberAsNoun(number) {
     var hundred = Math.floor(number % 1e3 / 100), ten = Math.floor(number % 100 / 10), one = number % 10, word = "";
     return hundred > 0 && (word += numbersNouns[hundred] + "vatlh"), ten > 0 && (word += ("" !== word ? " " : "") + numbersNouns[ten] + "maH"), 
     one > 0 && (word += ("" !== word ? " " : "") + numbersNouns[one]), "" === word ? "pagh" : word;
    }
    moment.defineLocale("tlh", {
     months: "tera’ jar wa’_tera’ jar cha’_tera’ jar wej_tera’ jar loS_tera’ jar vagh_tera’ jar jav_tera’ jar Soch_tera’ jar chorgh_tera’ jar Hut_tera’ jar wa’maH_tera’ jar wa’maH wa’_tera’ jar wa’maH cha’".split("_"),
     monthsShort: "jar wa’_jar cha’_jar wej_jar loS_jar vagh_jar jav_jar Soch_jar chorgh_jar Hut_jar wa’maH_jar wa’maH wa’_jar wa’maH cha’".split("_"),
     monthsParseExact: !0,
     weekdays: "lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj".split("_"),
     weekdaysShort: "lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj".split("_"),
     weekdaysMin: "lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj".split("_"),
     longDateFormat: {
      LT: "HH:mm",
      LTS: "HH:mm:ss",
      L: "DD.MM.YYYY",
      LL: "D MMMM YYYY",
      LLL: "D MMMM YYYY HH:mm",
      LLLL: "dddd, D MMMM YYYY HH:mm"
     },
     calendar: {
      sameDay: "[DaHjaj] LT",
      nextDay: "[wa’leS] LT",
      nextWeek: "LLL",
      lastDay: "[wa’Hu’] LT",
      lastWeek: "LLL",
      sameElse: "L"
     },
     relativeTime: {
      future: translateFuture,
      past: translatePast,
      s: "puS lup",
      ss: translate,
      m: "wa’ tup",
      mm: translate,
      h: "wa’ rep",
      hh: translate,
      d: "wa’ jaj",
      dd: translate,
      M: "wa’ jar",
      MM: translate,
      y: "wa’ DIS",
      yy: translate
     },
     dayOfMonthOrdinalParse: /\d{1,2}\./,
     ordinal: "%d.",
     week: {
      dow: 1,
      doy: 4
     }
    });
   }(__webpack_require__(95093));
  },
  85096: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    var suffixes = {
     1: "'inci",
     5: "'inci",
     8: "'inci",
     70: "'inci",
     80: "'inci",
     2: "'nci",
     7: "'nci",
     20: "'nci",
     50: "'nci",
     3: "'üncü",
     4: "'üncü",
     100: "'üncü",
     6: "'ncı",
     9: "'uncu",
     10: "'uncu",
     30: "'uncu",
     60: "'ıncı",
     90: "'ıncı"
    };
    moment.defineLocale("tr", {
     months: "Ocak_Şubat_Mart_Nisan_Mayıs_Haziran_Temmuz_Ağustos_Eylül_Ekim_Kasım_Aralık".split("_"),
     monthsShort: "Oca_Şub_Mar_Nis_May_Haz_Tem_Ağu_Eyl_Eki_Kas_Ara".split("_"),
     weekdays: "Pazar_Pazartesi_Salı_Çarşamba_Perşembe_Cuma_Cumartesi".split("_"),
     weekdaysShort: "Paz_Pzt_Sal_Çar_Per_Cum_Cmt".split("_"),
     weekdaysMin: "Pz_Pt_Sa_Ça_Pe_Cu_Ct".split("_"),
     meridiem: function(hours, minutes, isLower) {
      return hours < 12 ? isLower ? "öö" : "ÖÖ" : isLower ? "ös" : "ÖS";
     },
     meridiemParse: /öö|ÖÖ|ös|ÖS/,
     isPM: function(input) {
      return "ös" === input || "ÖS" === input;
     },
     longDateFormat: {
      LT: "HH:mm",
      LTS: "HH:mm:ss",
      L: "DD.MM.YYYY",
      LL: "D MMMM YYYY",
      LLL: "D MMMM YYYY HH:mm",
      LLLL: "dddd, D MMMM YYYY HH:mm"
     },
     calendar: {
      sameDay: "[bugün saat] LT",
      nextDay: "[yarın saat] LT",
      nextWeek: "[gelecek] dddd [saat] LT",
      lastDay: "[dün] LT",
      lastWeek: "[geçen] dddd [saat] LT",
      sameElse: "L"
     },
     relativeTime: {
      future: "%s sonra",
      past: "%s önce",
      s: "birkaç saniye",
      ss: "%d saniye",
      m: "bir dakika",
      mm: "%d dakika",
      h: "bir saat",
      hh: "%d saat",
      d: "bir gün",
      dd: "%d gün",
      w: "bir hafta",
      ww: "%d hafta",
      M: "bir ay",
      MM: "%d ay",
      y: "bir yıl",
      yy: "%d yıl"
     },
     ordinal: function(number, period) {
      switch (period) {
      case "d":
      case "D":
      case "Do":
      case "DD":
       return number;

      default:
       if (0 === number) return number + "'ıncı";
       var a = number % 10, b = number % 100 - a, c = number >= 100 ? 100 : null;
       return number + (suffixes[a] || suffixes[b] || suffixes[c]);
      }
     },
     week: {
      dow: 1,
      doy: 7
     }
    });
   }(__webpack_require__(95093));
  },
  79846: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    function processRelativeTime(number, withoutSuffix, key, isFuture) {
     var format = {
      s: [ "viensas secunds", "'iensas secunds" ],
      ss: [ number + " secunds", number + " secunds" ],
      m: [ "'n míut", "'iens míut" ],
      mm: [ number + " míuts", number + " míuts" ],
      h: [ "'n þora", "'iensa þora" ],
      hh: [ number + " þoras", number + " þoras" ],
      d: [ "'n ziua", "'iensa ziua" ],
      dd: [ number + " ziuas", number + " ziuas" ],
      M: [ "'n mes", "'iens mes" ],
      MM: [ number + " mesen", number + " mesen" ],
      y: [ "'n ar", "'iens ar" ],
      yy: [ number + " ars", number + " ars" ]
     };
     return isFuture || withoutSuffix ? format[key][0] : format[key][1];
    }
    moment.defineLocale("tzl", {
     months: "Januar_Fevraglh_Març_Avrïu_Mai_Gün_Julia_Guscht_Setemvar_Listopäts_Noemvar_Zecemvar".split("_"),
     monthsShort: "Jan_Fev_Mar_Avr_Mai_Gün_Jul_Gus_Set_Lis_Noe_Zec".split("_"),
     weekdays: "Súladi_Lúneçi_Maitzi_Márcuri_Xhúadi_Viénerçi_Sáturi".split("_"),
     weekdaysShort: "Súl_Lún_Mai_Már_Xhú_Vié_Sát".split("_"),
     weekdaysMin: "Sú_Lú_Ma_Má_Xh_Vi_Sá".split("_"),
     longDateFormat: {
      LT: "HH.mm",
      LTS: "HH.mm.ss",
      L: "DD.MM.YYYY",
      LL: "D. MMMM [dallas] YYYY",
      LLL: "D. MMMM [dallas] YYYY HH.mm",
      LLLL: "dddd, [li] D. MMMM [dallas] YYYY HH.mm"
     },
     meridiemParse: /d\'o|d\'a/i,
     isPM: function(input) {
      return "d'o" === input.toLowerCase();
     },
     meridiem: function(hours, minutes, isLower) {
      return hours > 11 ? isLower ? "d'o" : "D'O" : isLower ? "d'a" : "D'A";
     },
     calendar: {
      sameDay: "[oxhi à] LT",
      nextDay: "[demà à] LT",
      nextWeek: "dddd [à] LT",
      lastDay: "[ieiri à] LT",
      lastWeek: "[sür el] dddd [lasteu à] LT",
      sameElse: "L"
     },
     relativeTime: {
      future: "osprei %s",
      past: "ja%s",
      s: processRelativeTime,
      ss: processRelativeTime,
      m: processRelativeTime,
      mm: processRelativeTime,
      h: processRelativeTime,
      hh: processRelativeTime,
      d: processRelativeTime,
      dd: processRelativeTime,
      M: processRelativeTime,
      MM: processRelativeTime,
      y: processRelativeTime,
      yy: processRelativeTime
     },
     dayOfMonthOrdinalParse: /\d{1,2}\./,
     ordinal: "%d.",
     week: {
      dow: 1,
      doy: 4
     }
    });
   }(__webpack_require__(95093));
  },
  97711: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    moment.defineLocale("tzm-latn", {
     months: "innayr_brˤayrˤ_marˤsˤ_ibrir_mayyw_ywnyw_ywlywz_ɣwšt_šwtanbir_ktˤwbrˤ_nwwanbir_dwjnbir".split("_"),
     monthsShort: "innayr_brˤayrˤ_marˤsˤ_ibrir_mayyw_ywnyw_ywlywz_ɣwšt_šwtanbir_ktˤwbrˤ_nwwanbir_dwjnbir".split("_"),
     weekdays: "asamas_aynas_asinas_akras_akwas_asimwas_asiḍyas".split("_"),
     weekdaysShort: "asamas_aynas_asinas_akras_akwas_asimwas_asiḍyas".split("_"),
     weekdaysMin: "asamas_aynas_asinas_akras_akwas_asimwas_asiḍyas".split("_"),
     longDateFormat: {
      LT: "HH:mm",
      LTS: "HH:mm:ss",
      L: "DD/MM/YYYY",
      LL: "D MMMM YYYY",
      LLL: "D MMMM YYYY HH:mm",
      LLLL: "dddd D MMMM YYYY HH:mm"
     },
     calendar: {
      sameDay: "[asdkh g] LT",
      nextDay: "[aska g] LT",
      nextWeek: "dddd [g] LT",
      lastDay: "[assant g] LT",
      lastWeek: "dddd [g] LT",
      sameElse: "L"
     },
     relativeTime: {
      future: "dadkh s yan %s",
      past: "yan %s",
      s: "imik",
      ss: "%d imik",
      m: "minuḍ",
      mm: "%d minuḍ",
      h: "saɛa",
      hh: "%d tassaɛin",
      d: "ass",
      dd: "%d ossan",
      M: "ayowr",
      MM: "%d iyyirn",
      y: "asgas",
      yy: "%d isgasn"
     },
     week: {
      dow: 6,
      doy: 12
     }
    });
   }(__webpack_require__(95093));
  },
  81765: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    moment.defineLocale("tzm", {
     months: "ⵉⵏⵏⴰⵢⵔ_ⴱⵕⴰⵢⵕ_ⵎⴰⵕⵚ_ⵉⴱⵔⵉⵔ_ⵎⴰⵢⵢⵓ_ⵢⵓⵏⵢⵓ_ⵢⵓⵍⵢⵓⵣ_ⵖⵓⵛⵜ_ⵛⵓⵜⴰⵏⴱⵉⵔ_ⴽⵟⵓⴱⵕ_ⵏⵓⵡⴰⵏⴱⵉⵔ_ⴷⵓⵊⵏⴱⵉⵔ".split("_"),
     monthsShort: "ⵉⵏⵏⴰⵢⵔ_ⴱⵕⴰⵢⵕ_ⵎⴰⵕⵚ_ⵉⴱⵔⵉⵔ_ⵎⴰⵢⵢⵓ_ⵢⵓⵏⵢⵓ_ⵢⵓⵍⵢⵓⵣ_ⵖⵓⵛⵜ_ⵛⵓⵜⴰⵏⴱⵉⵔ_ⴽⵟⵓⴱⵕ_ⵏⵓⵡⴰⵏⴱⵉⵔ_ⴷⵓⵊⵏⴱⵉⵔ".split("_"),
     weekdays: "ⴰⵙⴰⵎⴰⵙ_ⴰⵢⵏⴰⵙ_ⴰⵙⵉⵏⴰⵙ_ⴰⴽⵔⴰⵙ_ⴰⴽⵡⴰⵙ_ⴰⵙⵉⵎⵡⴰⵙ_ⴰⵙⵉⴹⵢⴰⵙ".split("_"),
     weekdaysShort: "ⴰⵙⴰⵎⴰⵙ_ⴰⵢⵏⴰⵙ_ⴰⵙⵉⵏⴰⵙ_ⴰⴽⵔⴰⵙ_ⴰⴽⵡⴰⵙ_ⴰⵙⵉⵎⵡⴰⵙ_ⴰⵙⵉⴹⵢⴰⵙ".split("_"),
     weekdaysMin: "ⴰⵙⴰⵎⴰⵙ_ⴰⵢⵏⴰⵙ_ⴰⵙⵉⵏⴰⵙ_ⴰⴽⵔⴰⵙ_ⴰⴽⵡⴰⵙ_ⴰⵙⵉⵎⵡⴰⵙ_ⴰⵙⵉⴹⵢⴰⵙ".split("_"),
     longDateFormat: {
      LT: "HH:mm",
      LTS: "HH:mm:ss",
      L: "DD/MM/YYYY",
      LL: "D MMMM YYYY",
      LLL: "D MMMM YYYY HH:mm",
      LLLL: "dddd D MMMM YYYY HH:mm"
     },
     calendar: {
      sameDay: "[ⴰⵙⴷⵅ ⴴ] LT",
      nextDay: "[ⴰⵙⴽⴰ ⴴ] LT",
      nextWeek: "dddd [ⴴ] LT",
      lastDay: "[ⴰⵚⴰⵏⵜ ⴴ] LT",
      lastWeek: "dddd [ⴴ] LT",
      sameElse: "L"
     },
     relativeTime: {
      future: "ⴷⴰⴷⵅ ⵙ ⵢⴰⵏ %s",
      past: "ⵢⴰⵏ %s",
      s: "ⵉⵎⵉⴽ",
      ss: "%d ⵉⵎⵉⴽ",
      m: "ⵎⵉⵏⵓⴺ",
      mm: "%d ⵎⵉⵏⵓⴺ",
      h: "ⵙⴰⵄⴰ",
      hh: "%d ⵜⴰⵙⵙⴰⵄⵉⵏ",
      d: "ⴰⵙⵙ",
      dd: "%d oⵙⵙⴰⵏ",
      M: "ⴰⵢoⵓⵔ",
      MM: "%d ⵉⵢⵢⵉⵔⵏ",
      y: "ⴰⵙⴳⴰⵙ",
      yy: "%d ⵉⵙⴳⴰⵙⵏ"
     },
     week: {
      dow: 6,
      doy: 12
     }
    });
   }(__webpack_require__(95093));
  },
  48414: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    moment.defineLocale("ug-cn", {
     months: "يانۋار_فېۋرال_مارت_ئاپرېل_ماي_ئىيۇن_ئىيۇل_ئاۋغۇست_سېنتەبىر_ئۆكتەبىر_نويابىر_دېكابىر".split("_"),
     monthsShort: "يانۋار_فېۋرال_مارت_ئاپرېل_ماي_ئىيۇن_ئىيۇل_ئاۋغۇست_سېنتەبىر_ئۆكتەبىر_نويابىر_دېكابىر".split("_"),
     weekdays: "يەكشەنبە_دۈشەنبە_سەيشەنبە_چارشەنبە_پەيشەنبە_جۈمە_شەنبە".split("_"),
     weekdaysShort: "يە_دۈ_سە_چا_پە_جۈ_شە".split("_"),
     weekdaysMin: "يە_دۈ_سە_چا_پە_جۈ_شە".split("_"),
     longDateFormat: {
      LT: "HH:mm",
      LTS: "HH:mm:ss",
      L: "YYYY-MM-DD",
      LL: "YYYY-يىلىM-ئاينىڭD-كۈنى",
      LLL: "YYYY-يىلىM-ئاينىڭD-كۈنى، HH:mm",
      LLLL: "dddd، YYYY-يىلىM-ئاينىڭD-كۈنى، HH:mm"
     },
     meridiemParse: /يېرىم كېچە|سەھەر|چۈشتىن بۇرۇن|چۈش|چۈشتىن كېيىن|كەچ/,
     meridiemHour: function(hour, meridiem) {
      return 12 === hour && (hour = 0), "يېرىم كېچە" === meridiem || "سەھەر" === meridiem || "چۈشتىن بۇرۇن" === meridiem ? hour : "چۈشتىن كېيىن" === meridiem || "كەچ" === meridiem ? hour + 12 : hour >= 11 ? hour : hour + 12;
     },
     meridiem: function(hour, minute, isLower) {
      var hm = 100 * hour + minute;
      return hm < 600 ? "يېرىم كېچە" : hm < 900 ? "سەھەر" : hm < 1130 ? "چۈشتىن بۇرۇن" : hm < 1230 ? "چۈش" : hm < 1800 ? "چۈشتىن كېيىن" : "كەچ";
     },
     calendar: {
      sameDay: "[بۈگۈن سائەت] LT",
      nextDay: "[ئەتە سائەت] LT",
      nextWeek: "[كېلەركى] dddd [سائەت] LT",
      lastDay: "[تۆنۈگۈن] LT",
      lastWeek: "[ئالدىنقى] dddd [سائەت] LT",
      sameElse: "L"
     },
     relativeTime: {
      future: "%s كېيىن",
      past: "%s بۇرۇن",
      s: "نەچچە سېكونت",
      ss: "%d سېكونت",
      m: "بىر مىنۇت",
      mm: "%d مىنۇت",
      h: "بىر سائەت",
      hh: "%d سائەت",
      d: "بىر كۈن",
      dd: "%d كۈن",
      M: "بىر ئاي",
      MM: "%d ئاي",
      y: "بىر يىل",
      yy: "%d يىل"
     },
     dayOfMonthOrdinalParse: /\d{1,2}(-كۈنى|-ئاي|-ھەپتە)/,
     ordinal: function(number, period) {
      switch (period) {
      case "d":
      case "D":
      case "DDD":
       return number + "-كۈنى";

      case "w":
      case "W":
       return number + "-ھەپتە";

      default:
       return number;
      }
     },
     preparse: function(string) {
      return string.replace(/،/g, ",");
     },
     postformat: function(string) {
      return string.replace(/,/g, "،");
     },
     week: {
      dow: 1,
      doy: 7
     }
    });
   }(__webpack_require__(95093));
  },
  16618: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    function plural(word, num) {
     var forms = word.split("_");
     return num % 10 == 1 && num % 100 != 11 ? forms[0] : num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2];
    }
    function relativeTimeWithPlural(number, withoutSuffix, key) {
     return "m" === key ? withoutSuffix ? "хвилина" : "хвилину" : "h" === key ? withoutSuffix ? "година" : "годину" : number + " " + plural({
      ss: withoutSuffix ? "секунда_секунди_секунд" : "секунду_секунди_секунд",
      mm: withoutSuffix ? "хвилина_хвилини_хвилин" : "хвилину_хвилини_хвилин",
      hh: withoutSuffix ? "година_години_годин" : "годину_години_годин",
      dd: "день_дні_днів",
      MM: "місяць_місяці_місяців",
      yy: "рік_роки_років"
     }[key], +number);
    }
    function weekdaysCaseReplace(m, format) {
     var weekdays = {
      nominative: "неділя_понеділок_вівторок_середа_четвер_п’ятниця_субота".split("_"),
      accusative: "неділю_понеділок_вівторок_середу_четвер_п’ятницю_суботу".split("_"),
      genitive: "неділі_понеділка_вівторка_середи_четверга_п’ятниці_суботи".split("_")
     };
     return !0 === m ? weekdays.nominative.slice(1, 7).concat(weekdays.nominative.slice(0, 1)) : m ? weekdays[/(\[[ВвУу]\]) ?dddd/.test(format) ? "accusative" : /\[?(?:минулої|наступної)? ?\] ?dddd/.test(format) ? "genitive" : "nominative"][m.day()] : weekdays.nominative;
    }
    function processHoursFunction(str) {
     return function() {
      return str + "о" + (11 === this.hours() ? "б" : "") + "] LT";
     };
    }
    moment.defineLocale("uk", {
     months: {
      format: "січня_лютого_березня_квітня_травня_червня_липня_серпня_вересня_жовтня_листопада_грудня".split("_"),
      standalone: "січень_лютий_березень_квітень_травень_червень_липень_серпень_вересень_жовтень_листопад_грудень".split("_")
     },
     monthsShort: "січ_лют_бер_квіт_трав_черв_лип_серп_вер_жовт_лист_груд".split("_"),
     weekdays: weekdaysCaseReplace,
     weekdaysShort: "нд_пн_вт_ср_чт_пт_сб".split("_"),
     weekdaysMin: "нд_пн_вт_ср_чт_пт_сб".split("_"),
     longDateFormat: {
      LT: "HH:mm",
      LTS: "HH:mm:ss",
      L: "DD.MM.YYYY",
      LL: "D MMMM YYYY р.",
      LLL: "D MMMM YYYY р., HH:mm",
      LLLL: "dddd, D MMMM YYYY р., HH:mm"
     },
     calendar: {
      sameDay: processHoursFunction("[Сьогодні "),
      nextDay: processHoursFunction("[Завтра "),
      lastDay: processHoursFunction("[Вчора "),
      nextWeek: processHoursFunction("[У] dddd ["),
      lastWeek: function() {
       switch (this.day()) {
       case 0:
       case 3:
       case 5:
       case 6:
        return processHoursFunction("[Минулої] dddd [").call(this);

       case 1:
       case 2:
       case 4:
        return processHoursFunction("[Минулого] dddd [").call(this);
       }
      },
      sameElse: "L"
     },
     relativeTime: {
      future: "за %s",
      past: "%s тому",
      s: "декілька секунд",
      ss: relativeTimeWithPlural,
      m: relativeTimeWithPlural,
      mm: relativeTimeWithPlural,
      h: "годину",
      hh: relativeTimeWithPlural,
      d: "день",
      dd: relativeTimeWithPlural,
      M: "місяць",
      MM: relativeTimeWithPlural,
      y: "рік",
      yy: relativeTimeWithPlural
     },
     meridiemParse: /ночі|ранку|дня|вечора/,
     isPM: function(input) {
      return /^(дня|вечора)$/.test(input);
     },
     meridiem: function(hour, minute, isLower) {
      return hour < 4 ? "ночі" : hour < 12 ? "ранку" : hour < 17 ? "дня" : "вечора";
     },
     dayOfMonthOrdinalParse: /\d{1,2}-(й|го)/,
     ordinal: function(number, period) {
      switch (period) {
      case "M":
      case "d":
      case "DDD":
      case "w":
      case "W":
       return number + "-й";

      case "D":
       return number + "-го";

      default:
       return number;
      }
     },
     week: {
      dow: 1,
      doy: 7
     }
    });
   }(__webpack_require__(95093));
  },
  57777: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    var months = [ "جنوری", "فروری", "مارچ", "اپریل", "مئی", "جون", "جولائی", "اگست", "ستمبر", "اکتوبر", "نومبر", "دسمبر" ], days = [ "اتوار", "پیر", "منگل", "بدھ", "جمعرات", "جمعہ", "ہفتہ" ];
    moment.defineLocale("ur", {
     months,
     monthsShort: months,
     weekdays: days,
     weekdaysShort: days,
     weekdaysMin: days,
     longDateFormat: {
      LT: "HH:mm",
      LTS: "HH:mm:ss",
      L: "DD/MM/YYYY",
      LL: "D MMMM YYYY",
      LLL: "D MMMM YYYY HH:mm",
      LLLL: "dddd، D MMMM YYYY HH:mm"
     },
     meridiemParse: /صبح|شام/,
     isPM: function(input) {
      return "شام" === input;
     },
     meridiem: function(hour, minute, isLower) {
      return hour < 12 ? "صبح" : "شام";
     },
     calendar: {
      sameDay: "[آج بوقت] LT",
      nextDay: "[کل بوقت] LT",
      nextWeek: "dddd [بوقت] LT",
      lastDay: "[گذشتہ روز بوقت] LT",
      lastWeek: "[گذشتہ] dddd [بوقت] LT",
      sameElse: "L"
     },
     relativeTime: {
      future: "%s بعد",
      past: "%s قبل",
      s: "چند سیکنڈ",
      ss: "%d سیکنڈ",
      m: "ایک منٹ",
      mm: "%d منٹ",
      h: "ایک گھنٹہ",
      hh: "%d گھنٹے",
      d: "ایک دن",
      dd: "%d دن",
      M: "ایک ماہ",
      MM: "%d ماہ",
      y: "ایک سال",
      yy: "%d سال"
     },
     preparse: function(string) {
      return string.replace(/،/g, ",");
     },
     postformat: function(string) {
      return string.replace(/,/g, "،");
     },
     week: {
      dow: 1,
      doy: 4
     }
    });
   }(__webpack_require__(95093));
  },
  72475: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    moment.defineLocale("uz-latn", {
     months: "Yanvar_Fevral_Mart_Aprel_May_Iyun_Iyul_Avgust_Sentabr_Oktabr_Noyabr_Dekabr".split("_"),
     monthsShort: "Yan_Fev_Mar_Apr_May_Iyun_Iyul_Avg_Sen_Okt_Noy_Dek".split("_"),
     weekdays: "Yakshanba_Dushanba_Seshanba_Chorshanba_Payshanba_Juma_Shanba".split("_"),
     weekdaysShort: "Yak_Dush_Sesh_Chor_Pay_Jum_Shan".split("_"),
     weekdaysMin: "Ya_Du_Se_Cho_Pa_Ju_Sha".split("_"),
     longDateFormat: {
      LT: "HH:mm",
      LTS: "HH:mm:ss",
      L: "DD/MM/YYYY",
      LL: "D MMMM YYYY",
      LLL: "D MMMM YYYY HH:mm",
      LLLL: "D MMMM YYYY, dddd HH:mm"
     },
     calendar: {
      sameDay: "[Bugun soat] LT [da]",
      nextDay: "[Ertaga] LT [da]",
      nextWeek: "dddd [kuni soat] LT [da]",
      lastDay: "[Kecha soat] LT [da]",
      lastWeek: "[O'tgan] dddd [kuni soat] LT [da]",
      sameElse: "L"
     },
     relativeTime: {
      future: "Yaqin %s ichida",
      past: "Bir necha %s oldin",
      s: "soniya",
      ss: "%d soniya",
      m: "bir daqiqa",
      mm: "%d daqiqa",
      h: "bir soat",
      hh: "%d soat",
      d: "bir kun",
      dd: "%d kun",
      M: "bir oy",
      MM: "%d oy",
      y: "bir yil",
      yy: "%d yil"
     },
     week: {
      dow: 1,
      doy: 7
     }
    });
   }(__webpack_require__(95093));
  },
  57609: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    moment.defineLocale("uz", {
     months: "январ_феврал_март_апрел_май_июн_июл_август_сентябр_октябр_ноябр_декабр".split("_"),
     monthsShort: "янв_фев_мар_апр_май_июн_июл_авг_сен_окт_ноя_дек".split("_"),
     weekdays: "Якшанба_Душанба_Сешанба_Чоршанба_Пайшанба_Жума_Шанба".split("_"),
     weekdaysShort: "Якш_Душ_Сеш_Чор_Пай_Жум_Шан".split("_"),
     weekdaysMin: "Як_Ду_Се_Чо_Па_Жу_Ша".split("_"),
     longDateFormat: {
      LT: "HH:mm",
      LTS: "HH:mm:ss",
      L: "DD/MM/YYYY",
      LL: "D MMMM YYYY",
      LLL: "D MMMM YYYY HH:mm",
      LLLL: "D MMMM YYYY, dddd HH:mm"
     },
     calendar: {
      sameDay: "[Бугун соат] LT [да]",
      nextDay: "[Эртага] LT [да]",
      nextWeek: "dddd [куни соат] LT [да]",
      lastDay: "[Кеча соат] LT [да]",
      lastWeek: "[Утган] dddd [куни соат] LT [да]",
      sameElse: "L"
     },
     relativeTime: {
      future: "Якин %s ичида",
      past: "Бир неча %s олдин",
      s: "фурсат",
      ss: "%d фурсат",
      m: "бир дакика",
      mm: "%d дакика",
      h: "бир соат",
      hh: "%d соат",
      d: "бир кун",
      dd: "%d кун",
      M: "бир ой",
      MM: "%d ой",
      y: "бир йил",
      yy: "%d йил"
     },
     week: {
      dow: 1,
      doy: 7
     }
    });
   }(__webpack_require__(95093));
  },
  21135: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    moment.defineLocale("vi", {
     months: "tháng 1_tháng 2_tháng 3_tháng 4_tháng 5_tháng 6_tháng 7_tháng 8_tháng 9_tháng 10_tháng 11_tháng 12".split("_"),
     monthsShort: "Thg 01_Thg 02_Thg 03_Thg 04_Thg 05_Thg 06_Thg 07_Thg 08_Thg 09_Thg 10_Thg 11_Thg 12".split("_"),
     monthsParseExact: !0,
     weekdays: "chủ nhật_thứ hai_thứ ba_thứ tư_thứ năm_thứ sáu_thứ bảy".split("_"),
     weekdaysShort: "CN_T2_T3_T4_T5_T6_T7".split("_"),
     weekdaysMin: "CN_T2_T3_T4_T5_T6_T7".split("_"),
     weekdaysParseExact: !0,
     meridiemParse: /sa|ch/i,
     isPM: function(input) {
      return /^ch$/i.test(input);
     },
     meridiem: function(hours, minutes, isLower) {
      return hours < 12 ? isLower ? "sa" : "SA" : isLower ? "ch" : "CH";
     },
     longDateFormat: {
      LT: "HH:mm",
      LTS: "HH:mm:ss",
      L: "DD/MM/YYYY",
      LL: "D MMMM [năm] YYYY",
      LLL: "D MMMM [năm] YYYY HH:mm",
      LLLL: "dddd, D MMMM [năm] YYYY HH:mm",
      l: "DD/M/YYYY",
      ll: "D MMM YYYY",
      lll: "D MMM YYYY HH:mm",
      llll: "ddd, D MMM YYYY HH:mm"
     },
     calendar: {
      sameDay: "[Hôm nay lúc] LT",
      nextDay: "[Ngày mai lúc] LT",
      nextWeek: "dddd [tuần tới lúc] LT",
      lastDay: "[Hôm qua lúc] LT",
      lastWeek: "dddd [tuần trước lúc] LT",
      sameElse: "L"
     },
     relativeTime: {
      future: "%s tới",
      past: "%s trước",
      s: "vài giây",
      ss: "%d giây",
      m: "một phút",
      mm: "%d phút",
      h: "một giờ",
      hh: "%d giờ",
      d: "một ngày",
      dd: "%d ngày",
      w: "một tuần",
      ww: "%d tuần",
      M: "một tháng",
      MM: "%d tháng",
      y: "một năm",
      yy: "%d năm"
     },
     dayOfMonthOrdinalParse: /\d{1,2}/,
     ordinal: function(number) {
      return number;
     },
     week: {
      dow: 1,
      doy: 4
     }
    });
   }(__webpack_require__(95093));
  },
  64051: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    moment.defineLocale("x-pseudo", {
     months: "J~áñúá~rý_F~ébrú~árý_~Márc~h_Áp~ríl_~Máý_~Júñé~_Júl~ý_Áú~gúst~_Sép~témb~ér_Ó~ctób~ér_Ñ~óvém~bér_~Décé~mbér".split("_"),
     monthsShort: "J~áñ_~Féb_~Már_~Ápr_~Máý_~Júñ_~Júl_~Áúg_~Sép_~Óct_~Ñóv_~Déc".split("_"),
     monthsParseExact: !0,
     weekdays: "S~úñdá~ý_Mó~ñdáý~_Túé~sdáý~_Wéd~ñésd~áý_T~húrs~dáý_~Fríd~áý_S~átúr~dáý".split("_"),
     weekdaysShort: "S~úñ_~Móñ_~Túé_~Wéd_~Thú_~Frí_~Sát".split("_"),
     weekdaysMin: "S~ú_Mó~_Tú_~Wé_T~h_Fr~_Sá".split("_"),
     weekdaysParseExact: !0,
     longDateFormat: {
      LT: "HH:mm",
      L: "DD/MM/YYYY",
      LL: "D MMMM YYYY",
      LLL: "D MMMM YYYY HH:mm",
      LLLL: "dddd, D MMMM YYYY HH:mm"
     },
     calendar: {
      sameDay: "[T~ódá~ý át] LT",
      nextDay: "[T~ómó~rró~w át] LT",
      nextWeek: "dddd [át] LT",
      lastDay: "[Ý~ést~érdá~ý át] LT",
      lastWeek: "[L~ást] dddd [át] LT",
      sameElse: "L"
     },
     relativeTime: {
      future: "í~ñ %s",
      past: "%s á~gó",
      s: "á ~féw ~sécó~ñds",
      ss: "%d s~écóñ~ds",
      m: "á ~míñ~úté",
      mm: "%d m~íñú~tés",
      h: "á~ñ hó~úr",
      hh: "%d h~óúrs",
      d: "á ~dáý",
      dd: "%d d~áýs",
      M: "á ~móñ~th",
      MM: "%d m~óñt~hs",
      y: "á ~ýéár",
      yy: "%d ý~éárs"
     },
     dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
     ordinal: function(number) {
      var b = number % 10;
      return number + (1 == ~~(number % 100 / 10) ? "th" : 1 === b ? "st" : 2 === b ? "nd" : 3 === b ? "rd" : "th");
     },
     week: {
      dow: 1,
      doy: 4
     }
    });
   }(__webpack_require__(95093));
  },
  82218: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    moment.defineLocale("yo", {
     months: "Sẹ́rẹ́_Èrèlè_Ẹrẹ̀nà_Ìgbé_Èbibi_Òkùdu_Agẹmo_Ògún_Owewe_Ọ̀wàrà_Bélú_Ọ̀pẹ̀̀".split("_"),
     monthsShort: "Sẹ́r_Èrl_Ẹrn_Ìgb_Èbi_Òkù_Agẹ_Ògú_Owe_Ọ̀wà_Bél_Ọ̀pẹ̀̀".split("_"),
     weekdays: "Àìkú_Ajé_Ìsẹ́gun_Ọjọ́rú_Ọjọ́bọ_Ẹtì_Àbámẹ́ta".split("_"),
     weekdaysShort: "Àìk_Ajé_Ìsẹ́_Ọjr_Ọjb_Ẹtì_Àbá".split("_"),
     weekdaysMin: "Àì_Aj_Ìs_Ọr_Ọb_Ẹt_Àb".split("_"),
     longDateFormat: {
      LT: "h:mm A",
      LTS: "h:mm:ss A",
      L: "DD/MM/YYYY",
      LL: "D MMMM YYYY",
      LLL: "D MMMM YYYY h:mm A",
      LLLL: "dddd, D MMMM YYYY h:mm A"
     },
     calendar: {
      sameDay: "[Ònì ni] LT",
      nextDay: "[Ọ̀la ni] LT",
      nextWeek: "dddd [Ọsẹ̀ tón'bọ] [ni] LT",
      lastDay: "[Àna ni] LT",
      lastWeek: "dddd [Ọsẹ̀ tólọ́] [ni] LT",
      sameElse: "L"
     },
     relativeTime: {
      future: "ní %s",
      past: "%s kọjá",
      s: "ìsẹjú aayá die",
      ss: "aayá %d",
      m: "ìsẹjú kan",
      mm: "ìsẹjú %d",
      h: "wákati kan",
      hh: "wákati %d",
      d: "ọjọ́ kan",
      dd: "ọjọ́ %d",
      M: "osù kan",
      MM: "osù %d",
      y: "ọdún kan",
      yy: "ọdún %d"
     },
     dayOfMonthOrdinalParse: /ọjọ́\s\d{1,2}/,
     ordinal: "ọjọ́ %d",
     week: {
      dow: 1,
      doy: 4
     }
    });
   }(__webpack_require__(95093));
  },
  52648: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    moment.defineLocale("zh-cn", {
     months: "一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月".split("_"),
     monthsShort: "1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月".split("_"),
     weekdays: "星期日_星期一_星期二_星期三_星期四_星期五_星期六".split("_"),
     weekdaysShort: "周日_周一_周二_周三_周四_周五_周六".split("_"),
     weekdaysMin: "日_一_二_三_四_五_六".split("_"),
     longDateFormat: {
      LT: "HH:mm",
      LTS: "HH:mm:ss",
      L: "YYYY/MM/DD",
      LL: "YYYY年M月D日",
      LLL: "YYYY年M月D日Ah点mm分",
      LLLL: "YYYY年M月D日ddddAh点mm分",
      l: "YYYY/M/D",
      ll: "YYYY年M月D日",
      lll: "YYYY年M月D日 HH:mm",
      llll: "YYYY年M月D日dddd HH:mm"
     },
     meridiemParse: /凌晨|早上|上午|中午|下午|晚上/,
     meridiemHour: function(hour, meridiem) {
      return 12 === hour && (hour = 0), "凌晨" === meridiem || "早上" === meridiem || "上午" === meridiem ? hour : "下午" === meridiem || "晚上" === meridiem ? hour + 12 : hour >= 11 ? hour : hour + 12;
     },
     meridiem: function(hour, minute, isLower) {
      var hm = 100 * hour + minute;
      return hm < 600 ? "凌晨" : hm < 900 ? "早上" : hm < 1130 ? "上午" : hm < 1230 ? "中午" : hm < 1800 ? "下午" : "晚上";
     },
     calendar: {
      sameDay: "[今天]LT",
      nextDay: "[明天]LT",
      nextWeek: function(now) {
       return now.week() !== this.week() ? "[下]dddLT" : "[本]dddLT";
      },
      lastDay: "[昨天]LT",
      lastWeek: function(now) {
       return this.week() !== now.week() ? "[上]dddLT" : "[本]dddLT";
      },
      sameElse: "L"
     },
     dayOfMonthOrdinalParse: /\d{1,2}(日|月|周)/,
     ordinal: function(number, period) {
      switch (period) {
      case "d":
      case "D":
      case "DDD":
       return number + "日";

      case "M":
       return number + "月";

      case "w":
      case "W":
       return number + "周";

      default:
       return number;
      }
     },
     relativeTime: {
      future: "%s后",
      past: "%s前",
      s: "几秒",
      ss: "%d 秒",
      m: "1 分钟",
      mm: "%d 分钟",
      h: "1 小时",
      hh: "%d 小时",
      d: "1 天",
      dd: "%d 天",
      w: "1 周",
      ww: "%d 周",
      M: "1 个月",
      MM: "%d 个月",
      y: "1 年",
      yy: "%d 年"
     },
     week: {
      dow: 1,
      doy: 4
     }
    });
   }(__webpack_require__(95093));
  },
  1632: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    moment.defineLocale("zh-hk", {
     months: "一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月".split("_"),
     monthsShort: "1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月".split("_"),
     weekdays: "星期日_星期一_星期二_星期三_星期四_星期五_星期六".split("_"),
     weekdaysShort: "週日_週一_週二_週三_週四_週五_週六".split("_"),
     weekdaysMin: "日_一_二_三_四_五_六".split("_"),
     longDateFormat: {
      LT: "HH:mm",
      LTS: "HH:mm:ss",
      L: "YYYY/MM/DD",
      LL: "YYYY年M月D日",
      LLL: "YYYY年M月D日 HH:mm",
      LLLL: "YYYY年M月D日dddd HH:mm",
      l: "YYYY/M/D",
      ll: "YYYY年M月D日",
      lll: "YYYY年M月D日 HH:mm",
      llll: "YYYY年M月D日dddd HH:mm"
     },
     meridiemParse: /凌晨|早上|上午|中午|下午|晚上/,
     meridiemHour: function(hour, meridiem) {
      return 12 === hour && (hour = 0), "凌晨" === meridiem || "早上" === meridiem || "上午" === meridiem ? hour : "中午" === meridiem ? hour >= 11 ? hour : hour + 12 : "下午" === meridiem || "晚上" === meridiem ? hour + 12 : void 0;
     },
     meridiem: function(hour, minute, isLower) {
      var hm = 100 * hour + minute;
      return hm < 600 ? "凌晨" : hm < 900 ? "早上" : hm < 1200 ? "上午" : 1200 === hm ? "中午" : hm < 1800 ? "下午" : "晚上";
     },
     calendar: {
      sameDay: "[今天]LT",
      nextDay: "[明天]LT",
      nextWeek: "[下]ddddLT",
      lastDay: "[昨天]LT",
      lastWeek: "[上]ddddLT",
      sameElse: "L"
     },
     dayOfMonthOrdinalParse: /\d{1,2}(日|月|週)/,
     ordinal: function(number, period) {
      switch (period) {
      case "d":
      case "D":
      case "DDD":
       return number + "日";

      case "M":
       return number + "月";

      case "w":
      case "W":
       return number + "週";

      default:
       return number;
      }
     },
     relativeTime: {
      future: "%s後",
      past: "%s前",
      s: "幾秒",
      ss: "%d 秒",
      m: "1 分鐘",
      mm: "%d 分鐘",
      h: "1 小時",
      hh: "%d 小時",
      d: "1 天",
      dd: "%d 天",
      M: "1 個月",
      MM: "%d 個月",
      y: "1 年",
      yy: "%d 年"
     }
    });
   }(__webpack_require__(95093));
  },
  31541: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    moment.defineLocale("zh-mo", {
     months: "一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月".split("_"),
     monthsShort: "1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月".split("_"),
     weekdays: "星期日_星期一_星期二_星期三_星期四_星期五_星期六".split("_"),
     weekdaysShort: "週日_週一_週二_週三_週四_週五_週六".split("_"),
     weekdaysMin: "日_一_二_三_四_五_六".split("_"),
     longDateFormat: {
      LT: "HH:mm",
      LTS: "HH:mm:ss",
      L: "DD/MM/YYYY",
      LL: "YYYY年M月D日",
      LLL: "YYYY年M月D日 HH:mm",
      LLLL: "YYYY年M月D日dddd HH:mm",
      l: "D/M/YYYY",
      ll: "YYYY年M月D日",
      lll: "YYYY年M月D日 HH:mm",
      llll: "YYYY年M月D日dddd HH:mm"
     },
     meridiemParse: /凌晨|早上|上午|中午|下午|晚上/,
     meridiemHour: function(hour, meridiem) {
      return 12 === hour && (hour = 0), "凌晨" === meridiem || "早上" === meridiem || "上午" === meridiem ? hour : "中午" === meridiem ? hour >= 11 ? hour : hour + 12 : "下午" === meridiem || "晚上" === meridiem ? hour + 12 : void 0;
     },
     meridiem: function(hour, minute, isLower) {
      var hm = 100 * hour + minute;
      return hm < 600 ? "凌晨" : hm < 900 ? "早上" : hm < 1130 ? "上午" : hm < 1230 ? "中午" : hm < 1800 ? "下午" : "晚上";
     },
     calendar: {
      sameDay: "[今天] LT",
      nextDay: "[明天] LT",
      nextWeek: "[下]dddd LT",
      lastDay: "[昨天] LT",
      lastWeek: "[上]dddd LT",
      sameElse: "L"
     },
     dayOfMonthOrdinalParse: /\d{1,2}(日|月|週)/,
     ordinal: function(number, period) {
      switch (period) {
      case "d":
      case "D":
      case "DDD":
       return number + "日";

      case "M":
       return number + "月";

      case "w":
      case "W":
       return number + "週";

      default:
       return number;
      }
     },
     relativeTime: {
      future: "%s內",
      past: "%s前",
      s: "幾秒",
      ss: "%d 秒",
      m: "1 分鐘",
      mm: "%d 分鐘",
      h: "1 小時",
      hh: "%d 小時",
      d: "1 天",
      dd: "%d 天",
      M: "1 個月",
      MM: "%d 個月",
      y: "1 年",
      yy: "%d 年"
     }
    });
   }(__webpack_require__(95093));
  },
  50304: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
   !function(moment) {
    "use strict";
    moment.defineLocale("zh-tw", {
     months: "一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月".split("_"),
     monthsShort: "1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月".split("_"),
     weekdays: "星期日_星期一_星期二_星期三_星期四_星期五_星期六".split("_"),
     weekdaysShort: "週日_週一_週二_週三_週四_週五_週六".split("_"),
     weekdaysMin: "日_一_二_三_四_五_六".split("_"),
     longDateFormat: {
      LT: "HH:mm",
      LTS: "HH:mm:ss",
      L: "YYYY/MM/DD",
      LL: "YYYY年M月D日",
      LLL: "YYYY年M月D日 HH:mm",
      LLLL: "YYYY年M月D日dddd HH:mm",
      l: "YYYY/M/D",
      ll: "YYYY年M月D日",
      lll: "YYYY年M月D日 HH:mm",
      llll: "YYYY年M月D日dddd HH:mm"
     },
     meridiemParse: /凌晨|早上|上午|中午|下午|晚上/,
     meridiemHour: function(hour, meridiem) {
      return 12 === hour && (hour = 0), "凌晨" === meridiem || "早上" === meridiem || "上午" === meridiem ? hour : "中午" === meridiem ? hour >= 11 ? hour : hour + 12 : "下午" === meridiem || "晚上" === meridiem ? hour + 12 : void 0;
     },
     meridiem: function(hour, minute, isLower) {
      var hm = 100 * hour + minute;
      return hm < 600 ? "凌晨" : hm < 900 ? "早上" : hm < 1130 ? "上午" : hm < 1230 ? "中午" : hm < 1800 ? "下午" : "晚上";
     },
     calendar: {
      sameDay: "[今天] LT",
      nextDay: "[明天] LT",
      nextWeek: "[下]dddd LT",
      lastDay: "[昨天] LT",
      lastWeek: "[上]dddd LT",
      sameElse: "L"
     },
     dayOfMonthOrdinalParse: /\d{1,2}(日|月|週)/,
     ordinal: function(number, period) {
      switch (period) {
      case "d":
      case "D":
      case "DDD":
       return number + "日";

      case "M":
       return number + "月";

      case "w":
      case "W":
       return number + "週";

      default:
       return number;
      }
     },
     relativeTime: {
      future: "%s後",
      past: "%s前",
      s: "幾秒",
      ss: "%d 秒",
      m: "1 分鐘",
      mm: "%d 分鐘",
      h: "1 小時",
      hh: "%d 小時",
      d: "1 天",
      dd: "%d 天",
      M: "1 個月",
      MM: "%d 個月",
      y: "1 年",
      yy: "%d 年"
     }
    });
   }(__webpack_require__(95093));
  },
  35358: (module, __unused_webpack_exports, __webpack_require__) => {
   var map = {
    "./af": 25177,
    "./af.js": 25177,
    "./ar": 61509,
    "./ar-dz": 41488,
    "./ar-dz.js": 41488,
    "./ar-kw": 58676,
    "./ar-kw.js": 58676,
    "./ar-ly": 42353,
    "./ar-ly.js": 42353,
    "./ar-ma": 24496,
    "./ar-ma.js": 24496,
    "./ar-ps": 6947,
    "./ar-ps.js": 6947,
    "./ar-sa": 82682,
    "./ar-sa.js": 82682,
    "./ar-tn": 89756,
    "./ar-tn.js": 89756,
    "./ar.js": 61509,
    "./az": 95533,
    "./az.js": 95533,
    "./be": 28959,
    "./be.js": 28959,
    "./bg": 47777,
    "./bg.js": 47777,
    "./bm": 54903,
    "./bm.js": 54903,
    "./bn": 61290,
    "./bn-bd": 17357,
    "./bn-bd.js": 17357,
    "./bn.js": 61290,
    "./bo": 31545,
    "./bo.js": 31545,
    "./br": 11470,
    "./br.js": 11470,
    "./bs": 44429,
    "./bs.js": 44429,
    "./ca": 7306,
    "./ca.js": 7306,
    "./cs": 56464,
    "./cs.js": 56464,
    "./cv": 73635,
    "./cv.js": 73635,
    "./cy": 64226,
    "./cy.js": 64226,
    "./da": 93601,
    "./da.js": 93601,
    "./de": 77853,
    "./de-at": 26111,
    "./de-at.js": 26111,
    "./de-ch": 54697,
    "./de-ch.js": 54697,
    "./de.js": 77853,
    "./dv": 60708,
    "./dv.js": 60708,
    "./el": 54691,
    "./el.js": 54691,
    "./en-au": 53872,
    "./en-au.js": 53872,
    "./en-ca": 28298,
    "./en-ca.js": 28298,
    "./en-gb": 56195,
    "./en-gb.js": 56195,
    "./en-ie": 66584,
    "./en-ie.js": 66584,
    "./en-il": 65543,
    "./en-il.js": 65543,
    "./en-in": 9033,
    "./en-in.js": 9033,
    "./en-nz": 79402,
    "./en-nz.js": 79402,
    "./en-sg": 43004,
    "./en-sg.js": 43004,
    "./eo": 32934,
    "./eo.js": 32934,
    "./es": 97650,
    "./es-do": 20838,
    "./es-do.js": 20838,
    "./es-mx": 17730,
    "./es-mx.js": 17730,
    "./es-us": 56575,
    "./es-us.js": 56575,
    "./es.js": 97650,
    "./et": 3035,
    "./et.js": 3035,
    "./eu": 3508,
    "./eu.js": 3508,
    "./fa": 119,
    "./fa.js": 119,
    "./fi": 90527,
    "./fi.js": 90527,
    "./fil": 95995,
    "./fil.js": 95995,
    "./fo": 52477,
    "./fo.js": 52477,
    "./fr": 85498,
    "./fr-ca": 26435,
    "./fr-ca.js": 26435,
    "./fr-ch": 37892,
    "./fr-ch.js": 37892,
    "./fr.js": 85498,
    "./fy": 37071,
    "./fy.js": 37071,
    "./ga": 41734,
    "./ga.js": 41734,
    "./gd": 70217,
    "./gd.js": 70217,
    "./gl": 77329,
    "./gl.js": 77329,
    "./gom-deva": 32124,
    "./gom-deva.js": 32124,
    "./gom-latn": 93383,
    "./gom-latn.js": 93383,
    "./gu": 95050,
    "./gu.js": 95050,
    "./he": 11713,
    "./he.js": 11713,
    "./hi": 43861,
    "./hi.js": 43861,
    "./hr": 26308,
    "./hr.js": 26308,
    "./hu": 90609,
    "./hu.js": 90609,
    "./hy-am": 17160,
    "./hy-am.js": 17160,
    "./id": 74063,
    "./id.js": 74063,
    "./is": 89374,
    "./is.js": 89374,
    "./it": 88383,
    "./it-ch": 21827,
    "./it-ch.js": 21827,
    "./it.js": 88383,
    "./ja": 23827,
    "./ja.js": 23827,
    "./jv": 89722,
    "./jv.js": 89722,
    "./ka": 41794,
    "./ka.js": 41794,
    "./kk": 27088,
    "./kk.js": 27088,
    "./km": 96870,
    "./km.js": 96870,
    "./kn": 84451,
    "./kn.js": 84451,
    "./ko": 63164,
    "./ko.js": 63164,
    "./ku": 98174,
    "./ku-kmr": 6181,
    "./ku-kmr.js": 6181,
    "./ku.js": 98174,
    "./ky": 78474,
    "./ky.js": 78474,
    "./lb": 79680,
    "./lb.js": 79680,
    "./lo": 15867,
    "./lo.js": 15867,
    "./lt": 45766,
    "./lt.js": 45766,
    "./lv": 69532,
    "./lv.js": 69532,
    "./me": 58076,
    "./me.js": 58076,
    "./mi": 41848,
    "./mi.js": 41848,
    "./mk": 30306,
    "./mk.js": 30306,
    "./ml": 73739,
    "./ml.js": 73739,
    "./mn": 99053,
    "./mn.js": 99053,
    "./mr": 86169,
    "./mr.js": 86169,
    "./ms": 73386,
    "./ms-my": 92297,
    "./ms-my.js": 92297,
    "./ms.js": 73386,
    "./mt": 77075,
    "./mt.js": 77075,
    "./my": 72264,
    "./my.js": 72264,
    "./nb": 22274,
    "./nb.js": 22274,
    "./ne": 8235,
    "./ne.js": 8235,
    "./nl": 92572,
    "./nl-be": 43784,
    "./nl-be.js": 43784,
    "./nl.js": 92572,
    "./nn": 54566,
    "./nn.js": 54566,
    "./oc-lnc": 69330,
    "./oc-lnc.js": 69330,
    "./pa-in": 29849,
    "./pa-in.js": 29849,
    "./pl": 94418,
    "./pl.js": 94418,
    "./pt": 79834,
    "./pt-br": 48303,
    "./pt-br.js": 48303,
    "./pt.js": 79834,
    "./ro": 24457,
    "./ro.js": 24457,
    "./ru": 82271,
    "./ru.js": 82271,
    "./sd": 1221,
    "./sd.js": 1221,
    "./se": 33478,
    "./se.js": 33478,
    "./si": 17538,
    "./si.js": 17538,
    "./sk": 5784,
    "./sk.js": 5784,
    "./sl": 46637,
    "./sl.js": 46637,
    "./sq": 86794,
    "./sq.js": 86794,
    "./sr": 45719,
    "./sr-cyrl": 3322,
    "./sr-cyrl.js": 3322,
    "./sr.js": 45719,
    "./ss": 56e3,
    "./ss.js": 56e3,
    "./sv": 41011,
    "./sv.js": 41011,
    "./sw": 40748,
    "./sw.js": 40748,
    "./ta": 11025,
    "./ta.js": 11025,
    "./te": 11885,
    "./te.js": 11885,
    "./tet": 28861,
    "./tet.js": 28861,
    "./tg": 86571,
    "./tg.js": 86571,
    "./th": 55802,
    "./th.js": 55802,
    "./tk": 59527,
    "./tk.js": 59527,
    "./tl-ph": 29231,
    "./tl-ph.js": 29231,
    "./tlh": 31052,
    "./tlh.js": 31052,
    "./tr": 85096,
    "./tr.js": 85096,
    "./tzl": 79846,
    "./tzl.js": 79846,
    "./tzm": 81765,
    "./tzm-latn": 97711,
    "./tzm-latn.js": 97711,
    "./tzm.js": 81765,
    "./ug-cn": 48414,
    "./ug-cn.js": 48414,
    "./uk": 16618,
    "./uk.js": 16618,
    "./ur": 57777,
    "./ur.js": 57777,
    "./uz": 57609,
    "./uz-latn": 72475,
    "./uz-latn.js": 72475,
    "./uz.js": 57609,
    "./vi": 21135,
    "./vi.js": 21135,
    "./x-pseudo": 64051,
    "./x-pseudo.js": 64051,
    "./yo": 82218,
    "./yo.js": 82218,
    "./zh-cn": 52648,
    "./zh-cn.js": 52648,
    "./zh-hk": 1632,
    "./zh-hk.js": 1632,
    "./zh-mo": 31541,
    "./zh-mo.js": 31541,
    "./zh-tw": 50304,
    "./zh-tw.js": 50304
   };
   function webpackContext(req) {
    var id = webpackContextResolve(req);
    return __webpack_require__(id);
   }
   function webpackContextResolve(req) {
    if (!__webpack_require__.o(map, req)) {
     var e = new Error("Cannot find module '" + req + "'");
     throw e.code = "MODULE_NOT_FOUND", e;
    }
    return map[req];
   }
   webpackContext.keys = function() {
    return Object.keys(map);
   }, webpackContext.resolve = webpackContextResolve, module.exports = webpackContext, 
   webpackContext.id = 35358;
  },
  95093: function(module, __unused_webpack_exports, __webpack_require__) {
   (module = __webpack_require__.nmd(module)).exports = function() {
    "use strict";
    var hookCallback, some;
    function hooks() {
     return hookCallback.apply(null, arguments);
    }
    function setHookCallback(callback) {
     hookCallback = callback;
    }
    function isArray(input) {
     return input instanceof Array || "[object Array]" === Object.prototype.toString.call(input);
    }
    function isObject(input) {
     return null != input && "[object Object]" === Object.prototype.toString.call(input);
    }
    function hasOwnProp(a, b) {
     return Object.prototype.hasOwnProperty.call(a, b);
    }
    function isObjectEmpty(obj) {
     if (Object.getOwnPropertyNames) return 0 === Object.getOwnPropertyNames(obj).length;
     var k;
     for (k in obj) if (hasOwnProp(obj, k)) return !1;
     return !0;
    }
    function isUndefined(input) {
     return void 0 === input;
    }
    function isNumber(input) {
     return "number" == typeof input || "[object Number]" === Object.prototype.toString.call(input);
    }
    function isDate(input) {
     return input instanceof Date || "[object Date]" === Object.prototype.toString.call(input);
    }
    function map(arr, fn) {
     var i, res = [], arrLen = arr.length;
     for (i = 0; i < arrLen; ++i) res.push(fn(arr[i], i));
     return res;
    }
    function extend(a, b) {
     for (var i in b) hasOwnProp(b, i) && (a[i] = b[i]);
     return hasOwnProp(b, "toString") && (a.toString = b.toString), hasOwnProp(b, "valueOf") && (a.valueOf = b.valueOf), 
     a;
    }
    function createUTC(input, format, locale, strict) {
     return createLocalOrUTC(input, format, locale, strict, !0).utc();
    }
    function defaultParsingFlags() {
     return {
      empty: !1,
      unusedTokens: [],
      unusedInput: [],
      overflow: -2,
      charsLeftOver: 0,
      nullInput: !1,
      invalidEra: null,
      invalidMonth: null,
      invalidFormat: !1,
      userInvalidated: !1,
      iso: !1,
      parsedDateParts: [],
      era: null,
      meridiem: null,
      rfc2822: !1,
      weekdayMismatch: !1
     };
    }
    function getParsingFlags(m) {
     return null == m._pf && (m._pf = defaultParsingFlags()), m._pf;
    }
    function isValid(m) {
     var flags = null, parsedParts = !1, isNowValid = m._d && !isNaN(m._d.getTime());
     return isNowValid && (flags = getParsingFlags(m), parsedParts = some.call(flags.parsedDateParts, (function(i) {
      return null != i;
     })), isNowValid = flags.overflow < 0 && !flags.empty && !flags.invalidEra && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts), 
     m._strict && (isNowValid = isNowValid && 0 === flags.charsLeftOver && 0 === flags.unusedTokens.length && void 0 === flags.bigHour)), 
     null != Object.isFrozen && Object.isFrozen(m) ? isNowValid : (m._isValid = isNowValid, 
     m._isValid);
    }
    function createInvalid(flags) {
     var m = createUTC(NaN);
     return null != flags ? extend(getParsingFlags(m), flags) : getParsingFlags(m).userInvalidated = !0, 
     m;
    }
    some = Array.prototype.some ? Array.prototype.some : function(fun) {
     var i, t = Object(this), len = t.length >>> 0;
     for (i = 0; i < len; i++) if (i in t && fun.call(this, t[i], i, t)) return !0;
     return !1;
    };
    var momentProperties = hooks.momentProperties = [], updateInProgress = !1;
    function copyConfig(to, from) {
     var i, prop, val, momentPropertiesLen = momentProperties.length;
     if (isUndefined(from._isAMomentObject) || (to._isAMomentObject = from._isAMomentObject), 
     isUndefined(from._i) || (to._i = from._i), isUndefined(from._f) || (to._f = from._f), 
     isUndefined(from._l) || (to._l = from._l), isUndefined(from._strict) || (to._strict = from._strict), 
     isUndefined(from._tzm) || (to._tzm = from._tzm), isUndefined(from._isUTC) || (to._isUTC = from._isUTC), 
     isUndefined(from._offset) || (to._offset = from._offset), isUndefined(from._pf) || (to._pf = getParsingFlags(from)), 
     isUndefined(from._locale) || (to._locale = from._locale), momentPropertiesLen > 0) for (i = 0; i < momentPropertiesLen; i++) isUndefined(val = from[prop = momentProperties[i]]) || (to[prop] = val);
     return to;
    }
    function Moment(config) {
     copyConfig(this, config), this._d = new Date(null != config._d ? config._d.getTime() : NaN), 
     this.isValid() || (this._d = new Date(NaN)), !1 === updateInProgress && (updateInProgress = !0, 
     hooks.updateOffset(this), updateInProgress = !1);
    }
    function isMoment(obj) {
     return obj instanceof Moment || null != obj && null != obj._isAMomentObject;
    }
    function warn(msg) {
     !1 === hooks.suppressDeprecationWarnings && "undefined" != typeof console && console.warn && console.warn("Deprecation warning: " + msg);
    }
    function deprecate(msg, fn) {
     var firstTime = !0;
     return extend((function() {
      if (null != hooks.deprecationHandler && hooks.deprecationHandler(null, msg), firstTime) {
       var arg, i, key, args = [], argLen = arguments.length;
       for (i = 0; i < argLen; i++) {
        if (arg = "", "object" == typeof arguments[i]) {
         for (key in arg += "\n[" + i + "] ", arguments[0]) hasOwnProp(arguments[0], key) && (arg += key + ": " + arguments[0][key] + ", ");
         arg = arg.slice(0, -2);
        } else arg = arguments[i];
        args.push(arg);
       }
       warn(msg + "\nArguments: " + Array.prototype.slice.call(args).join("") + "\n" + (new Error).stack), 
       firstTime = !1;
      }
      return fn.apply(this, arguments);
     }), fn);
    }
    var keys, deprecations = {};
    function deprecateSimple(name, msg) {
     null != hooks.deprecationHandler && hooks.deprecationHandler(name, msg), deprecations[name] || (warn(msg), 
     deprecations[name] = !0);
    }
    function isFunction(input) {
     return "undefined" != typeof Function && input instanceof Function || "[object Function]" === Object.prototype.toString.call(input);
    }
    function set(config) {
     var prop, i;
     for (i in config) hasOwnProp(config, i) && (isFunction(prop = config[i]) ? this[i] = prop : this["_" + i] = prop);
     this._config = config, this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source);
    }
    function mergeConfigs(parentConfig, childConfig) {
     var prop, res = extend({}, parentConfig);
     for (prop in childConfig) hasOwnProp(childConfig, prop) && (isObject(parentConfig[prop]) && isObject(childConfig[prop]) ? (res[prop] = {}, 
     extend(res[prop], parentConfig[prop]), extend(res[prop], childConfig[prop])) : null != childConfig[prop] ? res[prop] = childConfig[prop] : delete res[prop]);
     for (prop in parentConfig) hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop]) && (res[prop] = extend({}, res[prop]));
     return res;
    }
    function Locale(config) {
     null != config && this.set(config);
    }
    hooks.suppressDeprecationWarnings = !1, hooks.deprecationHandler = null, keys = Object.keys ? Object.keys : function(obj) {
     var i, res = [];
     for (i in obj) hasOwnProp(obj, i) && res.push(i);
     return res;
    };
    var defaultCalendar = {
     sameDay: "[Today at] LT",
     nextDay: "[Tomorrow at] LT",
     nextWeek: "dddd [at] LT",
     lastDay: "[Yesterday at] LT",
     lastWeek: "[Last] dddd [at] LT",
     sameElse: "L"
    };
    function calendar(key, mom, now) {
     var output = this._calendar[key] || this._calendar.sameElse;
     return isFunction(output) ? output.call(mom, now) : output;
    }
    function zeroFill(number, targetLength, forceSign) {
     var absNumber = "" + Math.abs(number), zerosToFill = targetLength - absNumber.length;
     return (number >= 0 ? forceSign ? "+" : "" : "-") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
    }
    var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, formatFunctions = {}, formatTokenFunctions = {};
    function addFormatToken(token, padded, ordinal, callback) {
     var func = callback;
     "string" == typeof callback && (func = function() {
      return this[callback]();
     }), token && (formatTokenFunctions[token] = func), padded && (formatTokenFunctions[padded[0]] = function() {
      return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
     }), ordinal && (formatTokenFunctions[ordinal] = function() {
      return this.localeData().ordinal(func.apply(this, arguments), token);
     });
    }
    function removeFormattingTokens(input) {
     return input.match(/\[[\s\S]/) ? input.replace(/^\[|\]$/g, "") : input.replace(/\\/g, "");
    }
    function makeFormatFunction(format) {
     var i, length, array = format.match(formattingTokens);
     for (i = 0, length = array.length; i < length; i++) formatTokenFunctions[array[i]] ? array[i] = formatTokenFunctions[array[i]] : array[i] = removeFormattingTokens(array[i]);
     return function(mom) {
      var i, output = "";
      for (i = 0; i < length; i++) output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];
      return output;
     };
    }
    function formatMoment(m, format) {
     return m.isValid() ? (format = expandFormat(format, m.localeData()), formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format), 
     formatFunctions[format](m)) : m.localeData().invalidDate();
    }
    function expandFormat(format, locale) {
     var i = 5;
     function replaceLongDateFormatTokens(input) {
      return locale.longDateFormat(input) || input;
     }
     for (localFormattingTokens.lastIndex = 0; i >= 0 && localFormattingTokens.test(format); ) format = format.replace(localFormattingTokens, replaceLongDateFormatTokens), 
     localFormattingTokens.lastIndex = 0, i -= 1;
     return format;
    }
    var defaultLongDateFormat = {
     LTS: "h:mm:ss A",
     LT: "h:mm A",
     L: "MM/DD/YYYY",
     LL: "MMMM D, YYYY",
     LLL: "MMMM D, YYYY h:mm A",
     LLLL: "dddd, MMMM D, YYYY h:mm A"
    };
    function longDateFormat(key) {
     var format = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()];
     return format || !formatUpper ? format : (this._longDateFormat[key] = formatUpper.match(formattingTokens).map((function(tok) {
      return "MMMM" === tok || "MM" === tok || "DD" === tok || "dddd" === tok ? tok.slice(1) : tok;
     })).join(""), this._longDateFormat[key]);
    }
    var defaultInvalidDate = "Invalid date";
    function invalidDate() {
     return this._invalidDate;
    }
    var defaultOrdinal = "%d", defaultDayOfMonthOrdinalParse = /\d{1,2}/;
    function ordinal(number) {
     return this._ordinal.replace("%d", number);
    }
    var defaultRelativeTime = {
     future: "in %s",
     past: "%s ago",
     s: "a few seconds",
     ss: "%d seconds",
     m: "a minute",
     mm: "%d minutes",
     h: "an hour",
     hh: "%d hours",
     d: "a day",
     dd: "%d days",
     w: "a week",
     ww: "%d weeks",
     M: "a month",
     MM: "%d months",
     y: "a year",
     yy: "%d years"
    };
    function relativeTime(number, withoutSuffix, string, isFuture) {
     var output = this._relativeTime[string];
     return isFunction(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
    }
    function pastFuture(diff, output) {
     var format = this._relativeTime[diff > 0 ? "future" : "past"];
     return isFunction(format) ? format(output) : format.replace(/%s/i, output);
    }
    var aliases = {
     D: "date",
     dates: "date",
     date: "date",
     d: "day",
     days: "day",
     day: "day",
     e: "weekday",
     weekdays: "weekday",
     weekday: "weekday",
     E: "isoWeekday",
     isoweekdays: "isoWeekday",
     isoweekday: "isoWeekday",
     DDD: "dayOfYear",
     dayofyears: "dayOfYear",
     dayofyear: "dayOfYear",
     h: "hour",
     hours: "hour",
     hour: "hour",
     ms: "millisecond",
     milliseconds: "millisecond",
     millisecond: "millisecond",
     m: "minute",
     minutes: "minute",
     minute: "minute",
     M: "month",
     months: "month",
     month: "month",
     Q: "quarter",
     quarters: "quarter",
     quarter: "quarter",
     s: "second",
     seconds: "second",
     second: "second",
     gg: "weekYear",
     weekyears: "weekYear",
     weekyear: "weekYear",
     GG: "isoWeekYear",
     isoweekyears: "isoWeekYear",
     isoweekyear: "isoWeekYear",
     w: "week",
     weeks: "week",
     week: "week",
     W: "isoWeek",
     isoweeks: "isoWeek",
     isoweek: "isoWeek",
     y: "year",
     years: "year",
     year: "year"
    };
    function normalizeUnits(units) {
     return "string" == typeof units ? aliases[units] || aliases[units.toLowerCase()] : void 0;
    }
    function normalizeObjectUnits(inputObject) {
     var normalizedProp, prop, normalizedInput = {};
     for (prop in inputObject) hasOwnProp(inputObject, prop) && (normalizedProp = normalizeUnits(prop)) && (normalizedInput[normalizedProp] = inputObject[prop]);
     return normalizedInput;
    }
    var priorities = {
     date: 9,
     day: 11,
     weekday: 11,
     isoWeekday: 11,
     dayOfYear: 4,
     hour: 13,
     millisecond: 16,
     minute: 14,
     month: 8,
     quarter: 7,
     second: 15,
     weekYear: 1,
     isoWeekYear: 1,
     week: 5,
     isoWeek: 5,
     year: 1
    };
    function getPrioritizedUnits(unitsObj) {
     var u, units = [];
     for (u in unitsObj) hasOwnProp(unitsObj, u) && units.push({
      unit: u,
      priority: priorities[u]
     });
     return units.sort((function(a, b) {
      return a.priority - b.priority;
     })), units;
    }
    var regexes, match1 = /\d/, match2 = /\d\d/, match3 = /\d{3}/, match4 = /\d{4}/, match6 = /[+-]?\d{6}/, match1to2 = /\d\d?/, match3to4 = /\d\d\d\d?/, match5to6 = /\d\d\d\d\d\d?/, match1to3 = /\d{1,3}/, match1to4 = /\d{1,4}/, match1to6 = /[+-]?\d{1,6}/, matchUnsigned = /\d+/, matchSigned = /[+-]?\d+/, matchOffset = /Z|[+-]\d\d:?\d\d/gi, matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i, match1to2NoLeadingZero = /^[1-9]\d?/, match1to2HasZero = /^([1-9]\d|\d)/;
    function addRegexToken(token, regex, strictRegex) {
     regexes[token] = isFunction(regex) ? regex : function(isStrict, localeData) {
      return isStrict && strictRegex ? strictRegex : regex;
     };
    }
    function getParseRegexForToken(token, config) {
     return hasOwnProp(regexes, token) ? regexes[token](config._strict, config._locale) : new RegExp(unescapeFormat(token));
    }
    function unescapeFormat(s) {
     return regexEscape(s.replace("\\", "").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, (function(matched, p1, p2, p3, p4) {
      return p1 || p2 || p3 || p4;
     })));
    }
    function regexEscape(s) {
     return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
    }
    function absFloor(number) {
     return number < 0 ? Math.ceil(number) || 0 : Math.floor(number);
    }
    function toInt(argumentForCoercion) {
     var coercedNumber = +argumentForCoercion, value = 0;
     return 0 !== coercedNumber && isFinite(coercedNumber) && (value = absFloor(coercedNumber)), 
     value;
    }
    regexes = {};
    var tokens = {};
    function addParseToken(token, callback) {
     var i, tokenLen, func = callback;
     for ("string" == typeof token && (token = [ token ]), isNumber(callback) && (func = function(input, array) {
      array[callback] = toInt(input);
     }), tokenLen = token.length, i = 0; i < tokenLen; i++) tokens[token[i]] = func;
    }
    function addWeekParseToken(token, callback) {
     addParseToken(token, (function(input, array, config, token) {
      config._w = config._w || {}, callback(input, config._w, config, token);
     }));
    }
    function addTimeToArrayFromToken(token, input, config) {
     null != input && hasOwnProp(tokens, token) && tokens[token](input, config._a, config, token);
    }
    function isLeapYear(year) {
     return year % 4 == 0 && year % 100 != 0 || year % 400 == 0;
    }
    var YEAR = 0, MONTH = 1, DATE = 2, HOUR = 3, MINUTE = 4, SECOND = 5, MILLISECOND = 6, WEEK = 7, WEEKDAY = 8;
    function daysInYear(year) {
     return isLeapYear(year) ? 366 : 365;
    }
    addFormatToken("Y", 0, 0, (function() {
     var y = this.year();
     return y <= 9999 ? zeroFill(y, 4) : "+" + y;
    })), addFormatToken(0, [ "YY", 2 ], 0, (function() {
     return this.year() % 100;
    })), addFormatToken(0, [ "YYYY", 4 ], 0, "year"), addFormatToken(0, [ "YYYYY", 5 ], 0, "year"), 
    addFormatToken(0, [ "YYYYYY", 6, !0 ], 0, "year"), addRegexToken("Y", matchSigned), 
    addRegexToken("YY", match1to2, match2), addRegexToken("YYYY", match1to4, match4), 
    addRegexToken("YYYYY", match1to6, match6), addRegexToken("YYYYYY", match1to6, match6), 
    addParseToken([ "YYYYY", "YYYYYY" ], YEAR), addParseToken("YYYY", (function(input, array) {
     array[YEAR] = 2 === input.length ? hooks.parseTwoDigitYear(input) : toInt(input);
    })), addParseToken("YY", (function(input, array) {
     array[YEAR] = hooks.parseTwoDigitYear(input);
    })), addParseToken("Y", (function(input, array) {
     array[YEAR] = parseInt(input, 10);
    })), hooks.parseTwoDigitYear = function(input) {
     return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3);
    };
    var indexOf, getSetYear = makeGetSet("FullYear", !0);
    function getIsLeapYear() {
     return isLeapYear(this.year());
    }
    function makeGetSet(unit, keepTime) {
     return function(value) {
      return null != value ? (set$1(this, unit, value), hooks.updateOffset(this, keepTime), 
      this) : get(this, unit);
     };
    }
    function get(mom, unit) {
     if (!mom.isValid()) return NaN;
     var d = mom._d, isUTC = mom._isUTC;
     switch (unit) {
     case "Milliseconds":
      return isUTC ? d.getUTCMilliseconds() : d.getMilliseconds();

     case "Seconds":
      return isUTC ? d.getUTCSeconds() : d.getSeconds();

     case "Minutes":
      return isUTC ? d.getUTCMinutes() : d.getMinutes();

     case "Hours":
      return isUTC ? d.getUTCHours() : d.getHours();

     case "Date":
      return isUTC ? d.getUTCDate() : d.getDate();

     case "Day":
      return isUTC ? d.getUTCDay() : d.getDay();

     case "Month":
      return isUTC ? d.getUTCMonth() : d.getMonth();

     case "FullYear":
      return isUTC ? d.getUTCFullYear() : d.getFullYear();

     default:
      return NaN;
     }
    }
    function set$1(mom, unit, value) {
     var d, isUTC, year, month, date;
     if (mom.isValid() && !isNaN(value)) {
      switch (d = mom._d, isUTC = mom._isUTC, unit) {
      case "Milliseconds":
       return void (isUTC ? d.setUTCMilliseconds(value) : d.setMilliseconds(value));

      case "Seconds":
       return void (isUTC ? d.setUTCSeconds(value) : d.setSeconds(value));

      case "Minutes":
       return void (isUTC ? d.setUTCMinutes(value) : d.setMinutes(value));

      case "Hours":
       return void (isUTC ? d.setUTCHours(value) : d.setHours(value));

      case "Date":
       return void (isUTC ? d.setUTCDate(value) : d.setDate(value));

      case "FullYear":
       break;

      default:
       return;
      }
      year = value, month = mom.month(), date = 29 !== (date = mom.date()) || 1 !== month || isLeapYear(year) ? date : 28, 
      isUTC ? d.setUTCFullYear(year, month, date) : d.setFullYear(year, month, date);
     }
    }
    function stringGet(units) {
     return isFunction(this[units = normalizeUnits(units)]) ? this[units]() : this;
    }
    function stringSet(units, value) {
     if ("object" == typeof units) {
      var i, prioritized = getPrioritizedUnits(units = normalizeObjectUnits(units)), prioritizedLen = prioritized.length;
      for (i = 0; i < prioritizedLen; i++) this[prioritized[i].unit](units[prioritized[i].unit]);
     } else if (isFunction(this[units = normalizeUnits(units)])) return this[units](value);
     return this;
    }
    function mod(n, x) {
     return (n % x + x) % x;
    }
    function daysInMonth(year, month) {
     if (isNaN(year) || isNaN(month)) return NaN;
     var modMonth = mod(month, 12);
     return year += (month - modMonth) / 12, 1 === modMonth ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
    }
    indexOf = Array.prototype.indexOf ? Array.prototype.indexOf : function(o) {
     var i;
     for (i = 0; i < this.length; ++i) if (this[i] === o) return i;
     return -1;
    }, addFormatToken("M", [ "MM", 2 ], "Mo", (function() {
     return this.month() + 1;
    })), addFormatToken("MMM", 0, 0, (function(format) {
     return this.localeData().monthsShort(this, format);
    })), addFormatToken("MMMM", 0, 0, (function(format) {
     return this.localeData().months(this, format);
    })), addRegexToken("M", match1to2, match1to2NoLeadingZero), addRegexToken("MM", match1to2, match2), 
    addRegexToken("MMM", (function(isStrict, locale) {
     return locale.monthsShortRegex(isStrict);
    })), addRegexToken("MMMM", (function(isStrict, locale) {
     return locale.monthsRegex(isStrict);
    })), addParseToken([ "M", "MM" ], (function(input, array) {
     array[MONTH] = toInt(input) - 1;
    })), addParseToken([ "MMM", "MMMM" ], (function(input, array, config, token) {
     var month = config._locale.monthsParse(input, token, config._strict);
     null != month ? array[MONTH] = month : getParsingFlags(config).invalidMonth = input;
    }));
    var defaultLocaleMonths = "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, defaultMonthsShortRegex = matchWord, defaultMonthsRegex = matchWord;
    function localeMonths(m, format) {
     return m ? isArray(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? "format" : "standalone"][m.month()] : isArray(this._months) ? this._months : this._months.standalone;
    }
    function localeMonthsShort(m, format) {
     return m ? isArray(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format) ? "format" : "standalone"][m.month()] : isArray(this._monthsShort) ? this._monthsShort : this._monthsShort.standalone;
    }
    function handleStrictParse(monthName, format, strict) {
     var i, ii, mom, llc = monthName.toLocaleLowerCase();
     if (!this._monthsParse) for (this._monthsParse = [], this._longMonthsParse = [], 
     this._shortMonthsParse = [], i = 0; i < 12; ++i) mom = createUTC([ 2e3, i ]), this._shortMonthsParse[i] = this.monthsShort(mom, "").toLocaleLowerCase(), 
     this._longMonthsParse[i] = this.months(mom, "").toLocaleLowerCase();
     return strict ? "MMM" === format ? -1 !== (ii = indexOf.call(this._shortMonthsParse, llc)) ? ii : null : -1 !== (ii = indexOf.call(this._longMonthsParse, llc)) ? ii : null : "MMM" === format ? -1 !== (ii = indexOf.call(this._shortMonthsParse, llc)) || -1 !== (ii = indexOf.call(this._longMonthsParse, llc)) ? ii : null : -1 !== (ii = indexOf.call(this._longMonthsParse, llc)) || -1 !== (ii = indexOf.call(this._shortMonthsParse, llc)) ? ii : null;
    }
    function localeMonthsParse(monthName, format, strict) {
     var i, mom, regex;
     if (this._monthsParseExact) return handleStrictParse.call(this, monthName, format, strict);
     for (this._monthsParse || (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = []), 
     i = 0; i < 12; i++) {
      if (mom = createUTC([ 2e3, i ]), strict && !this._longMonthsParse[i] && (this._longMonthsParse[i] = new RegExp("^" + this.months(mom, "").replace(".", "") + "$", "i"), 
      this._shortMonthsParse[i] = new RegExp("^" + this.monthsShort(mom, "").replace(".", "") + "$", "i")), 
      strict || this._monthsParse[i] || (regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, ""), 
      this._monthsParse[i] = new RegExp(regex.replace(".", ""), "i")), strict && "MMMM" === format && this._longMonthsParse[i].test(monthName)) return i;
      if (strict && "MMM" === format && this._shortMonthsParse[i].test(monthName)) return i;
      if (!strict && this._monthsParse[i].test(monthName)) return i;
     }
    }
    function setMonth(mom, value) {
     if (!mom.isValid()) return mom;
     if ("string" == typeof value) if (/^\d+$/.test(value)) value = toInt(value); else if (!isNumber(value = mom.localeData().monthsParse(value))) return mom;
     var month = value, date = mom.date();
     return date = date < 29 ? date : Math.min(date, daysInMonth(mom.year(), month)), 
     mom._isUTC ? mom._d.setUTCMonth(month, date) : mom._d.setMonth(month, date), mom;
    }
    function getSetMonth(value) {
     return null != value ? (setMonth(this, value), hooks.updateOffset(this, !0), this) : get(this, "Month");
    }
    function getDaysInMonth() {
     return daysInMonth(this.year(), this.month());
    }
    function monthsShortRegex(isStrict) {
     return this._monthsParseExact ? (hasOwnProp(this, "_monthsRegex") || computeMonthsParse.call(this), 
     isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex) : (hasOwnProp(this, "_monthsShortRegex") || (this._monthsShortRegex = defaultMonthsShortRegex), 
     this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex);
    }
    function monthsRegex(isStrict) {
     return this._monthsParseExact ? (hasOwnProp(this, "_monthsRegex") || computeMonthsParse.call(this), 
     isStrict ? this._monthsStrictRegex : this._monthsRegex) : (hasOwnProp(this, "_monthsRegex") || (this._monthsRegex = defaultMonthsRegex), 
     this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex);
    }
    function computeMonthsParse() {
     function cmpLenRev(a, b) {
      return b.length - a.length;
     }
     var i, mom, shortP, longP, shortPieces = [], longPieces = [], mixedPieces = [];
     for (i = 0; i < 12; i++) mom = createUTC([ 2e3, i ]), shortP = regexEscape(this.monthsShort(mom, "")), 
     longP = regexEscape(this.months(mom, "")), shortPieces.push(shortP), longPieces.push(longP), 
     mixedPieces.push(longP), mixedPieces.push(shortP);
     shortPieces.sort(cmpLenRev), longPieces.sort(cmpLenRev), mixedPieces.sort(cmpLenRev), 
     this._monthsRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i"), this._monthsShortRegex = this._monthsRegex, 
     this._monthsStrictRegex = new RegExp("^(" + longPieces.join("|") + ")", "i"), this._monthsShortStrictRegex = new RegExp("^(" + shortPieces.join("|") + ")", "i");
    }
    function createDate(y, m, d, h, M, s, ms) {
     var date;
     return y < 100 && y >= 0 ? (date = new Date(y + 400, m, d, h, M, s, ms), isFinite(date.getFullYear()) && date.setFullYear(y)) : date = new Date(y, m, d, h, M, s, ms), 
     date;
    }
    function createUTCDate(y) {
     var date, args;
     return y < 100 && y >= 0 ? ((args = Array.prototype.slice.call(arguments))[0] = y + 400, 
     date = new Date(Date.UTC.apply(null, args)), isFinite(date.getUTCFullYear()) && date.setUTCFullYear(y)) : date = new Date(Date.UTC.apply(null, arguments)), 
     date;
    }
    function firstWeekOffset(year, dow, doy) {
     var fwd = 7 + dow - doy;
     return -(7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7 + fwd - 1;
    }
    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
     var resYear, resDayOfYear, dayOfYear = 1 + 7 * (week - 1) + (7 + weekday - dow) % 7 + firstWeekOffset(year, dow, doy);
     return dayOfYear <= 0 ? resDayOfYear = daysInYear(resYear = year - 1) + dayOfYear : dayOfYear > daysInYear(year) ? (resYear = year + 1, 
     resDayOfYear = dayOfYear - daysInYear(year)) : (resYear = year, resDayOfYear = dayOfYear), 
     {
      year: resYear,
      dayOfYear: resDayOfYear
     };
    }
    function weekOfYear(mom, dow, doy) {
     var resWeek, resYear, weekOffset = firstWeekOffset(mom.year(), dow, doy), week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1;
     return week < 1 ? resWeek = week + weeksInYear(resYear = mom.year() - 1, dow, doy) : week > weeksInYear(mom.year(), dow, doy) ? (resWeek = week - weeksInYear(mom.year(), dow, doy), 
     resYear = mom.year() + 1) : (resYear = mom.year(), resWeek = week), {
      week: resWeek,
      year: resYear
     };
    }
    function weeksInYear(year, dow, doy) {
     var weekOffset = firstWeekOffset(year, dow, doy), weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
     return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
    }
    function localeWeek(mom) {
     return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }
    addFormatToken("w", [ "ww", 2 ], "wo", "week"), addFormatToken("W", [ "WW", 2 ], "Wo", "isoWeek"), 
    addRegexToken("w", match1to2, match1to2NoLeadingZero), addRegexToken("ww", match1to2, match2), 
    addRegexToken("W", match1to2, match1to2NoLeadingZero), addRegexToken("WW", match1to2, match2), 
    addWeekParseToken([ "w", "ww", "W", "WW" ], (function(input, week, config, token) {
     week[token.substr(0, 1)] = toInt(input);
    }));
    var defaultLocaleWeek = {
     dow: 0,
     doy: 6
    };
    function localeFirstDayOfWeek() {
     return this._week.dow;
    }
    function localeFirstDayOfYear() {
     return this._week.doy;
    }
    function getSetWeek(input) {
     var week = this.localeData().week(this);
     return null == input ? week : this.add(7 * (input - week), "d");
    }
    function getSetISOWeek(input) {
     var week = weekOfYear(this, 1, 4).week;
     return null == input ? week : this.add(7 * (input - week), "d");
    }
    function parseWeekday(input, locale) {
     return "string" != typeof input ? input : isNaN(input) ? "number" == typeof (input = locale.weekdaysParse(input)) ? input : null : parseInt(input, 10);
    }
    function parseIsoWeekday(input, locale) {
     return "string" == typeof input ? locale.weekdaysParse(input) % 7 || 7 : isNaN(input) ? null : input;
    }
    function shiftWeekdays(ws, n) {
     return ws.slice(n, 7).concat(ws.slice(0, n));
    }
    addFormatToken("d", 0, "do", "day"), addFormatToken("dd", 0, 0, (function(format) {
     return this.localeData().weekdaysMin(this, format);
    })), addFormatToken("ddd", 0, 0, (function(format) {
     return this.localeData().weekdaysShort(this, format);
    })), addFormatToken("dddd", 0, 0, (function(format) {
     return this.localeData().weekdays(this, format);
    })), addFormatToken("e", 0, 0, "weekday"), addFormatToken("E", 0, 0, "isoWeekday"), 
    addRegexToken("d", match1to2), addRegexToken("e", match1to2), addRegexToken("E", match1to2), 
    addRegexToken("dd", (function(isStrict, locale) {
     return locale.weekdaysMinRegex(isStrict);
    })), addRegexToken("ddd", (function(isStrict, locale) {
     return locale.weekdaysShortRegex(isStrict);
    })), addRegexToken("dddd", (function(isStrict, locale) {
     return locale.weekdaysRegex(isStrict);
    })), addWeekParseToken([ "dd", "ddd", "dddd" ], (function(input, week, config, token) {
     var weekday = config._locale.weekdaysParse(input, token, config._strict);
     null != weekday ? week.d = weekday : getParsingFlags(config).invalidWeekday = input;
    })), addWeekParseToken([ "d", "e", "E" ], (function(input, week, config, token) {
     week[token] = toInt(input);
    }));
    var defaultLocaleWeekdays = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), defaultWeekdaysRegex = matchWord, defaultWeekdaysShortRegex = matchWord, defaultWeekdaysMinRegex = matchWord;
    function localeWeekdays(m, format) {
     var weekdays = isArray(this._weekdays) ? this._weekdays : this._weekdays[m && !0 !== m && this._weekdays.isFormat.test(format) ? "format" : "standalone"];
     return !0 === m ? shiftWeekdays(weekdays, this._week.dow) : m ? weekdays[m.day()] : weekdays;
    }
    function localeWeekdaysShort(m) {
     return !0 === m ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
    }
    function localeWeekdaysMin(m) {
     return !0 === m ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
    }
    function handleStrictParse$1(weekdayName, format, strict) {
     var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
     if (!this._weekdaysParse) for (this._weekdaysParse = [], this._shortWeekdaysParse = [], 
     this._minWeekdaysParse = [], i = 0; i < 7; ++i) mom = createUTC([ 2e3, 1 ]).day(i), 
     this._minWeekdaysParse[i] = this.weekdaysMin(mom, "").toLocaleLowerCase(), this._shortWeekdaysParse[i] = this.weekdaysShort(mom, "").toLocaleLowerCase(), 
     this._weekdaysParse[i] = this.weekdays(mom, "").toLocaleLowerCase();
     return strict ? "dddd" === format ? -1 !== (ii = indexOf.call(this._weekdaysParse, llc)) ? ii : null : "ddd" === format ? -1 !== (ii = indexOf.call(this._shortWeekdaysParse, llc)) ? ii : null : -1 !== (ii = indexOf.call(this._minWeekdaysParse, llc)) ? ii : null : "dddd" === format ? -1 !== (ii = indexOf.call(this._weekdaysParse, llc)) || -1 !== (ii = indexOf.call(this._shortWeekdaysParse, llc)) || -1 !== (ii = indexOf.call(this._minWeekdaysParse, llc)) ? ii : null : "ddd" === format ? -1 !== (ii = indexOf.call(this._shortWeekdaysParse, llc)) || -1 !== (ii = indexOf.call(this._weekdaysParse, llc)) || -1 !== (ii = indexOf.call(this._minWeekdaysParse, llc)) ? ii : null : -1 !== (ii = indexOf.call(this._minWeekdaysParse, llc)) || -1 !== (ii = indexOf.call(this._weekdaysParse, llc)) || -1 !== (ii = indexOf.call(this._shortWeekdaysParse, llc)) ? ii : null;
    }
    function localeWeekdaysParse(weekdayName, format, strict) {
     var i, mom, regex;
     if (this._weekdaysParseExact) return handleStrictParse$1.call(this, weekdayName, format, strict);
     for (this._weekdaysParse || (this._weekdaysParse = [], this._minWeekdaysParse = [], 
     this._shortWeekdaysParse = [], this._fullWeekdaysParse = []), i = 0; i < 7; i++) {
      if (mom = createUTC([ 2e3, 1 ]).day(i), strict && !this._fullWeekdaysParse[i] && (this._fullWeekdaysParse[i] = new RegExp("^" + this.weekdays(mom, "").replace(".", "\\.?") + "$", "i"), 
      this._shortWeekdaysParse[i] = new RegExp("^" + this.weekdaysShort(mom, "").replace(".", "\\.?") + "$", "i"), 
      this._minWeekdaysParse[i] = new RegExp("^" + this.weekdaysMin(mom, "").replace(".", "\\.?") + "$", "i")), 
      this._weekdaysParse[i] || (regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, ""), 
      this._weekdaysParse[i] = new RegExp(regex.replace(".", ""), "i")), strict && "dddd" === format && this._fullWeekdaysParse[i].test(weekdayName)) return i;
      if (strict && "ddd" === format && this._shortWeekdaysParse[i].test(weekdayName)) return i;
      if (strict && "dd" === format && this._minWeekdaysParse[i].test(weekdayName)) return i;
      if (!strict && this._weekdaysParse[i].test(weekdayName)) return i;
     }
    }
    function getSetDayOfWeek(input) {
     if (!this.isValid()) return null != input ? this : NaN;
     var day = get(this, "Day");
     return null != input ? (input = parseWeekday(input, this.localeData()), this.add(input - day, "d")) : day;
    }
    function getSetLocaleDayOfWeek(input) {
     if (!this.isValid()) return null != input ? this : NaN;
     var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
     return null == input ? weekday : this.add(input - weekday, "d");
    }
    function getSetISODayOfWeek(input) {
     if (!this.isValid()) return null != input ? this : NaN;
     if (null != input) {
      var weekday = parseIsoWeekday(input, this.localeData());
      return this.day(this.day() % 7 ? weekday : weekday - 7);
     }
     return this.day() || 7;
    }
    function weekdaysRegex(isStrict) {
     return this._weekdaysParseExact ? (hasOwnProp(this, "_weekdaysRegex") || computeWeekdaysParse.call(this), 
     isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex) : (hasOwnProp(this, "_weekdaysRegex") || (this._weekdaysRegex = defaultWeekdaysRegex), 
     this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex);
    }
    function weekdaysShortRegex(isStrict) {
     return this._weekdaysParseExact ? (hasOwnProp(this, "_weekdaysRegex") || computeWeekdaysParse.call(this), 
     isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex) : (hasOwnProp(this, "_weekdaysShortRegex") || (this._weekdaysShortRegex = defaultWeekdaysShortRegex), 
     this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex);
    }
    function weekdaysMinRegex(isStrict) {
     return this._weekdaysParseExact ? (hasOwnProp(this, "_weekdaysRegex") || computeWeekdaysParse.call(this), 
     isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex) : (hasOwnProp(this, "_weekdaysMinRegex") || (this._weekdaysMinRegex = defaultWeekdaysMinRegex), 
     this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex);
    }
    function computeWeekdaysParse() {
     function cmpLenRev(a, b) {
      return b.length - a.length;
     }
     var i, mom, minp, shortp, longp, minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [];
     for (i = 0; i < 7; i++) mom = createUTC([ 2e3, 1 ]).day(i), minp = regexEscape(this.weekdaysMin(mom, "")), 
     shortp = regexEscape(this.weekdaysShort(mom, "")), longp = regexEscape(this.weekdays(mom, "")), 
     minPieces.push(minp), shortPieces.push(shortp), longPieces.push(longp), mixedPieces.push(minp), 
     mixedPieces.push(shortp), mixedPieces.push(longp);
     minPieces.sort(cmpLenRev), shortPieces.sort(cmpLenRev), longPieces.sort(cmpLenRev), 
     mixedPieces.sort(cmpLenRev), this._weekdaysRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i"), 
     this._weekdaysShortRegex = this._weekdaysRegex, this._weekdaysMinRegex = this._weekdaysRegex, 
     this._weekdaysStrictRegex = new RegExp("^(" + longPieces.join("|") + ")", "i"), 
     this._weekdaysShortStrictRegex = new RegExp("^(" + shortPieces.join("|") + ")", "i"), 
     this._weekdaysMinStrictRegex = new RegExp("^(" + minPieces.join("|") + ")", "i");
    }
    function hFormat() {
     return this.hours() % 12 || 12;
    }
    function kFormat() {
     return this.hours() || 24;
    }
    function meridiem(token, lowercase) {
     addFormatToken(token, 0, 0, (function() {
      return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
     }));
    }
    function matchMeridiem(isStrict, locale) {
     return locale._meridiemParse;
    }
    function localeIsPM(input) {
     return "p" === (input + "").toLowerCase().charAt(0);
    }
    addFormatToken("H", [ "HH", 2 ], 0, "hour"), addFormatToken("h", [ "hh", 2 ], 0, hFormat), 
    addFormatToken("k", [ "kk", 2 ], 0, kFormat), addFormatToken("hmm", 0, 0, (function() {
     return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2);
    })), addFormatToken("hmmss", 0, 0, (function() {
     return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
    })), addFormatToken("Hmm", 0, 0, (function() {
     return "" + this.hours() + zeroFill(this.minutes(), 2);
    })), addFormatToken("Hmmss", 0, 0, (function() {
     return "" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
    })), meridiem("a", !0), meridiem("A", !1), addRegexToken("a", matchMeridiem), addRegexToken("A", matchMeridiem), 
    addRegexToken("H", match1to2, match1to2HasZero), addRegexToken("h", match1to2, match1to2NoLeadingZero), 
    addRegexToken("k", match1to2, match1to2NoLeadingZero), addRegexToken("HH", match1to2, match2), 
    addRegexToken("hh", match1to2, match2), addRegexToken("kk", match1to2, match2), 
    addRegexToken("hmm", match3to4), addRegexToken("hmmss", match5to6), addRegexToken("Hmm", match3to4), 
    addRegexToken("Hmmss", match5to6), addParseToken([ "H", "HH" ], HOUR), addParseToken([ "k", "kk" ], (function(input, array, config) {
     var kInput = toInt(input);
     array[HOUR] = 24 === kInput ? 0 : kInput;
    })), addParseToken([ "a", "A" ], (function(input, array, config) {
     config._isPm = config._locale.isPM(input), config._meridiem = input;
    })), addParseToken([ "h", "hh" ], (function(input, array, config) {
     array[HOUR] = toInt(input), getParsingFlags(config).bigHour = !0;
    })), addParseToken("hmm", (function(input, array, config) {
     var pos = input.length - 2;
     array[HOUR] = toInt(input.substr(0, pos)), array[MINUTE] = toInt(input.substr(pos)), 
     getParsingFlags(config).bigHour = !0;
    })), addParseToken("hmmss", (function(input, array, config) {
     var pos1 = input.length - 4, pos2 = input.length - 2;
     array[HOUR] = toInt(input.substr(0, pos1)), array[MINUTE] = toInt(input.substr(pos1, 2)), 
     array[SECOND] = toInt(input.substr(pos2)), getParsingFlags(config).bigHour = !0;
    })), addParseToken("Hmm", (function(input, array, config) {
     var pos = input.length - 2;
     array[HOUR] = toInt(input.substr(0, pos)), array[MINUTE] = toInt(input.substr(pos));
    })), addParseToken("Hmmss", (function(input, array, config) {
     var pos1 = input.length - 4, pos2 = input.length - 2;
     array[HOUR] = toInt(input.substr(0, pos1)), array[MINUTE] = toInt(input.substr(pos1, 2)), 
     array[SECOND] = toInt(input.substr(pos2));
    }));
    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i, getSetHour = makeGetSet("Hours", !0);
    function localeMeridiem(hours, minutes, isLower) {
     return hours > 11 ? isLower ? "pm" : "PM" : isLower ? "am" : "AM";
    }
    var globalLocale, baseConfig = {
     calendar: defaultCalendar,
     longDateFormat: defaultLongDateFormat,
     invalidDate: defaultInvalidDate,
     ordinal: defaultOrdinal,
     dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
     relativeTime: defaultRelativeTime,
     months: defaultLocaleMonths,
     monthsShort: defaultLocaleMonthsShort,
     week: defaultLocaleWeek,
     weekdays: defaultLocaleWeekdays,
     weekdaysMin: defaultLocaleWeekdaysMin,
     weekdaysShort: defaultLocaleWeekdaysShort,
     meridiemParse: defaultLocaleMeridiemParse
    }, locales = {}, localeFamilies = {};
    function commonPrefix(arr1, arr2) {
     var i, minl = Math.min(arr1.length, arr2.length);
     for (i = 0; i < minl; i += 1) if (arr1[i] !== arr2[i]) return i;
     return minl;
    }
    function normalizeLocale(key) {
     return key ? key.toLowerCase().replace("_", "-") : key;
    }
    function chooseLocale(names) {
     for (var j, next, locale, split, i = 0; i < names.length; ) {
      for (j = (split = normalizeLocale(names[i]).split("-")).length, next = (next = normalizeLocale(names[i + 1])) ? next.split("-") : null; j > 0; ) {
       if (locale = loadLocale(split.slice(0, j).join("-"))) return locale;
       if (next && next.length >= j && commonPrefix(split, next) >= j - 1) break;
       j--;
      }
      i++;
     }
     return globalLocale;
    }
    function isLocaleNameSane(name) {
     return !(!name || !name.match("^[^/\\\\]*$"));
    }
    function loadLocale(name) {
     var oldLocale = null;
     if (void 0 === locales[name] && module && module.exports && isLocaleNameSane(name)) try {
      oldLocale = globalLocale._abbr, __webpack_require__(35358)("./" + name), getSetGlobalLocale(oldLocale);
     } catch (e) {
      locales[name] = null;
     }
     return locales[name];
    }
    function getSetGlobalLocale(key, values) {
     var data;
     return key && ((data = isUndefined(values) ? getLocale(key) : defineLocale(key, values)) ? globalLocale = data : "undefined" != typeof console && console.warn && console.warn("Locale " + key + " not found. Did you forget to load it?")), 
     globalLocale._abbr;
    }
    function defineLocale(name, config) {
     if (null !== config) {
      var locale, parentConfig = baseConfig;
      if (config.abbr = name, null != locales[name]) deprecateSimple("defineLocaleOverride", "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."), 
      parentConfig = locales[name]._config; else if (null != config.parentLocale) if (null != locales[config.parentLocale]) parentConfig = locales[config.parentLocale]._config; else {
       if (null == (locale = loadLocale(config.parentLocale))) return localeFamilies[config.parentLocale] || (localeFamilies[config.parentLocale] = []), 
       localeFamilies[config.parentLocale].push({
        name,
        config
       }), null;
       parentConfig = locale._config;
      }
      return locales[name] = new Locale(mergeConfigs(parentConfig, config)), localeFamilies[name] && localeFamilies[name].forEach((function(x) {
       defineLocale(x.name, x.config);
      })), getSetGlobalLocale(name), locales[name];
     }
     return delete locales[name], null;
    }
    function updateLocale(name, config) {
     if (null != config) {
      var locale, tmpLocale, parentConfig = baseConfig;
      null != locales[name] && null != locales[name].parentLocale ? locales[name].set(mergeConfigs(locales[name]._config, config)) : (null != (tmpLocale = loadLocale(name)) && (parentConfig = tmpLocale._config), 
      config = mergeConfigs(parentConfig, config), null == tmpLocale && (config.abbr = name), 
      (locale = new Locale(config)).parentLocale = locales[name], locales[name] = locale), 
      getSetGlobalLocale(name);
     } else null != locales[name] && (null != locales[name].parentLocale ? (locales[name] = locales[name].parentLocale, 
     name === getSetGlobalLocale() && getSetGlobalLocale(name)) : null != locales[name] && delete locales[name]);
     return locales[name];
    }
    function getLocale(key) {
     var locale;
     if (key && key._locale && key._locale._abbr && (key = key._locale._abbr), !key) return globalLocale;
     if (!isArray(key)) {
      if (locale = loadLocale(key)) return locale;
      key = [ key ];
     }
     return chooseLocale(key);
    }
    function listLocales() {
     return keys(locales);
    }
    function checkOverflow(m) {
     var overflow, a = m._a;
     return a && -2 === getParsingFlags(m).overflow && (overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || 24 === a[HOUR] && (0 !== a[MINUTE] || 0 !== a[SECOND] || 0 !== a[MILLISECOND]) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1, 
     getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE) && (overflow = DATE), 
     getParsingFlags(m)._overflowWeeks && -1 === overflow && (overflow = WEEK), getParsingFlags(m)._overflowWeekday && -1 === overflow && (overflow = WEEKDAY), 
     getParsingFlags(m).overflow = overflow), m;
    }
    var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, tzRegex = /Z|[+-]\d\d(?::?\d\d)?/, isoDates = [ [ "YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/ ], [ "YYYY-MM-DD", /\d{4}-\d\d-\d\d/ ], [ "GGGG-[W]WW-E", /\d{4}-W\d\d-\d/ ], [ "GGGG-[W]WW", /\d{4}-W\d\d/, !1 ], [ "YYYY-DDD", /\d{4}-\d{3}/ ], [ "YYYY-MM", /\d{4}-\d\d/, !1 ], [ "YYYYYYMMDD", /[+-]\d{10}/ ], [ "YYYYMMDD", /\d{8}/ ], [ "GGGG[W]WWE", /\d{4}W\d{3}/ ], [ "GGGG[W]WW", /\d{4}W\d{2}/, !1 ], [ "YYYYDDD", /\d{7}/ ], [ "YYYYMM", /\d{6}/, !1 ], [ "YYYY", /\d{4}/, !1 ] ], isoTimes = [ [ "HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/ ], [ "HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/ ], [ "HH:mm:ss", /\d\d:\d\d:\d\d/ ], [ "HH:mm", /\d\d:\d\d/ ], [ "HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/ ], [ "HHmmss,SSSS", /\d\d\d\d\d\d,\d+/ ], [ "HHmmss", /\d\d\d\d\d\d/ ], [ "HHmm", /\d\d\d\d/ ], [ "HH", /\d\d/ ] ], aspNetJsonRegex = /^\/?Date\((-?\d+)/i, rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/, obsOffsets = {
     UT: 0,
     GMT: 0,
     EDT: -240,
     EST: -300,
     CDT: -300,
     CST: -360,
     MDT: -360,
     MST: -420,
     PDT: -420,
     PST: -480
    };
    function configFromISO(config) {
     var i, l, allowTime, dateFormat, timeFormat, tzFormat, string = config._i, match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string), isoDatesLen = isoDates.length, isoTimesLen = isoTimes.length;
     if (match) {
      for (getParsingFlags(config).iso = !0, i = 0, l = isoDatesLen; i < l; i++) if (isoDates[i][1].exec(match[1])) {
       dateFormat = isoDates[i][0], allowTime = !1 !== isoDates[i][2];
       break;
      }
      if (null == dateFormat) return void (config._isValid = !1);
      if (match[3]) {
       for (i = 0, l = isoTimesLen; i < l; i++) if (isoTimes[i][1].exec(match[3])) {
        timeFormat = (match[2] || " ") + isoTimes[i][0];
        break;
       }
       if (null == timeFormat) return void (config._isValid = !1);
      }
      if (!allowTime && null != timeFormat) return void (config._isValid = !1);
      if (match[4]) {
       if (!tzRegex.exec(match[4])) return void (config._isValid = !1);
       tzFormat = "Z";
      }
      config._f = dateFormat + (timeFormat || "") + (tzFormat || ""), configFromStringAndFormat(config);
     } else config._isValid = !1;
    }
    function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
     var result = [ untruncateYear(yearStr), defaultLocaleMonthsShort.indexOf(monthStr), parseInt(dayStr, 10), parseInt(hourStr, 10), parseInt(minuteStr, 10) ];
     return secondStr && result.push(parseInt(secondStr, 10)), result;
    }
    function untruncateYear(yearStr) {
     var year = parseInt(yearStr, 10);
     return year <= 49 ? 2e3 + year : year <= 999 ? 1900 + year : year;
    }
    function preprocessRFC2822(s) {
     return s.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
    }
    function checkWeekday(weekdayStr, parsedInput, config) {
     return !weekdayStr || defaultLocaleWeekdaysShort.indexOf(weekdayStr) === new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay() || (getParsingFlags(config).weekdayMismatch = !0, 
     config._isValid = !1, !1);
    }
    function calculateOffset(obsOffset, militaryOffset, numOffset) {
     if (obsOffset) return obsOffsets[obsOffset];
     if (militaryOffset) return 0;
     var hm = parseInt(numOffset, 10), m = hm % 100;
     return (hm - m) / 100 * 60 + m;
    }
    function configFromRFC2822(config) {
     var parsedArray, match = rfc2822.exec(preprocessRFC2822(config._i));
     if (match) {
      if (parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]), 
      !checkWeekday(match[1], parsedArray, config)) return;
      config._a = parsedArray, config._tzm = calculateOffset(match[8], match[9], match[10]), 
      config._d = createUTCDate.apply(null, config._a), config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm), 
      getParsingFlags(config).rfc2822 = !0;
     } else config._isValid = !1;
    }
    function configFromString(config) {
     var matched = aspNetJsonRegex.exec(config._i);
     null === matched ? (configFromISO(config), !1 === config._isValid && (delete config._isValid, 
     configFromRFC2822(config), !1 === config._isValid && (delete config._isValid, config._strict ? config._isValid = !1 : hooks.createFromInputFallback(config)))) : config._d = new Date(+matched[1]);
    }
    function defaults(a, b, c) {
     return null != a ? a : null != b ? b : c;
    }
    function currentDateArray(config) {
     var nowValue = new Date(hooks.now());
     return config._useUTC ? [ nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate() ] : [ nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate() ];
    }
    function configFromArray(config) {
     var i, date, currentDate, expectedWeekday, yearToUse, input = [];
     if (!config._d) {
      for (currentDate = currentDateArray(config), config._w && null == config._a[DATE] && null == config._a[MONTH] && dayOfYearFromWeekInfo(config), 
      null != config._dayOfYear && (yearToUse = defaults(config._a[YEAR], currentDate[YEAR]), 
      (config._dayOfYear > daysInYear(yearToUse) || 0 === config._dayOfYear) && (getParsingFlags(config)._overflowDayOfYear = !0), 
      date = createUTCDate(yearToUse, 0, config._dayOfYear), config._a[MONTH] = date.getUTCMonth(), 
      config._a[DATE] = date.getUTCDate()), i = 0; i < 3 && null == config._a[i]; ++i) config._a[i] = input[i] = currentDate[i];
      for (;i < 7; i++) config._a[i] = input[i] = null == config._a[i] ? 2 === i ? 1 : 0 : config._a[i];
      24 === config._a[HOUR] && 0 === config._a[MINUTE] && 0 === config._a[SECOND] && 0 === config._a[MILLISECOND] && (config._nextDay = !0, 
      config._a[HOUR] = 0), config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input), 
      expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay(), null != config._tzm && config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm), 
      config._nextDay && (config._a[HOUR] = 24), config._w && void 0 !== config._w.d && config._w.d !== expectedWeekday && (getParsingFlags(config).weekdayMismatch = !0);
     }
    }
    function dayOfYearFromWeekInfo(config) {
     var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;
     null != (w = config._w).GG || null != w.W || null != w.E ? (dow = 1, doy = 4, weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year), 
     week = defaults(w.W, 1), ((weekday = defaults(w.E, 1)) < 1 || weekday > 7) && (weekdayOverflow = !0)) : (dow = config._locale._week.dow, 
     doy = config._locale._week.doy, curWeek = weekOfYear(createLocal(), dow, doy), weekYear = defaults(w.gg, config._a[YEAR], curWeek.year), 
     week = defaults(w.w, curWeek.week), null != w.d ? ((weekday = w.d) < 0 || weekday > 6) && (weekdayOverflow = !0) : null != w.e ? (weekday = w.e + dow, 
     (w.e < 0 || w.e > 6) && (weekdayOverflow = !0)) : weekday = dow), week < 1 || week > weeksInYear(weekYear, dow, doy) ? getParsingFlags(config)._overflowWeeks = !0 : null != weekdayOverflow ? getParsingFlags(config)._overflowWeekday = !0 : (temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy), 
     config._a[YEAR] = temp.year, config._dayOfYear = temp.dayOfYear);
    }
    function configFromStringAndFormat(config) {
     if (config._f !== hooks.ISO_8601) if (config._f !== hooks.RFC_2822) {
      config._a = [], getParsingFlags(config).empty = !0;
      var i, parsedInput, tokens, token, skipped, era, tokenLen, string = "" + config._i, stringLength = string.length, totalParsedInputLength = 0;
      for (tokenLen = (tokens = expandFormat(config._f, config._locale).match(formattingTokens) || []).length, 
      i = 0; i < tokenLen; i++) token = tokens[i], (parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0]) && ((skipped = string.substr(0, string.indexOf(parsedInput))).length > 0 && getParsingFlags(config).unusedInput.push(skipped), 
      string = string.slice(string.indexOf(parsedInput) + parsedInput.length), totalParsedInputLength += parsedInput.length), 
      formatTokenFunctions[token] ? (parsedInput ? getParsingFlags(config).empty = !1 : getParsingFlags(config).unusedTokens.push(token), 
      addTimeToArrayFromToken(token, parsedInput, config)) : config._strict && !parsedInput && getParsingFlags(config).unusedTokens.push(token);
      getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength, string.length > 0 && getParsingFlags(config).unusedInput.push(string), 
      config._a[HOUR] <= 12 && !0 === getParsingFlags(config).bigHour && config._a[HOUR] > 0 && (getParsingFlags(config).bigHour = void 0), 
      getParsingFlags(config).parsedDateParts = config._a.slice(0), getParsingFlags(config).meridiem = config._meridiem, 
      config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem), 
      null !== (era = getParsingFlags(config).era) && (config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR])), 
      configFromArray(config), checkOverflow(config);
     } else configFromRFC2822(config); else configFromISO(config);
    }
    function meridiemFixWrap(locale, hour, meridiem) {
     var isPm;
     return null == meridiem ? hour : null != locale.meridiemHour ? locale.meridiemHour(hour, meridiem) : null != locale.isPM ? ((isPm = locale.isPM(meridiem)) && hour < 12 && (hour += 12), 
     isPm || 12 !== hour || (hour = 0), hour) : hour;
    }
    function configFromStringAndArray(config) {
     var tempConfig, bestMoment, scoreToBeat, i, currentScore, validFormatFound, bestFormatIsValid = !1, configfLen = config._f.length;
     if (0 === configfLen) return getParsingFlags(config).invalidFormat = !0, void (config._d = new Date(NaN));
     for (i = 0; i < configfLen; i++) currentScore = 0, validFormatFound = !1, tempConfig = copyConfig({}, config), 
     null != config._useUTC && (tempConfig._useUTC = config._useUTC), tempConfig._f = config._f[i], 
     configFromStringAndFormat(tempConfig), isValid(tempConfig) && (validFormatFound = !0), 
     currentScore += getParsingFlags(tempConfig).charsLeftOver, currentScore += 10 * getParsingFlags(tempConfig).unusedTokens.length, 
     getParsingFlags(tempConfig).score = currentScore, bestFormatIsValid ? currentScore < scoreToBeat && (scoreToBeat = currentScore, 
     bestMoment = tempConfig) : (null == scoreToBeat || currentScore < scoreToBeat || validFormatFound) && (scoreToBeat = currentScore, 
     bestMoment = tempConfig, validFormatFound && (bestFormatIsValid = !0));
     extend(config, bestMoment || tempConfig);
    }
    function configFromObject(config) {
     if (!config._d) {
      var i = normalizeObjectUnits(config._i), dayOrDate = void 0 === i.day ? i.date : i.day;
      config._a = map([ i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond ], (function(obj) {
       return obj && parseInt(obj, 10);
      })), configFromArray(config);
     }
    }
    function createFromConfig(config) {
     var res = new Moment(checkOverflow(prepareConfig(config)));
     return res._nextDay && (res.add(1, "d"), res._nextDay = void 0), res;
    }
    function prepareConfig(config) {
     var input = config._i, format = config._f;
     return config._locale = config._locale || getLocale(config._l), null === input || void 0 === format && "" === input ? createInvalid({
      nullInput: !0
     }) : ("string" == typeof input && (config._i = input = config._locale.preparse(input)), 
     isMoment(input) ? new Moment(checkOverflow(input)) : (isDate(input) ? config._d = input : isArray(format) ? configFromStringAndArray(config) : format ? configFromStringAndFormat(config) : configFromInput(config), 
     isValid(config) || (config._d = null), config));
    }
    function configFromInput(config) {
     var input = config._i;
     isUndefined(input) ? config._d = new Date(hooks.now()) : isDate(input) ? config._d = new Date(input.valueOf()) : "string" == typeof input ? configFromString(config) : isArray(input) ? (config._a = map(input.slice(0), (function(obj) {
      return parseInt(obj, 10);
     })), configFromArray(config)) : isObject(input) ? configFromObject(config) : isNumber(input) ? config._d = new Date(input) : hooks.createFromInputFallback(config);
    }
    function createLocalOrUTC(input, format, locale, strict, isUTC) {
     var c = {};
     return !0 !== format && !1 !== format || (strict = format, format = void 0), !0 !== locale && !1 !== locale || (strict = locale, 
     locale = void 0), (isObject(input) && isObjectEmpty(input) || isArray(input) && 0 === input.length) && (input = void 0), 
     c._isAMomentObject = !0, c._useUTC = c._isUTC = isUTC, c._l = locale, c._i = input, 
     c._f = format, c._strict = strict, createFromConfig(c);
    }
    function createLocal(input, format, locale, strict) {
     return createLocalOrUTC(input, format, locale, strict, !1);
    }
    hooks.createFromInputFallback = deprecate("value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.", (function(config) {
     config._d = new Date(config._i + (config._useUTC ? " UTC" : ""));
    })), hooks.ISO_8601 = function() {}, hooks.RFC_2822 = function() {};
    var prototypeMin = deprecate("moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/", (function() {
     var other = createLocal.apply(null, arguments);
     return this.isValid() && other.isValid() ? other < this ? this : other : createInvalid();
    })), prototypeMax = deprecate("moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/", (function() {
     var other = createLocal.apply(null, arguments);
     return this.isValid() && other.isValid() ? other > this ? this : other : createInvalid();
    }));
    function pickBy(fn, moments) {
     var res, i;
     if (1 === moments.length && isArray(moments[0]) && (moments = moments[0]), !moments.length) return createLocal();
     for (res = moments[0], i = 1; i < moments.length; ++i) moments[i].isValid() && !moments[i][fn](res) || (res = moments[i]);
     return res;
    }
    function min() {
     return pickBy("isBefore", [].slice.call(arguments, 0));
    }
    function max() {
     return pickBy("isAfter", [].slice.call(arguments, 0));
    }
    var now = function() {
     return Date.now ? Date.now() : +new Date;
    }, ordering = [ "year", "quarter", "month", "week", "day", "hour", "minute", "second", "millisecond" ];
    function isDurationValid(m) {
     var key, i, unitHasDecimal = !1, orderLen = ordering.length;
     for (key in m) if (hasOwnProp(m, key) && (-1 === indexOf.call(ordering, key) || null != m[key] && isNaN(m[key]))) return !1;
     for (i = 0; i < orderLen; ++i) if (m[ordering[i]]) {
      if (unitHasDecimal) return !1;
      parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]]) && (unitHasDecimal = !0);
     }
     return !0;
    }
    function isValid$1() {
     return this._isValid;
    }
    function createInvalid$1() {
     return createDuration(NaN);
    }
    function Duration(duration) {
     var normalizedInput = normalizeObjectUnits(duration), years = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months = normalizedInput.month || 0, weeks = normalizedInput.week || normalizedInput.isoWeek || 0, days = normalizedInput.day || 0, hours = normalizedInput.hour || 0, minutes = normalizedInput.minute || 0, seconds = normalizedInput.second || 0, milliseconds = normalizedInput.millisecond || 0;
     this._isValid = isDurationValid(normalizedInput), this._milliseconds = +milliseconds + 1e3 * seconds + 6e4 * minutes + 1e3 * hours * 60 * 60, 
     this._days = +days + 7 * weeks, this._months = +months + 3 * quarters + 12 * years, 
     this._data = {}, this._locale = getLocale(), this._bubble();
    }
    function isDuration(obj) {
     return obj instanceof Duration;
    }
    function absRound(number) {
     return number < 0 ? -1 * Math.round(-1 * number) : Math.round(number);
    }
    function compareArrays(array1, array2, dontConvert) {
     var i, len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0;
     for (i = 0; i < len; i++) (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) && diffs++;
     return diffs + lengthDiff;
    }
    function offset(token, separator) {
     addFormatToken(token, 0, 0, (function() {
      var offset = this.utcOffset(), sign = "+";
      return offset < 0 && (offset = -offset, sign = "-"), sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~offset % 60, 2);
     }));
    }
    offset("Z", ":"), offset("ZZ", ""), addRegexToken("Z", matchShortOffset), addRegexToken("ZZ", matchShortOffset), 
    addParseToken([ "Z", "ZZ" ], (function(input, array, config) {
     config._useUTC = !0, config._tzm = offsetFromString(matchShortOffset, input);
    }));
    var chunkOffset = /([\+\-]|\d\d)/gi;
    function offsetFromString(matcher, string) {
     var parts, minutes, matches = (string || "").match(matcher);
     return null === matches ? null : 0 === (minutes = 60 * (parts = ((matches[matches.length - 1] || []) + "").match(chunkOffset) || [ "-", 0, 0 ])[1] + toInt(parts[2])) ? 0 : "+" === parts[0] ? minutes : -minutes;
    }
    function cloneWithOffset(input, model) {
     var res, diff;
     return model._isUTC ? (res = model.clone(), diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf(), 
     res._d.setTime(res._d.valueOf() + diff), hooks.updateOffset(res, !1), res) : createLocal(input).local();
    }
    function getDateOffset(m) {
     return -Math.round(m._d.getTimezoneOffset());
    }
    function getSetOffset(input, keepLocalTime, keepMinutes) {
     var localAdjust, offset = this._offset || 0;
     if (!this.isValid()) return null != input ? this : NaN;
     if (null != input) {
      if ("string" == typeof input) {
       if (null === (input = offsetFromString(matchShortOffset, input))) return this;
      } else Math.abs(input) < 16 && !keepMinutes && (input *= 60);
      return !this._isUTC && keepLocalTime && (localAdjust = getDateOffset(this)), this._offset = input, 
      this._isUTC = !0, null != localAdjust && this.add(localAdjust, "m"), offset !== input && (!keepLocalTime || this._changeInProgress ? addSubtract(this, createDuration(input - offset, "m"), 1, !1) : this._changeInProgress || (this._changeInProgress = !0, 
      hooks.updateOffset(this, !0), this._changeInProgress = null)), this;
     }
     return this._isUTC ? offset : getDateOffset(this);
    }
    function getSetZone(input, keepLocalTime) {
     return null != input ? ("string" != typeof input && (input = -input), this.utcOffset(input, keepLocalTime), 
     this) : -this.utcOffset();
    }
    function setOffsetToUTC(keepLocalTime) {
     return this.utcOffset(0, keepLocalTime);
    }
    function setOffsetToLocal(keepLocalTime) {
     return this._isUTC && (this.utcOffset(0, keepLocalTime), this._isUTC = !1, keepLocalTime && this.subtract(getDateOffset(this), "m")), 
     this;
    }
    function setOffsetToParsedOffset() {
     if (null != this._tzm) this.utcOffset(this._tzm, !1, !0); else if ("string" == typeof this._i) {
      var tZone = offsetFromString(matchOffset, this._i);
      null != tZone ? this.utcOffset(tZone) : this.utcOffset(0, !0);
     }
     return this;
    }
    function hasAlignedHourOffset(input) {
     return !!this.isValid() && (input = input ? createLocal(input).utcOffset() : 0, 
     (this.utcOffset() - input) % 60 == 0);
    }
    function isDaylightSavingTime() {
     return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
    }
    function isDaylightSavingTimeShifted() {
     if (!isUndefined(this._isDSTShifted)) return this._isDSTShifted;
     var other, c = {};
     return copyConfig(c, this), (c = prepareConfig(c))._a ? (other = c._isUTC ? createUTC(c._a) : createLocal(c._a), 
     this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0) : this._isDSTShifted = !1, 
     this._isDSTShifted;
    }
    function isLocal() {
     return !!this.isValid() && !this._isUTC;
    }
    function isUtcOffset() {
     return !!this.isValid() && this._isUTC;
    }
    function isUtc() {
     return !!this.isValid() && this._isUTC && 0 === this._offset;
    }
    hooks.updateOffset = function() {};
    var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/, isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
    function createDuration(input, key) {
     var sign, ret, diffRes, duration = input, match = null;
     return isDuration(input) ? duration = {
      ms: input._milliseconds,
      d: input._days,
      M: input._months
     } : isNumber(input) || !isNaN(+input) ? (duration = {}, key ? duration[key] = +input : duration.milliseconds = +input) : (match = aspNetRegex.exec(input)) ? (sign = "-" === match[1] ? -1 : 1, 
     duration = {
      y: 0,
      d: toInt(match[DATE]) * sign,
      h: toInt(match[HOUR]) * sign,
      m: toInt(match[MINUTE]) * sign,
      s: toInt(match[SECOND]) * sign,
      ms: toInt(absRound(1e3 * match[MILLISECOND])) * sign
     }) : (match = isoRegex.exec(input)) ? (sign = "-" === match[1] ? -1 : 1, duration = {
      y: parseIso(match[2], sign),
      M: parseIso(match[3], sign),
      w: parseIso(match[4], sign),
      d: parseIso(match[5], sign),
      h: parseIso(match[6], sign),
      m: parseIso(match[7], sign),
      s: parseIso(match[8], sign)
     }) : null == duration ? duration = {} : "object" == typeof duration && ("from" in duration || "to" in duration) && (diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to)), 
     (duration = {}).ms = diffRes.milliseconds, duration.M = diffRes.months), ret = new Duration(duration), 
     isDuration(input) && hasOwnProp(input, "_locale") && (ret._locale = input._locale), 
     isDuration(input) && hasOwnProp(input, "_isValid") && (ret._isValid = input._isValid), 
     ret;
    }
    function parseIso(inp, sign) {
     var res = inp && parseFloat(inp.replace(",", "."));
     return (isNaN(res) ? 0 : res) * sign;
    }
    function positiveMomentsDifference(base, other) {
     var res = {};
     return res.months = other.month() - base.month() + 12 * (other.year() - base.year()), 
     base.clone().add(res.months, "M").isAfter(other) && --res.months, res.milliseconds = +other - +base.clone().add(res.months, "M"), 
     res;
    }
    function momentsDifference(base, other) {
     var res;
     return base.isValid() && other.isValid() ? (other = cloneWithOffset(other, base), 
     base.isBefore(other) ? res = positiveMomentsDifference(base, other) : ((res = positiveMomentsDifference(other, base)).milliseconds = -res.milliseconds, 
     res.months = -res.months), res) : {
      milliseconds: 0,
      months: 0
     };
    }
    function createAdder(direction, name) {
     return function(val, period) {
      var tmp;
      return null === period || isNaN(+period) || (deprecateSimple(name, "moment()." + name + "(period, number) is deprecated. Please use moment()." + name + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."), 
      tmp = val, val = period, period = tmp), addSubtract(this, createDuration(val, period), direction), 
      this;
     };
    }
    function addSubtract(mom, duration, isAdding, updateOffset) {
     var milliseconds = duration._milliseconds, days = absRound(duration._days), months = absRound(duration._months);
     mom.isValid() && (updateOffset = null == updateOffset || updateOffset, months && setMonth(mom, get(mom, "Month") + months * isAdding), 
     days && set$1(mom, "Date", get(mom, "Date") + days * isAdding), milliseconds && mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding), 
     updateOffset && hooks.updateOffset(mom, days || months));
    }
    createDuration.fn = Duration.prototype, createDuration.invalid = createInvalid$1;
    var add = createAdder(1, "add"), subtract = createAdder(-1, "subtract");
    function isString(input) {
     return "string" == typeof input || input instanceof String;
    }
    function isMomentInput(input) {
     return isMoment(input) || isDate(input) || isString(input) || isNumber(input) || isNumberOrStringArray(input) || isMomentInputObject(input) || null == input;
    }
    function isMomentInputObject(input) {
     var i, property, objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = !1, properties = [ "years", "year", "y", "months", "month", "M", "days", "day", "d", "dates", "date", "D", "hours", "hour", "h", "minutes", "minute", "m", "seconds", "second", "s", "milliseconds", "millisecond", "ms" ], propertyLen = properties.length;
     for (i = 0; i < propertyLen; i += 1) property = properties[i], propertyTest = propertyTest || hasOwnProp(input, property);
     return objectTest && propertyTest;
    }
    function isNumberOrStringArray(input) {
     var arrayTest = isArray(input), dataTypeTest = !1;
     return arrayTest && (dataTypeTest = 0 === input.filter((function(item) {
      return !isNumber(item) && isString(input);
     })).length), arrayTest && dataTypeTest;
    }
    function isCalendarSpec(input) {
     var i, property, objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = !1, properties = [ "sameDay", "nextDay", "lastDay", "nextWeek", "lastWeek", "sameElse" ];
     for (i = 0; i < properties.length; i += 1) property = properties[i], propertyTest = propertyTest || hasOwnProp(input, property);
     return objectTest && propertyTest;
    }
    function getCalendarFormat(myMoment, now) {
     var diff = myMoment.diff(now, "days", !0);
     return diff < -6 ? "sameElse" : diff < -1 ? "lastWeek" : diff < 0 ? "lastDay" : diff < 1 ? "sameDay" : diff < 2 ? "nextDay" : diff < 7 ? "nextWeek" : "sameElse";
    }
    function calendar$1(time, formats) {
     1 === arguments.length && (arguments[0] ? isMomentInput(arguments[0]) ? (time = arguments[0], 
     formats = void 0) : isCalendarSpec(arguments[0]) && (formats = arguments[0], time = void 0) : (time = void 0, 
     formats = void 0));
     var now = time || createLocal(), sod = cloneWithOffset(now, this).startOf("day"), format = hooks.calendarFormat(this, sod) || "sameElse", output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);
     return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
    }
    function clone() {
     return new Moment(this);
    }
    function isAfter(input, units) {
     var localInput = isMoment(input) ? input : createLocal(input);
     return !(!this.isValid() || !localInput.isValid()) && ("millisecond" === (units = normalizeUnits(units) || "millisecond") ? this.valueOf() > localInput.valueOf() : localInput.valueOf() < this.clone().startOf(units).valueOf());
    }
    function isBefore(input, units) {
     var localInput = isMoment(input) ? input : createLocal(input);
     return !(!this.isValid() || !localInput.isValid()) && ("millisecond" === (units = normalizeUnits(units) || "millisecond") ? this.valueOf() < localInput.valueOf() : this.clone().endOf(units).valueOf() < localInput.valueOf());
    }
    function isBetween(from, to, units, inclusivity) {
     var localFrom = isMoment(from) ? from : createLocal(from), localTo = isMoment(to) ? to : createLocal(to);
     return !!(this.isValid() && localFrom.isValid() && localTo.isValid()) && ("(" === (inclusivity = inclusivity || "()")[0] ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (")" === inclusivity[1] ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
    }
    function isSame(input, units) {
     var inputMs, localInput = isMoment(input) ? input : createLocal(input);
     return !(!this.isValid() || !localInput.isValid()) && ("millisecond" === (units = normalizeUnits(units) || "millisecond") ? this.valueOf() === localInput.valueOf() : (inputMs = localInput.valueOf(), 
     this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf()));
    }
    function isSameOrAfter(input, units) {
     return this.isSame(input, units) || this.isAfter(input, units);
    }
    function isSameOrBefore(input, units) {
     return this.isSame(input, units) || this.isBefore(input, units);
    }
    function diff(input, units, asFloat) {
     var that, zoneDelta, output;
     if (!this.isValid()) return NaN;
     if (!(that = cloneWithOffset(input, this)).isValid()) return NaN;
     switch (zoneDelta = 6e4 * (that.utcOffset() - this.utcOffset()), units = normalizeUnits(units)) {
     case "year":
      output = monthDiff(this, that) / 12;
      break;

     case "month":
      output = monthDiff(this, that);
      break;

     case "quarter":
      output = monthDiff(this, that) / 3;
      break;

     case "second":
      output = (this - that) / 1e3;
      break;

     case "minute":
      output = (this - that) / 6e4;
      break;

     case "hour":
      output = (this - that) / 36e5;
      break;

     case "day":
      output = (this - that - zoneDelta) / 864e5;
      break;

     case "week":
      output = (this - that - zoneDelta) / 6048e5;
      break;

     default:
      output = this - that;
     }
     return asFloat ? output : absFloor(output);
    }
    function monthDiff(a, b) {
     if (a.date() < b.date()) return -monthDiff(b, a);
     var wholeMonthDiff = 12 * (b.year() - a.year()) + (b.month() - a.month()), anchor = a.clone().add(wholeMonthDiff, "months");
     return -(wholeMonthDiff + (b - anchor < 0 ? (b - anchor) / (anchor - a.clone().add(wholeMonthDiff - 1, "months")) : (b - anchor) / (a.clone().add(wholeMonthDiff + 1, "months") - anchor))) || 0;
    }
    function toString() {
     return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
    }
    function toISOString(keepOffset) {
     if (!this.isValid()) return null;
     var utc = !0 !== keepOffset, m = utc ? this.clone().utc() : this;
     return m.year() < 0 || m.year() > 9999 ? formatMoment(m, utc ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ") : isFunction(Date.prototype.toISOString) ? utc ? this.toDate().toISOString() : new Date(this.valueOf() + 60 * this.utcOffset() * 1e3).toISOString().replace("Z", formatMoment(m, "Z")) : formatMoment(m, utc ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ");
    }
    function inspect() {
     if (!this.isValid()) return "moment.invalid(/* " + this._i + " */)";
     var prefix, year, datetime, suffix, func = "moment", zone = "";
     return this.isLocal() || (func = 0 === this.utcOffset() ? "moment.utc" : "moment.parseZone", 
     zone = "Z"), prefix = "[" + func + '("]', year = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY", 
     datetime = "-MM-DD[T]HH:mm:ss.SSS", suffix = zone + '[")]', this.format(prefix + year + datetime + suffix);
    }
    function format(inputString) {
     inputString || (inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat);
     var output = formatMoment(this, inputString);
     return this.localeData().postformat(output);
    }
    function from(time, withoutSuffix) {
     return this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid()) ? createDuration({
      to: this,
      from: time
     }).locale(this.locale()).humanize(!withoutSuffix) : this.localeData().invalidDate();
    }
    function fromNow(withoutSuffix) {
     return this.from(createLocal(), withoutSuffix);
    }
    function to(time, withoutSuffix) {
     return this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid()) ? createDuration({
      from: this,
      to: time
     }).locale(this.locale()).humanize(!withoutSuffix) : this.localeData().invalidDate();
    }
    function toNow(withoutSuffix) {
     return this.to(createLocal(), withoutSuffix);
    }
    function locale(key) {
     var newLocaleData;
     return void 0 === key ? this._locale._abbr : (null != (newLocaleData = getLocale(key)) && (this._locale = newLocaleData), 
     this);
    }
    hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ", hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
    var lang = deprecate("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.", (function(key) {
     return void 0 === key ? this.localeData() : this.locale(key);
    }));
    function localeData() {
     return this._locale;
    }
    var MS_PER_SECOND = 1e3, MS_PER_MINUTE = 60 * MS_PER_SECOND, MS_PER_HOUR = 60 * MS_PER_MINUTE, MS_PER_400_YEARS = 3506328 * MS_PER_HOUR;
    function mod$1(dividend, divisor) {
     return (dividend % divisor + divisor) % divisor;
    }
    function localStartOfDate(y, m, d) {
     return y < 100 && y >= 0 ? new Date(y + 400, m, d) - MS_PER_400_YEARS : new Date(y, m, d).valueOf();
    }
    function utcStartOfDate(y, m, d) {
     return y < 100 && y >= 0 ? Date.UTC(y + 400, m, d) - MS_PER_400_YEARS : Date.UTC(y, m, d);
    }
    function startOf(units) {
     var time, startOfDate;
     if (void 0 === (units = normalizeUnits(units)) || "millisecond" === units || !this.isValid()) return this;
     switch (startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate, units) {
     case "year":
      time = startOfDate(this.year(), 0, 1);
      break;

     case "quarter":
      time = startOfDate(this.year(), this.month() - this.month() % 3, 1);
      break;

     case "month":
      time = startOfDate(this.year(), this.month(), 1);
      break;

     case "week":
      time = startOfDate(this.year(), this.month(), this.date() - this.weekday());
      break;

     case "isoWeek":
      time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));
      break;

     case "day":
     case "date":
      time = startOfDate(this.year(), this.month(), this.date());
      break;

     case "hour":
      time = this._d.valueOf(), time -= mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR);
      break;

     case "minute":
      time = this._d.valueOf(), time -= mod$1(time, MS_PER_MINUTE);
      break;

     case "second":
      time = this._d.valueOf(), time -= mod$1(time, MS_PER_SECOND);
     }
     return this._d.setTime(time), hooks.updateOffset(this, !0), this;
    }
    function endOf(units) {
     var time, startOfDate;
     if (void 0 === (units = normalizeUnits(units)) || "millisecond" === units || !this.isValid()) return this;
     switch (startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate, units) {
     case "year":
      time = startOfDate(this.year() + 1, 0, 1) - 1;
      break;

     case "quarter":
      time = startOfDate(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;
      break;

     case "month":
      time = startOfDate(this.year(), this.month() + 1, 1) - 1;
      break;

     case "week":
      time = startOfDate(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;
      break;

     case "isoWeek":
      time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;
      break;

     case "day":
     case "date":
      time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
      break;

     case "hour":
      time = this._d.valueOf(), time += MS_PER_HOUR - mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR) - 1;
      break;

     case "minute":
      time = this._d.valueOf(), time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
      break;

     case "second":
      time = this._d.valueOf(), time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
     }
     return this._d.setTime(time), hooks.updateOffset(this, !0), this;
    }
    function valueOf() {
     return this._d.valueOf() - 6e4 * (this._offset || 0);
    }
    function unix() {
     return Math.floor(this.valueOf() / 1e3);
    }
    function toDate() {
     return new Date(this.valueOf());
    }
    function toArray() {
     var m = this;
     return [ m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond() ];
    }
    function toObject() {
     var m = this;
     return {
      years: m.year(),
      months: m.month(),
      date: m.date(),
      hours: m.hours(),
      minutes: m.minutes(),
      seconds: m.seconds(),
      milliseconds: m.milliseconds()
     };
    }
    function toJSON() {
     return this.isValid() ? this.toISOString() : null;
    }
    function isValid$2() {
     return isValid(this);
    }
    function parsingFlags() {
     return extend({}, getParsingFlags(this));
    }
    function invalidAt() {
     return getParsingFlags(this).overflow;
    }
    function creationData() {
     return {
      input: this._i,
      format: this._f,
      locale: this._locale,
      isUTC: this._isUTC,
      strict: this._strict
     };
    }
    function localeEras(m, format) {
     var i, l, date, eras = this._eras || getLocale("en")._eras;
     for (i = 0, l = eras.length; i < l; ++i) switch ("string" == typeof eras[i].since && (date = hooks(eras[i].since).startOf("day"), 
     eras[i].since = date.valueOf()), typeof eras[i].until) {
     case "undefined":
      eras[i].until = 1 / 0;
      break;

     case "string":
      date = hooks(eras[i].until).startOf("day").valueOf(), eras[i].until = date.valueOf();
     }
     return eras;
    }
    function localeErasParse(eraName, format, strict) {
     var i, l, name, abbr, narrow, eras = this.eras();
     for (eraName = eraName.toUpperCase(), i = 0, l = eras.length; i < l; ++i) if (name = eras[i].name.toUpperCase(), 
     abbr = eras[i].abbr.toUpperCase(), narrow = eras[i].narrow.toUpperCase(), strict) switch (format) {
     case "N":
     case "NN":
     case "NNN":
      if (abbr === eraName) return eras[i];
      break;

     case "NNNN":
      if (name === eraName) return eras[i];
      break;

     case "NNNNN":
      if (narrow === eraName) return eras[i];
     } else if ([ name, abbr, narrow ].indexOf(eraName) >= 0) return eras[i];
    }
    function localeErasConvertYear(era, year) {
     var dir = era.since <= era.until ? 1 : -1;
     return void 0 === year ? hooks(era.since).year() : hooks(era.since).year() + (year - era.offset) * dir;
    }
    function getEraName() {
     var i, l, val, eras = this.localeData().eras();
     for (i = 0, l = eras.length; i < l; ++i) {
      if (val = this.clone().startOf("day").valueOf(), eras[i].since <= val && val <= eras[i].until) return eras[i].name;
      if (eras[i].until <= val && val <= eras[i].since) return eras[i].name;
     }
     return "";
    }
    function getEraNarrow() {
     var i, l, val, eras = this.localeData().eras();
     for (i = 0, l = eras.length; i < l; ++i) {
      if (val = this.clone().startOf("day").valueOf(), eras[i].since <= val && val <= eras[i].until) return eras[i].narrow;
      if (eras[i].until <= val && val <= eras[i].since) return eras[i].narrow;
     }
     return "";
    }
    function getEraAbbr() {
     var i, l, val, eras = this.localeData().eras();
     for (i = 0, l = eras.length; i < l; ++i) {
      if (val = this.clone().startOf("day").valueOf(), eras[i].since <= val && val <= eras[i].until) return eras[i].abbr;
      if (eras[i].until <= val && val <= eras[i].since) return eras[i].abbr;
     }
     return "";
    }
    function getEraYear() {
     var i, l, dir, val, eras = this.localeData().eras();
     for (i = 0, l = eras.length; i < l; ++i) if (dir = eras[i].since <= eras[i].until ? 1 : -1, 
     val = this.clone().startOf("day").valueOf(), eras[i].since <= val && val <= eras[i].until || eras[i].until <= val && val <= eras[i].since) return (this.year() - hooks(eras[i].since).year()) * dir + eras[i].offset;
     return this.year();
    }
    function erasNameRegex(isStrict) {
     return hasOwnProp(this, "_erasNameRegex") || computeErasParse.call(this), isStrict ? this._erasNameRegex : this._erasRegex;
    }
    function erasAbbrRegex(isStrict) {
     return hasOwnProp(this, "_erasAbbrRegex") || computeErasParse.call(this), isStrict ? this._erasAbbrRegex : this._erasRegex;
    }
    function erasNarrowRegex(isStrict) {
     return hasOwnProp(this, "_erasNarrowRegex") || computeErasParse.call(this), isStrict ? this._erasNarrowRegex : this._erasRegex;
    }
    function matchEraAbbr(isStrict, locale) {
     return locale.erasAbbrRegex(isStrict);
    }
    function matchEraName(isStrict, locale) {
     return locale.erasNameRegex(isStrict);
    }
    function matchEraNarrow(isStrict, locale) {
     return locale.erasNarrowRegex(isStrict);
    }
    function matchEraYearOrdinal(isStrict, locale) {
     return locale._eraYearOrdinalRegex || matchUnsigned;
    }
    function computeErasParse() {
     var i, l, erasName, erasAbbr, erasNarrow, abbrPieces = [], namePieces = [], narrowPieces = [], mixedPieces = [], eras = this.eras();
     for (i = 0, l = eras.length; i < l; ++i) erasName = regexEscape(eras[i].name), erasAbbr = regexEscape(eras[i].abbr), 
     erasNarrow = regexEscape(eras[i].narrow), namePieces.push(erasName), abbrPieces.push(erasAbbr), 
     narrowPieces.push(erasNarrow), mixedPieces.push(erasName), mixedPieces.push(erasAbbr), 
     mixedPieces.push(erasNarrow);
     this._erasRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i"), this._erasNameRegex = new RegExp("^(" + namePieces.join("|") + ")", "i"), 
     this._erasAbbrRegex = new RegExp("^(" + abbrPieces.join("|") + ")", "i"), this._erasNarrowRegex = new RegExp("^(" + narrowPieces.join("|") + ")", "i");
    }
    function addWeekYearFormatToken(token, getter) {
     addFormatToken(0, [ token, token.length ], 0, getter);
    }
    function getSetWeekYear(input) {
     return getSetWeekYearHelper.call(this, input, this.week(), this.weekday() + this.localeData()._week.dow, this.localeData()._week.dow, this.localeData()._week.doy);
    }
    function getSetISOWeekYear(input) {
     return getSetWeekYearHelper.call(this, input, this.isoWeek(), this.isoWeekday(), 1, 4);
    }
    function getISOWeeksInYear() {
     return weeksInYear(this.year(), 1, 4);
    }
    function getISOWeeksInISOWeekYear() {
     return weeksInYear(this.isoWeekYear(), 1, 4);
    }
    function getWeeksInYear() {
     var weekInfo = this.localeData()._week;
     return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }
    function getWeeksInWeekYear() {
     var weekInfo = this.localeData()._week;
     return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
    }
    function getSetWeekYearHelper(input, week, weekday, dow, doy) {
     var weeksTarget;
     return null == input ? weekOfYear(this, dow, doy).year : (week > (weeksTarget = weeksInYear(input, dow, doy)) && (week = weeksTarget), 
     setWeekAll.call(this, input, week, weekday, dow, doy));
    }
    function setWeekAll(weekYear, week, weekday, dow, doy) {
     var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy), date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
     return this.year(date.getUTCFullYear()), this.month(date.getUTCMonth()), this.date(date.getUTCDate()), 
     this;
    }
    function getSetQuarter(input) {
     return null == input ? Math.ceil((this.month() + 1) / 3) : this.month(3 * (input - 1) + this.month() % 3);
    }
    addFormatToken("N", 0, 0, "eraAbbr"), addFormatToken("NN", 0, 0, "eraAbbr"), addFormatToken("NNN", 0, 0, "eraAbbr"), 
    addFormatToken("NNNN", 0, 0, "eraName"), addFormatToken("NNNNN", 0, 0, "eraNarrow"), 
    addFormatToken("y", [ "y", 1 ], "yo", "eraYear"), addFormatToken("y", [ "yy", 2 ], 0, "eraYear"), 
    addFormatToken("y", [ "yyy", 3 ], 0, "eraYear"), addFormatToken("y", [ "yyyy", 4 ], 0, "eraYear"), 
    addRegexToken("N", matchEraAbbr), addRegexToken("NN", matchEraAbbr), addRegexToken("NNN", matchEraAbbr), 
    addRegexToken("NNNN", matchEraName), addRegexToken("NNNNN", matchEraNarrow), addParseToken([ "N", "NN", "NNN", "NNNN", "NNNNN" ], (function(input, array, config, token) {
     var era = config._locale.erasParse(input, token, config._strict);
     era ? getParsingFlags(config).era = era : getParsingFlags(config).invalidEra = input;
    })), addRegexToken("y", matchUnsigned), addRegexToken("yy", matchUnsigned), addRegexToken("yyy", matchUnsigned), 
    addRegexToken("yyyy", matchUnsigned), addRegexToken("yo", matchEraYearOrdinal), 
    addParseToken([ "y", "yy", "yyy", "yyyy" ], YEAR), addParseToken([ "yo" ], (function(input, array, config, token) {
     var match;
     config._locale._eraYearOrdinalRegex && (match = input.match(config._locale._eraYearOrdinalRegex)), 
     config._locale.eraYearOrdinalParse ? array[YEAR] = config._locale.eraYearOrdinalParse(input, match) : array[YEAR] = parseInt(input, 10);
    })), addFormatToken(0, [ "gg", 2 ], 0, (function() {
     return this.weekYear() % 100;
    })), addFormatToken(0, [ "GG", 2 ], 0, (function() {
     return this.isoWeekYear() % 100;
    })), addWeekYearFormatToken("gggg", "weekYear"), addWeekYearFormatToken("ggggg", "weekYear"), 
    addWeekYearFormatToken("GGGG", "isoWeekYear"), addWeekYearFormatToken("GGGGG", "isoWeekYear"), 
    addRegexToken("G", matchSigned), addRegexToken("g", matchSigned), addRegexToken("GG", match1to2, match2), 
    addRegexToken("gg", match1to2, match2), addRegexToken("GGGG", match1to4, match4), 
    addRegexToken("gggg", match1to4, match4), addRegexToken("GGGGG", match1to6, match6), 
    addRegexToken("ggggg", match1to6, match6), addWeekParseToken([ "gggg", "ggggg", "GGGG", "GGGGG" ], (function(input, week, config, token) {
     week[token.substr(0, 2)] = toInt(input);
    })), addWeekParseToken([ "gg", "GG" ], (function(input, week, config, token) {
     week[token] = hooks.parseTwoDigitYear(input);
    })), addFormatToken("Q", 0, "Qo", "quarter"), addRegexToken("Q", match1), addParseToken("Q", (function(input, array) {
     array[MONTH] = 3 * (toInt(input) - 1);
    })), addFormatToken("D", [ "DD", 2 ], "Do", "date"), addRegexToken("D", match1to2, match1to2NoLeadingZero), 
    addRegexToken("DD", match1to2, match2), addRegexToken("Do", (function(isStrict, locale) {
     return isStrict ? locale._dayOfMonthOrdinalParse || locale._ordinalParse : locale._dayOfMonthOrdinalParseLenient;
    })), addParseToken([ "D", "DD" ], DATE), addParseToken("Do", (function(input, array) {
     array[DATE] = toInt(input.match(match1to2)[0]);
    }));
    var getSetDayOfMonth = makeGetSet("Date", !0);
    function getSetDayOfYear(input) {
     var dayOfYear = Math.round((this.clone().startOf("day") - this.clone().startOf("year")) / 864e5) + 1;
     return null == input ? dayOfYear : this.add(input - dayOfYear, "d");
    }
    addFormatToken("DDD", [ "DDDD", 3 ], "DDDo", "dayOfYear"), addRegexToken("DDD", match1to3), 
    addRegexToken("DDDD", match3), addParseToken([ "DDD", "DDDD" ], (function(input, array, config) {
     config._dayOfYear = toInt(input);
    })), addFormatToken("m", [ "mm", 2 ], 0, "minute"), addRegexToken("m", match1to2, match1to2HasZero), 
    addRegexToken("mm", match1to2, match2), addParseToken([ "m", "mm" ], MINUTE);
    var getSetMinute = makeGetSet("Minutes", !1);
    addFormatToken("s", [ "ss", 2 ], 0, "second"), addRegexToken("s", match1to2, match1to2HasZero), 
    addRegexToken("ss", match1to2, match2), addParseToken([ "s", "ss" ], SECOND);
    var token, getSetMillisecond, getSetSecond = makeGetSet("Seconds", !1);
    for (addFormatToken("S", 0, 0, (function() {
     return ~~(this.millisecond() / 100);
    })), addFormatToken(0, [ "SS", 2 ], 0, (function() {
     return ~~(this.millisecond() / 10);
    })), addFormatToken(0, [ "SSS", 3 ], 0, "millisecond"), addFormatToken(0, [ "SSSS", 4 ], 0, (function() {
     return 10 * this.millisecond();
    })), addFormatToken(0, [ "SSSSS", 5 ], 0, (function() {
     return 100 * this.millisecond();
    })), addFormatToken(0, [ "SSSSSS", 6 ], 0, (function() {
     return 1e3 * this.millisecond();
    })), addFormatToken(0, [ "SSSSSSS", 7 ], 0, (function() {
     return 1e4 * this.millisecond();
    })), addFormatToken(0, [ "SSSSSSSS", 8 ], 0, (function() {
     return 1e5 * this.millisecond();
    })), addFormatToken(0, [ "SSSSSSSSS", 9 ], 0, (function() {
     return 1e6 * this.millisecond();
    })), addRegexToken("S", match1to3, match1), addRegexToken("SS", match1to3, match2), 
    addRegexToken("SSS", match1to3, match3), token = "SSSS"; token.length <= 9; token += "S") addRegexToken(token, matchUnsigned);
    function parseMs(input, array) {
     array[MILLISECOND] = toInt(1e3 * ("0." + input));
    }
    for (token = "S"; token.length <= 9; token += "S") addParseToken(token, parseMs);
    function getZoneAbbr() {
     return this._isUTC ? "UTC" : "";
    }
    function getZoneName() {
     return this._isUTC ? "Coordinated Universal Time" : "";
    }
    getSetMillisecond = makeGetSet("Milliseconds", !1), addFormatToken("z", 0, 0, "zoneAbbr"), 
    addFormatToken("zz", 0, 0, "zoneName");
    var proto = Moment.prototype;
    function createUnix(input) {
     return createLocal(1e3 * input);
    }
    function createInZone() {
     return createLocal.apply(null, arguments).parseZone();
    }
    function preParsePostFormat(string) {
     return string;
    }
    proto.add = add, proto.calendar = calendar$1, proto.clone = clone, proto.diff = diff, 
    proto.endOf = endOf, proto.format = format, proto.from = from, proto.fromNow = fromNow, 
    proto.to = to, proto.toNow = toNow, proto.get = stringGet, proto.invalidAt = invalidAt, 
    proto.isAfter = isAfter, proto.isBefore = isBefore, proto.isBetween = isBetween, 
    proto.isSame = isSame, proto.isSameOrAfter = isSameOrAfter, proto.isSameOrBefore = isSameOrBefore, 
    proto.isValid = isValid$2, proto.lang = lang, proto.locale = locale, proto.localeData = localeData, 
    proto.max = prototypeMax, proto.min = prototypeMin, proto.parsingFlags = parsingFlags, 
    proto.set = stringSet, proto.startOf = startOf, proto.subtract = subtract, proto.toArray = toArray, 
    proto.toObject = toObject, proto.toDate = toDate, proto.toISOString = toISOString, 
    proto.inspect = inspect, "undefined" != typeof Symbol && null != Symbol.for && (proto[Symbol.for("nodejs.util.inspect.custom")] = function() {
     return "Moment<" + this.format() + ">";
    }), proto.toJSON = toJSON, proto.toString = toString, proto.unix = unix, proto.valueOf = valueOf, 
    proto.creationData = creationData, proto.eraName = getEraName, proto.eraNarrow = getEraNarrow, 
    proto.eraAbbr = getEraAbbr, proto.eraYear = getEraYear, proto.year = getSetYear, 
    proto.isLeapYear = getIsLeapYear, proto.weekYear = getSetWeekYear, proto.isoWeekYear = getSetISOWeekYear, 
    proto.quarter = proto.quarters = getSetQuarter, proto.month = getSetMonth, proto.daysInMonth = getDaysInMonth, 
    proto.week = proto.weeks = getSetWeek, proto.isoWeek = proto.isoWeeks = getSetISOWeek, 
    proto.weeksInYear = getWeeksInYear, proto.weeksInWeekYear = getWeeksInWeekYear, 
    proto.isoWeeksInYear = getISOWeeksInYear, proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear, 
    proto.date = getSetDayOfMonth, proto.day = proto.days = getSetDayOfWeek, proto.weekday = getSetLocaleDayOfWeek, 
    proto.isoWeekday = getSetISODayOfWeek, proto.dayOfYear = getSetDayOfYear, proto.hour = proto.hours = getSetHour, 
    proto.minute = proto.minutes = getSetMinute, proto.second = proto.seconds = getSetSecond, 
    proto.millisecond = proto.milliseconds = getSetMillisecond, proto.utcOffset = getSetOffset, 
    proto.utc = setOffsetToUTC, proto.local = setOffsetToLocal, proto.parseZone = setOffsetToParsedOffset, 
    proto.hasAlignedHourOffset = hasAlignedHourOffset, proto.isDST = isDaylightSavingTime, 
    proto.isLocal = isLocal, proto.isUtcOffset = isUtcOffset, proto.isUtc = isUtc, proto.isUTC = isUtc, 
    proto.zoneAbbr = getZoneAbbr, proto.zoneName = getZoneName, proto.dates = deprecate("dates accessor is deprecated. Use date instead.", getSetDayOfMonth), 
    proto.months = deprecate("months accessor is deprecated. Use month instead", getSetMonth), 
    proto.years = deprecate("years accessor is deprecated. Use year instead", getSetYear), 
    proto.zone = deprecate("moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/", getSetZone), 
    proto.isDSTShifted = deprecate("isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information", isDaylightSavingTimeShifted);
    var proto$1 = Locale.prototype;
    function get$1(format, index, field, setter) {
     var locale = getLocale(), utc = createUTC().set(setter, index);
     return locale[field](utc, format);
    }
    function listMonthsImpl(format, index, field) {
     if (isNumber(format) && (index = format, format = void 0), format = format || "", 
     null != index) return get$1(format, index, field, "month");
     var i, out = [];
     for (i = 0; i < 12; i++) out[i] = get$1(format, i, field, "month");
     return out;
    }
    function listWeekdaysImpl(localeSorted, format, index, field) {
     "boolean" == typeof localeSorted ? (isNumber(format) && (index = format, format = void 0), 
     format = format || "") : (index = format = localeSorted, localeSorted = !1, isNumber(format) && (index = format, 
     format = void 0), format = format || "");
     var i, locale = getLocale(), shift = localeSorted ? locale._week.dow : 0, out = [];
     if (null != index) return get$1(format, (index + shift) % 7, field, "day");
     for (i = 0; i < 7; i++) out[i] = get$1(format, (i + shift) % 7, field, "day");
     return out;
    }
    function listMonths(format, index) {
     return listMonthsImpl(format, index, "months");
    }
    function listMonthsShort(format, index) {
     return listMonthsImpl(format, index, "monthsShort");
    }
    function listWeekdays(localeSorted, format, index) {
     return listWeekdaysImpl(localeSorted, format, index, "weekdays");
    }
    function listWeekdaysShort(localeSorted, format, index) {
     return listWeekdaysImpl(localeSorted, format, index, "weekdaysShort");
    }
    function listWeekdaysMin(localeSorted, format, index) {
     return listWeekdaysImpl(localeSorted, format, index, "weekdaysMin");
    }
    proto$1.calendar = calendar, proto$1.longDateFormat = longDateFormat, proto$1.invalidDate = invalidDate, 
    proto$1.ordinal = ordinal, proto$1.preparse = preParsePostFormat, proto$1.postformat = preParsePostFormat, 
    proto$1.relativeTime = relativeTime, proto$1.pastFuture = pastFuture, proto$1.set = set, 
    proto$1.eras = localeEras, proto$1.erasParse = localeErasParse, proto$1.erasConvertYear = localeErasConvertYear, 
    proto$1.erasAbbrRegex = erasAbbrRegex, proto$1.erasNameRegex = erasNameRegex, proto$1.erasNarrowRegex = erasNarrowRegex, 
    proto$1.months = localeMonths, proto$1.monthsShort = localeMonthsShort, proto$1.monthsParse = localeMonthsParse, 
    proto$1.monthsRegex = monthsRegex, proto$1.monthsShortRegex = monthsShortRegex, 
    proto$1.week = localeWeek, proto$1.firstDayOfYear = localeFirstDayOfYear, proto$1.firstDayOfWeek = localeFirstDayOfWeek, 
    proto$1.weekdays = localeWeekdays, proto$1.weekdaysMin = localeWeekdaysMin, proto$1.weekdaysShort = localeWeekdaysShort, 
    proto$1.weekdaysParse = localeWeekdaysParse, proto$1.weekdaysRegex = weekdaysRegex, 
    proto$1.weekdaysShortRegex = weekdaysShortRegex, proto$1.weekdaysMinRegex = weekdaysMinRegex, 
    proto$1.isPM = localeIsPM, proto$1.meridiem = localeMeridiem, getSetGlobalLocale("en", {
     eras: [ {
      since: "0001-01-01",
      until: 1 / 0,
      offset: 1,
      name: "Anno Domini",
      narrow: "AD",
      abbr: "AD"
     }, {
      since: "0000-12-31",
      until: -1 / 0,
      offset: 1,
      name: "Before Christ",
      narrow: "BC",
      abbr: "BC"
     } ],
     dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
     ordinal: function(number) {
      var b = number % 10;
      return number + (1 === toInt(number % 100 / 10) ? "th" : 1 === b ? "st" : 2 === b ? "nd" : 3 === b ? "rd" : "th");
     }
    }), hooks.lang = deprecate("moment.lang is deprecated. Use moment.locale instead.", getSetGlobalLocale), 
    hooks.langData = deprecate("moment.langData is deprecated. Use moment.localeData instead.", getLocale);
    var mathAbs = Math.abs;
    function abs() {
     var data = this._data;
     return this._milliseconds = mathAbs(this._milliseconds), this._days = mathAbs(this._days), 
     this._months = mathAbs(this._months), data.milliseconds = mathAbs(data.milliseconds), 
     data.seconds = mathAbs(data.seconds), data.minutes = mathAbs(data.minutes), data.hours = mathAbs(data.hours), 
     data.months = mathAbs(data.months), data.years = mathAbs(data.years), this;
    }
    function addSubtract$1(duration, input, value, direction) {
     var other = createDuration(input, value);
     return duration._milliseconds += direction * other._milliseconds, duration._days += direction * other._days, 
     duration._months += direction * other._months, duration._bubble();
    }
    function add$1(input, value) {
     return addSubtract$1(this, input, value, 1);
    }
    function subtract$1(input, value) {
     return addSubtract$1(this, input, value, -1);
    }
    function absCeil(number) {
     return number < 0 ? Math.floor(number) : Math.ceil(number);
    }
    function bubble() {
     var seconds, minutes, hours, years, monthsFromDays, milliseconds = this._milliseconds, days = this._days, months = this._months, data = this._data;
     return milliseconds >= 0 && days >= 0 && months >= 0 || milliseconds <= 0 && days <= 0 && months <= 0 || (milliseconds += 864e5 * absCeil(monthsToDays(months) + days), 
     days = 0, months = 0), data.milliseconds = milliseconds % 1e3, seconds = absFloor(milliseconds / 1e3), 
     data.seconds = seconds % 60, minutes = absFloor(seconds / 60), data.minutes = minutes % 60, 
     hours = absFloor(minutes / 60), data.hours = hours % 24, days += absFloor(hours / 24), 
     months += monthsFromDays = absFloor(daysToMonths(days)), days -= absCeil(monthsToDays(monthsFromDays)), 
     years = absFloor(months / 12), months %= 12, data.days = days, data.months = months, 
     data.years = years, this;
    }
    function daysToMonths(days) {
     return 4800 * days / 146097;
    }
    function monthsToDays(months) {
     return 146097 * months / 4800;
    }
    function as(units) {
     if (!this.isValid()) return NaN;
     var days, months, milliseconds = this._milliseconds;
     if ("month" === (units = normalizeUnits(units)) || "quarter" === units || "year" === units) switch (days = this._days + milliseconds / 864e5, 
     months = this._months + daysToMonths(days), units) {
     case "month":
      return months;

     case "quarter":
      return months / 3;

     case "year":
      return months / 12;
     } else switch (days = this._days + Math.round(monthsToDays(this._months)), units) {
     case "week":
      return days / 7 + milliseconds / 6048e5;

     case "day":
      return days + milliseconds / 864e5;

     case "hour":
      return 24 * days + milliseconds / 36e5;

     case "minute":
      return 1440 * days + milliseconds / 6e4;

     case "second":
      return 86400 * days + milliseconds / 1e3;

     case "millisecond":
      return Math.floor(864e5 * days) + milliseconds;

     default:
      throw new Error("Unknown unit " + units);
     }
    }
    function makeAs(alias) {
     return function() {
      return this.as(alias);
     };
    }
    var asMilliseconds = makeAs("ms"), asSeconds = makeAs("s"), asMinutes = makeAs("m"), asHours = makeAs("h"), asDays = makeAs("d"), asWeeks = makeAs("w"), asMonths = makeAs("M"), asQuarters = makeAs("Q"), asYears = makeAs("y"), valueOf$1 = asMilliseconds;
    function clone$1() {
     return createDuration(this);
    }
    function get$2(units) {
     return units = normalizeUnits(units), this.isValid() ? this[units + "s"]() : NaN;
    }
    function makeGetter(name) {
     return function() {
      return this.isValid() ? this._data[name] : NaN;
     };
    }
    var milliseconds = makeGetter("milliseconds"), seconds = makeGetter("seconds"), minutes = makeGetter("minutes"), hours = makeGetter("hours"), days = makeGetter("days"), months = makeGetter("months"), years = makeGetter("years");
    function weeks() {
     return absFloor(this.days() / 7);
    }
    var round = Math.round, thresholds = {
     ss: 44,
     s: 45,
     m: 45,
     h: 22,
     d: 26,
     w: null,
     M: 11
    };
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
     return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }
    function relativeTime$1(posNegDuration, withoutSuffix, thresholds, locale) {
     var duration = createDuration(posNegDuration).abs(), seconds = round(duration.as("s")), minutes = round(duration.as("m")), hours = round(duration.as("h")), days = round(duration.as("d")), months = round(duration.as("M")), weeks = round(duration.as("w")), years = round(duration.as("y")), a = seconds <= thresholds.ss && [ "s", seconds ] || seconds < thresholds.s && [ "ss", seconds ] || minutes <= 1 && [ "m" ] || minutes < thresholds.m && [ "mm", minutes ] || hours <= 1 && [ "h" ] || hours < thresholds.h && [ "hh", hours ] || days <= 1 && [ "d" ] || days < thresholds.d && [ "dd", days ];
     return null != thresholds.w && (a = a || weeks <= 1 && [ "w" ] || weeks < thresholds.w && [ "ww", weeks ]), 
     (a = a || months <= 1 && [ "M" ] || months < thresholds.M && [ "MM", months ] || years <= 1 && [ "y" ] || [ "yy", years ])[2] = withoutSuffix, 
     a[3] = +posNegDuration > 0, a[4] = locale, substituteTimeAgo.apply(null, a);
    }
    function getSetRelativeTimeRounding(roundingFunction) {
     return void 0 === roundingFunction ? round : "function" == typeof roundingFunction && (round = roundingFunction, 
     !0);
    }
    function getSetRelativeTimeThreshold(threshold, limit) {
     return void 0 !== thresholds[threshold] && (void 0 === limit ? thresholds[threshold] : (thresholds[threshold] = limit, 
     "s" === threshold && (thresholds.ss = limit - 1), !0));
    }
    function humanize(argWithSuffix, argThresholds) {
     if (!this.isValid()) return this.localeData().invalidDate();
     var locale, output, withSuffix = !1, th = thresholds;
     return "object" == typeof argWithSuffix && (argThresholds = argWithSuffix, argWithSuffix = !1), 
     "boolean" == typeof argWithSuffix && (withSuffix = argWithSuffix), "object" == typeof argThresholds && (th = Object.assign({}, thresholds, argThresholds), 
     null != argThresholds.s && null == argThresholds.ss && (th.ss = argThresholds.s - 1)), 
     output = relativeTime$1(this, !withSuffix, th, locale = this.localeData()), withSuffix && (output = locale.pastFuture(+this, output)), 
     locale.postformat(output);
    }
    var abs$1 = Math.abs;
    function sign(x) {
     return (x > 0) - (x < 0) || +x;
    }
    function toISOString$1() {
     if (!this.isValid()) return this.localeData().invalidDate();
     var minutes, hours, years, s, totalSign, ymSign, daysSign, hmsSign, seconds = abs$1(this._milliseconds) / 1e3, days = abs$1(this._days), months = abs$1(this._months), total = this.asSeconds();
     return total ? (minutes = absFloor(seconds / 60), hours = absFloor(minutes / 60), 
     seconds %= 60, minutes %= 60, years = absFloor(months / 12), months %= 12, s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, "") : "", 
     totalSign = total < 0 ? "-" : "", ymSign = sign(this._months) !== sign(total) ? "-" : "", 
     daysSign = sign(this._days) !== sign(total) ? "-" : "", hmsSign = sign(this._milliseconds) !== sign(total) ? "-" : "", 
     totalSign + "P" + (years ? ymSign + years + "Y" : "") + (months ? ymSign + months + "M" : "") + (days ? daysSign + days + "D" : "") + (hours || minutes || seconds ? "T" : "") + (hours ? hmsSign + hours + "H" : "") + (minutes ? hmsSign + minutes + "M" : "") + (seconds ? hmsSign + s + "S" : "")) : "P0D";
    }
    var proto$2 = Duration.prototype;
    return proto$2.isValid = isValid$1, proto$2.abs = abs, proto$2.add = add$1, proto$2.subtract = subtract$1, 
    proto$2.as = as, proto$2.asMilliseconds = asMilliseconds, proto$2.asSeconds = asSeconds, 
    proto$2.asMinutes = asMinutes, proto$2.asHours = asHours, proto$2.asDays = asDays, 
    proto$2.asWeeks = asWeeks, proto$2.asMonths = asMonths, proto$2.asQuarters = asQuarters, 
    proto$2.asYears = asYears, proto$2.valueOf = valueOf$1, proto$2._bubble = bubble, 
    proto$2.clone = clone$1, proto$2.get = get$2, proto$2.milliseconds = milliseconds, 
    proto$2.seconds = seconds, proto$2.minutes = minutes, proto$2.hours = hours, proto$2.days = days, 
    proto$2.weeks = weeks, proto$2.months = months, proto$2.years = years, proto$2.humanize = humanize, 
    proto$2.toISOString = toISOString$1, proto$2.toString = toISOString$1, proto$2.toJSON = toISOString$1, 
    proto$2.locale = locale, proto$2.localeData = localeData, proto$2.toIsoString = deprecate("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)", toISOString$1), 
    proto$2.lang = lang, addFormatToken("X", 0, 0, "unix"), addFormatToken("x", 0, 0, "valueOf"), 
    addRegexToken("x", matchSigned), addRegexToken("X", matchTimestamp), addParseToken("X", (function(input, array, config) {
     config._d = new Date(1e3 * parseFloat(input));
    })), addParseToken("x", (function(input, array, config) {
     config._d = new Date(toInt(input));
    })), hooks.version = "2.30.1", setHookCallback(createLocal), hooks.fn = proto, hooks.min = min, 
    hooks.max = max, hooks.now = now, hooks.utc = createUTC, hooks.unix = createUnix, 
    hooks.months = listMonths, hooks.isDate = isDate, hooks.locale = getSetGlobalLocale, 
    hooks.invalid = createInvalid, hooks.duration = createDuration, hooks.isMoment = isMoment, 
    hooks.weekdays = listWeekdays, hooks.parseZone = createInZone, hooks.localeData = getLocale, 
    hooks.isDuration = isDuration, hooks.monthsShort = listMonthsShort, hooks.weekdaysMin = listWeekdaysMin, 
    hooks.defineLocale = defineLocale, hooks.updateLocale = updateLocale, hooks.locales = listLocales, 
    hooks.weekdaysShort = listWeekdaysShort, hooks.normalizeUnits = normalizeUnits, 
    hooks.relativeTimeRounding = getSetRelativeTimeRounding, hooks.relativeTimeThreshold = getSetRelativeTimeThreshold, 
    hooks.calendarFormat = getCalendarFormat, hooks.prototype = proto, hooks.HTML5_FMT = {
     DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
     DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
     DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
     DATE: "YYYY-MM-DD",
     TIME: "HH:mm",
     TIME_SECONDS: "HH:mm:ss",
     TIME_MS: "HH:mm:ss.SSS",
     WEEK: "GGGG-[W]WW",
     MONTH: "YYYY-MM"
    }, hooks;
   }();
  },
  45157: (module, __unused_webpack_exports, __webpack_require__) => {
   if (!globalThis.DOMException) try {
    const {MessageChannel} = __webpack_require__(28167), port = (new MessageChannel).port1, ab = new ArrayBuffer;
    port.postMessage(ab, [ ab, ab ]);
   } catch (err) {
    "DOMException" === err.constructor.name && (globalThis.DOMException = err.constructor);
   }
   module.exports = globalThis.DOMException;
  },
  54856: module => {
   "use strict";
   function _typeof(obj) {
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
     return typeof obj;
    } : function(obj) {
     return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    }, _typeof(obj);
   }
   function _defineProperty(obj, key, value) {
    return (key = function(arg) {
     var key = function(input, hint) {
      if ("object" !== _typeof(input) || null === input) return input;
      var prim = input[Symbol.toPrimitive];
      if (void 0 !== prim) {
       var res = prim.call(input, hint || "default");
       if ("object" !== _typeof(res)) return res;
       throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === hint ? String : Number)(input);
     }(arg, "string");
     return "symbol" === _typeof(key) ? key : String(key);
    }(key)) in obj ? Object.defineProperty(obj, key, {
     value,
     enumerable: !0,
     configurable: !0,
     writable: !0
    }) : obj[key] = value, obj;
   }
   function _slicedToArray(arr, i) {
    return function(arr) {
     if (Array.isArray(arr)) return arr;
    }(arr) || function(arr, i) {
     var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"];
     if (null != _i) {
      var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1;
      try {
       if (_x = (_i = _i.call(arr)).next, 0 === i) {
        if (Object(_i) !== _i) return;
        _n = !1;
       } else for (;!(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0) ;
      } catch (err) {
       _d = !0, _e = err;
      } finally {
       try {
        if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return;
       } finally {
        if (_d) throw _e;
       }
      }
      return _arr;
     }
    }(arr, i) || _unsupportedIterableToArray(arr, i) || function() {
     throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }();
   }
   function _unsupportedIterableToArray(o, minLen) {
    if (o) {
     if ("string" == typeof o) return _arrayLikeToArray(o, minLen);
     var n = Object.prototype.toString.call(o).slice(8, -1);
     return "Object" === n && o.constructor && (n = o.constructor.name), "Map" === n || "Set" === n ? Array.from(o) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? _arrayLikeToArray(o, minLen) : void 0;
    }
   }
   function _arrayLikeToArray(arr, len) {
    (null == len || len > arr.length) && (len = arr.length);
    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
    return arr2;
   }
   module.exports = function(input) {
    if (!input) return [];
    if ("string" != typeof input || input.match(/^\s+$/)) return [];
    var lines = input.split("\n");
    if (0 === lines.length) return [];
    var _step, files = [], currentFile = null, currentChunk = null, deletedLineCounter = 0, addedLineCounter = 0, currentFileChanges = null, start = function(line) {
     var _parseFiles, _ref2 = _slicedToArray(null !== (_parseFiles = parseFiles(line)) && void 0 !== _parseFiles ? _parseFiles : [], 2), fromFileName = _ref2[0], toFileName = _ref2[1];
     currentFile = {
      chunks: [],
      deletions: 0,
      additions: 0,
      from: fromFileName,
      to: toFileName
     }, files.push(currentFile);
    }, restart = function() {
     currentFile && !currentFile.chunks.length || start();
    }, toNumOfLines = function(number) {
     return +(number || 1);
    }, eof = function(line) {
     var _currentChunk$changes3;
     if (currentChunk) {
      var mostRecentChange = _slicedToArray(currentChunk.changes.slice(-1), 1)[0];
      currentChunk.changes.push((_defineProperty(_currentChunk$changes3 = {
       type: mostRecentChange.type
      }, mostRecentChange.type, !0), _defineProperty(_currentChunk$changes3, "ln1", mostRecentChange.ln1), 
      _defineProperty(_currentChunk$changes3, "ln2", mostRecentChange.ln2), _defineProperty(_currentChunk$changes3, "ln", mostRecentChange.ln), 
      _defineProperty(_currentChunk$changes3, "content", line), _currentChunk$changes3));
     }
    }, schemaHeaders = [ [ /^diff\s/, start ], [ /^new file mode (\d+)$/, function(_, match) {
     restart(), currentFile.new = !0, currentFile.newMode = match[1], currentFile.from = "/dev/null";
    } ], [ /^deleted file mode (\d+)$/, function(_, match) {
     restart(), currentFile.deleted = !0, currentFile.oldMode = match[1], currentFile.to = "/dev/null";
    } ], [ /^old mode (\d+)$/, function(_, match) {
     restart(), currentFile.oldMode = match[1];
    } ], [ /^new mode (\d+)$/, function(_, match) {
     restart(), currentFile.newMode = match[1];
    } ], [ /^index\s[\da-zA-Z]+\.\.[\da-zA-Z]+(\s(\d+))?$/, function(line, match) {
     restart(), currentFile.index = line.split(" ").slice(1), match[1] && (currentFile.oldMode = currentFile.newMode = match[1].trim());
    } ], [ /^---\s/, function(line) {
     restart(), currentFile.from = parseOldOrNewFile(line);
    } ], [ /^\+\+\+\s/, function(line) {
     restart(), currentFile.to = parseOldOrNewFile(line);
    } ], [ /^@@\s+-(\d+),?(\d+)?\s+\+(\d+),?(\d+)?\s@@/, function(line, match) {
     currentFile || start(line);
     var _match$slice2 = _slicedToArray(match.slice(1), 4), oldStart = _match$slice2[0], oldNumLines = _match$slice2[1], newStart = _match$slice2[2], newNumLines = _match$slice2[3];
     deletedLineCounter = +oldStart, addedLineCounter = +newStart, currentChunk = {
      content: line,
      changes: [],
      oldStart: +oldStart,
      oldLines: toNumOfLines(oldNumLines),
      newStart: +newStart,
      newLines: toNumOfLines(newNumLines)
     }, currentFileChanges = {
      oldLines: toNumOfLines(oldNumLines),
      newLines: toNumOfLines(newNumLines)
     }, currentFile.chunks.push(currentChunk);
    } ], [ /^\\ No newline at end of file$/, eof ] ], schemaContent = [ [ /^\\ No newline at end of file$/, eof ], [ /^-/, function(line) {
     currentChunk && (currentChunk.changes.push({
      type: "del",
      del: !0,
      ln: deletedLineCounter++,
      content: line
     }), currentFile.deletions++, currentFileChanges.oldLines--);
    } ], [ /^\+/, function(line) {
     currentChunk && (currentChunk.changes.push({
      type: "add",
      add: !0,
      ln: addedLineCounter++,
      content: line
     }), currentFile.additions++, currentFileChanges.newLines--);
    } ], [ /^\s+/, function(line) {
     var _currentChunk;
     null === (_currentChunk = currentChunk) || void 0 === _currentChunk || _currentChunk.changes.push({
      type: "normal",
      normal: !0,
      ln1: deletedLineCounter++,
      ln2: addedLineCounter++,
      content: line
     }), currentFileChanges.oldLines--, currentFileChanges.newLines--;
    } ] ], parseLine = function(line) {
     currentFileChanges ? function(line) {
      for (var _i2 = 0, _schemaContent = schemaContent; _i2 < _schemaContent.length; _i2++) {
       var _schemaContent$_i = _slicedToArray(_schemaContent[_i2], 2), pattern = _schemaContent$_i[0], handler = _schemaContent$_i[1], match = line.match(pattern);
       if (match) {
        handler(line, match);
        break;
       }
      }
      0 === currentFileChanges.oldLines && 0 === currentFileChanges.newLines && (currentFileChanges = null);
     }(line) : function(line) {
      for (var _i3 = 0, _schemaHeaders = schemaHeaders; _i3 < _schemaHeaders.length; _i3++) {
       var _schemaHeaders$_i = _slicedToArray(_schemaHeaders[_i3], 2), pattern = _schemaHeaders$_i[0], handler = _schemaHeaders$_i[1], match = line.match(pattern);
       if (match) {
        handler(line, match);
        break;
       }
      }
     }(line);
    }, _iterator = function(o, allowArrayLike) {
     var it = "undefined" != typeof Symbol && o[Symbol.iterator] || o["@@iterator"];
     if (!it) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && "number" == typeof o.length) {
       it && (o = it);
       var i = 0, F = function() {};
       return {
        s: F,
        n: function() {
         return i >= o.length ? {
          done: !0
         } : {
          done: !1,
          value: o[i++]
         };
        },
        e: function(_e2) {
         throw _e2;
        },
        f: F
       };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
     }
     var err, normalCompletion = !0, didErr = !1;
     return {
      s: function() {
       it = it.call(o);
      },
      n: function() {
       var step = it.next();
       return normalCompletion = step.done, step;
      },
      e: function(_e3) {
       didErr = !0, err = _e3;
      },
      f: function() {
       try {
        normalCompletion || null == it.return || it.return();
       } finally {
        if (didErr) throw err;
       }
      }
     };
    }(lines);
    try {
     for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      parseLine(_step.value);
     }
    } catch (err) {
     _iterator.e(err);
    } finally {
     _iterator.f();
    }
    return files;
   };
   var fileNameDiffRegex = /(a|i|w|c|o|1|2)\/.*(?=["']? ["']?(b|i|w|c|o|1|2)\/)|(b|i|w|c|o|1|2)\/.*$/g, gitFileHeaderRegex = /^(a|b|i|w|c|o|1|2)\//, parseFiles = function(line) {
    var fileNames = null == line ? void 0 : line.match(fileNameDiffRegex);
    return null == fileNames ? void 0 : fileNames.map((function(fileName) {
     return fileName.replace(gitFileHeaderRegex, "").replace(/("|')$/, "");
    }));
   }, qoutedFileNameRegex = /^\\?['"]|\\?['"]$/g, parseOldOrNewFile = function(line) {
    var fileName = leftTrimChars(line, "-+").trim();
    return (fileName = removeTimeStamp(fileName)).replace(qoutedFileNameRegex, "").replace(gitFileHeaderRegex, "");
   }, leftTrimChars = function(string, trimmingChars) {
    if (string = makeString(string), !trimmingChars && String.prototype.trimLeft) return string.trimLeft();
    var trimmingString = formTrimmingString(trimmingChars);
    return string.replace(new RegExp("^".concat(trimmingString, "+")), "");
   }, timeStampRegex = /\t.*|\d{4}-\d\d-\d\d\s\d\d:\d\d:\d\d(.\d+)?\s(\+|-)\d\d\d\d/, removeTimeStamp = function(string) {
    var timeStamp = timeStampRegex.exec(string);
    return timeStamp && (string = string.substring(0, timeStamp.index).trim()), string;
   }, formTrimmingString = function(trimmingChars) {
    return null == trimmingChars ? "\\s" : trimmingChars instanceof RegExp ? trimmingChars.source : "[".concat(makeString(trimmingChars).replace(/([.*+?^=!:${}()|[\]/\\])/g, "\\$1"), "]");
   }, makeString = function(itemToConvert) {
    return (null != itemToConvert ? itemToConvert : "") + "";
   };
  },
  63283: (module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   let Promise = __webpack_require__(51007), path = __webpack_require__(16928), child_process = Promise.promisifyAll(__webpack_require__(35317));
   const PYTHON_BRIDGE_SCRIPT = path.join(__dirname, "node_python_bridge.py");
   function pythonBridge(opts) {
    let intepreter = opts && opts.python || "python", stdio = opts && opts.stdio || [ "pipe", process.stdout, process.stderr ], options = {
     cwd: opts && opts.cwd,
     env: opts && opts.env,
     uid: opts && opts.uid,
     gid: opts && opts.gid,
     stdio: stdio.concat([ "ipc" ]),
     detached: opts && opts.detached
    }, ps = child_process.spawn(intepreter, [ PYTHON_BRIDGE_SCRIPT ], options), queue = singleQueue();
    function sendPythonCommand(type, enqueue, self) {
     function wrapper() {
      self = self || wrapper;
      let code = json.apply(this, arguments);
      return this && this.connected || self.connected ? enqueue((() => new Promise(((resolve, reject) => {
       function onMessage(data) {
        ps.removeListener("close", onClose), data && data.type && "success" === data.type ? resolve(eval(`(${data.value})`)) : data && data.type && "exception" === data.type ? reject(new PythonException(data.value)) : reject(data);
       }
       function onClose(exit_code, message) {
        ps.removeListener("message", onMessage), reject(message ? new Error(`Python process closed with exit code ${exit_code} and message: ${message}`) : new Error(`Python process closed with exit code ${exit_code}`));
       }
       ps.send({
        type,
        code
       }), ps.once("message", onMessage), ps.once("close", onClose);
      })))) : Promise.reject(new PythonBridgeNotConnected);
     }
     return wrapper;
    }
    function setupLock(enqueue) {
     return f => enqueue((() => {
      let lock_queue = singleQueue(), lock_python = sendPythonCommand("evaluate", lock_queue);
      return lock_python.ex = sendPythonCommand("execute", lock_queue, lock_python), lock_python.lock = setupLock(lock_queue), 
      lock_python.connected = !0, lock_python.__proto__ = python, f(lock_python);
     }));
    }
    let python = sendPythonCommand("evaluate", queue);
    return python.ex = sendPythonCommand("execute", queue, python), python.lock = setupLock(queue), 
    python.pid = ps.pid, python.connected = !0, python.Exception = PythonException, 
    python.isException = isPythonException, python.disconnect = () => (python.connected = !1, 
    queue((() => {
     ps.disconnect();
    }))), python.end = python.disconnect, python.kill = signal => {
     python.connected = !1, ps.kill(signal);
    }, python.stdin = ps.stdin, python.stdout = ps.stdout, python.stderr = ps.stderr, 
    python;
   }
   class PythonException extends Error {
    constructor(exc) {
     exc && exc.format ? super(exc.format.join("")) : exc && exc.error ? super(`Python exception: ${exc.error}`) : super("Unknown Python exception"), 
     this.error = exc.error, this.exception = exc.exception, this.traceback = exc.traceback, 
     this.format = exc.format;
    }
   }
   class PythonBridgeNotConnected extends Error {
    constructor() {
     super("Python bridge is no longer connected.");
    }
   }
   function isPythonException(name, exc) {
    const thunk = exc => exc instanceof PythonException && exc.exception && exc.exception.type.name === name;
    return void 0 === exc ? thunk : thunk(exc);
   }
   function singleQueue() {
    let last = Promise.resolve();
    return function(f) {
     let done, wait = last;
     return last = new Promise((resolve => {
      done = resolve;
     })), new Promise(((resolve, reject) => {
      wait.finally((() => {
       Promise.try(f).then(resolve, reject);
      }));
     })).finally((() => done()));
    };
   }
   function dedent(code) {
    let lines = code.split("\n"), offset = null;
    lines[0].trim() || lines.shift();
    for (let line of lines) {
     let trimmed = line.trimLeft();
     if (trimmed) {
      offset = line.length - trimmed.length + 1;
      break;
     }
    }
    if (!offset) return code;
    let match = new RegExp("^" + new Array(offset).join("\\s?"));
    return lines.map((line => line.replace(match, ""))).join("\n");
   }
   function json(text_nodes) {
    let values = Array.prototype.slice.call(arguments, 1);
    return dedent(text_nodes.reduce(((cur, acc, i) => cur + serializePython(values[i - 1]) + acc)));
   }
   function serializePython(value) {
    if (null == value) return "None";
    if (!0 === value) return "True";
    if (!1 === value) return "False";
    if (value === 1 / 0) return "float('inf')";
    if (value === -1 / 0) return "float('-inf')";
    if (value instanceof Array) return `[${value.map(serializePython).join(", ")}]`;
    if ("number" == typeof value) return isNaN(value) ? "float('nan')" : JSON.stringify(value);
    if ("string" == typeof value) return JSON.stringify(value);
    if (value instanceof Map) {
     return `{${Array.from(value.entries()).map((kv => `${serializePython(kv[0])}: ${serializePython(kv[1])}`)).join(", ")}}`;
    }
    return `{${Object.keys(value).map((k => `${serializePython(k)}: ${serializePython(value[k])}`)).join(", ")}}`;
   }
   pythonBridge.pythonBridge = pythonBridge, pythonBridge.PythonException = PythonException, 
   pythonBridge.PythonBridgeNotConnected = PythonBridgeNotConnected, pythonBridge.isPythonException = isPythonException, 
   pythonBridge.json = json, pythonBridge.serializePython = serializePython, module.exports = pythonBridge.pythonBridge = pythonBridge;
  },
  73992: (__unused_webpack_module, exports) => {
   "use strict";
   var has = Object.prototype.hasOwnProperty;
   function decode(input) {
    try {
     return decodeURIComponent(input.replace(/\+/g, " "));
    } catch (e) {
     return null;
    }
   }
   function encode(input) {
    try {
     return encodeURIComponent(input);
    } catch (e) {
     return null;
    }
   }
   exports.stringify = function(obj, prefix) {
    prefix = prefix || "";
    var value, key, pairs = [];
    for (key in "string" != typeof prefix && (prefix = "?"), obj) if (has.call(obj, key)) {
     if ((value = obj[key]) || null != value && !isNaN(value) || (value = ""), key = encode(key), 
     value = encode(value), null === key || null === value) continue;
     pairs.push(key + "=" + value);
    }
    return pairs.length ? prefix + pairs.join("&") : "";
   }, exports.parse = function(query) {
    for (var part, parser = /([^=?#&]+)=?([^&]*)/g, result = {}; part = parser.exec(query); ) {
     var key = decode(part[1]), value = decode(part[2]);
     null === key || null === value || key in result || (result[key] = value);
    }
    return result;
   };
  },
  92063: module => {
   "use strict";
   module.exports = function(port, protocol) {
    if (protocol = protocol.split(":")[0], !(port = +port)) return !1;
    switch (protocol) {
    case "http":
    case "ws":
     return 80 !== port;

    case "https":
    case "wss":
     return 443 !== port;

    case "ftp":
     return 21 !== port;

    case "gopher":
     return 70 !== port;

    case "file":
     return !1;
    }
    return 0 !== port;
   };
  },
  93904: (module, __unused_webpack_exports, __webpack_require__) => {
   const ANY = Symbol("SemVer ANY");
   class Comparator {
    static get ANY() {
     return ANY;
    }
    constructor(comp, options) {
     if (options = parseOptions(options), comp instanceof Comparator) {
      if (comp.loose === !!options.loose) return comp;
      comp = comp.value;
     }
     comp = comp.trim().split(/\s+/).join(" "), debug("comparator", comp, options), this.options = options, 
     this.loose = !!options.loose, this.parse(comp), this.semver === ANY ? this.value = "" : this.value = this.operator + this.semver.version, 
     debug("comp", this);
    }
    parse(comp) {
     const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR], m = comp.match(r);
     if (!m) throw new TypeError(`Invalid comparator: ${comp}`);
     this.operator = void 0 !== m[1] ? m[1] : "", "=" === this.operator && (this.operator = ""), 
     m[2] ? this.semver = new SemVer(m[2], this.options.loose) : this.semver = ANY;
    }
    toString() {
     return this.value;
    }
    test(version) {
     if (debug("Comparator.test", version, this.options.loose), this.semver === ANY || version === ANY) return !0;
     if ("string" == typeof version) try {
      version = new SemVer(version, this.options);
     } catch (er) {
      return !1;
     }
     return cmp(version, this.operator, this.semver, this.options);
    }
    intersects(comp, options) {
     if (!(comp instanceof Comparator)) throw new TypeError("a Comparator is required");
     return "" === this.operator ? "" === this.value || new Range(comp.value, options).test(this.value) : "" === comp.operator ? "" === comp.value || new Range(this.value, options).test(comp.semver) : (!(options = parseOptions(options)).includePrerelease || "<0.0.0-0" !== this.value && "<0.0.0-0" !== comp.value) && (!(!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) && (!(!this.operator.startsWith(">") || !comp.operator.startsWith(">")) || (!(!this.operator.startsWith("<") || !comp.operator.startsWith("<")) || (!(this.semver.version !== comp.semver.version || !this.operator.includes("=") || !comp.operator.includes("=")) || (!!(cmp(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) || !!(cmp(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")))))));
    }
   }
   module.exports = Comparator;
   const parseOptions = __webpack_require__(98587), {safeRe: re, t} = __webpack_require__(99718), cmp = __webpack_require__(72111), debug = __webpack_require__(57272), SemVer = __webpack_require__(53908), Range = __webpack_require__(78311);
  },
  78311: (module, __unused_webpack_exports, __webpack_require__) => {
   const SPACE_CHARACTERS = /\s+/g;
   class Range {
    constructor(range, options) {
     if (options = parseOptions(options), range instanceof Range) return range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease ? range : new Range(range.raw, options);
     if (range instanceof Comparator) return this.raw = range.value, this.set = [ [ range ] ], 
     this.formatted = void 0, this;
     if (this.options = options, this.loose = !!options.loose, this.includePrerelease = !!options.includePrerelease, 
     this.raw = range.trim().replace(SPACE_CHARACTERS, " "), this.set = this.raw.split("||").map((r => this.parseRange(r.trim()))).filter((c => c.length)), 
     !this.set.length) throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
     if (this.set.length > 1) {
      const first = this.set[0];
      if (this.set = this.set.filter((c => !isNullSet(c[0]))), 0 === this.set.length) this.set = [ first ]; else if (this.set.length > 1) for (const c of this.set) if (1 === c.length && isAny(c[0])) {
       this.set = [ c ];
       break;
      }
     }
     this.formatted = void 0;
    }
    get range() {
     if (void 0 === this.formatted) {
      this.formatted = "";
      for (let i = 0; i < this.set.length; i++) {
       i > 0 && (this.formatted += "||");
       const comps = this.set[i];
       for (let k = 0; k < comps.length; k++) k > 0 && (this.formatted += " "), this.formatted += comps[k].toString().trim();
      }
     }
     return this.formatted;
    }
    format() {
     return this.range;
    }
    toString() {
     return this.range;
    }
    parseRange(range) {
     const memoKey = ((this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE)) + ":" + range, cached = cache.get(memoKey);
     if (cached) return cached;
     const loose = this.options.loose, hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
     range = range.replace(hr, hyphenReplace(this.options.includePrerelease)), debug("hyphen replace", range), 
     range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace), debug("comparator trim", range), 
     range = range.replace(re[t.TILDETRIM], tildeTrimReplace), debug("tilde trim", range), 
     range = range.replace(re[t.CARETTRIM], caretTrimReplace), debug("caret trim", range);
     let rangeList = range.split(" ").map((comp => parseComparator(comp, this.options))).join(" ").split(/\s+/).map((comp => replaceGTE0(comp, this.options)));
     loose && (rangeList = rangeList.filter((comp => (debug("loose invalid filter", comp, this.options), 
     !!comp.match(re[t.COMPARATORLOOSE]))))), debug("range list", rangeList);
     const rangeMap = new Map, comparators = rangeList.map((comp => new Comparator(comp, this.options)));
     for (const comp of comparators) {
      if (isNullSet(comp)) return [ comp ];
      rangeMap.set(comp.value, comp);
     }
     rangeMap.size > 1 && rangeMap.has("") && rangeMap.delete("");
     const result = [ ...rangeMap.values() ];
     return cache.set(memoKey, result), result;
    }
    intersects(range, options) {
     if (!(range instanceof Range)) throw new TypeError("a Range is required");
     return this.set.some((thisComparators => isSatisfiable(thisComparators, options) && range.set.some((rangeComparators => isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator => rangeComparators.every((rangeComparator => thisComparator.intersects(rangeComparator, options)))))))));
    }
    test(version) {
     if (!version) return !1;
     if ("string" == typeof version) try {
      version = new SemVer(version, this.options);
     } catch (er) {
      return !1;
     }
     for (let i = 0; i < this.set.length; i++) if (testSet(this.set[i], version, this.options)) return !0;
     return !1;
    }
   }
   module.exports = Range;
   const cache = new (__webpack_require__(68794)), parseOptions = __webpack_require__(98587), Comparator = __webpack_require__(93904), debug = __webpack_require__(57272), SemVer = __webpack_require__(53908), {safeRe: re, t, comparatorTrimReplace, tildeTrimReplace, caretTrimReplace} = __webpack_require__(99718), {FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE} = __webpack_require__(16874), isNullSet = c => "<0.0.0-0" === c.value, isAny = c => "" === c.value, isSatisfiable = (comparators, options) => {
    let result = !0;
    const remainingComparators = comparators.slice();
    let testComparator = remainingComparators.pop();
    for (;result && remainingComparators.length; ) result = remainingComparators.every((otherComparator => testComparator.intersects(otherComparator, options))), 
    testComparator = remainingComparators.pop();
    return result;
   }, parseComparator = (comp, options) => (debug("comp", comp, options), comp = replaceCarets(comp, options), 
   debug("caret", comp), comp = replaceTildes(comp, options), debug("tildes", comp), 
   comp = replaceXRanges(comp, options), debug("xrange", comp), comp = replaceStars(comp, options), 
   debug("stars", comp), comp), isX = id => !id || "x" === id.toLowerCase() || "*" === id, replaceTildes = (comp, options) => comp.trim().split(/\s+/).map((c => replaceTilde(c, options))).join(" "), replaceTilde = (comp, options) => {
    const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
    return comp.replace(r, ((_, M, m, p, pr) => {
     let ret;
     return debug("tilde", comp, _, M, m, p, pr), isX(M) ? ret = "" : isX(m) ? ret = `>=${M}.0.0 <${+M + 1}.0.0-0` : isX(p) ? ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0` : pr ? (debug("replaceTilde pr", pr), 
     ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`) : ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`, 
     debug("tilde return", ret), ret;
    }));
   }, replaceCarets = (comp, options) => comp.trim().split(/\s+/).map((c => replaceCaret(c, options))).join(" "), replaceCaret = (comp, options) => {
    debug("caret", comp, options);
    const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET], z = options.includePrerelease ? "-0" : "";
    return comp.replace(r, ((_, M, m, p, pr) => {
     let ret;
     return debug("caret", comp, _, M, m, p, pr), isX(M) ? ret = "" : isX(m) ? ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0` : isX(p) ? ret = "0" === M ? `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0` : `>=${M}.${m}.0${z} <${+M + 1}.0.0-0` : pr ? (debug("replaceCaret pr", pr), 
     ret = "0" === M ? "0" === m ? `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0` : `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0` : `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`) : (debug("no pr"), 
     ret = "0" === M ? "0" === m ? `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0` : `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0` : `>=${M}.${m}.${p} <${+M + 1}.0.0-0`), 
     debug("caret return", ret), ret;
    }));
   }, replaceXRanges = (comp, options) => (debug("replaceXRanges", comp, options), 
   comp.split(/\s+/).map((c => replaceXRange(c, options))).join(" ")), replaceXRange = (comp, options) => {
    comp = comp.trim();
    const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
    return comp.replace(r, ((ret, gtlt, M, m, p, pr) => {
     debug("xRange", comp, ret, gtlt, M, m, p, pr);
     const xM = isX(M), xm = xM || isX(m), xp = xm || isX(p), anyX = xp;
     return "=" === gtlt && anyX && (gtlt = ""), pr = options.includePrerelease ? "-0" : "", 
     xM ? ret = ">" === gtlt || "<" === gtlt ? "<0.0.0-0" : "*" : gtlt && anyX ? (xm && (m = 0), 
     p = 0, ">" === gtlt ? (gtlt = ">=", xm ? (M = +M + 1, m = 0, p = 0) : (m = +m + 1, 
     p = 0)) : "<=" === gtlt && (gtlt = "<", xm ? M = +M + 1 : m = +m + 1), "<" === gtlt && (pr = "-0"), 
     ret = `${gtlt + M}.${m}.${p}${pr}`) : xm ? ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0` : xp && (ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`), 
     debug("xRange return", ret), ret;
    }));
   }, replaceStars = (comp, options) => (debug("replaceStars", comp, options), comp.trim().replace(re[t.STAR], "")), replaceGTE0 = (comp, options) => (debug("replaceGTE0", comp, options), 
   comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], "")), hyphenReplace = incPr => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) => `${from = isX(fM) ? "" : isX(fm) ? `>=${fM}.0.0${incPr ? "-0" : ""}` : isX(fp) ? `>=${fM}.${fm}.0${incPr ? "-0" : ""}` : fpr ? `>=${from}` : `>=${from}${incPr ? "-0" : ""}`} ${to = isX(tM) ? "" : isX(tm) ? `<${+tM + 1}.0.0-0` : isX(tp) ? `<${tM}.${+tm + 1}.0-0` : tpr ? `<=${tM}.${tm}.${tp}-${tpr}` : incPr ? `<${tM}.${tm}.${+tp + 1}-0` : `<=${to}`}`.trim(), testSet = (set, version, options) => {
    for (let i = 0; i < set.length; i++) if (!set[i].test(version)) return !1;
    if (version.prerelease.length && !options.includePrerelease) {
     for (let i = 0; i < set.length; i++) if (debug(set[i].semver), set[i].semver !== Comparator.ANY && set[i].semver.prerelease.length > 0) {
      const allowed = set[i].semver;
      if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) return !0;
     }
     return !1;
    }
    return !0;
   };
  },
  53908: (module, __unused_webpack_exports, __webpack_require__) => {
   const debug = __webpack_require__(57272), {MAX_LENGTH, MAX_SAFE_INTEGER} = __webpack_require__(16874), {safeRe: re, t} = __webpack_require__(99718), parseOptions = __webpack_require__(98587), {compareIdentifiers} = __webpack_require__(61123);
   class SemVer {
    constructor(version, options) {
     if (options = parseOptions(options), version instanceof SemVer) {
      if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) return version;
      version = version.version;
     } else if ("string" != typeof version) throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version}".`);
     if (version.length > MAX_LENGTH) throw new TypeError(`version is longer than ${MAX_LENGTH} characters`);
     debug("SemVer", version, options), this.options = options, this.loose = !!options.loose, 
     this.includePrerelease = !!options.includePrerelease;
     const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
     if (!m) throw new TypeError(`Invalid Version: ${version}`);
     if (this.raw = version, this.major = +m[1], this.minor = +m[2], this.patch = +m[3], 
     this.major > MAX_SAFE_INTEGER || this.major < 0) throw new TypeError("Invalid major version");
     if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) throw new TypeError("Invalid minor version");
     if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) throw new TypeError("Invalid patch version");
     m[4] ? this.prerelease = m[4].split(".").map((id => {
      if (/^[0-9]+$/.test(id)) {
       const num = +id;
       if (num >= 0 && num < MAX_SAFE_INTEGER) return num;
      }
      return id;
     })) : this.prerelease = [], this.build = m[5] ? m[5].split(".") : [], this.format();
    }
    format() {
     return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), 
     this.version;
    }
    toString() {
     return this.version;
    }
    compare(other) {
     if (debug("SemVer.compare", this.version, this.options, other), !(other instanceof SemVer)) {
      if ("string" == typeof other && other === this.version) return 0;
      other = new SemVer(other, this.options);
     }
     return other.version === this.version ? 0 : this.compareMain(other) || this.comparePre(other);
    }
    compareMain(other) {
     return other instanceof SemVer || (other = new SemVer(other, this.options)), compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
    }
    comparePre(other) {
     if (other instanceof SemVer || (other = new SemVer(other, this.options)), this.prerelease.length && !other.prerelease.length) return -1;
     if (!this.prerelease.length && other.prerelease.length) return 1;
     if (!this.prerelease.length && !other.prerelease.length) return 0;
     let i = 0;
     do {
      const a = this.prerelease[i], b = other.prerelease[i];
      if (debug("prerelease compare", i, a, b), void 0 === a && void 0 === b) return 0;
      if (void 0 === b) return 1;
      if (void 0 === a) return -1;
      if (a !== b) return compareIdentifiers(a, b);
     } while (++i);
    }
    compareBuild(other) {
     other instanceof SemVer || (other = new SemVer(other, this.options));
     let i = 0;
     do {
      const a = this.build[i], b = other.build[i];
      if (debug("build compare", i, a, b), void 0 === a && void 0 === b) return 0;
      if (void 0 === b) return 1;
      if (void 0 === a) return -1;
      if (a !== b) return compareIdentifiers(a, b);
     } while (++i);
    }
    inc(release, identifier, identifierBase) {
     switch (release) {
     case "premajor":
      this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", identifier, identifierBase);
      break;

     case "preminor":
      this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", identifier, identifierBase);
      break;

     case "prepatch":
      this.prerelease.length = 0, this.inc("patch", identifier, identifierBase), this.inc("pre", identifier, identifierBase);
      break;

     case "prerelease":
      0 === this.prerelease.length && this.inc("patch", identifier, identifierBase), this.inc("pre", identifier, identifierBase);
      break;

     case "major":
      0 === this.minor && 0 === this.patch && 0 !== this.prerelease.length || this.major++, 
      this.minor = 0, this.patch = 0, this.prerelease = [];
      break;

     case "minor":
      0 === this.patch && 0 !== this.prerelease.length || this.minor++, this.patch = 0, 
      this.prerelease = [];
      break;

     case "patch":
      0 === this.prerelease.length && this.patch++, this.prerelease = [];
      break;

     case "pre":
      {
       const base = Number(identifierBase) ? 1 : 0;
       if (!identifier && !1 === identifierBase) throw new Error("invalid increment argument: identifier is empty");
       if (0 === this.prerelease.length) this.prerelease = [ base ]; else {
        let i = this.prerelease.length;
        for (;--i >= 0; ) "number" == typeof this.prerelease[i] && (this.prerelease[i]++, 
        i = -2);
        if (-1 === i) {
         if (identifier === this.prerelease.join(".") && !1 === identifierBase) throw new Error("invalid increment argument: identifier already exists");
         this.prerelease.push(base);
        }
       }
       if (identifier) {
        let prerelease = [ identifier, base ];
        !1 === identifierBase && (prerelease = [ identifier ]), 0 === compareIdentifiers(this.prerelease[0], identifier) ? isNaN(this.prerelease[1]) && (this.prerelease = prerelease) : this.prerelease = prerelease;
       }
       break;
      }

     default:
      throw new Error(`invalid increment argument: ${release}`);
     }
     return this.raw = this.format(), this.build.length && (this.raw += `+${this.build.join(".")}`), 
     this;
    }
   }
   module.exports = SemVer;
  },
  57414: (module, __unused_webpack_exports, __webpack_require__) => {
   const parse = __webpack_require__(30144);
   module.exports = (version, options) => {
    const s = parse(version.trim().replace(/^[=v]+/, ""), options);
    return s ? s.version : null;
   };
  },
  72111: (module, __unused_webpack_exports, __webpack_require__) => {
   const eq = __webpack_require__(94641), neq = __webpack_require__(13999), gt = __webpack_require__(35580), gte = __webpack_require__(54089), lt = __webpack_require__(7059), lte = __webpack_require__(25200);
   module.exports = (a, op, b, loose) => {
    switch (op) {
    case "===":
     return "object" == typeof a && (a = a.version), "object" == typeof b && (b = b.version), 
     a === b;

    case "!==":
     return "object" == typeof a && (a = a.version), "object" == typeof b && (b = b.version), 
     a !== b;

    case "":
    case "=":
    case "==":
     return eq(a, b, loose);

    case "!=":
     return neq(a, b, loose);

    case ">":
     return gt(a, b, loose);

    case ">=":
     return gte(a, b, loose);

    case "<":
     return lt(a, b, loose);

    case "<=":
     return lte(a, b, loose);

    default:
     throw new TypeError(`Invalid operator: ${op}`);
    }
   };
  },
  23789: (module, __unused_webpack_exports, __webpack_require__) => {
   const SemVer = __webpack_require__(53908), parse = __webpack_require__(30144), {safeRe: re, t} = __webpack_require__(99718);
   module.exports = (version, options) => {
    if (version instanceof SemVer) return version;
    if ("number" == typeof version && (version = String(version)), "string" != typeof version) return null;
    let match = null;
    if ((options = options || {}).rtl) {
     const coerceRtlRegex = options.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL];
     let next;
     for (;(next = coerceRtlRegex.exec(version)) && (!match || match.index + match[0].length !== version.length); ) match && next.index + next[0].length === match.index + match[0].length || (match = next), 
     coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
     coerceRtlRegex.lastIndex = -1;
    } else match = version.match(options.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE]);
    if (null === match) return null;
    const major = match[2], minor = match[3] || "0", patch = match[4] || "0", prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : "", build = options.includePrerelease && match[6] ? `+${match[6]}` : "";
    return parse(`${major}.${minor}.${patch}${prerelease}${build}`, options);
   };
  },
  40909: (module, __unused_webpack_exports, __webpack_require__) => {
   const SemVer = __webpack_require__(53908);
   module.exports = (a, b, loose) => {
    const versionA = new SemVer(a, loose), versionB = new SemVer(b, loose);
    return versionA.compare(versionB) || versionA.compareBuild(versionB);
   };
  },
  11763: (module, __unused_webpack_exports, __webpack_require__) => {
   const compare = __webpack_require__(50560);
   module.exports = (a, b) => compare(a, b, !0);
  },
  50560: (module, __unused_webpack_exports, __webpack_require__) => {
   const SemVer = __webpack_require__(53908);
   module.exports = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
  },
  51832: (module, __unused_webpack_exports, __webpack_require__) => {
   const parse = __webpack_require__(30144);
   module.exports = (version1, version2) => {
    const v1 = parse(version1, null, !0), v2 = parse(version2, null, !0), comparison = v1.compare(v2);
    if (0 === comparison) return null;
    const v1Higher = comparison > 0, highVersion = v1Higher ? v1 : v2, lowVersion = v1Higher ? v2 : v1, highHasPre = !!highVersion.prerelease.length;
    if (!!lowVersion.prerelease.length && !highHasPre) return lowVersion.patch || lowVersion.minor ? highVersion.patch ? "patch" : highVersion.minor ? "minor" : "major" : "major";
    const prefix = highHasPre ? "pre" : "";
    return v1.major !== v2.major ? prefix + "major" : v1.minor !== v2.minor ? prefix + "minor" : v1.patch !== v2.patch ? prefix + "patch" : "prerelease";
   };
  },
  94641: (module, __unused_webpack_exports, __webpack_require__) => {
   const compare = __webpack_require__(50560);
   module.exports = (a, b, loose) => 0 === compare(a, b, loose);
  },
  35580: (module, __unused_webpack_exports, __webpack_require__) => {
   const compare = __webpack_require__(50560);
   module.exports = (a, b, loose) => compare(a, b, loose) > 0;
  },
  54089: (module, __unused_webpack_exports, __webpack_require__) => {
   const compare = __webpack_require__(50560);
   module.exports = (a, b, loose) => compare(a, b, loose) >= 0;
  },
  93007: (module, __unused_webpack_exports, __webpack_require__) => {
   const SemVer = __webpack_require__(53908);
   module.exports = (version, release, options, identifier, identifierBase) => {
    "string" == typeof options && (identifierBase = identifier, identifier = options, 
    options = void 0);
    try {
     return new SemVer(version instanceof SemVer ? version.version : version, options).inc(release, identifier, identifierBase).version;
    } catch (er) {
     return null;
    }
   };
  },
  7059: (module, __unused_webpack_exports, __webpack_require__) => {
   const compare = __webpack_require__(50560);
   module.exports = (a, b, loose) => compare(a, b, loose) < 0;
  },
  25200: (module, __unused_webpack_exports, __webpack_require__) => {
   const compare = __webpack_require__(50560);
   module.exports = (a, b, loose) => compare(a, b, loose) <= 0;
  },
  32938: (module, __unused_webpack_exports, __webpack_require__) => {
   const SemVer = __webpack_require__(53908);
   module.exports = (a, loose) => new SemVer(a, loose).major;
  },
  46254: (module, __unused_webpack_exports, __webpack_require__) => {
   const SemVer = __webpack_require__(53908);
   module.exports = (a, loose) => new SemVer(a, loose).minor;
  },
  13999: (module, __unused_webpack_exports, __webpack_require__) => {
   const compare = __webpack_require__(50560);
   module.exports = (a, b, loose) => 0 !== compare(a, b, loose);
  },
  30144: (module, __unused_webpack_exports, __webpack_require__) => {
   const SemVer = __webpack_require__(53908);
   module.exports = (version, options, throwErrors = !1) => {
    if (version instanceof SemVer) return version;
    try {
     return new SemVer(version, options);
    } catch (er) {
     if (!throwErrors) return null;
     throw er;
    }
   };
  },
  24493: (module, __unused_webpack_exports, __webpack_require__) => {
   const SemVer = __webpack_require__(53908);
   module.exports = (a, loose) => new SemVer(a, loose).patch;
  },
  31729: (module, __unused_webpack_exports, __webpack_require__) => {
   const parse = __webpack_require__(30144);
   module.exports = (version, options) => {
    const parsed = parse(version, options);
    return parsed && parsed.prerelease.length ? parsed.prerelease : null;
   };
  },
  9970: (module, __unused_webpack_exports, __webpack_require__) => {
   const compare = __webpack_require__(50560);
   module.exports = (a, b, loose) => compare(b, a, loose);
  },
  74277: (module, __unused_webpack_exports, __webpack_require__) => {
   const compareBuild = __webpack_require__(40909);
   module.exports = (list, loose) => list.sort(((a, b) => compareBuild(b, a, loose)));
  },
  97638: (module, __unused_webpack_exports, __webpack_require__) => {
   const Range = __webpack_require__(78311);
   module.exports = (version, range, options) => {
    try {
     range = new Range(range, options);
    } catch (er) {
     return !1;
    }
    return range.test(version);
   };
  },
  43927: (module, __unused_webpack_exports, __webpack_require__) => {
   const compareBuild = __webpack_require__(40909);
   module.exports = (list, loose) => list.sort(((a, b) => compareBuild(a, b, loose)));
  },
  56953: (module, __unused_webpack_exports, __webpack_require__) => {
   const parse = __webpack_require__(30144);
   module.exports = (version, options) => {
    const v = parse(version, options);
    return v ? v.version : null;
   };
  },
  99589: (module, __unused_webpack_exports, __webpack_require__) => {
   const internalRe = __webpack_require__(99718), constants = __webpack_require__(16874), SemVer = __webpack_require__(53908), identifiers = __webpack_require__(61123), parse = __webpack_require__(30144), valid = __webpack_require__(56953), clean = __webpack_require__(57414), inc = __webpack_require__(93007), diff = __webpack_require__(51832), major = __webpack_require__(32938), minor = __webpack_require__(46254), patch = __webpack_require__(24493), prerelease = __webpack_require__(31729), compare = __webpack_require__(50560), rcompare = __webpack_require__(9970), compareLoose = __webpack_require__(11763), compareBuild = __webpack_require__(40909), sort = __webpack_require__(43927), rsort = __webpack_require__(74277), gt = __webpack_require__(35580), lt = __webpack_require__(7059), eq = __webpack_require__(94641), neq = __webpack_require__(13999), gte = __webpack_require__(54089), lte = __webpack_require__(25200), cmp = __webpack_require__(72111), coerce = __webpack_require__(23789), Comparator = __webpack_require__(93904), Range = __webpack_require__(78311), satisfies = __webpack_require__(97638), toComparators = __webpack_require__(77631), maxSatisfying = __webpack_require__(19628), minSatisfying = __webpack_require__(270), minVersion = __webpack_require__(41261), validRange = __webpack_require__(13874), outside = __webpack_require__(97075), gtr = __webpack_require__(75571), ltr = __webpack_require__(5342), intersects = __webpack_require__(76780), simplifyRange = __webpack_require__(72525), subset = __webpack_require__(75032);
   module.exports = {
    parse,
    valid,
    clean,
    inc,
    diff,
    major,
    minor,
    patch,
    prerelease,
    compare,
    rcompare,
    compareLoose,
    compareBuild,
    sort,
    rsort,
    gt,
    lt,
    eq,
    neq,
    gte,
    lte,
    cmp,
    coerce,
    Comparator,
    Range,
    satisfies,
    toComparators,
    maxSatisfying,
    minSatisfying,
    minVersion,
    validRange,
    outside,
    gtr,
    ltr,
    intersects,
    simplifyRange,
    subset,
    SemVer,
    re: internalRe.re,
    src: internalRe.src,
    tokens: internalRe.t,
    SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
    RELEASE_TYPES: constants.RELEASE_TYPES,
    compareIdentifiers: identifiers.compareIdentifiers,
    rcompareIdentifiers: identifiers.rcompareIdentifiers
   };
  },
  16874: module => {
   const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
   module.exports = {
    MAX_LENGTH: 256,
    MAX_SAFE_COMPONENT_LENGTH: 16,
    MAX_SAFE_BUILD_LENGTH: 250,
    MAX_SAFE_INTEGER,
    RELEASE_TYPES: [ "major", "premajor", "minor", "preminor", "patch", "prepatch", "prerelease" ],
    SEMVER_SPEC_VERSION: "2.0.0",
    FLAG_INCLUDE_PRERELEASE: 1,
    FLAG_LOOSE: 2
   };
  },
  57272: module => {
   const debug = "object" == typeof process && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {};
   module.exports = debug;
  },
  61123: module => {
   const numeric = /^[0-9]+$/, compareIdentifiers = (a, b) => {
    const anum = numeric.test(a), bnum = numeric.test(b);
    return anum && bnum && (a = +a, b = +b), a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
   };
   module.exports = {
    compareIdentifiers,
    rcompareIdentifiers: (a, b) => compareIdentifiers(b, a)
   };
  },
  68794: module => {
   module.exports = class {
    constructor() {
     this.max = 1e3, this.map = new Map;
    }
    get(key) {
     const value = this.map.get(key);
     return void 0 === value ? void 0 : (this.map.delete(key), this.map.set(key, value), 
     value);
    }
    delete(key) {
     return this.map.delete(key);
    }
    set(key, value) {
     if (!this.delete(key) && void 0 !== value) {
      if (this.map.size >= this.max) {
       const firstKey = this.map.keys().next().value;
       this.delete(firstKey);
      }
      this.map.set(key, value);
     }
     return this;
    }
   };
  },
  98587: module => {
   const looseOption = Object.freeze({
    loose: !0
   }), emptyOpts = Object.freeze({});
   module.exports = options => options ? "object" != typeof options ? looseOption : options : emptyOpts;
  },
  99718: (module, exports, __webpack_require__) => {
   const {MAX_SAFE_COMPONENT_LENGTH, MAX_SAFE_BUILD_LENGTH, MAX_LENGTH} = __webpack_require__(16874), debug = __webpack_require__(57272), re = (exports = module.exports = {}).re = [], safeRe = exports.safeRe = [], src = exports.src = [], t = exports.t = {};
   let R = 0;
   const safeRegexReplacements = [ [ "\\s", 1 ], [ "\\d", MAX_LENGTH ], [ "[a-zA-Z0-9-]", MAX_SAFE_BUILD_LENGTH ] ], createToken = (name, value, isGlobal) => {
    const safe = (value => {
     for (const [token, max] of safeRegexReplacements) value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
     return value;
    })(value), index = R++;
    debug(name, index, value), t[name] = index, src[index] = value, re[index] = new RegExp(value, isGlobal ? "g" : void 0), 
    safeRe[index] = new RegExp(safe, isGlobal ? "g" : void 0);
   };
   createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*"), createToken("NUMERICIDENTIFIERLOOSE", "\\d+"), 
   createToken("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`), 
   createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`), 
   createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`), 
   createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`), 
   createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`), 
   createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`), 
   createToken("BUILDIDENTIFIER", "[a-zA-Z0-9-]+"), createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`), 
   createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`), 
   createToken("FULL", `^${src[t.FULLPLAIN]}$`), createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`), 
   createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`), createToken("GTLT", "((?:<|>)?=?)"), 
   createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), 
   createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`), createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`), 
   createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`), 
   createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`), createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`), 
   createToken("COERCEPLAIN", `(^|[^\\d])(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`), 
   createToken("COERCE", `${src[t.COERCEPLAIN]}(?:$|[^\\d])`), createToken("COERCEFULL", src[t.COERCEPLAIN] + `(?:${src[t.PRERELEASE]})?` + `(?:${src[t.BUILD]})?(?:$|[^\\d])`), 
   createToken("COERCERTL", src[t.COERCE], !0), createToken("COERCERTLFULL", src[t.COERCEFULL], !0), 
   createToken("LONETILDE", "(?:~>?)"), createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, !0), 
   exports.tildeTrimReplace = "$1~", createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`), 
   createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`), createToken("LONECARET", "(?:\\^)"), 
   createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, !0), exports.caretTrimReplace = "$1^", 
   createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`), createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`), 
   createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`), 
   createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`), createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, !0), 
   exports.comparatorTrimReplace = "$1$2$3", createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`), 
   createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`), 
   createToken("STAR", "(<|>)?=?\\s*\\*"), createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"), 
   createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  },
  75571: (module, __unused_webpack_exports, __webpack_require__) => {
   const outside = __webpack_require__(97075);
   module.exports = (version, range, options) => outside(version, range, ">", options);
  },
  76780: (module, __unused_webpack_exports, __webpack_require__) => {
   const Range = __webpack_require__(78311);
   module.exports = (r1, r2, options) => (r1 = new Range(r1, options), r2 = new Range(r2, options), 
   r1.intersects(r2, options));
  },
  5342: (module, __unused_webpack_exports, __webpack_require__) => {
   const outside = __webpack_require__(97075);
   module.exports = (version, range, options) => outside(version, range, "<", options);
  },
  19628: (module, __unused_webpack_exports, __webpack_require__) => {
   const SemVer = __webpack_require__(53908), Range = __webpack_require__(78311);
   module.exports = (versions, range, options) => {
    let max = null, maxSV = null, rangeObj = null;
    try {
     rangeObj = new Range(range, options);
    } catch (er) {
     return null;
    }
    return versions.forEach((v => {
     rangeObj.test(v) && (max && -1 !== maxSV.compare(v) || (max = v, maxSV = new SemVer(max, options)));
    })), max;
   };
  },
  270: (module, __unused_webpack_exports, __webpack_require__) => {
   const SemVer = __webpack_require__(53908), Range = __webpack_require__(78311);
   module.exports = (versions, range, options) => {
    let min = null, minSV = null, rangeObj = null;
    try {
     rangeObj = new Range(range, options);
    } catch (er) {
     return null;
    }
    return versions.forEach((v => {
     rangeObj.test(v) && (min && 1 !== minSV.compare(v) || (min = v, minSV = new SemVer(min, options)));
    })), min;
   };
  },
  41261: (module, __unused_webpack_exports, __webpack_require__) => {
   const SemVer = __webpack_require__(53908), Range = __webpack_require__(78311), gt = __webpack_require__(35580);
   module.exports = (range, loose) => {
    range = new Range(range, loose);
    let minver = new SemVer("0.0.0");
    if (range.test(minver)) return minver;
    if (minver = new SemVer("0.0.0-0"), range.test(minver)) return minver;
    minver = null;
    for (let i = 0; i < range.set.length; ++i) {
     const comparators = range.set[i];
     let setMin = null;
     comparators.forEach((comparator => {
      const compver = new SemVer(comparator.semver.version);
      switch (comparator.operator) {
      case ">":
       0 === compver.prerelease.length ? compver.patch++ : compver.prerelease.push(0), 
       compver.raw = compver.format();

      case "":
      case ">=":
       setMin && !gt(compver, setMin) || (setMin = compver);
       break;

      case "<":
      case "<=":
       break;

      default:
       throw new Error(`Unexpected operation: ${comparator.operator}`);
      }
     })), !setMin || minver && !gt(minver, setMin) || (minver = setMin);
    }
    return minver && range.test(minver) ? minver : null;
   };
  },
  97075: (module, __unused_webpack_exports, __webpack_require__) => {
   const SemVer = __webpack_require__(53908), Comparator = __webpack_require__(93904), {ANY} = Comparator, Range = __webpack_require__(78311), satisfies = __webpack_require__(97638), gt = __webpack_require__(35580), lt = __webpack_require__(7059), lte = __webpack_require__(25200), gte = __webpack_require__(54089);
   module.exports = (version, range, hilo, options) => {
    let gtfn, ltefn, ltfn, comp, ecomp;
    switch (version = new SemVer(version, options), range = new Range(range, options), 
    hilo) {
    case ">":
     gtfn = gt, ltefn = lte, ltfn = lt, comp = ">", ecomp = ">=";
     break;

    case "<":
     gtfn = lt, ltefn = gte, ltfn = gt, comp = "<", ecomp = "<=";
     break;

    default:
     throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    if (satisfies(version, range, options)) return !1;
    for (let i = 0; i < range.set.length; ++i) {
     const comparators = range.set[i];
     let high = null, low = null;
     if (comparators.forEach((comparator => {
      comparator.semver === ANY && (comparator = new Comparator(">=0.0.0")), high = high || comparator, 
      low = low || comparator, gtfn(comparator.semver, high.semver, options) ? high = comparator : ltfn(comparator.semver, low.semver, options) && (low = comparator);
     })), high.operator === comp || high.operator === ecomp) return !1;
     if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) return !1;
     if (low.operator === ecomp && ltfn(version, low.semver)) return !1;
    }
    return !0;
   };
  },
  72525: (module, __unused_webpack_exports, __webpack_require__) => {
   const satisfies = __webpack_require__(97638), compare = __webpack_require__(50560);
   module.exports = (versions, range, options) => {
    const set = [];
    let first = null, prev = null;
    const v = versions.sort(((a, b) => compare(a, b, options)));
    for (const version of v) {
     satisfies(version, range, options) ? (prev = version, first || (first = version)) : (prev && set.push([ first, prev ]), 
     prev = null, first = null);
    }
    first && set.push([ first, null ]);
    const ranges = [];
    for (const [min, max] of set) min === max ? ranges.push(min) : max || min !== v[0] ? max ? min === v[0] ? ranges.push(`<=${max}`) : ranges.push(`${min} - ${max}`) : ranges.push(`>=${min}`) : ranges.push("*");
    const simplified = ranges.join(" || "), original = "string" == typeof range.raw ? range.raw : String(range);
    return simplified.length < original.length ? simplified : range;
   };
  },
  75032: (module, __unused_webpack_exports, __webpack_require__) => {
   const Range = __webpack_require__(78311), Comparator = __webpack_require__(93904), {ANY} = Comparator, satisfies = __webpack_require__(97638), compare = __webpack_require__(50560), minimumVersionWithPreRelease = [ new Comparator(">=0.0.0-0") ], minimumVersion = [ new Comparator(">=0.0.0") ], simpleSubset = (sub, dom, options) => {
    if (sub === dom) return !0;
    if (1 === sub.length && sub[0].semver === ANY) {
     if (1 === dom.length && dom[0].semver === ANY) return !0;
     sub = options.includePrerelease ? minimumVersionWithPreRelease : minimumVersion;
    }
    if (1 === dom.length && dom[0].semver === ANY) {
     if (options.includePrerelease) return !0;
     dom = minimumVersion;
    }
    const eqSet = new Set;
    let gt, lt, gtltComp, higher, lower, hasDomLT, hasDomGT;
    for (const c of sub) ">" === c.operator || ">=" === c.operator ? gt = higherGT(gt, c, options) : "<" === c.operator || "<=" === c.operator ? lt = lowerLT(lt, c, options) : eqSet.add(c.semver);
    if (eqSet.size > 1) return null;
    if (gt && lt) {
     if (gtltComp = compare(gt.semver, lt.semver, options), gtltComp > 0) return null;
     if (0 === gtltComp && (">=" !== gt.operator || "<=" !== lt.operator)) return null;
    }
    for (const eq of eqSet) {
     if (gt && !satisfies(eq, String(gt), options)) return null;
     if (lt && !satisfies(eq, String(lt), options)) return null;
     for (const c of dom) if (!satisfies(eq, String(c), options)) return !1;
     return !0;
    }
    let needDomLTPre = !(!lt || options.includePrerelease || !lt.semver.prerelease.length) && lt.semver, needDomGTPre = !(!gt || options.includePrerelease || !gt.semver.prerelease.length) && gt.semver;
    needDomLTPre && 1 === needDomLTPre.prerelease.length && "<" === lt.operator && 0 === needDomLTPre.prerelease[0] && (needDomLTPre = !1);
    for (const c of dom) {
     if (hasDomGT = hasDomGT || ">" === c.operator || ">=" === c.operator, hasDomLT = hasDomLT || "<" === c.operator || "<=" === c.operator, 
     gt) if (needDomGTPre && c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch && (needDomGTPre = !1), 
     ">" === c.operator || ">=" === c.operator) {
      if (higher = higherGT(gt, c, options), higher === c && higher !== gt) return !1;
     } else if (">=" === gt.operator && !satisfies(gt.semver, String(c), options)) return !1;
     if (lt) if (needDomLTPre && c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch && (needDomLTPre = !1), 
     "<" === c.operator || "<=" === c.operator) {
      if (lower = lowerLT(lt, c, options), lower === c && lower !== lt) return !1;
     } else if ("<=" === lt.operator && !satisfies(lt.semver, String(c), options)) return !1;
     if (!c.operator && (lt || gt) && 0 !== gtltComp) return !1;
    }
    return !(gt && hasDomLT && !lt && 0 !== gtltComp) && (!(lt && hasDomGT && !gt && 0 !== gtltComp) && (!needDomGTPre && !needDomLTPre));
   }, higherGT = (a, b, options) => {
    if (!a) return b;
    const comp = compare(a.semver, b.semver, options);
    return comp > 0 ? a : comp < 0 || ">" === b.operator && ">=" === a.operator ? b : a;
   }, lowerLT = (a, b, options) => {
    if (!a) return b;
    const comp = compare(a.semver, b.semver, options);
    return comp < 0 ? a : comp > 0 || "<" === b.operator && "<=" === a.operator ? b : a;
   };
   module.exports = (sub, dom, options = {}) => {
    if (sub === dom) return !0;
    sub = new Range(sub, options), dom = new Range(dom, options);
    let sawNonNull = !1;
    OUTER: for (const simpleSub of sub.set) {
     for (const simpleDom of dom.set) {
      const isSub = simpleSubset(simpleSub, simpleDom, options);
      if (sawNonNull = sawNonNull || null !== isSub, isSub) continue OUTER;
     }
     if (sawNonNull) return !1;
    }
    return !0;
   };
  },
  77631: (module, __unused_webpack_exports, __webpack_require__) => {
   const Range = __webpack_require__(78311);
   module.exports = (range, options) => new Range(range, options).set.map((comp => comp.map((c => c.value)).join(" ").trim().split(" ")));
  },
  13874: (module, __unused_webpack_exports, __webpack_require__) => {
   const Range = __webpack_require__(78311);
   module.exports = (range, options) => {
    try {
     return new Range(range, options).range || "*";
    } catch (er) {
     return null;
    }
   };
  },
  36673: (module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   var punycode = __webpack_require__(24876), mappingTable = __webpack_require__(92472), PROCESSING_OPTIONS = {
    TRANSITIONAL: 0,
    NONTRANSITIONAL: 1
   };
   function normalize(str) {
    return str.split("\0").map((function(s) {
     return s.normalize("NFC");
    })).join("\0");
   }
   function findStatus(val) {
    for (var start = 0, end = mappingTable.length - 1; start <= end; ) {
     var mid = Math.floor((start + end) / 2), target = mappingTable[mid];
     if (target[0][0] <= val && target[0][1] >= val) return target;
     target[0][0] > val ? end = mid - 1 : start = mid + 1;
    }
    return null;
   }
   var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
   function countSymbols(string) {
    return string.replace(regexAstralSymbols, "_").length;
   }
   var combiningMarksRegex = /[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08E4-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C03\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D01-\u0D03\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u192B\u1930-\u193B\u19B0-\u19C0\u19C8\u19C9\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFC-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2D]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD804[\uDC00-\uDC02\uDC38-\uDC46\uDC7F-\uDC82\uDCB0-\uDCBA\uDD00-\uDD02\uDD27-\uDD34\uDD73\uDD80-\uDD82\uDDB3-\uDDC0\uDE2C-\uDE37\uDEDF-\uDEEA\uDF01-\uDF03\uDF3C\uDF3E-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF62\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDCB0-\uDCC3\uDDAF-\uDDB5\uDDB8-\uDDC0\uDE30-\uDE40\uDEAB-\uDEB7]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF51-\uDF7E\uDF8F-\uDF92]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD83A[\uDCD0-\uDCD6]|\uDB40[\uDD00-\uDDEF]/;
   function validateLabel(label, processing_option) {
    "xn--" === label.substr(0, 4) && (label = punycode.toUnicode(label));
    var error = !1;
    (normalize(label) !== label || "-" === label[3] && "-" === label[4] || "-" === label[0] || "-" === label[label.length - 1] || -1 !== label.indexOf(".") || 0 === label.search(combiningMarksRegex)) && (error = !0);
    for (var len = countSymbols(label), i = 0; i < len; ++i) {
     var status = findStatus(label.codePointAt(i));
     if (processing === PROCESSING_OPTIONS.TRANSITIONAL && "valid" !== status[1] || processing === PROCESSING_OPTIONS.NONTRANSITIONAL && "valid" !== status[1] && "deviation" !== status[1]) {
      error = !0;
      break;
     }
    }
    return {
     label,
     error
    };
   }
   function processing(domain_name, useSTD3, processing_option) {
    var result = function(domain_name, useSTD3, processing_option) {
     for (var hasError = !1, processed = "", len = countSymbols(domain_name), i = 0; i < len; ++i) {
      var codePoint = domain_name.codePointAt(i), status = findStatus(codePoint);
      switch (status[1]) {
      case "disallowed":
       hasError = !0, processed += String.fromCodePoint(codePoint);
       break;

      case "ignored":
       break;

      case "mapped":
       processed += String.fromCodePoint.apply(String, status[2]);
       break;

      case "deviation":
       processed += processing_option === PROCESSING_OPTIONS.TRANSITIONAL ? String.fromCodePoint.apply(String, status[2]) : String.fromCodePoint(codePoint);
       break;

      case "valid":
       processed += String.fromCodePoint(codePoint);
       break;

      case "disallowed_STD3_mapped":
       useSTD3 ? (hasError = !0, processed += String.fromCodePoint(codePoint)) : processed += String.fromCodePoint.apply(String, status[2]);
       break;

      case "disallowed_STD3_valid":
       useSTD3 && (hasError = !0), processed += String.fromCodePoint(codePoint);
      }
     }
     return {
      string: processed,
      error: hasError
     };
    }(domain_name, useSTD3, processing_option);
    result.string = normalize(result.string);
    for (var labels = result.string.split("."), i = 0; i < labels.length; ++i) try {
     var validation = validateLabel(labels[i]);
     labels[i] = validation.label, result.error = result.error || validation.error;
    } catch (e) {
     result.error = !0;
    }
    return {
     string: labels.join("."),
     error: result.error
    };
   }
   module.exports.toASCII = function(domain_name, useSTD3, processing_option, verifyDnsLength) {
    var result = processing(domain_name, useSTD3, processing_option), labels = result.string.split(".");
    if (labels = labels.map((function(l) {
     try {
      return punycode.toASCII(l);
     } catch (e) {
      return result.error = !0, l;
     }
    })), verifyDnsLength) {
     var total = labels.slice(0, labels.length - 1).join(".").length;
     (total.length > 253 || 0 === total.length) && (result.error = !0);
     for (var i = 0; i < labels.length; ++i) if (labels.length > 63 || 0 === labels.length) {
      result.error = !0;
      break;
     }
    }
    return result.error ? null : labels.join(".");
   }, module.exports.toUnicode = function(domain_name, useSTD3) {
    var result = processing(domain_name, useSTD3, PROCESSING_OPTIONS.NONTRANSITIONAL);
    return {
     domain: result.string,
     error: result.error
    };
   }, module.exports.PROCESSING_OPTIONS = PROCESSING_OPTIONS;
  },
  91741: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var AltimateRequest_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.AltimateRequest = exports.QueryAnalysisChatType = exports.QueryAnalysisType = exports.APIError = exports.ForbiddenError = exports.UserInputError = exports.NotFoundError = exports.NoCredentialsError = void 0;
   const tslib_1 = __webpack_require__(31635), vscode_1 = __webpack_require__(54980), utils_1 = __webpack_require__(86185), node_fetch_1 = __webpack_require__(82065), telemetry_1 = __webpack_require__(22644), path_1 = __webpack_require__(16928), fs_1 = __webpack_require__(79896), os = __webpack_require__(70857), exceptions_1 = __webpack_require__(46055), dbtProject_1 = __webpack_require__(38821), dbtTerminal_1 = __webpack_require__(83683), pythonEnvironment_1 = __webpack_require__(88103);
   class NoCredentialsError extends Error {}
   exports.NoCredentialsError = NoCredentialsError;
   class NotFoundError extends Error {}
   exports.NotFoundError = NotFoundError;
   class UserInputError extends Error {}
   exports.UserInputError = UserInputError;
   class ForbiddenError extends Error {
    constructor() {
     super("Invalid credentials. Please check instance name and API Key.");
    }
   }
   exports.ForbiddenError = ForbiddenError;
   class APIError extends Error {}
   var PromptAnswer;
   exports.APIError = APIError, function(QueryAnalysisType) {
    QueryAnalysisType.EXPLAIN = "explain", QueryAnalysisType.FIX = "fix", QueryAnalysisType.MODIFY = "modify", 
    QueryAnalysisType.TRANSLATE = "translate";
   }(exports.QueryAnalysisType || (exports.QueryAnalysisType = {})), function(QueryAnalysisChatType) {
    QueryAnalysisChatType.SYSTEM = "SystemMessage", QueryAnalysisChatType.HUMAN = "HumanMessage";
   }(exports.QueryAnalysisChatType || (exports.QueryAnalysisChatType = {})), function(PromptAnswer) {
    PromptAnswer.YES = "Get your free API Key";
   }(PromptAnswer || (PromptAnswer = {}));
   let AltimateRequest = AltimateRequest_1 = class {
    constructor(telemetry, dbtTerminal, pythonEnvironment) {
     this.telemetry = telemetry, this.dbtTerminal = dbtTerminal, this.pythonEnvironment = pythonEnvironment, 
     this.getQueryString = params => {
      const queryString = Object.keys(params).map((key => `${encodeURIComponent(key)}=${encodeURIComponent(params[key])}`)).join("&");
      return queryString ? `?${queryString}` : "";
     };
    }
    getInstanceName() {
     return this.pythonEnvironment.getResolvedConfigValue("altimateInstanceName");
    }
    getAIKey() {
     return this.pythonEnvironment.getResolvedConfigValue("altimateAiKey");
    }
    enabled() {
     return !!this.getConfig();
    }
    showAPIKeyMessage(message) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      (yield vscode_1.window.showInformationMessage(message, PromptAnswer.YES)) === PromptAnswer.YES && vscode_1.env.openExternal(vscode_1.Uri.parse("https://app.myaltimate.com/register?source=extension"));
     }));
    }
    getConfig() {
     const key = this.getAIKey(), instance = this.getInstanceName();
     if (key && instance) return {
      key,
      instance
     };
    }
    getCredentialsMessage() {
     const key = this.getAIKey(), instance = this.getInstanceName();
     return key || instance ? key ? instance ? void 0 : "To use this feature, please add an instance name in the settings." : "To use this feature, please add an API key in the settings." : "To use this feature, please add an API Key and an instance name in the settings.";
    }
    handlePreviewFeatures() {
     const message = this.getCredentialsMessage();
     return !message || (this.showAPIKeyMessage(message), !1);
    }
    fetchAsStream(endpoint, request, onProgress, timeout = 12e4) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.throwIfLocalMode(endpoint);
      const url = `${AltimateRequest_1.ALTIMATE_URL}/${endpoint}`;
      this.dbtTerminal.debug("fetchAsStream:request", url, request);
      const config = this.getConfig(), abortController = new AbortController, timeoutHandler = setTimeout((() => {
       abortController.abort();
      }), timeout);
      try {
       const response = yield (0, node_fetch_1.default)(url, {
        method: "POST",
        body: JSON.stringify(request),
        signal: abortController.signal,
        headers: {
         "x-tenant": config.instance,
         Authorization: "Bearer " + config.key,
         "Content-Type": "application/json"
        }
       });
       if (response.ok && 200 === response.status) {
        if (!(null == response ? void 0 : response.body)) return this.dbtTerminal.debug("fetchAsStream", "empty response"), 
        null;
        return yield (0, utils_1.processStreamResponse)(response.body, onProgress);
       }
       if (401 === response.status || 403 === response.status) throw this.telemetry.sendTelemetryEvent("invalidCredentials", {
        url
       }), new ForbiddenError;
       if (404 === response.status) throw this.telemetry.sendTelemetryEvent("resourceNotFound", {
        url
       }), new NotFoundError("Resource Not found");
       if (402 === response.status) {
        const jsonResponse = yield response.json();
        throw new exceptions_1.ExecutionsExhaustedException(jsonResponse.detail);
       }
       const textResponse = yield response.text();
       if (this.dbtTerminal.debug("network:response", "error from backend", textResponse), 
       429 === response.status) throw new exceptions_1.RateLimitException(textResponse, response.headers.get("Retry-After") ? parseInt(response.headers.get("Retry-After") || "") : 6e4);
       throw this.telemetry.sendTelemetryError("apiError", {
        endpoint,
        status: response.status,
        textResponse
       }), new APIError(`Could not process request, server responded with ${response.status}: ${textResponse}`);
      } catch (error) {
       throw this.dbtTerminal.error("apiCatchAllError", "fetchAsStream catchAllError", error, !0, {
        endpoint
       }), error;
      } finally {
       clearTimeout(timeoutHandler);
      }
      return null;
     }));
    }
    readStreamToBlob(stream) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      return new Promise(((resolve, reject) => {
       const chunks = [];
       stream.on("data", (chunk => chunks.push(chunk))), stream.on("end", (() => {
        const blob = new Blob(chunks);
        resolve(blob);
       })), stream.on("error", reject);
      }));
     }));
    }
    uploadToS3(endpoint, fetchArgs, filePath) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.dbtTerminal.debug("uploadToS3:", endpoint, fetchArgs, filePath), this.throwIfLocalMode(endpoint);
      const blob = yield this.readStreamToBlob((0, fs_1.createReadStream)(filePath)), response = yield (0, 
      node_fetch_1.default)(endpoint, Object.assign(Object.assign({}, fetchArgs), {
       method: "PUT",
       body: blob
      }));
      if (this.dbtTerminal.debug("uploadToS3:response:", `${response.status}`, response.statusText), 
      !response.ok || 200 !== response.status) {
       const textResponse = yield response.text();
       throw this.telemetry.sendTelemetryError("uploadToS3", {
        endpoint,
        status: response.status,
        textResponse
       }), new Error("Failed to upload data to signed url");
      }
      return response;
     }));
    }
    throwIfLocalMode(endpoint) {
     if (vscode_1.workspace.getConfiguration("dbt").get("isLocalMode", !1) && (endpoint = endpoint.split("?")[0], 
     ![ /^dbtconfig\/datapilot_version\/.*$/, /^dbtconfig\/.*\/download$/ ].some((regex => regex.test(endpoint))) && ![ "auth_health", "dbtconfig", "dbt/v1/fetch_artifact_url", "dbtconfig/extension/start_scan", "dbt/v1/project_integrations", "dbt/v1/defer_to_prod_event", "dbt/v3/validate-credentials" ].includes(endpoint))) throw new Error("This feature is not supported in local mode.");
    }
    fetch(endpoint, fetchArgs = {}, timeout = 12e4) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.dbtTerminal.debug("network:request", endpoint, fetchArgs), this.throwIfLocalMode(endpoint);
      const abortController = new AbortController, timeoutHandler = setTimeout((() => {
       abortController.abort();
      }), timeout), message = this.getCredentialsMessage();
      if (message) throw new NoCredentialsError(message);
      const config = this.getConfig();
      try {
       const url = `${AltimateRequest_1.ALTIMATE_URL}/${endpoint}`, response = yield (0, 
       node_fetch_1.default)(url, Object.assign(Object.assign({
        method: "GET"
       }, fetchArgs), {
        signal: abortController.signal,
        headers: {
         "x-tenant": config.instance,
         Authorization: "Bearer " + config.key,
         "Content-Type": "application/json"
        }
       }));
       if (this.dbtTerminal.debug("network:response", endpoint, response.status), response.ok && 200 === response.status) {
        return yield response.json();
       }
       if (401 === response.status || 403 === response.status) throw this.telemetry.sendTelemetryEvent("invalidCredentials", {
        url
       }), new ForbiddenError;
       if (404 === response.status) throw this.telemetry.sendTelemetryEvent("resourceNotFound", {
        url
       }), new NotFoundError("Resource Not found");
       if (402 === response.status) {
        const jsonResponse = yield response.json();
        throw new exceptions_1.ExecutionsExhaustedException(jsonResponse.detail);
       }
       const textResponse = yield response.text();
       if (this.dbtTerminal.debug("network:response", "error from backend", textResponse), 
       429 === response.status) throw new exceptions_1.RateLimitException(textResponse, response.headers.get("Retry-After") ? parseInt(response.headers.get("Retry-After") || "") : 6e4);
       let jsonResponse;
       this.telemetry.sendTelemetryError("apiError", {
        endpoint,
        status: response.status,
        textResponse
       });
       try {
        jsonResponse = JSON.parse(textResponse);
       } catch (_a) {}
       throw new APIError(`Could not process request, server responded with ${response.status}: ${(null == jsonResponse ? void 0 : jsonResponse.detail) || textResponse}`);
      } catch (e) {
       throw this.dbtTerminal.error("apiCatchAllError", "catchAllError", e, !0, {
        endpoint
       }), e;
      } finally {
       clearTimeout(timeoutHandler);
      }
     }));
    }
    downloadFileLocally(artifactUrl, projectRoot, fileName = "manifest.json") {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const hashedProjectRoot = dbtProject_1.DBTProject.hashProjectRoot(projectRoot.fsPath), tempFolder = (0, 
      path_1.join)(os.tmpdir(), hashedProjectRoot);
      try {
       this.dbtTerminal.debug("AltimateRequest", `creating temporary folder: ${tempFolder} for file: ${fileName}`), 
       (0, fs_1.mkdirSync)(tempFolder, {
        recursive: !0
       });
       const destinationPath = (0, path_1.join)(tempFolder, fileName);
       this.dbtTerminal.debug("AltimateRequest", `fetching artifactUrl: ${artifactUrl}`);
       const response = yield (0, node_fetch_1.default)(artifactUrl, {
        agent: void 0
       }), fileStream = (0, fs_1.createWriteStream)(destinationPath);
       return yield new Promise(((resolve, reject) => {
        var _a, _b;
        null === (_a = response.body) || void 0 === _a || _a.pipe(fileStream), null === (_b = response.body) || void 0 === _b || _b.on("error", reject), 
        fileStream.on("finish", resolve);
       })), this.dbtTerminal.debug("File downloaded successfully!", fileName), tempFolder;
      } catch (err) {
       throw this.dbtTerminal.error("downloadFileLocally", `Could not save ${fileName} locally`, err), 
       vscode_1.window.showErrorMessage(`Could not save ${fileName} locally: ${err}`), 
       err;
      }
     }));
    }
    isAuthenticated() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      try {
       yield this.fetch("auth_health", {
        method: "POST"
       });
      } catch (error) {
       return !1;
      }
      return !0;
     }));
    }
    generateModelDocsV2(docsGenerate) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      return this.fetch("dbt/v2", {
       method: "POST",
       body: JSON.stringify(docsGenerate)
      });
     }));
    }
    sendFeedback(feedback) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      return yield this.fetch("feedbacks/ai/fb", {
       method: "POST",
       body: JSON.stringify(feedback)
      });
     }));
    }
    getColumnLevelLineage(req) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      return this.fetch("dbt/v4/lineage", {
       method: "POST",
       body: JSON.stringify(req)
      });
     }));
    }
    runModeller(req) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      return this.fetch("dbt/v1/sqltomodel", {
       method: "POST",
       body: JSON.stringify(req)
      });
     }));
    }
    validateCredentials(instance, key) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const url = `${AltimateRequest_1.ALTIMATE_URL}/dbt/v3/validate-credentials`, response = yield (0, 
      node_fetch_1.default)(url, {
       method: "GET",
       headers: {
        "x-tenant": instance,
        Authorization: "Bearer " + key,
        "Content-Type": "application/json"
       }
      });
      return yield response.json();
     }));
    }
    checkApiConnectivity() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const url = `${AltimateRequest_1.ALTIMATE_URL}/health`;
      try {
       const response = yield (0, node_fetch_1.default)(url, {
        method: "GET"
       }), {status} = yield response.json();
       return {
        status
       };
      } catch (e) {
       this.dbtTerminal.error("checkApiConnectivity", "Unable to connect to backend", e, !0, {
        url
       });
       return {
        status: "not-ok",
        errorMsg: e instanceof Error ? e.message : JSON.stringify(e)
       };
      }
     }));
    }
    fetchProjectIntegrations() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      return this.fetch("dbt/v1/project_integrations");
     }));
    }
    sendDeferToProdEvent(defer_type) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      return this.fetch("dbt/v1/defer_to_prod_event", {
       method: "POST",
       body: JSON.stringify({
        defer_type
       })
      });
     }));
    }
    fetchArtifactUrl(artifact_type, dbtCoreIntegrationId) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      return this.fetch(`dbt/v1/fetch_artifact_url${this.getQueryString({
       artifact_type,
       dbt_core_integration_id: dbtCoreIntegrationId
      })}`);
     }));
    }
    getHealthcheckConfigs() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      return this.fetch(`dbtconfig${this.getQueryString({
       size: "100"
      })}`);
     }));
    }
    logDBTHealthcheckConfig(configId) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      return this.fetch(`dbtconfig/${configId}/download`);
     }));
    }
    logDBTHealthcheckStartScan() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      return this.fetch("dbtconfig/extension/start_scan");
     }));
    }
    getDatapilotVersion(extension_version) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      return this.fetch(`dbtconfig/datapilot_version/${extension_version}`);
     }));
    }
    getUsersInTenant() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      return yield this.fetch("users/chat");
     }));
    }
    getCurrentUser() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      return yield this.fetch("dbt/dbt_docs_share/user/details");
     }));
    }
    getAllSharedDbtDocs(projectNames) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const params = new URLSearchParams;
      return projectNames.forEach((p => params.append("projects", p))), yield this.fetch(`dbt/dbt_docs_share/all?${params.toString()}`);
     }));
    }
    getAppUrlByShareId(shareId) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      return yield this.fetch(`dbt/dbt_docs_share/${shareId}`, {
       method: "GET"
      });
     }));
    }
    addConversationToGroup(shareId, conversationGroupId, message) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      return yield this.fetch(`dbt/dbt_docs_share/${shareId}/conversation_group/${conversationGroupId}/conversation`, {
       method: "POST",
       body: JSON.stringify({
        message
       })
      });
     }));
    }
    createConversationGroup(shareId, data) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      return yield this.fetch(`dbt/dbt_docs_share/${shareId}/conversation_group`, {
       method: "POST",
       body: JSON.stringify(data)
      });
     }));
    }
    resolveConversation(shareId, conversationGroupId) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      return yield this.fetch(`dbt/dbt_docs_share/${shareId}/conversation_group/${conversationGroupId}/resolve`, {
       method: "POST",
       body: JSON.stringify({
        resolved: !0
       })
      });
     }));
    }
    loadConversationsByShareId(shareId) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      return yield this.fetch(`dbt/dbt_docs_share/${shareId}/conversations`);
     }));
    }
    createDbtDocsShare(data, projectName) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      return yield this.fetch("dbt/dbt_docs_share", {
       method: "POST",
       body: JSON.stringify({
        description: data.description,
        name: data.name,
        project_name: projectName
       })
      });
     }));
    }
    verifyDbtDocsUpload(share_id) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      return this.fetch("dbt/dbt_docs_share/verify_upload/", {
       method: "POST",
       body: JSON.stringify({
        share_id
       })
      });
     }));
    }
    getQueryBookmarks() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      return yield this.fetch("query/bookmark");
     }));
    }
    sqlLineage(req) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      return this.fetch("dbt/v3/sql_lineage", {
       method: "POST",
       body: JSON.stringify(req)
      });
     }));
    }
    getPreConfiguredNotebooks() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      return this.fetch("notebook/preconfigured/list", {
       method: "GET"
      });
     }));
    }
    getNotebooks(name = "", tags_list = [], privacy = "private") {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const params = new URLSearchParams(Object.assign({
       name,
       privacy
      }, tags_list.length > 0 && {
       tags_list: tags_list.join(",")
      }));
      return this.fetch(`notebook/list?${params.toString()}`, {
       method: "GET"
      });
     }));
    }
    addNotebook(req) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      return this.fetch("notebook", {
       method: "POST",
       body: JSON.stringify(req)
      });
     }));
    }
    deleteNotebook(id) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      return this.fetch(`notebook/${id}`, {
       method: "DELETE"
      });
     }));
    }
    updateNotebook(id, req) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      return this.fetch(`notebook/${id}`, {
       method: "PUT",
       body: JSON.stringify(req)
      });
     }));
    }
    updateNotebookPrivacy(id, privacy) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const params = new URLSearchParams({
       privacy
      });
      return this.fetch(`notebook/privacy/${id}?${params.toString()}`, {
       method: "PUT"
      });
     }));
    }
   };
   AltimateRequest.ALTIMATE_URL = vscode_1.workspace.getConfiguration("dbt").get("altimateUrl", "https://api.myaltimate.com"), 
   AltimateRequest = AltimateRequest_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(AltimateRequest_1), tslib_1.__metadata("design:paramtypes", [ telemetry_1.TelemetryService, dbtTerminal_1.DBTTerminal, pythonEnvironment_1.PythonEnvironment ]) ], AltimateRequest), 
   exports.AltimateRequest = AltimateRequest;
  },
  40486: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var DocAutocompletionProvider_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.DocAutocompletionProvider = void 0;
   const tslib_1 = __webpack_require__(31635), vscode_1 = __webpack_require__(54980), dbtProjectContainer_1 = __webpack_require__(82018), utils_1 = __webpack_require__(86185), telemetry_1 = __webpack_require__(22644);
   let DocAutocompletionProvider = DocAutocompletionProvider_1 = class {
    constructor(dbtProjectContainer, telemetry) {
     this.dbtProjectContainer = dbtProjectContainer, this.telemetry = telemetry, this.docAutocompleteNameItemsMap = new Map, 
     this.disposables = [], this.disposables.push(dbtProjectContainer.onManifestChanged((event => this.onManifestCacheChanged(event))));
    }
    dispose() {
     for (;this.disposables.length; ) {
      const x = this.disposables.pop();
      x && x.dispose();
     }
    }
    provideCompletionItems(document, position, token, context) {
     const linePrefix = document.lineAt(position).text.substr(0, position.character);
     if (!(0, utils_1.isEnclosedWithinCodeBlock)(document, position)) return;
     const projectRootpath = this.dbtProjectContainer.getProjectRootpath(document.uri);
     return void 0 !== projectRootpath && linePrefix.match(DocAutocompletionProvider_1.ENDS_WITH_DOC) ? this.showDocNameAutocompletionItems(projectRootpath) : void 0;
    }
    onManifestCacheChanged(event) {
     var _a, _b;
     null === (_a = event.added) || void 0 === _a || _a.forEach((added => {
      this.docAutocompleteNameItemsMap.set(added.project.projectRoot.fsPath, Array.from(added.docMetaMap.keys()).map((docName => new vscode_1.CompletionItem(docName, vscode_1.CompletionItemKind.File))));
     })), null === (_b = event.removed) || void 0 === _b || _b.forEach((removed => {
      this.docAutocompleteNameItemsMap.delete(removed.projectRoot.fsPath);
     }));
    }
    showDocNameAutocompletionItems(projectRootpath) {
     return this.telemetry.sendTelemetryEvent("provideDocAutocompletion"), this.docAutocompleteNameItemsMap.get(projectRootpath.fsPath);
    }
   };
   DocAutocompletionProvider.ENDS_WITH_DOC = /doc\(['|"]$/, DocAutocompletionProvider = DocAutocompletionProvider_1 = tslib_1.__decorate([ (0, 
   utils_1.provideSingleton)(DocAutocompletionProvider_1), tslib_1.__metadata("design:paramtypes", [ dbtProjectContainer_1.DBTProjectContainer, telemetry_1.TelemetryService ]) ], DocAutocompletionProvider), 
   exports.DocAutocompletionProvider = DocAutocompletionProvider;
  },
  78200: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var AutocompletionProviders_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.AutocompletionProviders = void 0;
   const tslib_1 = __webpack_require__(31635), vscode_1 = __webpack_require__(54980), dbtPowerUserExtension_1 = __webpack_require__(29597), utils_1 = __webpack_require__(86185), docAutocompletionProvider_1 = __webpack_require__(40486), macroAutocompletionProvider_1 = __webpack_require__(69316), modelAutocompletionProvider_1 = __webpack_require__(62409), sourceAutocompletionProvider_1 = __webpack_require__(28691), usercompletion_provider_1 = __webpack_require__(77411);
   let AutocompletionProviders = AutocompletionProviders_1 = class {
    constructor(macroAutocompletionProvider, modelAutocompletionProvider, sourceAutocompletionProvider, docAutocompletionProvider, userCompletionProvider) {
     this.macroAutocompletionProvider = macroAutocompletionProvider, this.modelAutocompletionProvider = modelAutocompletionProvider, 
     this.sourceAutocompletionProvider = sourceAutocompletionProvider, this.docAutocompletionProvider = docAutocompletionProvider, 
     this.userCompletionProvider = userCompletionProvider, this.disposables = [], this.disposables.push(vscode_1.languages.registerCompletionItemProvider(dbtPowerUserExtension_1.DBTPowerUserExtension.DBT_SQL_SELECTOR, this.macroAutocompletionProvider), vscode_1.languages.registerCompletionItemProvider(dbtPowerUserExtension_1.DBTPowerUserExtension.DBT_SQL_SELECTOR, this.modelAutocompletionProvider, ".", "(", '"', "'"), vscode_1.languages.registerCompletionItemProvider(dbtPowerUserExtension_1.DBTPowerUserExtension.DBT_SQL_SELECTOR, this.sourceAutocompletionProvider, ".", "(", '"', "'"), vscode_1.languages.registerCompletionItemProvider(dbtPowerUserExtension_1.DBTPowerUserExtension.DBT_YAML_SELECTOR, this.docAutocompletionProvider, ".", "(", '"', "'"), vscode_1.languages.registerCompletionItemProvider({
      language: "markdown"
     }, this.userCompletionProvider, "@"));
    }
    dispose() {
     for (;this.disposables.length; ) {
      const x = this.disposables.pop();
      x && x.dispose();
     }
    }
   };
   AutocompletionProviders = AutocompletionProviders_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(AutocompletionProviders_1), tslib_1.__metadata("design:paramtypes", [ macroAutocompletionProvider_1.MacroAutocompletionProvider, modelAutocompletionProvider_1.ModelAutocompletionProvider, sourceAutocompletionProvider_1.SourceAutocompletionProvider, docAutocompletionProvider_1.DocAutocompletionProvider, usercompletion_provider_1.UserCompletionProvider ]) ], AutocompletionProviders), 
   exports.AutocompletionProviders = AutocompletionProviders;
  },
  69316: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var MacroAutocompletionProvider_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.MacroAutocompletionProvider = void 0;
   const tslib_1 = __webpack_require__(31635), vscode_1 = __webpack_require__(54980), dbtProjectContainer_1 = __webpack_require__(82018), utils_1 = __webpack_require__(86185), telemetry_1 = __webpack_require__(22644);
   let MacroAutocompletionProvider = MacroAutocompletionProvider_1 = class {
    constructor(dbtProjectContainer, telemetry) {
     this.dbtProjectContainer = dbtProjectContainer, this.telemetry = telemetry, this.macrosAutocompleteMap = new Map, 
     this.disposables = [], this.getAutoCompleteItems = currentFilePath => {
      const projectRootpath = this.dbtProjectContainer.getProjectRootpath(currentFilePath);
      if (void 0 !== projectRootpath) return this.telemetry.sendTelemetryEvent("provideMacroAutocompletion"), 
      this.macrosAutocompleteMap.get(projectRootpath.fsPath);
     }, this.disposables.push(dbtProjectContainer.onManifestChanged((event => this.onManifestCacheChanged(event))));
    }
    dispose() {
     for (;this.disposables.length; ) {
      const x = this.disposables.pop();
      x && x.dispose();
     }
    }
    provideCompletionItems(document, position, token, context) {
     const range = document.getWordRangeAtPosition(position);
     if (range && (0, utils_1.isEnclosedWithinCodeBlock)(document, range)) return this.getAutoCompleteItems(document.uri);
    }
    onManifestCacheChanged(event) {
     var _a, _b;
     null === (_a = event.added) || void 0 === _a || _a.forEach((added => {
      this.macrosAutocompleteMap.set(added.project.projectRoot.fsPath, Array.from(added.macroMetaMap.keys()).map((macro => ({
       label: macro,
       insertText: macro,
       kind: vscode_1.CompletionItemKind.Value,
       detail: "Macro"
      }))));
     })), null === (_b = event.removed) || void 0 === _b || _b.forEach((removed => {
      this.macrosAutocompleteMap.delete(removed.projectRoot.fsPath);
     }));
    }
   };
   MacroAutocompletionProvider = MacroAutocompletionProvider_1 = tslib_1.__decorate([ (0, 
   utils_1.provideSingleton)(MacroAutocompletionProvider_1), tslib_1.__metadata("design:paramtypes", [ dbtProjectContainer_1.DBTProjectContainer, telemetry_1.TelemetryService ]) ], MacroAutocompletionProvider), 
   exports.MacroAutocompletionProvider = MacroAutocompletionProvider;
  },
  62409: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var ModelAutocompletionProvider_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.ModelAutocompletionProvider = void 0;
   const tslib_1 = __webpack_require__(31635), vscode_1 = __webpack_require__(54980), dbtProjectContainer_1 = __webpack_require__(82018), utils_1 = __webpack_require__(86185), telemetry_1 = __webpack_require__(22644), dbtProject_1 = __webpack_require__(38821);
   let ModelAutocompletionProvider = ModelAutocompletionProvider_1 = class {
    constructor(dbtProjectContainer, telemetry) {
     this.dbtProjectContainer = dbtProjectContainer, this.telemetry = telemetry, this.modelAutocompleteMap = new Map, 
     this.disposables = [], this.getAutoCompleteItems = currentFilePath => {
      const projectRootpath = this.dbtProjectContainer.getProjectRootpath(currentFilePath);
      if (void 0 === projectRootpath) {
       const project = this.dbtProjectContainer.getFromWorkspaceState("dbtPowerUser.projectSelected");
       if (!(null == project ? void 0 : project.uri)) return;
       return this.modelAutocompleteMap.get(project.uri.fsPath);
      }
      return this.telemetry.sendTelemetryEvent("provideModelAutocompletion"), this.modelAutocompleteMap.get(projectRootpath.fsPath);
     }, this.disposables.push(dbtProjectContainer.onManifestChanged((event => this.onManifestCacheChanged(event))));
    }
    dispose() {
     for (;this.disposables.length; ) {
      const x = this.disposables.pop();
      x && x.dispose();
     }
    }
    provideCompletionItems(document, position, token, context) {
     const line = document.lineAt(position).text, linePrefix = line.substring(0, position.character);
     if (!(0, utils_1.isEnclosedWithinCodeBlock)(document, position)) return;
     const modelMatch = linePrefix.match(ModelAutocompletionProvider_1.MODEL_PATTERN), packageMatch = linePrefix.match(ModelAutocompletionProvider_1.PACKAGE_PATTERN);
     if (!modelMatch && !packageMatch) return;
     let autoCompleteItems = this.getAutoCompleteItems(document.uri);
     if (autoCompleteItems) {
      if (modelMatch) {
       if (!modelMatch[1]) return autoCompleteItems.map((completionItem => ({
        label: `(${completionItem.packageName}) ${completionItem.modelName}`,
        kind: vscode_1.CompletionItemKind.Value,
        detail: "Model",
        insertText: completionItem.projectName === completionItem.packageName ? `"${completionItem.modelName}"` : `"${completionItem.packageName}", "${completionItem.modelName}"`
       })));
       const endQuote = line[position.character] === modelMatch[1] ? "" : modelMatch[1];
       return autoCompleteItems.map((completionItem => ({
        label: `(${completionItem.packageName}) ${completionItem.modelName}`,
        kind: vscode_1.CompletionItemKind.Value,
        detail: "Model",
        insertText: completionItem.projectName === completionItem.packageName ? `${completionItem.modelName}${endQuote}` : `${completionItem.packageName}${modelMatch[1]}, ${modelMatch[1]}${completionItem.modelName}${endQuote}`
       })));
      }
      if (packageMatch) {
       const packageName = packageMatch[1].replace(/['"]/g, "");
       if (autoCompleteItems = autoCompleteItems.filter((completionItem => completionItem.packageName === packageName)), 
       !packageMatch[2]) return autoCompleteItems.map((completionItem => ({
        label: completionItem.modelName,
        kind: vscode_1.CompletionItemKind.Value,
        detail: "Model",
        insertText: `"${completionItem.modelName}"`
       })));
       const endQuote = line[position.character] === packageMatch[2] ? "" : packageMatch[2];
       return autoCompleteItems.map((completionItem => ({
        label: completionItem.modelName,
        kind: vscode_1.CompletionItemKind.Value,
        detail: "Model",
        insertText: `${completionItem.modelName}${endQuote}`
       })));
      }
     }
    }
    onManifestCacheChanged(event) {
     var _a, _b;
     null === (_a = event.added) || void 0 === _a || _a.forEach((added => {
      const projectName = added.project.getProjectName(), models = added.nodeMetaMap.nodes(), autocompleteItems = Array.from(models).filter((model => model.resource_type !== dbtProject_1.DBTProject.RESOURCE_TYPE_ANALYSIS)).map((model => ({
       projectName,
       packageName: model.package_name,
       modelName: model.name
      }))), uniqueItems = {};
      for (const item of autocompleteItems) {
       const key = `${item.projectName}|${item.packageName}|${item.modelName}`;
       uniqueItems[key] || (uniqueItems[key] = item);
      }
      this.modelAutocompleteMap.set(added.project.projectRoot.fsPath, Object.values(uniqueItems));
     })), null === (_b = event.removed) || void 0 === _b || _b.forEach((removed => {
      this.modelAutocompleteMap.delete(removed.projectRoot.fsPath);
     }));
    }
   };
   ModelAutocompletionProvider.MODEL_PATTERN = /ref\s*\(\s*(['"])?\s*\w*$/, ModelAutocompletionProvider.PACKAGE_PATTERN = /ref\s*\(\s*('[^)']*'|"[^)"]*")\s*,\s*(['"])?\s*\w*$/, 
   ModelAutocompletionProvider = ModelAutocompletionProvider_1 = tslib_1.__decorate([ (0, 
   utils_1.provideSingleton)(ModelAutocompletionProvider_1), tslib_1.__metadata("design:paramtypes", [ dbtProjectContainer_1.DBTProjectContainer, telemetry_1.TelemetryService ]) ], ModelAutocompletionProvider), 
   exports.ModelAutocompletionProvider = ModelAutocompletionProvider;
  },
  28691: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var SourceAutocompletionProvider_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.SourceAutocompletionProvider = void 0;
   const tslib_1 = __webpack_require__(31635), vscode_1 = __webpack_require__(54980), dbtProjectContainer_1 = __webpack_require__(82018), utils_1 = __webpack_require__(86185), telemetry_1 = __webpack_require__(22644);
   let SourceAutocompletionProvider = SourceAutocompletionProvider_1 = class {
    constructor(dbtProjectContainer, telemetry) {
     this.dbtProjectContainer = dbtProjectContainer, this.telemetry = telemetry, this.sourceAutocompleteNameItemsMap = new Map, 
     this.sourceAutocompleteTableMap = new Map, this.disposables = [], this.disposables.push(dbtProjectContainer.onManifestChanged((event => this.onManifestCacheChanged(event))));
    }
    dispose() {
     for (;this.disposables.length; ) {
      const x = this.disposables.pop();
      x && x.dispose();
     }
    }
    provideCompletionItems(document, position, token, context) {
     const linePrefix = document.lineAt(position).text.substr(0, position.character);
     if (!(0, utils_1.isEnclosedWithinCodeBlock)(document, position)) return;
     const projectRootpath = this.dbtProjectContainer.getProjectRootpath(document.uri);
     if (void 0 !== projectRootpath) {
      if (linePrefix.match(SourceAutocompletionProvider_1.ENDS_WITH_SOURCE)) return this.showSourceNameAutocompletionItems(projectRootpath);
      if (linePrefix.match(SourceAutocompletionProvider_1.GET_SOURCE_NAME) && linePrefix.includes("source")) {
       return this.showTableNameAutocompletionItems(linePrefix, projectRootpath);
      }
     }
    }
    onManifestCacheChanged(event) {
     var _a, _b;
     null === (_a = event.added) || void 0 === _a || _a.forEach((added => {
      this.sourceAutocompleteNameItemsMap.set(added.project.projectRoot.fsPath, Array.from(added.sourceMetaMap.keys()).map((source => new vscode_1.CompletionItem(source, vscode_1.CompletionItemKind.File))));
      const sourceTableMap = new Map;
      added.sourceMetaMap.forEach(((value, key) => {
       const autocompleteItems = value.tables.map((item => new vscode_1.CompletionItem(item.name, vscode_1.CompletionItemKind.File)));
       sourceTableMap.set(key, autocompleteItems);
      })), this.sourceAutocompleteTableMap.set(added.project.projectRoot.fsPath, sourceTableMap);
     })), null === (_b = event.removed) || void 0 === _b || _b.forEach((removed => {
      this.sourceAutocompleteNameItemsMap.delete(removed.projectRoot.fsPath), this.sourceAutocompleteTableMap.delete(removed.projectRoot.fsPath);
     }));
    }
    showSourceNameAutocompletionItems(projectRootpath) {
     return this.sourceAutocompleteNameItemsMap.get(projectRootpath.fsPath);
    }
    showTableNameAutocompletionItems(linePrefix, projectRootpath) {
     const sourceNameMatch = linePrefix.match(SourceAutocompletionProvider_1.GET_SOURCE_NAME);
     if (null !== sourceNameMatch) {
      const sourceTableMap = this.sourceAutocompleteTableMap.get(projectRootpath.fsPath);
      if (void 0 === sourceTableMap) return;
      return this.telemetry.sendTelemetryEvent("provideSourceAutocompletion"), sourceTableMap.get(sourceNameMatch[0]);
     }
    }
   };
   SourceAutocompletionProvider.GET_SOURCE_NAME = /(?!['"])(\w+)(?=['"])/, SourceAutocompletionProvider.ENDS_WITH_SOURCE = /source\(['|"]$/, 
   SourceAutocompletionProvider = SourceAutocompletionProvider_1 = tslib_1.__decorate([ (0, 
   utils_1.provideSingleton)(SourceAutocompletionProvider_1), tslib_1.__metadata("design:paramtypes", [ dbtProjectContainer_1.DBTProjectContainer, telemetry_1.TelemetryService ]) ], SourceAutocompletionProvider), 
   exports.SourceAutocompletionProvider = SourceAutocompletionProvider;
  },
  77411: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var UserCompletionProvider_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.UserCompletionProvider = void 0;
   const tslib_1 = __webpack_require__(31635), vscode_1 = __webpack_require__(54980), utils_1 = __webpack_require__(86185), usersService_1 = __webpack_require__(8502);
   let UserCompletionProvider = UserCompletionProvider_1 = class {
    constructor(usersService) {
     this.usersService = usersService, this.disposables = [];
    }
    dispose() {
     for (;this.disposables.length; ) {
      const x = this.disposables.pop();
      x && x.dispose();
     }
    }
    provideCompletionItems() {
     return this.usersService.users.map((user => ({
      label: {
       label: `${user.display_name}`,
       detail: " (Altimate)"
      },
      kind: vscode_1.CompletionItemKind.User,
      keepWhitespace: !0,
      insertText: `${user.display_name} `
     })));
    }
   };
   UserCompletionProvider = UserCompletionProvider_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(UserCompletionProvider_1), tslib_1.__metadata("design:paramtypes", [ usersService_1.UsersService ]) ], UserCompletionProvider), 
   exports.UserCompletionProvider = UserCompletionProvider;
  },
  69137: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var DocumentationCodeLensProvider_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.DocumentationCodeLensProvider = void 0;
   const tslib_1 = __webpack_require__(31635), vscode_1 = __webpack_require__(54980), utils_1 = __webpack_require__(86185), yaml_1 = __webpack_require__(91198);
   let DocumentationCodeLensProvider = DocumentationCodeLensProvider_1 = class {
    constructor() {
     this._onDidChangeCodeLenses = new vscode_1.EventEmitter, this.onDidChangeCodeLenses = this._onDidChangeCodeLenses.event;
    }
    provideCodeLenses(document, token) {
     const isNotebooksEnabled = vscode_1.workspace.getConfiguration("dbt").get("enableNotebooks", !1), codeLenses = [];
     if (document.fileName.endsWith(".sql")) return codeLenses.push(new vscode_1.CodeLens(new vscode_1.Range(0, 0, 1, 1), {
      title: "Add documentation or tests",
      tooltip: "Add documentation or tests for this model",
      command: "dbtPowerUser.DocsEdit.focus",
      arguments: []
     })), isNotebooksEnabled && (codeLenses.push(new vscode_1.CodeLens(new vscode_1.Range(0, 0, 1, 1), {
      title: "Profile this query",
      tooltip: "Profile this query",
      command: "dbtPowerUser.createDatapilotNotebook",
      arguments: [ {
       template: "Profile your query"
      } ]
     })), codeLenses.push(new vscode_1.CodeLens(new vscode_1.Range(0, 0, 1, 1), {
      title: "Get test suggestions",
      tooltip: "Get test suggestions",
      command: "dbtPowerUser.createDatapilotNotebook",
      arguments: [ {
       template: "Get test suggestions"
      } ]
     })), codeLenses.push(new vscode_1.CodeLens(new vscode_1.Range(0, 0, 1, 1), {
      title: "Generate dbt base model sql",
      tooltip: "Generate dbt base model sql",
      command: "dbtPowerUser.createDatapilotNotebook",
      arguments: [ {
       template: "Generate dbt base model sql"
      } ]
     })), codeLenses.push(new vscode_1.CodeLens(new vscode_1.Range(0, 0, 1, 1), {
      title: "Generate dbt model yaml",
      tooltip: "Generate dbt model yaml",
      command: "dbtPowerUser.createDatapilotNotebook",
      arguments: [ {
       template: "Generate dbt model yaml"
      } ]
     })), codeLenses.push(new vscode_1.CodeLens(new vscode_1.Range(0, 0, 1, 1), {
      title: "Generate dbt model CTE",
      tooltip: "Generate dbt model CTE",
      command: "dbtPowerUser.createDatapilotNotebook",
      arguments: [ {
       template: "Generate dbt model CTE"
      } ]
     }))), codeLenses;
     const lineCounter = new yaml_1.LineCounter;
     for (const token of new yaml_1.Parser(lineCounter.addNewLine).parse(document.getText())) if ("document" === token.type && yaml_1.CST.isCollection(token.value)) for (const item of token.value.items) if (yaml_1.CST.isScalar(item.key) && "models" === item.key.source && yaml_1.CST.isCollection(item.value)) for (const modelItem of item.value.items) if (yaml_1.CST.isCollection(modelItem.value)) for (const properties of modelItem.value.items) if (yaml_1.CST.isScalar(properties.key) && yaml_1.CST.isScalar(properties.value) && "name" === properties.key.source) {
      const position = lineCounter.linePos(properties.key.offset);
      codeLenses.push(new vscode_1.CodeLens(new vscode_1.Range(position.line - 1, position.col, position.line - 1, position.col), {
       title: "Add documentation or tests",
       tooltip: "Add documentation or tests for this model",
       command: "dbtPowerUser.showDocumentation",
       arguments: [ properties.value.source ]
      }));
     }
     return codeLenses;
    }
   };
   DocumentationCodeLensProvider = DocumentationCodeLensProvider_1 = tslib_1.__decorate([ (0, 
   utils_1.provideSingleton)(DocumentationCodeLensProvider_1) ], DocumentationCodeLensProvider), 
   exports.DocumentationCodeLensProvider = DocumentationCodeLensProvider;
  },
  77463: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var CodeLensProviders_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.CodeLensProviders = void 0;
   const tslib_1 = __webpack_require__(31635), vscode_1 = __webpack_require__(54980), dbtPowerUserExtension_1 = __webpack_require__(29597), utils_1 = __webpack_require__(86185), sourceModelCreationCodeLensProvider_1 = __webpack_require__(46788), virtualSqlCodeLensProvider_1 = __webpack_require__(55666), documentationCodeLensProvider_1 = __webpack_require__(69137), dbtProjectContainer_1 = __webpack_require__(82018);
   let CodeLensProviders = CodeLensProviders_1 = class {
    constructor(dbtProjectContainer, sourceModelCreationCodeLensProvider, virtualSqlCodeLensProvider, documentationCodeLensProvider) {
     this.dbtProjectContainer = dbtProjectContainer, this.sourceModelCreationCodeLensProvider = sourceModelCreationCodeLensProvider, 
     this.virtualSqlCodeLensProvider = virtualSqlCodeLensProvider, this.documentationCodeLensProvider = documentationCodeLensProvider, 
     this.disposables = [], this.dbtProjectContainer.onDBTProjectsInitialization((() => {
      this.disposables.push(vscode_1.languages.registerCodeLensProvider(dbtPowerUserExtension_1.DBTPowerUserExtension.DBT_YAML_SELECTOR, this.sourceModelCreationCodeLensProvider)), 
      this.disposables.push(vscode_1.languages.registerCodeLensProvider(dbtPowerUserExtension_1.DBTPowerUserExtension.DBT_SQL_SELECTOR, this.virtualSqlCodeLensProvider)), 
      this.disposables.push(vscode_1.languages.registerCodeLensProvider(dbtPowerUserExtension_1.DBTPowerUserExtension.DBT_YAML_SELECTOR, this.documentationCodeLensProvider)), 
      this.disposables.push(vscode_1.languages.registerCodeLensProvider(dbtPowerUserExtension_1.DBTPowerUserExtension.DBT_SQL_SELECTOR, this.documentationCodeLensProvider));
     }));
    }
    dispose() {
     for (;this.disposables.length; ) {
      const x = this.disposables.pop();
      x && x.dispose();
     }
    }
   };
   CodeLensProviders = CodeLensProviders_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(CodeLensProviders_1), tslib_1.__metadata("design:paramtypes", [ dbtProjectContainer_1.DBTProjectContainer, sourceModelCreationCodeLensProvider_1.SourceModelCreationCodeLensProvider, virtualSqlCodeLensProvider_1.VirtualSqlCodeLensProvider, documentationCodeLensProvider_1.DocumentationCodeLensProvider ]) ], CodeLensProviders), 
   exports.CodeLensProviders = CodeLensProviders;
  },
  46788: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var SourceModelCreationCodeLensProvider_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.SourceModelCreationCodeLensProvider = void 0;
   const tslib_1 = __webpack_require__(31635), vscode_1 = __webpack_require__(54980), yaml_1 = __webpack_require__(91198), utils_1 = __webpack_require__(86185);
   let SourceModelCreationCodeLensProvider = SourceModelCreationCodeLensProvider_1 = class {
    constructor() {
     this.codeLenses = [], this._onDidChangeCodeLenses = new vscode_1.EventEmitter, this.onDidChangeCodeLenses = this._onDidChangeCodeLenses.event;
    }
    provideCodeLenses(document, token) {
     this.codeLenses = [];
     const lineCounter = new yaml_1.LineCounter;
     let currentSource, currentDatabase, currentSchema, currentTables;
     for (const token of new yaml_1.Parser(lineCounter.addNewLine).parse(document.getText())) if ("document" === token.type && yaml_1.CST.isCollection(token.value)) for (const i in token.value.items) {
      const item = token.value.items[i];
      if (yaml_1.CST.isScalar(item.key) && "sources" === item.key.source && yaml_1.CST.isCollection(item.value)) for (const j in item.value.items) {
       currentTables = [];
       const source = item.value.items[j];
       if (yaml_1.CST.isCollection(source.value)) for (const k in source.value.items) {
        const sourceProperty = source.value.items[k];
        if (yaml_1.CST.isScalar(sourceProperty.key) && yaml_1.CST.isScalar(sourceProperty.value) && ("name" === sourceProperty.key.source && (currentSource = sourceProperty.value.source), 
        "database" === sourceProperty.key.source && (currentDatabase = sourceProperty.value.source), 
        "schema" === sourceProperty.key.source && (currentSchema = sourceProperty.value.source)), 
        yaml_1.CST.isScalar(sourceProperty.key) && yaml_1.CST.isCollection(sourceProperty.value) && "tables" === sourceProperty.key.source) {
         let tableName, tableIdentifier, position;
         for (const l in sourceProperty.value.items) {
          const table = sourceProperty.value.items[l];
          if (yaml_1.CST.isCollection(table.value)) for (const m in table.value.items) {
           position = lineCounter.linePos(table.value.offset);
           const tableProperty = table.value.items[m];
           yaml_1.CST.isScalar(tableProperty.value) && yaml_1.CST.isScalar(tableProperty.key) && ("name" === tableProperty.key.source && (tableName = tableProperty.value.source), 
           "identifier" === tableProperty.key.source && (tableIdentifier = tableProperty.value.source));
          }
          void 0 !== tableName && void 0 !== position && (currentTables.push({
           tableName,
           tableIdentifier,
           pos: position
          }), tableName = void 0, tableIdentifier = void 0, position = void 0);
         }
        }
       }
       for (const i in currentTables) {
        const table = currentTables[i], params = {
         currentDoc: document.uri,
         sourceName: currentSource,
         database: currentDatabase,
         schema: currentSchema,
         tableName: table.tableName,
         tableIdentifier: table.tableIdentifier
        };
        this.codeLenses.push(new vscode_1.CodeLens(new vscode_1.Range(table.pos.line - 1, table.pos.col, table.pos.line - 1, table.pos.col), {
         title: "Generate model",
         tooltip: "Generate model based on source configuration",
         command: "dbtPowerUser.createModelBasedonSourceConfig",
         arguments: [ params ]
        }));
       }
       currentDatabase = void 0, currentSchema = void 0, currentSource = void 0;
      }
     }
     return this.codeLenses;
    }
   };
   SourceModelCreationCodeLensProvider = SourceModelCreationCodeLensProvider_1 = tslib_1.__decorate([ (0, 
   utils_1.provideSingleton)(SourceModelCreationCodeLensProvider_1) ], SourceModelCreationCodeLensProvider), 
   exports.SourceModelCreationCodeLensProvider = SourceModelCreationCodeLensProvider;
  },
  55666: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var VirtualSqlCodeLensProvider_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.VirtualSqlCodeLensProvider = void 0;
   const tslib_1 = __webpack_require__(31635), vscode_1 = __webpack_require__(54980), utils_1 = __webpack_require__(86185), queryManifestService_1 = __webpack_require__(59269), dbtProjectContainer_1 = __webpack_require__(82018), _lib_1 = __webpack_require__(17176);
   let VirtualSqlCodeLensProvider = VirtualSqlCodeLensProvider_1 = class {
    constructor(dbtProjectContainer, queryManifestService, notebookService) {
     this.dbtProjectContainer = dbtProjectContainer, this.queryManifestService = queryManifestService, 
     this.notebookService = notebookService, this.disposables = [];
    }
    dispose() {
     for (;this.disposables.length; ) {
      const x = this.disposables.pop();
      x && x.dispose();
     }
    }
    getProjectName() {
     var _a;
     const project = this.dbtProjectContainer.getFromWorkspaceState("dbtPowerUser.projectSelected");
     return (null == project ? void 0 : project.label) ? project.label : null === (_a = this.queryManifestService.getProject()) || void 0 === _a ? void 0 : _a.getProjectName();
    }
    provideCodeLenses(document, token) {
     var _a, _b;
     if ("untitled" !== document.uri.scheme && "vscode-notebook-cell" !== document.uri.scheme || "jinja-sql" !== document.languageId) return [];
     const topOfDocument = new vscode_1.Range(0, 0, 0, 0), projectSelectorCommand = {
      title: `Project: ${this.getProjectName() || "Select a project"}`,
      command: "dbtPowerUser.pickProject",
      arguments: [ document.uri ]
     }, projectSelectorCodeLens = new vscode_1.CodeLens(topOfDocument, projectSelectorCommand);
     if ("vscode-notebook-cell" === document.uri.scheme && (null === (_a = vscode_1.window.activeNotebookEditor) || void 0 === _a ? void 0 : _a.notebook)) {
      const cells = this.notebookService.getCellByNotebookAutocompleteMap().get(null === (_b = vscode_1.window.activeNotebookEditor) || void 0 === _b ? void 0 : _b.notebook.uri.fsPath), cell = null == cells ? void 0 : cells.find((c => c.fragment === document.uri.fragment));
      if (cell) {
       return [ new vscode_1.CodeLens(topOfDocument, {
        title: `Cell id: cell_${cell.cellId}`,
        command: "",
        arguments: [ document.uri ]
       }) ];
      }
      return [];
     }
     return [ projectSelectorCodeLens ];
    }
   };
   VirtualSqlCodeLensProvider = VirtualSqlCodeLensProvider_1 = tslib_1.__decorate([ (0, 
   utils_1.provideSingleton)(VirtualSqlCodeLensProvider_1), tslib_1.__metadata("design:paramtypes", [ dbtProjectContainer_1.DBTProjectContainer, queryManifestService_1.QueryManifestService, _lib_1.NotebookService ]) ], VirtualSqlCodeLensProvider), 
   exports.VirtualSqlCodeLensProvider = VirtualSqlCodeLensProvider;
  },
  7824: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var CommandProcessExecutionFactory_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.CommandProcessExecution = exports.CommandProcessExecutionFactory = void 0;
   const tslib_1 = __webpack_require__(31635), child_process_1 = __webpack_require__(35317), inversify_binding_decorators_1 = __webpack_require__(25567), dbtTerminal_1 = __webpack_require__(83683);
   let CommandProcessExecutionFactory = CommandProcessExecutionFactory_1 = class {
    constructor(terminal) {
     this.terminal = terminal;
    }
    createCommandProcessExecution({command, args, stdin, cwd, tokens, envVars}) {
     return new CommandProcessExecution(this.terminal, command, args, stdin, cwd, tokens, envVars);
    }
   };
   CommandProcessExecutionFactory = CommandProcessExecutionFactory_1 = tslib_1.__decorate([ (0, 
   inversify_binding_decorators_1.provide)(CommandProcessExecutionFactory_1), tslib_1.__metadata("design:paramtypes", [ dbtTerminal_1.DBTTerminal ]) ], CommandProcessExecutionFactory), 
   exports.CommandProcessExecutionFactory = CommandProcessExecutionFactory;
   class CommandProcessExecution {
    constructor(terminal, command, args, stdin, cwd, tokens, envVars) {
     this.terminal = terminal, this.command = command, this.args = args, this.stdin = stdin, 
     this.cwd = cwd, this.tokens = tokens, this.envVars = envVars, this.disposables = [];
    }
    spawn() {
     const proc = (0, child_process_1.spawn)(this.command, this.args, {
      cwd: this.cwd,
      env: this.envVars
     });
     return void 0 !== this.tokens && this.tokens.forEach((token => this.disposables.push(token.onCancellationRequested((() => {
      proc.kill("SIGTERM");
     }))))), proc;
    }
    dispose() {
     for (;this.disposables.length; ) {
      const x = this.disposables.pop();
      x && x.dispose();
     }
    }
    complete() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      return new Promise(((resolve, reject) => {
       this.terminal.debug("CommandProcessExecution", "Going to execute command : " + this.command, this.args);
       const commandProcess = this.spawn();
       let stdoutBuffer = "", stderrBuffer = "", fullOutput = "";
       commandProcess.stdout.on("data", (chunk => {
        chunk = chunk.toString(), stdoutBuffer += chunk, fullOutput += chunk;
       })), commandProcess.stderr.on("data", (chunk => {
        chunk = chunk.toString(), stderrBuffer += chunk, fullOutput += chunk;
       })), commandProcess.once("close", (() => {
        this.terminal.debug("CommandProcessExecution", "Return value from command: " + this.command, this.args, fullOutput), 
        resolve({
         stdout: stdoutBuffer,
         stderr: stderrBuffer,
         fullOutput
        });
       })), commandProcess.once("error", (error => {
        this.terminal.error("CommandProcessExecutionError", "Command errored: " + this.command, error, !0, this.command, this.args, error), 
        reject(new Error(`${error}`));
       })), this.stdin && (commandProcess.stdin.write(this.stdin), commandProcess.stdin.end());
      }));
     }));
    }
    completeWithTerminalOutput() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      return new Promise(((resolve, reject) => {
       const commandProcess = this.spawn();
       let stdoutBuffer = "", stderrBuffer = "", fullOutput = "";
       commandProcess.stdout.on("data", (chunk => {
        const line = `${this.formatText(chunk.toString())}`;
        stdoutBuffer += line, this.terminal.log(line), fullOutput += line;
       })), commandProcess.stderr.on("data", (chunk => {
        const line = `${this.formatText(chunk.toString())}`;
        stderrBuffer += line, this.terminal.log(line), fullOutput += line;
       })), commandProcess.once("close", (() => {
        resolve({
         stdout: stdoutBuffer,
         stderr: stderrBuffer,
         fullOutput
        }), this.terminal.log(""), this.dispose();
       })), commandProcess.once("error", (error => {
        reject(new Error(`Error occurred during process execution: ${error}`));
       })), this.stdin && (commandProcess.stdin.write(this.stdin), commandProcess.stdin.end());
      }));
     }));
    }
    formatText(text) {
     return `${text.split(/(\r?\n)+/g).join("\r")}`;
    }
   }
   exports.CommandProcessExecution = CommandProcessExecution;
  },
  48933: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var AltimateScan_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.AltimateScan = void 0;
   const tslib_1 = __webpack_require__(31635), vscode_1 = __webpack_require__(54980), altimate_1 = __webpack_require__(91741), dbtProjectContainer_1 = __webpack_require__(82018), telemetry_1 = __webpack_require__(22644), utils_1 = __webpack_require__(86185), initCatalog_1 = __webpack_require__(37296), undocumentedModelColumnTest_1 = __webpack_require__(78367), staleModelColumnTest_1 = __webpack_require__(28237), missingSchemaTest_1 = __webpack_require__(90718), unmaterializedModelTest_1 = __webpack_require__(10332), scanContext_1 = __webpack_require__(67209), dbtTerminal_1 = __webpack_require__(83683);
   let AltimateScan = AltimateScan_1 = class {
    constructor(dbtProjectContainer, telemetry, altimate, missingSchemaTest, undocumentedModelColumnTest, unmaterializedModelTest, staleModelColumnTest, dbtTerminal) {
     this.dbtProjectContainer = dbtProjectContainer, this.telemetry = telemetry, this.altimate = altimate, 
     this.missingSchemaTest = missingSchemaTest, this.undocumentedModelColumnTest = undocumentedModelColumnTest, 
     this.unmaterializedModelTest = unmaterializedModelTest, this.staleModelColumnTest = staleModelColumnTest, 
     this.dbtTerminal = dbtTerminal, this.eventMap = new Map, dbtProjectContainer.onManifestChanged((event => this.onManifestCacheChanged(event))), 
     this.offlineAltimateScanSteps = [ missingSchemaTest ], this.onlineAltimateScanSteps = [ unmaterializedModelTest, undocumentedModelColumnTest, staleModelColumnTest ], 
     this.altimateScanSteps = [];
    }
    onManifestCacheChanged(event) {
     var _a, _b;
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      null === (_a = event.added) || void 0 === _a || _a.forEach((added => {
       this.eventMap.set(added.project.projectRoot.fsPath, added);
      })), null === (_b = event.removed) || void 0 === _b || _b.forEach((removed => {
       this.eventMap.delete(removed.projectRoot.fsPath);
      }));
     }));
    }
    clearProblems() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.telemetry.sendTelemetryEvent("altimateScan:Clear"), vscode_1.window.withProgress({
       location: vscode_1.ProgressLocation.Notification,
       title: "Clearing problems...",
       cancellable: !1
      }, (() => tslib_1.__awaiter(this, void 0, void 0, (function*() {
       const projects = this.dbtProjectContainer.getProjects();
       for (const project of projects) project.projectHealth.clear();
      }))));
     }));
    }
    getProblems() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.telemetry.sendTelemetryEvent("altimateScan:Start");
      let totalProblems = 0;
      vscode_1.window.withProgress({
       location: vscode_1.ProgressLocation.Notification,
       title: "Scanning for problems...",
       cancellable: !0
      }, (() => tslib_1.__awaiter(this, void 0, void 0, (function*() {
       const projects = this.dbtProjectContainer.getProjects();
       for (const project of projects) try {
        const scanContext = new scanContext_1.ScanContext(project, this.eventMap.get(project.projectRoot.fsPath));
        yield this.runSteps(scanContext), totalProblems += this.showDiagnostics(scanContext);
       } catch (err) {
        this.dbtTerminal.debug("altimateScane:getProblems", `Error occurred for ${project.getProjectName()}`, err);
       }
       yield vscode_1.commands.executeCommand("workbench.actions.view.problems"), this.telemetry.sendTelemetryEvent("altimateScan:Done", {
        problemsFound: totalProblems.toString()
       });
      }))));
     }));
    }
    runSteps(scanContext) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      yield Promise.all(this.offlineAltimateScanSteps.map((stepof => tslib_1.__awaiter(this, void 0, void 0, (function*() {
       return yield stepof.run(scanContext);
      }))))), yield this.initCatalog(scanContext), void 0 !== scanContext.scanResults.missingCatalog && !0 === scanContext.scanResults.missingCatalog[scanContext.project.getProjectName() + scanContext.project.projectRoot] || (yield Promise.all(this.onlineAltimateScanSteps.map((stepon => tslib_1.__awaiter(this, void 0, void 0, (function*() {
       return yield stepon.run(scanContext);
      }))))));
     }));
    }
    initCatalog(scanContext) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      if (void 0 === scanContext) throw new Error("Scan Context has not been set");
      const projectCatalog = yield (new initCatalog_1.InitCatalog).run(scanContext);
      scanContext.catalog[scanContext.project.getProjectName() + scanContext.project.projectRoot] = projectCatalog;
     }));
    }
    showDiagnostics(scanContext) {
     if (void 0 === scanContext) throw new Error("Scan Context has not been set");
     scanContext.project.projectHealth.clear();
     let totalProblems = 0;
     for (const [filePath, fileDiagnostics] of Object.entries(scanContext.diagnostics)) scanContext.project.projectHealth.set(vscode_1.Uri.file(filePath), fileDiagnostics), 
     totalProblems += fileDiagnostics.length;
     return totalProblems;
    }
   };
   AltimateScan = AltimateScan_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(AltimateScan_1), tslib_1.__metadata("design:paramtypes", [ dbtProjectContainer_1.DBTProjectContainer, telemetry_1.TelemetryService, altimate_1.AltimateRequest, missingSchemaTest_1.MissingSchemaTest, undocumentedModelColumnTest_1.UndocumentedModelColumnTest, unmaterializedModelTest_1.UnmaterializedModelTest, staleModelColumnTest_1.StaleModelColumnTest, dbtTerminal_1.DBTTerminal ]) ], AltimateScan), 
   exports.AltimateScan = AltimateScan;
  },
  52850: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var BigQueryCostEstimate_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.BigQueryCostEstimate = void 0;
   const tslib_1 = __webpack_require__(31635), vscode_1 = __webpack_require__(54980), path = __webpack_require__(16928), utils_1 = __webpack_require__(86185), dbtTerminal_1 = __webpack_require__(83683), telemetry_1 = __webpack_require__(22644), dbtProjectContainer_1 = __webpack_require__(82018), python_bridge_1 = __webpack_require__(63283);
   let BigQueryCostEstimate = BigQueryCostEstimate_1 = class {
    constructor(dbtProjectContainer, dbtTerminal, telemetry) {
     this.dbtProjectContainer = dbtProjectContainer, this.dbtTerminal = dbtTerminal, 
     this.telemetry = telemetry;
    }
    estimateCost({returnResult}) {
     var _a, _b, _c;
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const modelName = path.basename(vscode_1.window.activeTextEditor.document.fileName, ".sql");
      returnResult || (yield this.dbtTerminal.show(!0));
      try {
       const query = null === (_a = vscode_1.window.activeTextEditor) || void 0 === _a ? void 0 : _a.document.getText();
       if (!query) return void vscode_1.window.showErrorMessage("We need a valid query to get a cost estimate.");
       const compiledQuery = yield null === (_b = this.getProject()) || void 0 === _b ? void 0 : _b.unsafeCompileQuery(query, modelName);
       if (!compiledQuery) return void vscode_1.window.showErrorMessage("We need a valid query to get a cost estimate.");
       const result = yield null === (_c = this.getProject()) || void 0 === _c ? void 0 : _c.validateSQLDryRun(compiledQuery);
       if (!result) return;
       if (this.dbtTerminal.log(`The query for ${modelName} will process ${result.bytes_processed}.\r\n`), 
       returnResult) return {
        modelName,
        result
       };
      } catch (error) {
       if (error instanceof python_bridge_1.PythonException) return vscode_1.window.showErrorMessage((0, 
       utils_1.extendErrorWithSupportLinks)(`An error occured while trying to compile your node: ${modelName}` + error.exception.message + ".")), 
       void this.telemetry.sendTelemetryError("bigqueryCostEstimatePythonError", error);
       vscode_1.window.showErrorMessage("Could not perform bigquery cost estimate: " + error.message);
      }
     }));
    }
    getProject() {
     var _a;
     const currentFilePath = null === (_a = vscode_1.window.activeTextEditor) || void 0 === _a ? void 0 : _a.document.uri;
     if (currentFilePath) return this.dbtProjectContainer.findDBTProject(currentFilePath);
    }
   };
   BigQueryCostEstimate = BigQueryCostEstimate_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(BigQueryCostEstimate_1), tslib_1.__metadata("design:paramtypes", [ dbtProjectContainer_1.DBTProjectContainer, dbtTerminal_1.DBTTerminal, telemetry_1.TelemetryService ]) ], BigQueryCostEstimate), 
   exports.BigQueryCostEstimate = BigQueryCostEstimate;
  },
  15059: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var VSCodeCommands_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.VSCodeCommands = void 0;
   const tslib_1 = __webpack_require__(31635), vscode_1 = __webpack_require__(54980), sqlPreviewContentProvider_1 = __webpack_require__(96246), domain_1 = __webpack_require__(97066), utils_1 = __webpack_require__(86185), runModel_1 = __webpack_require__(19389), sqlToModel_1 = __webpack_require__(27109), altimateScan_1 = __webpack_require__(48933), walkthroughCommands_1 = __webpack_require__(37987), dbtProjectContainer_1 = __webpack_require__(82018), validateSql_1 = __webpack_require__(35797), bigQueryCostEstimate_1 = __webpack_require__(52850), dbtTerminal_1 = __webpack_require__(83683), sharedStateService_1 = __webpack_require__(37712), conversationProvider_1 = __webpack_require__(10998), pythonEnvironment_1 = __webpack_require__(88103), dbt_client_1 = __webpack_require__(78629), fs_1 = __webpack_require__(79896), sqlLineagePanel_1 = __webpack_require__(58261), queryManifestService_1 = __webpack_require__(59269), altimate_1 = __webpack_require__(91741), _lib_1 = __webpack_require__(17176);
   let VSCodeCommands = VSCodeCommands_1 = class {
    constructor(dbtProjectContainer, runModel, sqlToModel, validateSql, altimateScan, walkthroughCommands, bigQueryCostEstimate, dbtTerminal, eventEmitterService, conversationController, pythonEnvironment, dbtClient, sqlLineagePanel, queryManifestService, altimate, notebookController) {
     this.dbtProjectContainer = dbtProjectContainer, this.runModel = runModel, this.sqlToModel = sqlToModel, 
     this.validateSql = validateSql, this.altimateScan = altimateScan, this.walkthroughCommands = walkthroughCommands, 
     this.bigQueryCostEstimate = bigQueryCostEstimate, this.dbtTerminal = dbtTerminal, 
     this.eventEmitterService = eventEmitterService, this.conversationController = conversationController, 
     this.pythonEnvironment = pythonEnvironment, this.dbtClient = dbtClient, this.sqlLineagePanel = sqlLineagePanel, 
     this.queryManifestService = queryManifestService, this.altimate = altimate, this.notebookController = notebookController, 
     this.disposables = [], this.disposables.push(vscode_1.commands.registerCommand("dbtPowerUser.checkIfDbtIsInstalled", (() => tslib_1.__awaiter(this, void 0, void 0, (function*() {
      yield this.dbtProjectContainer.detectDBT(), this.dbtProjectContainer.initialize();
     })))), vscode_1.commands.registerCommand("dbtPowerUser.installDbt", (() => this.walkthroughCommands.installDbt())), vscode_1.commands.registerCommand("dbtPowerUser.runCurrentModel", (() => this.runModel.runModelOnActiveWindow())), vscode_1.commands.registerCommand("dbtPowerUser.testCurrentModel", (() => this.runModel.runTestsOnActiveWindow())), vscode_1.commands.registerCommand("dbtPowerUser.compileCurrentModel", (() => this.runModel.compileModelOnActiveWindow())), vscode_1.commands.registerCommand("dbtPowerUser.bigqueryCostEstimate", (({returnResult}) => this.bigQueryCostEstimate.estimateCost({
      returnResult
     }))), vscode_1.commands.registerTextEditorCommand("dbtPowerUser.sqlPreview", (editor => tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const uri = editor.document.uri.with({
       scheme: sqlPreviewContentProvider_1.SqlPreviewContentProvider.SCHEME
      }), doc = yield vscode_1.workspace.openTextDocument(uri), isOpen = vscode_1.window.visibleTextEditors.some((e => e.document.uri === uri));
      yield vscode_1.window.showTextDocument(doc, vscode_1.ViewColumn.Beside, !1), yield vscode_1.languages.setTextDocumentLanguage(doc, "sql"), 
      isOpen ? yield vscode_1.commands.executeCommand("workbench.action.closeActiveEditor") : (yield vscode_1.commands.executeCommand("workbench.action.lockEditorGroup"), 
      yield vscode_1.commands.executeCommand("workbench.action.focusPreviousGroup"));
     })))), vscode_1.commands.registerCommand("dbtPowerUser.goToDocumentationEditor", (() => tslib_1.__awaiter(this, void 0, void 0, (function*() {
      yield vscode_1.commands.executeCommand("workbench.view.extension.docs_edit_view");
     })))), vscode_1.commands.registerCommand("dbtPowerUser.runTest", (model => this.runModel.runModelOnNodeTreeItem(domain_1.RunModelType.TEST)(model))), vscode_1.commands.registerCommand("dbtPowerUser.runChildrenModels", (model => this.runModel.runModelOnNodeTreeItem(domain_1.RunModelType.RUN_CHILDREN)(model))), vscode_1.commands.registerCommand("dbtPowerUser.runParentModels", (model => this.runModel.runModelOnNodeTreeItem(domain_1.RunModelType.RUN_PARENTS)(model))), vscode_1.commands.registerCommand("dbtPowerUser.showRunSQL", (() => this.runModel.showRunSQLOnActiveWindow())), vscode_1.commands.registerCommand("dbtPowerUser.showCompiledSQL", (() => this.runModel.showCompiledSQLOnActiveWindow())), vscode_1.commands.registerCommand("dbtPowerUser.generateSchemaYML", (() => this.runModel.generateSchemaYMLOnActiveWindow())), vscode_1.commands.registerCommand("dbtPowerUser.generateDBTDocs", (() => this.runModel.generateDBTDocsOnActiveWindow())), vscode_1.commands.registerCommand("dbtPowerUser.executeSQL", (() => this.runModel.executeQueryOnActiveWindow())), vscode_1.commands.registerCommand("dbtPowerUser.summarizeQuery", (() => this.eventEmitterService.fire({
      command: "dbtPowerUser.summarizeQuery",
      payload: {}
     }))), vscode_1.commands.registerCommand("dbtPowerUser.changeQuery", (() => this.eventEmitterService.fire({
      command: "dbtPowerUser.changeQuery",
      payload: {}
     }))), vscode_1.commands.registerCommand("dbtPowerUser.translateQuery", (() => this.eventEmitterService.fire({
      command: "dbtPowerUser.translateQuery",
      payload: {}
     }))), vscode_1.commands.registerCommand("dbtPowerUser.createModelBasedonSourceConfig", (params => {
      this.runModel.createModelBasedonSourceConfig(params);
     })), vscode_1.commands.registerCommand("dbtPowerUser.buildCurrentModel", (() => this.runModel.buildModelOnActiveWindow())), vscode_1.commands.registerCommand("dbtPowerUser.buildCurrentProject", (() => {
      if (!vscode_1.window.activeTextEditor) return;
      const activeFileUri = vscode_1.window.activeTextEditor.document.uri;
      if (!activeFileUri) return void this.dbtTerminal.debug("buildCurrentProject", "skipping buildCurrentProject without active file");
      const dbtProject = this.dbtProjectContainer.findDBTProject(activeFileUri);
      dbtProject ? (this.dbtTerminal.debug("buildCurrentProject", `building current project: ${dbtProject.getProjectName()} with active file: ${activeFileUri.path}`), 
      dbtProject.buildProject()) : this.dbtTerminal.debug("buildCurrentProject", `buildCurrentProject unable to find dbtproject by active file: ${activeFileUri.path}`);
     })), vscode_1.commands.registerCommand("dbtPowerUser.buildChildrenModels", (() => this.runModel.buildModelOnActiveWindow(domain_1.RunModelType.BUILD_CHILDREN))), vscode_1.commands.registerCommand("dbtPowerUser.buildParentModels", (() => this.runModel.buildModelOnActiveWindow(domain_1.RunModelType.BUILD_PARENTS))), vscode_1.commands.registerCommand("dbtPowerUser.buildChildrenParentModels", (() => this.runModel.buildModelOnActiveWindow(domain_1.RunModelType.BUILD_CHILDREN_PARENTS))), vscode_1.commands.registerCommand("dbtPowerUser.sqlToModel", (() => this.sqlToModel.getModelFromSql())), vscode_1.commands.registerCommand("dbtPowerUser.validateSql", (() => this.validateSql.validateSql())), vscode_1.commands.registerCommand("dbtPowerUser.altimateScan", (() => this.altimateScan.getProblems())), vscode_1.commands.registerCommand("dbtPowerUser.clearAltimateScanResults", (() => this.altimateScan.clearProblems())), vscode_1.commands.registerCommand("dbtPowerUser.switchDbtIntegration", (() => tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const dbtIntegration = vscode_1.workspace.getConfiguration("dbt").get("dbtIntegration", "core"), message = `Switching to dbt ${"cloud" === dbtIntegration ? "core" : "cloud"} requires reloading the window, any unsaved changes will be lost.`;
      "Confirm" === (yield vscode_1.window.showInformationMessage(message, "Confirm")) && (yield vscode_1.workspace.getConfiguration("dbt").update("dbtIntegration", "cloud" === dbtIntegration ? "core" : "cloud"), 
      yield vscode_1.commands.executeCommand("workbench.action.reloadWindow"));
     })))), vscode_1.commands.registerCommand("dbtPowerUser.validateProject", (() => {
      const pickedProject = this.dbtProjectContainer.getFromWorkspaceState("dbtPowerUser.projectSelected");
      this.walkthroughCommands.validateProjects(pickedProject);
     })), vscode_1.commands.registerCommand("dbtPowerUser.installDeps", (() => {
      this.dbtProjectContainer.setToGlobalState("showSetupWalkthrough", !1);
      const pickedProject = this.dbtProjectContainer.getFromWorkspaceState("dbtPowerUser.projectSelected");
      this.walkthroughCommands.installDeps(pickedProject);
     })), vscode_1.commands.registerCommand("dbtPowerUser.openSetupWalkthrough", (() => tslib_1.__awaiter(this, void 0, void 0, (function*() {
      yield vscode_1.commands.executeCommand("workbench.action.openWalkthrough"), vscode_1.commands.executeCommand("workbench.action.openWalkthrough", `${this.dbtProjectContainer.extensionId}#initialSetup`, !0);
     })))), vscode_1.commands.registerCommand("dbtPowerUser.openTutorialWalkthrough", (() => tslib_1.__awaiter(this, void 0, void 0, (function*() {
      yield vscode_1.commands.executeCommand("workbench.action.openWalkthrough"), vscode_1.commands.executeCommand("workbench.action.openWalkthrough", `${this.dbtProjectContainer.extensionId}#tutorials`, !1);
     })))), vscode_1.commands.registerCommand("dbtPowerUser.associateFileExts", (() => tslib_1.__awaiter(this, void 0, void 0, (function*() {
      vscode_1.commands.executeCommand("workbench.action.openSettings", "@id:files.associations");
     })))), vscode_1.commands.registerCommand("dbtPowerUser.openDatapilotWithQuery", (() => this.eventEmitterService.fire({
      command: "dbtPowerUser.openDatapilotWithQuery",
      payload: {}
     }))), vscode_1.commands.registerCommand("dbtPowerUser.showHelpDatapilot", (() => this.eventEmitterService.fire({
      command: "dbtPowerUser.openHelpInDatapilot",
      payload: {}
     }))), vscode_1.commands.registerCommand("dbtPowerUser.createConversation", (reply => {
      try {
       this.conversationController.createConversation(reply);
      } catch (err) {
       vscode_1.window.showErrorMessage((0, utils_1.extendErrorWithSupportLinks)(err.message));
      }
     })), vscode_1.commands.registerCommand("dbtPowerUser.replyToConversation", (reply => {
      try {
       this.conversationController.replyToConversation(reply);
      } catch (err) {
       vscode_1.window.showErrorMessage((0, utils_1.extendErrorWithSupportLinks)(err.message));
      }
     })), vscode_1.commands.registerCommand("dbtPowerUser.resolveConversation", (thread => {
      try {
       this.conversationController.resolveConversation(thread);
      } catch (err) {
       vscode_1.window.showErrorMessage((0, utils_1.extendErrorWithSupportLinks)(err.message));
      }
     })), vscode_1.commands.registerCommand("dbtPowerUser.copyDbtDocsLink", (thread => {
      try {
       this.conversationController.copyThreadLink(thread);
      } catch (err) {
       vscode_1.window.showErrorMessage((0, utils_1.extendErrorWithSupportLinks)(err.message));
      }
     })), vscode_1.commands.registerCommand("dbtPowerUser.viewInDocEditor", (thread => {
      try {
       this.conversationController.viewInDocEditor(thread);
      } catch (err) {
       vscode_1.window.showErrorMessage((0, utils_1.extendErrorWithSupportLinks)(err.message));
      }
     })), vscode_1.commands.registerCommand("dbtPowerUser.viewInDbtDocs", (thread => {
      try {
       this.conversationController.viewInDbtDocs(thread);
      } catch (err) {
       vscode_1.window.showErrorMessage((0, utils_1.extendErrorWithSupportLinks)(err.message));
      }
     })), vscode_1.commands.registerCommand("dbtPowerUser.printEnvVars", (() => this.pythonEnvironment.printEnvVars())), vscode_1.commands.registerCommand("dbtPowerUser.diagnostics", (() => tslib_1.__awaiter(this, void 0, void 0, (function*() {
      var _a, _b;
      try {
       yield this.dbtTerminal.show(!0), yield new Promise((resolve => setTimeout(resolve, 1e3))), 
       this.dbtTerminal.logLine("Diagnostics started..."), this.dbtTerminal.logNewLine(), 
       this.dbtTerminal.logBlockWithHeader([ "Printing environment variables...", "* Please remove any sensitive information before sending it to us" ], Object.entries(this.pythonEnvironment.environmentVariables).map((([key, value]) => `${key}=${value}`))), 
       this.dbtTerminal.logNewLine(), this.dbtTerminal.logBlockWithHeader([ "Printing all python paths...", "* Please remove any sensitive information before sending it to us" ], this.pythonEnvironment.allPythonPaths.map((({path}) => path))), 
       this.dbtTerminal.logNewLine();
       const dbtSettings = vscode_1.workspace.getConfiguration().inspect("dbt"), globalValue = (null == dbtSettings ? void 0 : dbtSettings.globalValue) || {}, defaultValue = (null == dbtSettings ? void 0 : dbtSettings.defaultValue) || {}, workspaceValue = (null == dbtSettings ? void 0 : dbtSettings.workspaceValue) || {}, settingKeys = [ ...Object.keys(globalValue), ...Object.keys(defaultValue), ...Object.keys(workspaceValue) ];
       this.dbtTerminal.logBlockWithHeader([ "Printing extension settings...", "* Please remove any sensitive information before sending it to us" ], settingKeys.map((key => {
        const value = vscode_1.workspace.getConfiguration("dbt").get(key);
        let overridenText = "";
        (0, utils_1.deepEqual)(value, defaultValue[key]) || ((0, utils_1.deepEqual)(value, workspaceValue[key]) ? overridenText = `${key} is overridden in workspace settings` : (0, 
        utils_1.deepEqual)(value, globalValue[key]) && (overridenText = `${key} is overridden in user settings`));
        return `${key}=${Array.isArray(value) || "object" == typeof value ? JSON.stringify(value) : value}\t\t${overridenText}`;
       }))), this.dbtTerminal.logNewLine();
       const dbtIntegrationMode = vscode_1.workspace.getConfiguration("dbt").get("dbtIntegration", "core"), allowListFolders = vscode_1.workspace.getConfiguration("dbt").get("allowListFolders", []), apiConnectivity = yield this.altimate.checkApiConnectivity();
       if (this.dbtTerminal.logBlock([ `Python Path=${this.pythonEnvironment.pythonPath}`, `VSCode version=${vscode_1.version}`, `Extension version=${null === (_b = null === (_a = vscode_1.extensions.getExtension("innoverio.vscode-dbt-power-user")) || void 0 === _a ? void 0 : _a.packageJSON) || void 0 === _b ? void 0 : _b.version}`, `DBT integration mode=${dbtIntegrationMode}`, `First workspace path=${(0, 
       utils_1.getFirstWorkspacePath)()}`, `Altimate API connectivity=${apiConnectivity.status}`, apiConnectivity.errorMsg ? `Altimate API connectivity error=${apiConnectivity.errorMsg}` : "", `AllowList Folders=${allowListFolders}` ]), 
       this.dbtTerminal.logNewLine(), !this.dbtClient.pythonInstalled) return this.dbtTerminal.logLine("Python is not installed"), 
       void this.dbtTerminal.logLine("Can't proceed further without fixing python installation");
       if (this.dbtTerminal.logLine("Python is installed"), !this.dbtClient.dbtInstalled) return this.dbtTerminal.logLine("DBT is not installed"), 
       void this.dbtTerminal.logLine("Can't proceed further without fixing dbt installation");
       this.dbtTerminal.logLine("DBT is installed");
       const dbtWorkspaces = this.dbtProjectContainer.dbtWorkspaceFolders;
       this.dbtTerminal.logLine(`Number of workspaces=${dbtWorkspaces.length}`);
       for (const w of dbtWorkspaces) this.dbtTerminal.logHorizontalRule(), this.dbtTerminal.logLine(`Workspace Path=${w.workspaceFolder.uri.fsPath}`), 
       this.dbtTerminal.logLine(`Adapters=${w.getAdapters()}`), this.dbtTerminal.logLine(`AllowList Folders=${w.getAllowListFolders()}`), 
       w.projectDiscoveryDiagnostics.forEach(((uri, diagnostics) => {
        this.dbtTerminal.logLine(`Problems for ${uri.fsPath}`), diagnostics.forEach((d => {
         this.dbtTerminal.logLine(`source=${d.source}\tmessage=${d.message}`);
        }));
       })), this.dbtTerminal.logHorizontalRule();
       const projects = this.dbtProjectContainer.getProjects();
       if (this.dbtTerminal.logLine(`Number of projects=${projects.length}`), 0 === projects.length) return this.dbtTerminal.logLine("No project detected"), 
       void this.dbtTerminal.logLine("Can't proceed further without project");
       this.dbtTerminal.logNewLine();
       for (const project of projects) try {
        this.dbtTerminal.logHorizontalRule(), this.dbtTerminal.logLine(`Printing information for ${project.getProjectName()}`), 
        this.dbtTerminal.logHorizontalRule(), yield this.printProjectInfo(project);
       } catch (e) {
        this.dbtTerminal.logNewLine(), this.dbtTerminal.logLine("Failed to print all the info for the project..."), 
        this.dbtTerminal.logLine(`Error=${e}`);
       } finally {
        this.dbtTerminal.logHorizontalRule();
       }
       this.dbtTerminal.logNewLine(), this.dbtTerminal.logLine("Diagnostics completed successfully...");
      } catch (e) {
       this.dbtTerminal.logNewLine(), this.dbtTerminal.logLine("Diagnostics ended with error..."), 
       this.dbtTerminal.logLine(`Error=${e}`);
      }
     })))), vscode_1.commands.registerCommand("dbtPowerUser.createDatapilotNotebook", (args => tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.notebookController.createNotebook(args);
     })))), vscode_1.commands.registerCommand("dbtPowerUser.openTargetSelector", ((targets, project, statusBar) => tslib_1.__awaiter(this, void 0, void 0, (function*() {
      try {
       if (!targets) return;
       this.dbtTerminal.debug("OpenTargetSelector", "Showing following targets", targets);
       const target = yield vscode_1.window.showQuickPick(targets, {
        title: "Select your target",
        canPickMany: !1
       });
       target && (yield project.setSelectedTarget(target), yield statusBar.updateStatusBar(), 
       this.dbtTerminal.info("OpenTargetSelector", "Selecting target", !0, target));
      } catch (error) {
       this.dbtTerminal.error("OpenTargetSelector", "An error occurred while changing target", error), 
       vscode_1.window.showErrorMessage("An error occurred while changing target: " + error);
      }
     })))), vscode_1.commands.registerCommand("dbtPowerUser.createSqlFile", (args => tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const {code, fileName} = args || {};
      try {
       const project = yield this.queryManifestService.getOrPickProjectFromWorkspace();
       if (!project) return void vscode_1.window.showErrorMessage("No dbt project selected.");
       const fileNamePrefix = fileName || "poweruser", uri = vscode_1.Uri.parse(`${project.projectRoot}/${fileNamePrefix}-${(0, 
       utils_1.getFormattedDateTime)()}.sql`).with({
        scheme: "untitled"
       }), annotationDecoration = vscode_1.window.createTextEditorDecorationType({
        rangeBehavior: vscode_1.DecorationRangeBehavior.OpenOpen
       }), decorations = [ {
        renderOptions: {
         before: {
          color: "#666666",
          contentText: "Enter your query here and execute it just like any dbt model file. This file is unsaved, you can either save it to your project or save it as a bookmark for later usage or share it with your team members.",
          width: "90%;display: block;white-space: pre-line;"
         }
        },
        range: new vscode_1.Range(2, 0, 2, 0)
       } ];
       vscode_1.workspace.openTextDocument(uri).then((doc => {
        vscode_1.languages.setTextDocumentLanguage(doc, "jinja-sql"), vscode_1.window.showTextDocument(doc).then((editor => {
         editor.edit((editBuilder => {
          const entireDocumentRange = new vscode_1.Range(doc.positionAt(0), doc.positionAt(doc.getText().length));
          editBuilder.replace(entireDocumentRange, code || "\n"), editor.setDecorations(annotationDecoration, decorations), 
          setTimeout((() => {
           vscode_1.commands.executeCommand("cursorMove", {
            to: "up",
            by: "line",
            value: 1
           });
          }), 0);
          const disposable = vscode_1.workspace.onDidChangeTextDocument((e => {
           const activeEditor = vscode_1.window.activeTextEditor;
           activeEditor && e.document === editor.document && activeEditor.document.getText().trim() && (activeEditor.setDecorations(annotationDecoration, []), 
           disposable.dispose());
          }));
         }));
        }));
       }));
      } catch (e) {
       const message = e.message;
       this.dbtTerminal.error("createSqlFile", message, e, !0), vscode_1.window.showErrorMessage(message);
      }
     })))), vscode_1.commands.registerCommand("dbtPowerUser.sqlLineage", (() => tslib_1.__awaiter(this, void 0, void 0, (function*() {
      vscode_1.window.withProgress({
       title: "Retrieving SQL visualization",
       location: vscode_1.ProgressLocation.Notification,
       cancellable: !1
      }, ((_, token) => tslib_1.__awaiter(this, void 0, void 0, (function*() {
       try {
        const modelName = this.sqlLineagePanel.getActiveEditorFilename(), lineage = yield this.sqlLineagePanel.getSQLLineage(token), panel = vscode_1.window.createWebviewPanel(sqlLineagePanel_1.SQLLineagePanel.viewType, `${modelName} - visualization`, vscode_1.ViewColumn.Two, {
         retainContextWhenHidden: !0,
         enableScripts: !0
        });
        this.sqlLineagePanel.renderSqlVisualizer(panel, lineage);
       } catch (e) {
        const errorMessage = null == e ? void 0 : e.message;
        this.dbtTerminal.error("sqlLineage", errorMessage, e, !0), vscode_1.window.showErrorMessage(errorMessage);
       }
      }))));
     })))), vscode_1.commands.registerCommand("dbtPowerUser.showDocumentation", (modelName => tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const result = queryManifestService.getEventByCurrentProject();
      if (!result) return;
      const {event} = result;
      if (!event) return;
      const {nodeMetaMap} = event, model = nodeMetaMap.lookupByBaseName(modelName);
      if (!(null == model ? void 0 : model.path)) return;
      const doc = yield vscode_1.workspace.openTextDocument(vscode_1.Uri.file(model.path));
      yield vscode_1.window.showTextDocument(doc), yield vscode_1.commands.executeCommand("dbtPowerUser.DocsEdit.focus");
     })))));
    }
    printProjectInfo(project) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.dbtTerminal.logLine(`Project Name=${project.getProjectName()}`), this.dbtTerminal.logLine(`Adapter Type=${project.getAdapterType()}`);
      const dbtVersion = project.getDBTVersion();
      dbtVersion ? this.dbtTerminal.logLine(`DBT version=${dbtVersion.join(".")}`) : this.dbtTerminal.logLine("DBT is not initialized properly"), 
      project.getPythonBridgeStatus() ? this.dbtTerminal.logLine("Python bridge is connected") : this.dbtTerminal.logLine("Python bridge is not connected"), 
      this.dbtTerminal.logNewLine();
      const paths = [ {
       pathType: "DBT Project File",
       path: project.getDBTProjectFilePath()
      }, {
       pathType: "Target",
       path: project.getTargetPath()
      }, {
       pathType: "PackageInstall",
       path: project.getPackageInstallPath()
      }, {
       pathType: "Manifest",
       path: project.getManifestPath()
      }, {
       pathType: "Catalog",
       path: project.getCatalogPath()
      }, ...(project.getModelPaths() || []).map((path => ({
       pathType: "Model",
       path
      }))), ...(project.getSeedPaths() || []).map((path => ({
       pathType: "Seed",
       path
      }))), ...(project.getMacroPaths() || []).map((path => ({
       pathType: "Macro",
       path
      }))) ];
      for (const p of paths) {
       if (!p.path) {
        this.dbtTerminal.logLine(`${p.pathType} path not found`);
        continue;
       }
       let line = `${p.pathType} path=${p.path}\t\t`;
       (0, fs_1.existsSync)(p.path) ? line += "File exists at location" : line += "File doesn't exists at location", 
       this.dbtTerminal.logLine(line);
      }
      const dbtProjectFilePath = project.getDBTProjectFilePath();
      if ((0, fs_1.existsSync)(dbtProjectFilePath)) {
       this.dbtTerminal.logNewLine(), this.dbtTerminal.logNewLine(), this.dbtTerminal.logLine("dbt_project.yml"), 
       this.dbtTerminal.logHorizontalRule();
       const fileContent = (0, fs_1.readFileSync)(dbtProjectFilePath, "utf8");
       this.dbtTerminal.logLine(fileContent.replace(/\n/g, "\r\n")), this.dbtTerminal.logHorizontalRule();
      }
      this.dbtTerminal.logNewLine();
      const diagnostics = project.getAllDiagnostic();
      this.dbtTerminal.logLine(`Number of diagnostics issues=${diagnostics.length}`);
      for (const d of diagnostics) this.dbtTerminal.logLine(d.message);
      yield project.debug();
     }));
    }
    dispose() {
     for (;this.disposables.length; ) {
      const x = this.disposables.pop();
      x && x.dispose();
     }
    }
   };
   VSCodeCommands = VSCodeCommands_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(VSCodeCommands_1), tslib_1.__metadata("design:paramtypes", [ dbtProjectContainer_1.DBTProjectContainer, runModel_1.RunModel, sqlToModel_1.SqlToModel, validateSql_1.ValidateSql, altimateScan_1.AltimateScan, walkthroughCommands_1.WalkthroughCommands, bigQueryCostEstimate_1.BigQueryCostEstimate, dbtTerminal_1.DBTTerminal, sharedStateService_1.SharedStateService, conversationProvider_1.ConversationProvider, pythonEnvironment_1.PythonEnvironment, dbt_client_1.DBTClient, sqlLineagePanel_1.SQLLineagePanel, queryManifestService_1.QueryManifestService, altimate_1.AltimateRequest, _lib_1.DatapilotNotebookController ]) ], VSCodeCommands), 
   exports.VSCodeCommands = VSCodeCommands;
  },
  19389: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var RunModel_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.RunModel = void 0;
   const tslib_1 = __webpack_require__(31635), path = __webpack_require__(16928), vscode_1 = __webpack_require__(54980), domain_1 = __webpack_require__(97066), dbtProjectContainer_1 = __webpack_require__(82018), utils_1 = __webpack_require__(86185);
   let RunModel = RunModel_1 = class {
    constructor(dbtProjectContainer) {
     this.dbtProjectContainer = dbtProjectContainer;
    }
    runModelOnActiveWindow(type) {
     if (!vscode_1.window.activeTextEditor) return;
     const fullPath = vscode_1.window.activeTextEditor.document.uri;
     this.runDBTModel(fullPath, type);
    }
    buildModelOnActiveWindow(type) {
     if (!vscode_1.window.activeTextEditor) return;
     const fullPath = vscode_1.window.activeTextEditor.document.uri;
     this.buildDBTModel(fullPath, type);
    }
    runTestsOnActiveWindow() {
     if (!vscode_1.window.activeTextEditor) return;
     const fullPath = vscode_1.window.activeTextEditor.document.uri;
     this.runDBTModelTest(fullPath);
    }
    compileModelOnActiveWindow() {
     if (!vscode_1.window.activeTextEditor) return;
     const fullPath = vscode_1.window.activeTextEditor.document.uri;
     this.compileDBTModel(fullPath);
    }
    compileQueryOnActiveWindow() {
     if (!vscode_1.window.activeTextEditor) return;
     const fullPath = vscode_1.window.activeTextEditor.document.uri, query = vscode_1.window.activeTextEditor.document.getText();
     void 0 !== query && this.compileDBTQuery(fullPath, query);
    }
    getQuery() {
     if (!vscode_1.window.activeTextEditor) return;
     const cursor = vscode_1.window.activeTextEditor.selection;
     return vscode_1.window.activeTextEditor.document.getText(cursor.isEmpty ? void 0 : cursor);
    }
    executeQueryOnActiveWindow() {
     var _a;
     const query = this.getQuery();
     if (void 0 === query) return;
     const modelPath = null === (_a = vscode_1.window.activeTextEditor) || void 0 === _a ? void 0 : _a.document.uri;
     if (modelPath) {
      const modelName = path.basename(modelPath.fsPath, ".sql");
      this.executeSQL(vscode_1.window.activeTextEditor.document.uri, query, modelName);
     }
    }
    runModelOnNodeTreeItem(type) {
     return model => {
      if (void 0 !== model) {
       if (model.url) switch (type) {
       case domain_1.RunModelType.TEST:
        model.label && this.runDBTTest(vscode_1.Uri.file(model.url), model.label.toString().split(".")[0]);
        break;

       case domain_1.RunModelType.BUILD_CHILDREN:
       case domain_1.RunModelType.BUILD_CHILDREN_PARENTS:
       case domain_1.RunModelType.BUILD_PARENTS:
        this.buildDBTModel(vscode_1.Uri.file(model.url), type);
        break;

       case domain_1.RunModelType.RUN_CHILDREN:
       case domain_1.RunModelType.RUN_PARENTS:
        this.runDBTModel(vscode_1.Uri.file(model.url), type);
       }
      } else this.runModelOnActiveWindow(type);
     };
    }
    showCompiledSQLOnActiveWindow() {
     var _a;
     const fullPath = null === (_a = vscode_1.window.activeTextEditor) || void 0 === _a ? void 0 : _a.document.uri;
     void 0 !== fullPath && this.showCompiledSQL(fullPath);
    }
    generateSchemaYMLOnActiveWindow() {
     var _a;
     const fullPath = null === (_a = vscode_1.window.activeTextEditor) || void 0 === _a ? void 0 : _a.document.uri;
     void 0 !== fullPath && this.generateSchemaYML(fullPath);
    }
    showRunSQLOnActiveWindow() {
     var _a;
     const fullPath = null === (_a = vscode_1.window.activeTextEditor) || void 0 === _a ? void 0 : _a.document.uri;
     void 0 !== fullPath && this.showRunSQL(fullPath);
    }
    generateDBTDocsOnActiveWindow() {
     var _a;
     const fullPath = null === (_a = vscode_1.window.activeTextEditor) || void 0 === _a ? void 0 : _a.document.uri;
     void 0 !== fullPath && this.generateDBTDocs(fullPath);
    }
    runDBTModel(modelPath, type) {
     this.dbtProjectContainer.runModel(modelPath, type);
    }
    buildDBTModel(modelPath, type) {
     this.dbtProjectContainer.buildModel(modelPath, type);
    }
    compileDBTModel(modelPath, type) {
     this.dbtProjectContainer.compileModel(modelPath, type);
    }
    generateDBTDocs(modelPath, type) {
     this.dbtProjectContainer.generateDocs(modelPath);
    }
    compileDBTQuery(modelPath, query) {
     this.dbtProjectContainer.compileQuery(modelPath, query);
    }
    runDBTTest(modelPath, testName) {
     this.dbtProjectContainer.runTest(modelPath, testName);
    }
    runDBTModelTest(modelPath) {
     const modelName = path.basename(modelPath.fsPath, ".sql");
     this.dbtProjectContainer.runModelTest(modelPath, modelName);
    }
    executeSQL(uri, query, modelName) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.dbtProjectContainer.executeSQL(uri, query, modelName);
     }));
    }
    showCompiledSQL(modelPath) {
     this.dbtProjectContainer.showCompiledSQL(modelPath);
    }
    generateSchemaYML(modelPath) {
     const modelName = path.basename(modelPath.fsPath, ".sql");
     this.dbtProjectContainer.generateSchemaYML(modelPath, modelName);
    }
    showRunSQL(modelPath) {
     this.dbtProjectContainer.showRunSQL(modelPath);
    }
    createModelBasedonSourceConfig(params) {
     const project = this.dbtProjectContainer.findDBTProject(params.currentDoc), sourcePath = path.dirname(params.currentDoc.fsPath);
     project ? project.generateModel(params.sourceName, params.tableName, sourcePath) : vscode_1.window.showErrorMessage((0, 
     utils_1.extendErrorWithSupportLinks)("Could not generate model! No project found for " + params.currentDoc.fsPath + "."));
    }
   };
   RunModel = RunModel_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(RunModel_1), tslib_1.__metadata("design:paramtypes", [ dbtProjectContainer_1.DBTProjectContainer ]) ], RunModel), 
   exports.RunModel = RunModel;
  },
  27109: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var SqlToModel_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.SqlToModel = void 0;
   const tslib_1 = __webpack_require__(31635), altimate_1 = __webpack_require__(91741), dbtTerminal_1 = __webpack_require__(83683), dbtProjectContainer_1 = __webpack_require__(82018), telemetry_1 = __webpack_require__(22644), utils_1 = __webpack_require__(86185), vscode_1 = __webpack_require__(54980), path = __webpack_require__(16928);
   let SqlToModel = SqlToModel_1 = class {
    constructor(dbtProjectContainer, telemetry, altimate, dbtTerminal) {
     this.dbtProjectContainer = dbtProjectContainer, this.telemetry = telemetry, this.altimate = altimate, 
     this.dbtTerminal = dbtTerminal, this.eventMap = new Map, dbtProjectContainer.onManifestChanged((event => this.onManifestCacheChanged(event)));
    }
    onManifestCacheChanged(event) {
     var _a, _b;
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      null === (_a = event.added) || void 0 === _a || _a.forEach((added => {
       this.eventMap.set(added.project.projectRoot.fsPath, added);
      })), null === (_b = event.removed) || void 0 === _b || _b.forEach((removed => {
       this.eventMap.delete(removed.projectRoot.fsPath);
      }));
     }));
    }
    getModelFromSql() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      if (!this.altimate.handlePreviewFeatures()) return;
      if (this.telemetry.sendTelemetryEvent("sqlToModel"), !vscode_1.window.activeTextEditor) return;
      const activedoc = vscode_1.window.activeTextEditor, currentFilePath = activedoc.document.uri, model = path.basename(vscode_1.window.activeTextEditor.document.fileName, ".sql"), project = this.dbtProjectContainer.findDBTProject(currentFilePath);
      if (!project) return vscode_1.window.showErrorMessage((0, utils_1.extendErrorWithSupportLinks)("Could not find a dbt project. Please put the new model in a dbt project before converting to a model.")), 
      void this.telemetry.sendTelemetryError("sqlToModelNoProjectError");
      const event = this.eventMap.get(project.projectRoot.fsPath);
      if (!event) return project.throwDiagnosticsErrorIfAvailable(), vscode_1.window.showErrorMessage((0, 
      utils_1.extendErrorWithSupportLinks)("The extension is still initializing, please retry again.")), 
      void this.telemetry.sendTelemetryError("sqlToModelNoManifestError");
      const {nodeMetaMap, sourceMetaMap} = event, allmodels = Array.from(nodeMetaMap.nodes()), allsources = Array.from(sourceMetaMap.values()), fileText = activedoc.document.getText();
      try {
       const sqlToModelResponse = yield vscode_1.window.withProgress({
        location: vscode_1.ProgressLocation.Notification,
        title: "Convert SQL to Model...",
        cancellable: !1
       }, (() => tslib_1.__awaiter(this, void 0, void 0, (function*() {
        let compiledSql;
        try {
         compiledSql = yield project.unsafeCompileQuery(fileText);
        } catch (error) {
         return void vscode_1.window.showErrorMessage((0, utils_1.extendErrorWithSupportLinks)("Could not compile the SQL: " + error.message));
        }
        return yield this.altimate.runModeller({
         sql: compiledSql || fileText,
         adapter: project.getAdapterType(),
         models: allmodels,
         sources: allsources
        });
       }))));
       if (void 0 === sqlToModelResponse || void 0 === sqlToModelResponse.sql) return vscode_1.window.showErrorMessage((0, 
       utils_1.extendErrorWithSupportLinks)("Could not convert sql to model. Encountered unknown error when converting sql to model.")), 
       void this.dbtTerminal.error("sqlToModelEmptyBackendResponseError", `Could not convert sql to model for query: ${fileText}`, new Error("Empty response from backend"));
       const startpos = new vscode_1.Position(0, 0), endpos = new vscode_1.Position(activedoc.document.lineCount, activedoc.document.lineAt(activedoc.document.lineCount - 1).text.length);
       activedoc.edit((editBuilder => {
        editBuilder.replace(new vscode_1.Range(startpos, endpos), sqlToModelResponse.sql);
       })), vscode_1.window.showInformationMessage(`SQL successfully converted to model ${model}`);
      } catch (err) {
       vscode_1.window.showErrorMessage((0, utils_1.extendErrorWithSupportLinks)("Could not convert SQL to model: " + err.message)), 
       this.dbtTerminal.error("sqlToModelError", `Could not convert sql to model for query: ${fileText}`, err);
      }
     }));
    }
   };
   SqlToModel = SqlToModel_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(SqlToModel_1), tslib_1.__metadata("design:paramtypes", [ dbtProjectContainer_1.DBTProjectContainer, telemetry_1.TelemetryService, altimate_1.AltimateRequest, dbtTerminal_1.DBTTerminal ]) ], SqlToModel), 
   exports.SqlToModel = SqlToModel;
  },
  37296: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var InitCatalog_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.InitCatalog = void 0;
   const tslib_1 = __webpack_require__(31635), utils_1 = __webpack_require__(86185);
   let InitCatalog = InitCatalog_1 = class {
    run(scanContext) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const project = scanContext.project, scanResults = scanContext.scanResults, cata = yield project.getCatalog();
      if (0 === cata.length) {
       let catalogResults = scanResults.missingCatalog;
       void 0 === catalogResults && (catalogResults = scanResults.missingCatalog = {}), 
       scanResults.missingCatalog[project.getProjectName() + project.projectRoot] = !0;
      }
      const modelDict = Object.create(null);
      return cata.forEach((model => {
       const modelKey = JSON.stringify({
        projectroot: project.projectRoot.fsPath,
        project: project.getProjectName(),
        database: model.table_database.toLowerCase(),
        schema: model.table_schema.toLowerCase(),
        name: model.table_name.toLowerCase()
       });
       modelDict[modelKey] = modelDict[modelKey] || [], modelDict[modelKey].push(model);
      })), modelDict;
     }));
    }
   };
   InitCatalog = InitCatalog_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(InitCatalog_1) ], InitCatalog), 
   exports.InitCatalog = InitCatalog;
  },
  90718: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var MissingSchemaTest_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.MissingSchemaTest = void 0;
   const tslib_1 = __webpack_require__(31635), vscode_1 = __webpack_require__(54980), utils_1 = __webpack_require__(86185), dbtProject_1 = __webpack_require__(38821);
   let MissingSchemaTest = MissingSchemaTest_1 = class {
    run(scanContext) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const {eventMap: projectEventMap, diagnostics: projectDiagnostics, scanResults} = scanContext;
      if (void 0 === projectEventMap) return;
      const {nodeMetaMap} = projectEventMap;
      for (const value of nodeMetaMap.nodes()) if (value.uniqueId.startsWith(dbtProject_1.DBTProject.RESOURCE_TYPE_MODEL) && "seed" !== value.config.materialized && "ephemeral" !== value.config.materialized && !value.patch_path && value.path) {
       const errMessage = `Documentation missing for model: ${value.name}`;
       let projDiagnostic = projectDiagnostics[value.path];
       void 0 === projDiagnostic && (projectDiagnostics[value.path] = projDiagnostic = []), 
       projDiagnostic.push(new vscode_1.Diagnostic(new vscode_1.Range(0, 0, 0, 0), errMessage, vscode_1.DiagnosticSeverity.Information));
       let missingDocsDict = scanResults.missingDoc;
       void 0 === missingDocsDict && (scanResults.missingDoc = missingDocsDict = new Set), 
       missingDocsDict.add(value.uniqueId);
      }
     }));
    }
   };
   MissingSchemaTest = MissingSchemaTest_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(MissingSchemaTest_1) ], MissingSchemaTest), 
   exports.MissingSchemaTest = MissingSchemaTest;
  },
  67209: (__unused_webpack_module, exports) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.ScanContext = void 0;
   exports.ScanContext = class {
    constructor(project, eventMap) {
     this.catalog = {}, this.scanResults = {}, this.project = project, this.catalog = {}, 
     this.eventMap = eventMap, this.diagnostics = {};
    }
   };
  },
  28237: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var StaleModelColumnTest_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.StaleModelColumnTest = void 0;
   const tslib_1 = __webpack_require__(31635), vscode_1 = __webpack_require__(54980), fs_1 = __webpack_require__(79896), utils_1 = __webpack_require__(86185), parsers_1 = __webpack_require__(12847);
   let StaleModelColumnTest = StaleModelColumnTest_1 = class {
    getTextLocation(modelname, colname, schemaPath) {
     const docContent = (0, fs_1.readFileSync)(schemaPath, "utf-8"), modelRegex = new RegExp(`\\bname\\:\\s*?${modelname}\\b`), modelMatch = docContent.match(modelRegex);
     if (!modelMatch) return;
     const colRegex = new RegExp(`\\bname\\:\\s*?${colname}\\b|\\balias\\:\\s*?${colname}\\b`, "g");
     let colMatch;
     for (;null !== (colMatch = colRegex.exec(docContent)); ) if (colMatch.index > (modelMatch.index || 0)) {
      const lines = docContent.substring(0, colMatch.index).split("\n"), line = lines.length - 1, char = lines[line].length, matchLength = colMatch[0].length;
      return new vscode_1.Range(line, char + matchLength - colname.length, line, char + matchLength);
     }
    }
    run(scanContext) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const {project, catalog: altimateCatalog, eventMap: projectEventMap, diagnostics: projectDiagnostics} = scanContext, projectName = project.getProjectName(), projectRootUri = project.projectRoot;
      if (void 0 === projectEventMap) return;
      const {nodeMetaMap} = projectEventMap;
      for (const value of nodeMetaMap.nodes()) {
       if ("ephemeral" === value.config.materialized) continue;
       const modelKey = JSON.stringify({
        projectroot: projectRootUri.fsPath,
        project: projectName,
        database: value.database.toLowerCase(),
        schema: value.schema.toLowerCase(),
        name: value.alias.toLowerCase()
       });
       if (Object.keys(altimateCatalog[projectName + projectRootUri]).includes(modelKey)) {
        const allDBColumns = altimateCatalog[projectName + projectRootUri][modelKey].map((({column_name}) => (0, 
        utils_1.getColumnNameByCase)(column_name, project.getAdapterType()))), packagePath = project.getPackageInstallPath();
        if (void 0 === packagePath) throw new Error("packagePath is not defined in " + project.projectRoot.fsPath);
        for (const existingCol of Object.keys(value.columns)) if (!allDBColumns.includes((0, 
        utils_1.getColumnNameByCase)(existingCol, project.getAdapterType()))) {
         const errMessage = `Column ${existingCol} listed in model ${value.name} is not found in the database.\n            It may be outdated or misspelled.`, schemaPath = (0, 
         parsers_1.createFullPathForNode)(projectName, projectRootUri.fsPath, value.package_name, packagePath, value.patch_path.split("://")[1]) || vscode_1.Uri.joinPath(project.projectRoot, value.patch_path.split("://")[1]).fsPath, colInDocRange = this.getTextLocation(value.name, existingCol, schemaPath);
         let schemaDiagnostics = projectDiagnostics[schemaPath];
         void 0 === schemaDiagnostics && (projectDiagnostics[schemaPath] = schemaDiagnostics = []), 
         schemaDiagnostics.push(new vscode_1.Diagnostic(colInDocRange || new vscode_1.Range(0, 0, 0, 0), errMessage, vscode_1.DiagnosticSeverity.Warning));
        }
       }
      }
     }));
    }
   };
   StaleModelColumnTest = StaleModelColumnTest_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(StaleModelColumnTest_1) ], StaleModelColumnTest), 
   exports.StaleModelColumnTest = StaleModelColumnTest;
  },
  78367: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var UndocumentedModelColumnTest_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.UndocumentedModelColumnTest = void 0;
   const tslib_1 = __webpack_require__(31635), vscode_1 = __webpack_require__(54980), utils_1 = __webpack_require__(86185);
   let UndocumentedModelColumnTest = UndocumentedModelColumnTest_1 = class {
    run(scanContext) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const {project, catalog: altimateCatalog, eventMap: projectEventMap, diagnostics: projectDiagnostics, scanResults} = scanContext, projectName = project.getProjectName(), projectRootUri = project.projectRoot;
      if (void 0 === projectEventMap) return;
      const {nodeMetaMap} = projectEventMap;
      for (const value of nodeMetaMap.nodes()) {
       if (void 0 !== scanResults.missingDoc && scanResults.missingDoc.has(value.uniqueId) || "seed" === value.config.materialized || "ephemeral" === value.config.materialized) continue;
       const modelKey = JSON.stringify({
        projectroot: projectRootUri.fsPath,
        project: projectName,
        database: value.database.toLowerCase(),
        schema: value.schema.toLowerCase(),
        name: value.alias.toLowerCase()
       });
       if (Object.keys(altimateCatalog[projectName + projectRootUri]).includes(modelKey)) {
        const modelDict = altimateCatalog[projectName + projectRootUri][modelKey], existingColumnsLowered = Object.keys(value.columns).map((key => (0, 
        utils_1.getColumnNameByCase)(key, project.getAdapterType())));
        for (const column of modelDict) if (!existingColumnsLowered.includes((0, utils_1.getColumnNameByCase)(column.column_name, project.getAdapterType()))) {
         if (!value.path) continue;
         const errMessage = `Column ${column.column_name} is undocumented in model: ${value.name}`;
         let modelDiagnostics = projectDiagnostics[value.path];
         void 0 === modelDiagnostics && (projectDiagnostics[value.path] = modelDiagnostics = []), 
         modelDiagnostics.push(new vscode_1.Diagnostic(new vscode_1.Range(0, 0, 0, 0), errMessage, vscode_1.DiagnosticSeverity.Information));
        }
       }
      }
     }));
    }
   };
   UndocumentedModelColumnTest = UndocumentedModelColumnTest_1 = tslib_1.__decorate([ (0, 
   utils_1.provideSingleton)(UndocumentedModelColumnTest_1) ], UndocumentedModelColumnTest), 
   exports.UndocumentedModelColumnTest = UndocumentedModelColumnTest;
  },
  10332: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var UnmaterializedModelTest_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.UnmaterializedModelTest = void 0;
   const tslib_1 = __webpack_require__(31635), vscode_1 = __webpack_require__(54980), utils_1 = __webpack_require__(86185);
   let UnmaterializedModelTest = UnmaterializedModelTest_1 = class {
    run(scanContext) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const {project, catalog: altimateCatalog, eventMap: projectEventMap, diagnostics: projectDiagnostics} = scanContext, projectName = project.getProjectName(), projectRootUri = project.projectRoot;
      if (void 0 === projectEventMap) return;
      const {nodeMetaMap} = projectEventMap;
      for (const value of nodeMetaMap.nodes()) {
       if ("ephemeral" === value.config.materialized) continue;
       const modelKey = JSON.stringify({
        projectroot: projectRootUri.fsPath,
        project: projectName,
        database: value.database.toLowerCase(),
        schema: value.schema.toLowerCase(),
        name: value.alias.toLowerCase()
       });
       if (!Object.keys(altimateCatalog[projectName + projectRootUri]).includes(modelKey) && value.path) {
        const errMessage = `Model ${value.name} does not exist in the database`;
        let modelDiagnostics = projectDiagnostics[value.path];
        void 0 === modelDiagnostics && (projectDiagnostics[value.path] = modelDiagnostics = []), 
        modelDiagnostics.push(new vscode_1.Diagnostic(new vscode_1.Range(0, 0, 0, 0), errMessage, vscode_1.DiagnosticSeverity.Information));
       }
      }
     }));
    }
   };
   UnmaterializedModelTest = UnmaterializedModelTest_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(UnmaterializedModelTest_1) ], UnmaterializedModelTest), 
   exports.UnmaterializedModelTest = UnmaterializedModelTest;
  },
  35797: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var ValidateSql_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.ValidateSql = void 0;
   const tslib_1 = __webpack_require__(31635), path_1 = __webpack_require__(16928), altimate_1 = __webpack_require__(91741), dbtProjectContainer_1 = __webpack_require__(82018), telemetry_1 = __webpack_require__(22644), utils_1 = __webpack_require__(86185), vscode_1 = __webpack_require__(54980), dbtProject_1 = __webpack_require__(38821), vscode_2 = __webpack_require__(54980), sqlPreviewContentProvider_1 = __webpack_require__(96246), python_bridge_1 = __webpack_require__(63283), dbtTerminal_1 = __webpack_require__(83683);
   let ValidateSql = ValidateSql_1 = class {
    constructor(dbtProjectContainer, telemetry, altimate, dbtTerminal) {
     this.dbtProjectContainer = dbtProjectContainer, this.telemetry = telemetry, this.altimate = altimate, 
     this.dbtTerminal = dbtTerminal, this.eventMap = new Map, dbtProjectContainer.onManifestChanged((event => this.onManifestCacheChanged(event))), 
     this.diagnosticsCollection = vscode_2.languages.createDiagnosticCollection();
    }
    onManifestCacheChanged(event) {
     var _a, _b;
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      null === (_a = event.added) || void 0 === _a || _a.forEach((added => {
       this.eventMap.set(added.project.projectRoot.fsPath, added);
      })), null === (_b = event.removed) || void 0 === _b || _b.forEach((removed => {
       this.eventMap.delete(removed.projectRoot.fsPath);
      }));
     }));
    }
    showError(exc) {
     if (exc instanceof python_bridge_1.PythonException) return vscode_1.window.showErrorMessage((0, 
     utils_1.extendErrorWithSupportLinks)("An error occured while trying to compile your model: " + exc.exception.message + ".")), 
     this.telemetry.sendTelemetryError("validateSQLCompileNodePythonError", exc), void this.dbtTerminal.error("validateSQLError", "Error encountered while compiling/retrieving schema for model", exc);
     this.telemetry.sendTelemetryError("validateSQLCompileNodeUnknownError", exc), vscode_1.window.showErrorMessage((0, 
     utils_1.extendErrorWithSupportLinks)("Could not validate SQL: " + exc.message));
    }
    validateSql() {
     var _a, _b, _c, _d;
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      if (this.telemetry.sendTelemetryEvent("validateSql"), !vscode_1.window.activeTextEditor) return;
      const currentFilePath = vscode_1.window.activeTextEditor.document.uri, project = this.dbtProjectContainer.findDBTProject(currentFilePath);
      if (!project) return void (yield vscode_1.window.showErrorMessage("Unable to build project"));
      const modelName = (0, path_1.basename)(currentFilePath.fsPath, ".sql"), event = this.getEvent();
      if (!event) return;
      const {graphMetaMap, nodeMetaMap} = event, node = nodeMetaMap.lookupByBaseName(modelName);
      if (!node) return;
      if (!(null === (_a = graphMetaMap.parents.get(node.uniqueId)) || void 0 === _a ? void 0 : _a.nodes)) return;
      const parentModels = [];
      let compiledQuery, cancellationToken, relationsWithoutColumns = [];
      if (yield vscode_1.window.withProgress({
       location: vscode_1.ProgressLocation.Notification,
       title: "Validating SQL",
       cancellable: !0
      }, ((_, token) => tslib_1.__awaiter(this, void 0, void 0, (function*() {
       try {
        cancellationToken = token;
        const fileContentBytes = yield vscode_2.workspace.fs.readFile(currentFilePath);
        if (cancellationToken.isCancellationRequested) return;
        try {
         compiledQuery = yield project.unsafeCompileQuery(fileContentBytes.toString(), modelName);
        } catch (error) {
         return void vscode_1.window.showErrorMessage((0, utils_1.extendErrorWithSupportLinks)("Unable to compile query for model " + node.name + " : " + error));
        }
        if (cancellationToken.isCancellationRequested) return;
        const modelsToFetch = dbtProject_1.DBTProject.getNonEphemeralParents(event, [ node.uniqueId ]), {mappedNode, relationsWithoutColumns: _relationsWithoutColumns} = yield project.getNodesWithDBColumns(event, modelsToFetch, cancellationToken);
        parentModels.push(...modelsToFetch.map((n => mappedNode[n]))), relationsWithoutColumns = _relationsWithoutColumns;
       } catch (exc) {
        this.showError(exc);
       }
      })))), null == cancellationToken ? void 0 : cancellationToken.isCancellationRequested) return;
      if (!compiledQuery) return;
      0 !== relationsWithoutColumns.length && vscode_1.window.showErrorMessage((0, utils_1.extendErrorWithSupportLinks)("Failed to fetch columns for " + relationsWithoutColumns.join(", ") + ". Probably the dbt models are not yet materialized."));
      const request = {
       sql: compiledQuery,
       dialect: project.getAdapterType(),
       models: parentModels
      }, response = yield null === (_b = this.getProject()) || void 0 === _b ? void 0 : _b.validateSql(request), activeUri = null === (_c = vscode_1.window.activeTextEditor) || void 0 === _c ? void 0 : _c.document.uri;
      if (activeUri.scheme === sqlPreviewContentProvider_1.SqlPreviewContentProvider.SCHEME) return;
      const compileSQLUri = activeUri.with({
       scheme: sqlPreviewContentProvider_1.SqlPreviewContentProvider.SCHEME
      }), isOpen = !!vscode_1.window.visibleTextEditors.find((item => item.document.uri === compileSQLUri));
      if (!response || !(null == response ? void 0 : response.error_type)) {
       const tabGroup = vscode_1.window.tabGroups.all.find((tabGroup => {
        var _a, _b;
        return (null === (_b = null === (_a = tabGroup.activeTab) || void 0 === _a ? void 0 : _a.input) || void 0 === _b ? void 0 : _b.uri.toString()) === compileSQLUri.toString();
       }));
       return tabGroup && (yield vscode_1.window.tabGroups.close(tabGroup)), vscode_1.window.showInformationMessage("SQL is valid."), 
       void this.diagnosticsCollection.set(compileSQLUri, []);
      }
      if ("sql_unknown_error" === response.error_type) return vscode_1.window.showErrorMessage("Unable to validate SQL."), 
      this.telemetry.sendTelemetryError("validateSQLError", response.errors[0].description), 
      void this.diagnosticsCollection.set(compileSQLUri, []);
      if (("sql_parse_error" === response.error_type || response.errors.length > 0 && response.errors[0].start_position) && !isOpen) {
       const doc = yield vscode_2.workspace.openTextDocument(compileSQLUri);
       yield vscode_1.window.showTextDocument(doc, vscode_1.ViewColumn.Beside, !0), yield vscode_2.languages.setTextDocumentLanguage(doc, "sql");
      }
      vscode_2.commands.executeCommand("workbench.action.problems.focus");
      const diagnostics = null === (_d = null == response ? void 0 : response.errors) || void 0 === _d ? void 0 : _d.map((({description, start_position, end_position}) => {
       let startPos = new vscode_2.Position(0, 1), endPos = new vscode_2.Position(0, 1);
       return start_position && (startPos = new vscode_2.Position(start_position[0], start_position[1])), 
       end_position && (endPos = new vscode_2.Position(end_position[0], end_position[1])), 
       new vscode_2.Diagnostic(new vscode_2.Range(startPos, endPos), description, vscode_2.DiagnosticSeverity.Error);
      }));
      this.diagnosticsCollection.set(compileSQLUri, diagnostics);
     }));
    }
    getProject() {
     var _a;
     const currentFilePath = null === (_a = vscode_1.window.activeTextEditor) || void 0 === _a ? void 0 : _a.document.uri;
     if (currentFilePath) return this.dbtProjectContainer.findDBTProject(currentFilePath);
    }
    getEvent() {
     if (void 0 === vscode_1.window.activeTextEditor || void 0 === this.eventMap) return;
     const currentFilePath = vscode_1.window.activeTextEditor.document.uri, projectRootpath = this.dbtProjectContainer.getProjectRootpath(currentFilePath);
     if (void 0 === projectRootpath) return;
     const event = this.eventMap.get(projectRootpath.fsPath);
     return void 0 !== event ? event : void 0;
    }
   };
   ValidateSql = ValidateSql_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(ValidateSql_1), tslib_1.__metadata("design:paramtypes", [ dbtProjectContainer_1.DBTProjectContainer, telemetry_1.TelemetryService, altimate_1.AltimateRequest, dbtTerminal_1.DBTTerminal ]) ], ValidateSql), 
   exports.ValidateSql = ValidateSql;
  },
  37987: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var WalkthroughCommands_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.WalkthroughCommands = void 0;
   const tslib_1 = __webpack_require__(31635), vscode_1 = __webpack_require__(54980), utils_1 = __webpack_require__(86185), dbtProjectContainer_1 = __webpack_require__(82018), telemetry_1 = __webpack_require__(22644), commandProcessExecution_1 = __webpack_require__(7824), pythonEnvironment_1 = __webpack_require__(88103), dbtTerminal_1 = __webpack_require__(83683);
   var PromptAnswer, DbtInstallationPromptAnswer;
   !function(PromptAnswer) {
    PromptAnswer.YES = "Yes", PromptAnswer.NO = "No";
   }(PromptAnswer || (PromptAnswer = {})), function(DbtInstallationPromptAnswer) {
    DbtInstallationPromptAnswer.INSTALL = "Install dbt core", DbtInstallationPromptAnswer.INSTALL_CLOUD = "Install dbt cloud";
   }(DbtInstallationPromptAnswer || (DbtInstallationPromptAnswer = {}));
   let WalkthroughCommands = WalkthroughCommands_1 = class {
    constructor(dbtProjectContainer, telemetry, commandProcessExecutionFactory, pythonEnvironment, dbtTerminal) {
     this.dbtProjectContainer = dbtProjectContainer, this.telemetry = telemetry, this.commandProcessExecutionFactory = commandProcessExecutionFactory, 
     this.pythonEnvironment = pythonEnvironment, this.dbtTerminal = dbtTerminal;
    }
    validateProjects(projectContext) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      if (void 0 === projectContext) return void vscode_1.window.showErrorMessage("No project was selected, please select a project in the step 'Pick a dbt project' above.");
      let debugCommand = "dbt debug";
      "cloud" === vscode_1.workspace.getConfiguration("dbt").get("dbtIntegration", "core") && (debugCommand = "dbt environment show");
      if ((yield vscode_1.window.showInformationMessage(`Do you want to validate the project: ${projectContext.label}? This will run the command '${debugCommand}' inside this project. Do you want to continue?`, PromptAnswer.YES, PromptAnswer.NO)) === PromptAnswer.YES) try {
       this.telemetry.sendTelemetryEvent("validateProject");
       const project = this.dbtProjectContainer.findDBTProject(projectContext.uri);
       if (void 0 === project) return void vscode_1.window.showErrorMessage(`Project ${projectContext.label} was not found`);
       const runModelOutput = yield project.debug();
       if (runModelOutput.includes("ERROR")) throw new Error(runModelOutput);
      } catch (err) {
       this.dbtTerminal.error("validateProjectError", `Error when validating ${projectContext.label}`, err), 
       vscode_1.window.showErrorMessage("Error running dbt debug for project " + projectContext.label + ". Please check the output tab for more details.");
      }
     }));
    }
    installDeps(projectContext) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      if (void 0 === projectContext) return void vscode_1.window.showErrorMessage("No project was selected, please select a project in the step 'Pick a dbt project' above.");
      if ((yield vscode_1.window.showInformationMessage(`Do you want to install packages for the project: ${projectContext.label}? This will run the command 'dbt deps' inside this project. Do you want to continue?`, PromptAnswer.YES, PromptAnswer.NO)) === PromptAnswer.YES) try {
       this.telemetry.sendTelemetryEvent("installDeps");
       const project = this.dbtProjectContainer.findDBTProject(projectContext.uri);
       if (void 0 === project) return void vscode_1.window.showErrorMessage(`Project ${projectContext.label} was not found`);
       yield project.installDeps();
      } catch (err) {
       this.dbtTerminal.debug("WalkthroughCommands.installDeps", "Could not install deps", err), 
       this.telemetry.sendTelemetryError("installDepsError", err), vscode_1.window.showErrorMessage("Error installing dbt dependencies for project " + projectContext.label + ". Please check the output tab for more details.");
      }
     }));
    }
    installDbt() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      "cloud" === vscode_1.workspace.getConfiguration("dbt").get("dbtIntegration", "core") ? this.installDbtCloud() : this.installDbtCore();
     }));
    }
    installDbtCloud() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      let error;
      if (yield vscode_1.window.withProgress({
       title: "Installing dbt cloud...",
       location: vscode_1.ProgressLocation.Notification,
       cancellable: !1
      }, (() => tslib_1.__awaiter(this, void 0, void 0, (function*() {
       try {
        const {stdout, stderr} = yield this.commandProcessExecutionFactory.createCommandProcessExecution({
         command: this.pythonEnvironment.pythonPath,
         args: [ "-m", "pip", "install", "dbt", "--no-cache-dir", "--force-reinstall" ],
         cwd: (0, utils_1.getFirstWorkspacePath)(),
         envVars: this.pythonEnvironment.environmentVariables
        }).completeWithTerminalOutput();
        if (!stdout.includes("Successfully installed") && !stdout.includes("Requirement already satisfied") && stderr) throw new Error(stderr);
        yield this.dbtProjectContainer.detectDBT(), this.dbtProjectContainer.initialize();
       } catch (err) {
        error = err;
       }
      })))), error) {
       (yield vscode_1.window.showErrorMessage("Could not install dbt cloud: " + error.message, DbtInstallationPromptAnswer.INSTALL_CLOUD)) === DbtInstallationPromptAnswer.INSTALL_CLOUD && vscode_1.commands.executeCommand("dbtPowerUser.installDbt");
      }
     }));
    }
    installDbtCore() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const dbtVersion = yield vscode_1.window.showQuickPick([ "1.0", "1.1", "1.2", "1.3", "1.4", "1.5", "1.6", "1.7", "1.8" ].map((value => ({
       label: value
      }))), {
       title: "Select your dbt version",
       canPickMany: !1
      });
      if (!dbtVersion) return;
      const adapter = yield vscode_1.window.showQuickPick([ "snowflake", "bigquery", "redshift", "postgres", "databricks", "sqlserver", "duckdb", "athena", "spark", "clickhouse", "trino", "synapse", "fabric" ].map((value => ({
       label: value
      }))), {
       title: "Select your adapter",
       canPickMany: !1
      });
      if (!adapter || !adapter.label) return;
      const packageVersion = dbtVersion.label, packageName = this.mapToAdapterPackage(adapter.label);
      let error;
      if (yield vscode_1.window.withProgress({
       title: `Installing ${packageName} ${packageVersion}...`,
       location: vscode_1.ProgressLocation.Notification,
       cancellable: !1
      }, (() => tslib_1.__awaiter(this, void 0, void 0, (function*() {
       try {
        const args = [ "-m", "pip", "install", "--no-cache-dir", "--force-reinstall" ];
        packageVersion >= "1.8" ? (args.push(`dbt-core==${packageVersion}`), args.push(`${packageName}>=${packageVersion}`)) : args.push(`${packageName}==${packageVersion}`), 
        args.push("--upgrade");
        const {stdout, stderr} = yield this.commandProcessExecutionFactory.createCommandProcessExecution({
         command: this.pythonEnvironment.pythonPath,
         args,
         cwd: (0, utils_1.getFirstWorkspacePath)(),
         envVars: this.pythonEnvironment.environmentVariables
        }).completeWithTerminalOutput();
        if (!stdout.includes("Successfully installed") && !stdout.includes("Requirement already satisfied") && stderr) throw new Error(stderr);
        yield this.dbtProjectContainer.detectDBT(), this.dbtProjectContainer.initialize();
       } catch (err) {
        error = err;
       }
      })))), error) {
       (yield vscode_1.window.showErrorMessage("Could not install dbt: " + error.message, DbtInstallationPromptAnswer.INSTALL)) === DbtInstallationPromptAnswer.INSTALL && vscode_1.commands.executeCommand("dbtPowerUser.installDbt");
      }
     }));
    }
    mapToAdapterPackage(adapter) {
     switch (adapter) {
     case "snowflake":
      return "dbt-snowflake";

     case "bigquery":
      return "dbt-bigquery";

     case "redshift":
      return "dbt-redshift";

     case "postgres":
      return "dbt-postgres";

     case "databricks":
      return "dbt-databricks";

     case "sqlserver":
      return "dbt-sqlserver";

     case "duckdb":
      return "dbt-duckdb";

     case "athena":
      return "dbt-athena-community";

     case "spark":
      return "dbt-spark";

     case "clickhouse":
      return "dbt-clickhouse";

     case "trino":
      return "dbt-trino";

     case "synapse":
      return "dbt-synapse";

     case "fabric":
      return "dbt-fabric";
     }
     throw new Error("Adapter is not supported" + adapter);
    }
   };
   WalkthroughCommands = WalkthroughCommands_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(WalkthroughCommands_1), tslib_1.__metadata("design:paramtypes", [ dbtProjectContainer_1.DBTProjectContainer, telemetry_1.TelemetryService, commandProcessExecution_1.CommandProcessExecutionFactory, pythonEnvironment_1.PythonEnvironment, dbtTerminal_1.DBTTerminal ]) ], WalkthroughCommands), 
   exports.WalkthroughCommands = WalkthroughCommands;
  },
  10998: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var ConversationProvider_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.ConversationProvider = exports.ConversationComment = void 0;
   const tslib_1 = __webpack_require__(31635), vscode_1 = __webpack_require__(54980), utils_1 = __webpack_require__(86185), dbtTerminal_1 = __webpack_require__(83683), path = __webpack_require__(16928), conversationService_1 = __webpack_require__(99311), sharedStateService_1 = __webpack_require__(37712), usersService_1 = __webpack_require__(8502), queryManifestService_1 = __webpack_require__(59269), dbtProject_1 = __webpack_require__(38821), telemetry_1 = __webpack_require__(22644);
   class ConversationComment {
    constructor(conversation_id, body, mode, author, time, parent, contextValue) {
     this.conversation_id = conversation_id, this.body = body, this.mode = mode, this.author = author, 
     this.time = time, this.parent = parent, this.contextValue = contextValue, this.savedBody = this.body, 
     this.timestamp = new Date(this.time);
    }
   }
   exports.ConversationComment = ConversationComment;
   const ALLOWED_FILE_EXTENSIONS = [ ".sql" ];
   let ConversationProvider = ConversationProvider_1 = class {
    constructor(conversationService, usersService, dbtTerminal, emitterService, queryManifestService, telemetry) {
     this.conversationService = conversationService, this.usersService = usersService, 
     this.dbtTerminal = dbtTerminal, this.emitterService = emitterService, this.queryManifestService = queryManifestService, 
     this.telemetry = telemetry, this.disposables = [], this.isPolling = !1, this._threads = {}, 
     this.isCollaborationEnabled() && (this.commentController = vscode_1.comments.createCommentController("altimate-conversations", "Altimate dbt conversations"), 
     this.commentController.commentingRangeProvider = {
      provideCommentingRanges: (document, token) => {
       if (!ALLOWED_FILE_EXTENSIONS.find((ext => document.uri.fsPath.endsWith(ext)))) return null;
       const lineCount = document.lineCount;
       return [ new vscode_1.Range(0, 0, lineCount - 1, 0) ];
      }
     }, this.disposables.push(emitterService.eventEmitter.event((d => {
      "dbtProjectsInitialized" !== d.command && "refetchConversations" !== d.command || this.loadThreads();
     }))), this.disposables.push(this.commentController));
    }
    isCollaborationEnabled() {
     const enableCollaboration = vscode_1.workspace.getConfiguration("dbt").get("enableCollaboration", !1);
     return this.dbtTerminal.debug("ConversationProvider:isCollaborationEnabled", "collaboration status", enableCollaboration), 
     enableCollaboration;
    }
    setupPolling() {
     clearTimeout(this.timer);
     const pollingInterval = vscode_1.workspace.getConfiguration("dbt").get("conversationsPollingInterval", 30);
     this.dbtTerminal.debug("ConversationProvider:setupRefetch", "refresh conversations after", pollingInterval), 
     this.timer = setTimeout((() => {
      this.loadThreads();
     }), 1e3 * pollingInterval), this.isPolling = !0;
    }
    loadThreads() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.dbtTerminal.debug("ConversationProvider:loadThreads", "loading threads");
      const shares = yield this.conversationService.loadSharedDocs();
      shares && shares.length && !this.isPolling && this.setupPolling(), (null == shares ? void 0 : shares.length) ? shares.map((dbtDocsShare => tslib_1.__awaiter(this, void 0, void 0, (function*() {
       this.dbtTerminal.debug("ConversationProvider:loadThreads", "loading conversations", dbtDocsShare.share_id);
       const conversations = dbtDocsShare.conversation_group;
       if (!(null == conversations ? void 0 : conversations.length)) return void this.dbtTerminal.debug("ConversationProvider:loadThreads", "No conversations in share", dbtDocsShare.share_id);
       const pendingConversations = conversations.filter((c => "Pending" === c.status));
       if (this.emitterService.fire({
        command: "conversations:updates",
        payload: {
         shareId: dbtDocsShare.share_id,
         conversationGroups: pendingConversations
        }
       }), this._threads[dbtDocsShare.share_id]) {
        const currentConversationGroupIds = Object.keys(this._threads[dbtDocsShare.share_id]), conversationGroupIdsFromDB = pendingConversations.map((c => c.conversation_group_id.toString())), missingConversationGroupIds = currentConversationGroupIds.filter((id => !conversationGroupIdsFromDB.includes(id)));
        missingConversationGroupIds.length && (this.dbtTerminal.debug("ConversationProvider:loadThreads", "resolving threads", missingConversationGroupIds), 
        missingConversationGroupIds.forEach((id => this._threads[dbtDocsShare.share_id][id].dispose())));
       }
       const project = this.queryManifestService.getProjectByName(dbtDocsShare.project_name);
       project ? pendingConversations.map((conversationGroup => {
        var _a, _b, _c;
        const uri = vscode_1.Uri.file(path.join(project.projectRoot.fsPath, conversationGroup.meta.filePath)), thread = null !== (_b = null === (_a = this._threads[dbtDocsShare.share_id]) || void 0 === _a ? void 0 : _a[conversationGroup.conversation_group_id]) && void 0 !== _b ? _b : this.commentController.createCommentThread(uri, new vscode_1.Range(conversationGroup.meta.range.start.line, conversationGroup.meta.range.start.character, conversationGroup.meta.range.end.line, conversationGroup.meta.range.end.character), []);
        (null === (_c = vscode_1.window.activeTextEditor) || void 0 === _c ? void 0 : _c.document.uri.fsPath) === uri.fsPath && vscode_1.window.showTextDocument(vscode_1.window.activeTextEditor.document), 
        thread.state = vscode_1.CommentThreadState.Unresolved, thread.comments = conversationGroup.conversations.map((conversation => {
         var _a;
         return new ConversationComment(conversation.conversation_id, this.convertTextFromDbToCommentFormat(conversation.message), vscode_1.CommentMode.Preview, {
          name: (null === (_a = this.usersService.getUserById(conversation.user_id)) || void 0 === _a ? void 0 : _a.first_name) || "Unknown"
         }, conversation.timestamp, void 0, "");
        }));
        !!conversationGroup.meta.field && (thread.comments = [ new ConversationComment(-1, [ "This comment is added from documentation editor.", 'Please click "View in documentation editor" button to view in documentation editor.\n', conversationGroup.meta.column ? `Column: ${conversationGroup.meta.column}\n` : "", "Description:", conversationGroup.meta.highlight ].join(" "), vscode_1.CommentMode.Preview, {
         name: "Altimate"
        }, (new Date).toISOString(), void 0, ""), ...thread.comments ]), thread.conversation_group_id = conversationGroup.conversation_group_id, 
        thread.meta = conversationGroup.meta, thread.share_id = dbtDocsShare.share_id, thread.label = "Discussion", 
        this.addContextValue(thread), this._threads[dbtDocsShare.share_id] = Object.assign(Object.assign({}, this._threads[dbtDocsShare.share_id]), {
         [conversationGroup.conversation_group_id]: thread
        });
       })) : this.dbtTerminal.debug("ConversationProvider:loadThreads", "not able to get project", dbtDocsShare);
      })))) : this.dbtTerminal.debug("ConversationProvider:loadThreads", "No conversations yet");
     }));
    }
    addContextValue(thread) {
     let contextValue = "saved";
     "description" === thread.meta.field && (contextValue += "|description"), thread.contextValue = contextValue;
    }
    convertTextFromDbToCommentFormat(text) {
     return new vscode_1.MarkdownString(text.replace(/@\[(.*?)\]\((.*?)\)/g, "@$2"));
    }
    convertTextToDbFormat(text) {
     return new vscode_1.MarkdownString(text).value.replace(/@(\S+)\s/g, "@[$1]($1) ");
    }
    addComment(reply) {
     var _a;
     const thread = reply.thread;
     thread.contextValue = "saving";
     const newComment = new ConversationComment(-1, new vscode_1.MarkdownString(reply.text), vscode_1.CommentMode.Preview, {
      name: (null === (_a = this.usersService.user) || void 0 === _a ? void 0 : _a.first_name) || "Unknown"
     }, (new Date).toISOString(), thread, "");
     return thread.comments = [ ...thread.comments, newComment ], newComment;
    }
    copyThreadLink(thread) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      if (this.telemetry.sendTelemetryEvent("dbtCollaboration:copyLink", {
       source: "vscode"
      }), !thread.share_id) return void vscode_1.window.showErrorMessage((0, utils_1.extendErrorWithSupportLinks)("Unable to find conversation."));
      const result = yield this.conversationService.getAppUrlByShareId(thread.share_id);
      (null == result ? void 0 : result.app_url) && (vscode_1.env.clipboard.writeText(`${result.app_url}/${thread.conversation_group_id}`), 
      vscode_1.window.showInformationMessage("Url copied", "Ok"));
     }));
    }
    viewInDocEditor(thread) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.telemetry.sendTelemetryEvent("dbtCollaboration:viewInDocEditor", {
       source: "vscode"
      }), this.dbtTerminal.debug("ConversationProvider:viewInDocEditor", "viewing conversation", thread.share_id, thread.conversation_group_id), 
      vscode_1.commands.executeCommand("dbtPowerUser.DocsEdit.focus"), this.emitterService.fire({
       command: "viewConversation",
       payload: {
        shareId: thread.share_id,
        conversation_group_id: thread.conversation_group_id
       }
      });
      const editor = vscode_1.window.visibleTextEditors.find((editor => editor.document.uri.fsPath === thread.uri.fsPath));
      (null == editor ? void 0 : editor.document) && vscode_1.window.showTextDocument(editor.document);
     }));
    }
    viewInDbtDocs(thread) {
     var _a;
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.telemetry.sendTelemetryEvent("dbtCollaboration:viewInDbtDocs", {
       source: "vscode"
      }), thread.share_id ? (this.dbtTerminal.debug("ConversationProvider:viewInDbtDocs", "firing render dbtdocs event", thread.share_id), 
      this.emitterService.fire({
       command: "dbtdocsview:render",
       payload: {
        shareId: thread.share_id,
        conversationGroupId: thread.conversation_group_id,
        userId: null === (_a = this.usersService.user) || void 0 === _a ? void 0 : _a.id
       }
      })) : vscode_1.window.showErrorMessage((0, utils_1.extendErrorWithSupportLinks)("Unable to find conversation."));
     }));
    }
    getNodeMeta(uri, resourceName) {
     const event = this.queryManifestService.getEventByDocument(uri);
     if (!event) return void this.dbtTerminal.debug("getNodeMeta", "event not available");
     const currentNode = event.nodeMetaMap.lookupByBaseName(resourceName);
     if (currentNode) return {
      resource_type: currentNode.resource_type,
      uniqueId: currentNode.uniqueId
     };
     const macroNode = event.macroMetaMap.get(resourceName);
     if (macroNode) return {
      resource_type: dbtProject_1.DBTProject.RESOURCE_TYPE_MACRO,
      uniqueId: macroNode.uniqueId
     };
     const testNode = event.testMetaMap.get(resourceName);
     return testNode ? {
      resource_type: dbtProject_1.DBTProject.RESOURCE_TYPE_TEST,
      uniqueId: testNode.uniqueId
     } : void 0;
    }
    createCommentThread(uri, range) {
     var _a;
     return null === (_a = this.commentController) || void 0 === _a ? void 0 : _a.createCommentThread(uri, range, []);
    }
    saveConversation(message, uri, extraMeta = {}, range, source = "vscode") {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.telemetry.sendTelemetryEvent("dbtCollaboration:create", {
       source
      });
      const model = path.basename(uri.fsPath, ".sql"), convertedMessage = this.convertTextToDbFormat(message), nodeMeta = this.getNodeMeta(uri, model), editor = vscode_1.window.visibleTextEditors.find((editor => editor.document.uri.fsPath === uri.fsPath)), project = this.queryManifestService.getProjectByUri(uri), {value} = extraMeta, rest = tslib_1.__rest(extraMeta, [ "value" ]), highlight = "description" === rest.field ? value : (range.isSingleLine ? null == editor ? void 0 : editor.document.lineAt(range.start.line).text : null == editor ? void 0 : editor.document.getText(range)) || "", meta = Object.assign(Object.assign({}, rest), {
       highlight,
       source: "extension",
       uniqueId: null == nodeMeta ? void 0 : nodeMeta.uniqueId,
       filePath: path.relative((null == project ? void 0 : project.projectRoot.fsPath) || "", uri.fsPath),
       resource_type: null == nodeMeta ? void 0 : nodeMeta.resource_type,
       range: {
        end: range.end,
        start: range.start
       }
      });
      let shareName = "Discussion on ";
      (null == nodeMeta ? void 0 : nodeMeta.uniqueId) ? shareName += nodeMeta.uniqueId : model ? shareName += model : shareName = "Untitled Discussion";
      const result = yield this.conversationService.shareDbtDocs({
       name: shareName,
       description: "",
       uri,
       model
      });
      if (!result) return;
      const {shareId, shareUrl} = result;
      this.dbtTerminal.debug("ConversationProvider:createConversation", "created conversation, adding conversation to group", shareId, shareUrl);
      const addReplyResult = yield this.conversationService.createConversationGroup(shareId, {
       message: convertedMessage,
       meta
      });
      if (!addReplyResult) throw new Error("Unable to create group");
      return this.dbtTerminal.debug("ConversationProvider", "added conversation to created conversation group", addReplyResult), 
      {
       conversation_id: addReplyResult.conversation_id,
       shareId,
       conversation_group_id: addReplyResult.conversation_group_id,
       meta
      };
     }));
    }
    createConversation(reply, extraMeta = {}, source = "vscode") {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      try {
       this.dbtTerminal.debug("ConversationProvider:createConversation", "creating conversation", reply);
       const thread = reply.thread;
       thread.state = vscode_1.CommentThreadState.Unresolved, this.addComment(reply), thread.label = "Pending";
       const result = yield this.saveConversation(reply.text, thread.uri, extraMeta, thread.range, source);
       if (!result) return;
       const {conversation_id, shareId, conversation_group_id, meta} = result;
       thread.comments[0].conversation_id = conversation_id, thread.share_id = shareId, 
       thread.conversation_group_id = conversation_group_id, thread.meta = meta, this._threads[shareId] = Object.assign(Object.assign({}, this._threads[shareId]), {
        [thread.conversation_group_id]: thread
       }), thread.label = "Discussion", this.addContextValue(thread);
      } catch (error) {
       this.dbtTerminal.error("ConversationProvider:createConversation", "unable to create conversation", error), 
       reply.thread.dispose(), vscode_1.window.showErrorMessage((0, utils_1.extendErrorWithSupportLinks)(`Unable to save your comment. ${error.message}`));
      } finally {
       this.isPolling || this.setupPolling();
      }
     }));
    }
    replyToConversation(reply) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.telemetry.sendTelemetryEvent("dbtCollaboration:reply", {
       source: "vscode"
      });
      const thread = reply.thread;
      try {
       if (!thread.share_id) throw new Error("Unable to find conversation. Missing share id");
       if (this.dbtTerminal.debug("ConversationProvider:replyToConversation", "replying to conversation", reply), 
       this.addComment(reply), !thread.conversation_group_id) {
        if (!thread.share_id) throw new Error("Unable to find conversation. Missing conversation group id");
        return;
       }
       yield this.conversationService.addConversationToGroup(thread.share_id, thread.conversation_group_id, this.convertTextToDbFormat(reply.text));
      } catch (error) {
       this.dbtTerminal.error("ConversationProvider:replyToConversation", "unable to reply conversation", error), 
       vscode_1.window.showErrorMessage((0, utils_1.extendErrorWithSupportLinks)(`Unable to save your reply. ${error.message}`));
      }
      this.addContextValue(thread);
     }));
    }
    resolveConversation(commentThread) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      try {
       if (this.telemetry.sendTelemetryEvent("dbtCollaboration:resolve", {
        source: "vscode"
       }), !commentThread.share_id) throw new Error("Unable to find conversation. Missing share id");
       this.dbtTerminal.debug("ConversationProvider:resolveConversation", `resolving conversation: ${commentThread.conversation_group_id} in share: ${commentThread.share_id}`);
       const result = yield this.conversationService.resolveConversation(commentThread.share_id, commentThread.conversation_group_id);
       this.dbtTerminal.debug("ConversationProvider:resolveConversation", `resolved conversation: ${commentThread.conversation_group_id} in share: ${commentThread.share_id}`, result), 
       commentThread.dispose();
      } catch (error) {
       this.dbtTerminal.error("ConversationProvider:resolveConversation", "unable to resolve conversation", error), 
       vscode_1.window.showErrorMessage((0, utils_1.extendErrorWithSupportLinks)(`Unable to resolve comment. ${error.message}`));
      }
     }));
    }
    dispose() {
     for (;this.disposables.length; ) {
      const x = this.disposables.pop();
      x && x.dispose();
     }
    }
   };
   ConversationProvider = ConversationProvider_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(ConversationProvider_1), tslib_1.__metadata("design:paramtypes", [ conversationService_1.ConversationService, usersService_1.UsersService, dbtTerminal_1.DBTTerminal, sharedStateService_1.SharedStateService, queryManifestService_1.QueryManifestService, telemetry_1.TelemetryService ]) ], ConversationProvider), 
   exports.ConversationProvider = ConversationProvider;
  },
  55318: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var CommentProviders_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.CommentProviders = void 0;
   const tslib_1 = __webpack_require__(31635), utils_1 = __webpack_require__(86185), conversationProvider_1 = __webpack_require__(10998);
   let CommentProviders = CommentProviders_1 = class {
    constructor(conversationProvider) {
     this.conversationProvider = conversationProvider, this.disposables = [], this.disposables.push(this.conversationProvider);
    }
    dispose() {
     for (;this.disposables.length; ) {
      const x = this.disposables.pop();
      x && x.dispose();
     }
    }
   };
   CommentProviders = CommentProviders_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(CommentProviders_1), tslib_1.__metadata("design:paramtypes", [ conversationProvider_1.ConversationProvider ]) ], CommentProviders), 
   exports.CommentProviders = CommentProviders;
  },
  96921: (__unused_webpack_module, exports) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.ManifestPathType = void 0, function(ManifestPathType) {
    ManifestPathType.EMPTY = "", ManifestPathType.LOCAL = "local", ManifestPathType.REMOTE = "remote";
   }(exports.ManifestPathType || (exports.ManifestPathType = {}));
  },
  18166: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var ContentProviders_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.ContentProviders = void 0;
   const tslib_1 = __webpack_require__(31635), vscode_1 = __webpack_require__(54980), utils_1 = __webpack_require__(86185), sqlPreviewContentProvider_1 = __webpack_require__(96246);
   let ContentProviders = ContentProviders_1 = class {
    constructor(sqlPreviewContentProvider) {
     this.sqlPreviewContentProvider = sqlPreviewContentProvider, this.disposables = [], 
     this.disposables.push(vscode_1.workspace.registerTextDocumentContentProvider(sqlPreviewContentProvider_1.SqlPreviewContentProvider.SCHEME, this.sqlPreviewContentProvider));
    }
    dispose() {
     for (;this.disposables.length; ) {
      const x = this.disposables.pop();
      x && x.dispose();
     }
    }
   };
   ContentProviders = ContentProviders_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(ContentProviders_1), tslib_1.__metadata("design:paramtypes", [ sqlPreviewContentProvider_1.SqlPreviewContentProvider ]) ], ContentProviders), 
   exports.ContentProviders = ContentProviders;
  },
  96246: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var SqlPreviewContentProvider_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.SqlPreviewContentProvider = void 0;
   const tslib_1 = __webpack_require__(31635), fs_1 = __webpack_require__(79896), vscode_1 = __webpack_require__(54980), dbtProjectContainer_1 = __webpack_require__(82018), utils_1 = __webpack_require__(86185), telemetry_1 = __webpack_require__(22644), deferToProdService_1 = __webpack_require__(2826), altimate_1 = __webpack_require__(91741), constants_1 = __webpack_require__(96921), path = __webpack_require__(16928);
   let SqlPreviewContentProvider = SqlPreviewContentProvider_1 = class {
    constructor(dbtProjectContainer, deferToProdService, altimateRequest, telemetry) {
     this.dbtProjectContainer = dbtProjectContainer, this.deferToProdService = deferToProdService, 
     this.altimateRequest = altimateRequest, this.telemetry = telemetry, this._onDidChange = new vscode_1.EventEmitter, 
     this.compilationDocs = new Map, this.watchers = [], this.subscriptions = vscode_1.workspace.onDidCloseTextDocument((compilationDoc => this.compilationDocs.delete(compilationDoc.uri.toString())));
    }
    dispose() {
     for (this._onDidChange.dispose(), this.subscriptions.dispose(); this.watchers.length; ) {
      const x = this.watchers.pop();
      x && x.dispose();
     }
    }
    get onDidChange() {
     return this._onDidChange.event;
    }
    provideTextDocumentContent(uri) {
     if (void 0 === this.compilationDocs.get(uri.toString())) {
      this.compilationDocs.set(uri.toString(), uri);
      const watcher = vscode_1.workspace.createFileSystemWatcher(new vscode_1.RelativePattern(uri, "*"));
      this.watchers.push(watcher), watcher.onDidChange((0, utils_1.debounce)((() => this._onDidChange.fire(uri)), 500));
     }
     return vscode_1.window.withProgress({
      location: vscode_1.ProgressLocation.Notification,
      title: "Compiling dbt model...",
      cancellable: !1
     }, (() => tslib_1.__awaiter(this, void 0, void 0, (function*() {
      return yield this.requestCompilation(uri);
     }))));
    }
    requestCompilation(uri) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      try {
       const fsPath = decodeURI(uri.fsPath), modelName = path.basename(fsPath, ".sql"), query = (0, 
       fs_1.readFileSync)(fsPath, "utf8"), project = this.dbtProjectContainer.findDBTProject(vscode_1.Uri.file(fsPath));
       if (void 0 === project) return this.telemetry.sendTelemetryError("sqlPreviewNotLoadingError"), 
       "Still loading dbt project, please try again later...";
       this.telemetry.sendTelemetryEvent("requestCompilation"), yield project.refreshProjectConfig();
       const result = yield project.unsafeCompileQuery(query, modelName), {manifestPathType} = this.deferToProdService.getDeferConfigByProjectRoot(project.projectRoot.fsPath);
       return "core" === vscode_1.workspace.getConfiguration("dbt").get("dbtIntegration", "core") && manifestPathType === constants_1.ManifestPathType.REMOTE && this.altimateRequest.sendDeferToProdEvent(constants_1.ManifestPathType.REMOTE), 
       result;
      } catch (error) {
       const errorMessage = error.message;
       return vscode_1.window.showErrorMessage(`Error while compiling: ${errorMessage}`), 
       errorMessage;
      }
     }));
    }
   };
   SqlPreviewContentProvider.SCHEME = "query-preview", SqlPreviewContentProvider = SqlPreviewContentProvider_1 = tslib_1.__decorate([ (0, 
   utils_1.provideSingleton)(SqlPreviewContentProvider_1), tslib_1.__metadata("design:paramtypes", [ dbtProjectContainer_1.DBTProjectContainer, deferToProdService_1.DeferToProdService, altimate_1.AltimateRequest, telemetry_1.TelemetryService ]) ], SqlPreviewContentProvider), 
   exports.SqlPreviewContentProvider = SqlPreviewContentProvider;
  },
  29597: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var DBTPowerUserExtension_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.DBTPowerUserExtension = void 0;
   const tslib_1 = __webpack_require__(31635), vscode_1 = __webpack_require__(54980), autocompletion_provider_1 = __webpack_require__(78200), code_lens_provider_1 = __webpack_require__(77463), commands_1 = __webpack_require__(15059), content_provider_1 = __webpack_require__(18166), definition_provider_1 = __webpack_require__(45608), document_formatting_edit_provider_1 = __webpack_require__(5113), dbtProjectContainer_1 = __webpack_require__(82018), statusbar_1 = __webpack_require__(58280), treeview_provider_1 = __webpack_require__(57052), utils_1 = __webpack_require__(86185), webview_provider_1 = __webpack_require__(84208), telemetry_1 = __webpack_require__(22644), hover_provider_1 = __webpack_require__(93875), quickpick_1 = __webpack_require__(25809), validation_provider_1 = __webpack_require__(79262), comment_provider_1 = __webpack_require__(55318), _lib_1 = __webpack_require__(17176);
   var PromptAnswer;
   !function(PromptAnswer) {
    PromptAnswer.YES = "Yes", PromptAnswer.NO = "No";
   }(PromptAnswer || (PromptAnswer = {}));
   let DBTPowerUserExtension = DBTPowerUserExtension_1 = class {
    constructor(dbtProjectContainer, webviewViewProviders, autocompletionProviders, definitionProviders, vscodeCommands, treeviewProviders, contentProviders, codeLensProviders, documentFormattingEditProviders, statusBars, puStatusBars, telemetry, hoverProviders, validationProvider, commentProviders, notebookProviders) {
     this.dbtProjectContainer = dbtProjectContainer, this.webviewViewProviders = webviewViewProviders, 
     this.autocompletionProviders = autocompletionProviders, this.definitionProviders = definitionProviders, 
     this.vscodeCommands = vscodeCommands, this.treeviewProviders = treeviewProviders, 
     this.contentProviders = contentProviders, this.codeLensProviders = codeLensProviders, 
     this.documentFormattingEditProviders = documentFormattingEditProviders, this.statusBars = statusBars, 
     this.puStatusBars = puStatusBars, this.telemetry = telemetry, this.hoverProviders = hoverProviders, 
     this.validationProvider = validationProvider, this.commentProviders = commentProviders, 
     this.notebookProviders = notebookProviders, this.disposables = [], this.disposables.push(this.dbtProjectContainer, this.webviewViewProviders, this.definitionProviders, this.autocompletionProviders, this.treeviewProviders, this.contentProviders, this.codeLensProviders, this.vscodeCommands, this.documentFormattingEditProviders, this.statusBars, this.puStatusBars, this.telemetry, this.hoverProviders, this.validationProvider, this.commentProviders, this.notebookProviders);
    }
    dispose() {
     for (;this.disposables.length; ) {
      const x = this.disposables.pop();
      x && x.dispose();
     }
    }
    activate(context) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.dbtProjectContainer.setContext(context), this.dbtProjectContainer.initializeWalkthrough(), 
      yield this.dbtProjectContainer.detectDBT(), yield this.dbtProjectContainer.initializeDBTProjects(), 
      yield this.statusBars.initialize();
      const dbtIntegration = vscode_1.workspace.getConfiguration("dbt").get("dbtIntegration", "core");
      vscode_1.workspace.onDidChangeConfiguration((e => {
       if (!e.affectsConfiguration("dbt")) return;
       const newDbtIntegration = vscode_1.workspace.getConfiguration("dbt").get("dbtIntegration", "core");
       dbtIntegration !== newDbtIntegration && [ "core", "cloud" ].includes(newDbtIntegration) && vscode_1.commands.executeCommand("workbench.action.reloadWindow");
      }));
     }));
    }
   };
   DBTPowerUserExtension.DBT_SQL_SELECTOR = [ {
    language: "jinja-sql",
    scheme: "file"
   }, {
    language: "sql",
    scheme: "file"
   }, {
    language: "jinja-sql",
    scheme: "untitled"
   }, {
    language: "jinja-sql",
    scheme: "vscode-notebook-cell"
   } ], DBTPowerUserExtension.DBT_YAML_SELECTOR = [ {
    language: "yaml",
    scheme: "file"
   }, {
    language: "jinja-yaml",
    scheme: "file"
   } ], DBTPowerUserExtension.DBT_YAML_SQL_SELECTOR = [ {
    language: "jinja-sql",
    scheme: "file"
   }, {
    language: "sql",
    scheme: "file"
   }, {
    language: "yaml",
    scheme: "file"
   }, {
    language: "jinja-yaml",
    scheme: "file"
   } ], DBTPowerUserExtension = DBTPowerUserExtension_1 = tslib_1.__decorate([ (0, 
   utils_1.provideSingleton)(DBTPowerUserExtension_1), tslib_1.__metadata("design:paramtypes", [ dbtProjectContainer_1.DBTProjectContainer, webview_provider_1.WebviewViewProviders, autocompletion_provider_1.AutocompletionProviders, definition_provider_1.DefinitionProviders, commands_1.VSCodeCommands, treeview_provider_1.TreeviewProviders, content_provider_1.ContentProviders, code_lens_provider_1.CodeLensProviders, document_formatting_edit_provider_1.DocumentFormattingEditProviders, statusbar_1.StatusBars, quickpick_1.DbtPowerUserActionsCenter, telemetry_1.TelemetryService, hover_provider_1.HoverProviders, validation_provider_1.ValidationProvider, comment_provider_1.CommentProviders, _lib_1.NotebookProviders ]) ], DBTPowerUserExtension), 
   exports.DBTPowerUserExtension = DBTPowerUserExtension;
  },
  98439: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var AltimateDatapilot_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.AltimateDatapilot = void 0;
   const tslib_1 = __webpack_require__(31635), utils_1 = __webpack_require__(86185), pythonEnvironment_1 = __webpack_require__(88103), commandProcessExecution_1 = __webpack_require__(7824), dbtTerminal_1 = __webpack_require__(83683);
   let AltimateDatapilot = AltimateDatapilot_1 = class {
    constructor(pythonEnvironment, commandProcessExecutionFactory, dbtTerminal) {
     this.pythonEnvironment = pythonEnvironment, this.commandProcessExecutionFactory = commandProcessExecutionFactory, 
     this.dbtTerminal = dbtTerminal, this.packageName = "altimate-datapilot-cli";
    }
    checkIfAltimateDatapilotInstalled() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const process = this.commandProcessExecutionFactory.createCommandProcessExecution({
       command: this.pythonEnvironment.pythonPath,
       args: [ "-c", "import datapilot;print(datapilot.__version__)" ],
       cwd: (0, utils_1.getFirstWorkspacePath)(),
       envVars: this.pythonEnvironment.environmentVariables
      }), {stdout, stderr} = yield process.complete();
      return stderr ? (this.dbtTerminal.debug("AltimateDatapilot:checkIfAltimateDatapilotInstalled", "Datapilot not installed", stderr), 
      "") : stdout.trim();
     }));
    }
    installAltimateDatapilot(datapilotVersion) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const {stderr, stdout} = yield this.commandProcessExecutionFactory.createCommandProcessExecution({
       command: this.pythonEnvironment.pythonPath,
       args: [ "-m", "pip", "install", `${this.packageName}==${datapilotVersion}` ],
       cwd: (0, utils_1.getFirstWorkspacePath)(),
       envVars: this.pythonEnvironment.environmentVariables
      }).completeWithTerminalOutput();
      if (!stdout.includes("Successfully installed") && stderr) throw new Error(stderr);
     }));
    }
   };
   AltimateDatapilot = AltimateDatapilot_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(AltimateDatapilot_1), tslib_1.__metadata("design:paramtypes", [ pythonEnvironment_1.PythonEnvironment, commandProcessExecution_1.CommandProcessExecutionFactory, dbtTerminal_1.DBTTerminal ]) ], AltimateDatapilot), 
   exports.AltimateDatapilot = AltimateDatapilot;
  },
  54958: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var DBTCloudDetection_1, DBTCloudProjectDetection_1, DBTCloudProjectIntegration_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.DBTCloudProjectIntegration = exports.DBTCloudProjectDetection = exports.DBTCloudDetection = void 0;
   const tslib_1 = __webpack_require__(31635), vscode_1 = __webpack_require__(54980), utils_1 = __webpack_require__(86185), dbtIntegration_1 = __webpack_require__(22373), commandProcessExecution_1 = __webpack_require__(7824), path_1 = __webpack_require__(16928), altimate_1 = __webpack_require__(91741), path = __webpack_require__(16928), dbtProject_1 = __webpack_require__(38821), telemetry_1 = __webpack_require__(22644), dbtTerminal_1 = __webpack_require__(83683), pythonEnvironment_1 = __webpack_require__(88103), fs_1 = __webpack_require__(79896), validation_provider_1 = __webpack_require__(79262), deferToProdService_1 = __webpack_require__(2826), semver = __webpack_require__(99589), crypto = __webpack_require__(76982);
   function getDBTPath(pythonEnvironment, terminal) {
    if (pythonEnvironment.pythonPath) {
     const dbtPath = [ "dbt", "dbt.exe" ].find((path => (0, fs_1.existsSync)((0, path_1.join)((0, 
     path_1.dirname)(pythonEnvironment.pythonPath), path))));
     if (dbtPath) {
      const dbtPythonPath = (0, path_1.join)((0, path_1.dirname)(pythonEnvironment.pythonPath), dbtPath);
      return terminal.debug("Found dbt path in Python bin directory:", dbtPythonPath), 
      dbtPythonPath;
     }
    }
    return terminal.debug("Using default dbt path:", "dbt"), "dbt";
   }
   let DBTCloudDetection = DBTCloudDetection_1 = class {
    constructor(commandProcessExecutionFactory, pythonEnvironment, terminal) {
     this.commandProcessExecutionFactory = commandProcessExecutionFactory, this.pythonEnvironment = pythonEnvironment, 
     this.terminal = terminal;
    }
    detectDBT() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const dbtPath = getDBTPath(this.pythonEnvironment, this.terminal);
      try {
       this.terminal.debug("DBTCLIDetection", "Detecting dbt cloud cli");
       const checkDBTInstalledProcess = this.commandProcessExecutionFactory.createCommandProcessExecution({
        command: dbtPath,
        args: [ "--version" ],
        cwd: this.getFirstWorkspacePath()
       }), {stdout, stderr} = yield checkDBTInstalledProcess.complete();
       if (stderr) throw new Error(stderr);
       if (stdout.includes("dbt Cloud CLI")) {
        const matches = /dbt Cloud CLI - (\d*\.\d*\.\d*)/gm.exec(stdout);
        if (2 === (null == matches ? void 0 : matches.length)) {
         const minVersion = "0.37.6", currentVersion = matches[1];
         if (semver.lt(currentVersion, minVersion)) return vscode_1.window.showErrorMessage(`This version of dbt Cloud is not supported. Please update to a dbt Cloud CLI version higher than ${minVersion}`), 
         this.terminal.debug("DBTCLIDetectionFailed", "dbt cloud cli was found but version is not supported. Detection command returned :  " + stdout), 
         !0;
        }
        return this.terminal.debug("DBTCLIDetectionSuccess", "dbt cloud cli detected"), 
        !0;
       }
       this.terminal.debug("DBTCLIDetectionFailed", "dbt cloud cli was not found. Detection command returned :  " + stdout);
      } catch (error) {
       this.terminal.warn("DBTCLIDetectionError", "Detection failed with error : " + error.message);
      }
      return this.terminal.debug("DBTCLIDetectionFailed", "dbt cloud cli was not found. Detection command returning false"), 
      !1;
     }));
    }
    getFirstWorkspacePath() {
     const folders = vscode_1.workspace.workspaceFolders;
     return folders ? folders[0].uri.fsPath : vscode_1.Uri.file("./").fsPath;
    }
   };
   DBTCloudDetection = DBTCloudDetection_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(DBTCloudDetection_1), tslib_1.__metadata("design:paramtypes", [ commandProcessExecution_1.CommandProcessExecutionFactory, pythonEnvironment_1.PythonEnvironment, dbtTerminal_1.DBTTerminal ]) ], DBTCloudDetection), 
   exports.DBTCloudDetection = DBTCloudDetection;
   let DBTCloudProjectDetection = DBTCloudProjectDetection_1 = class {
    constructor(altimate) {
     this.altimate = altimate;
    }
    discoverProjects(projectDirectories) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.altimate.handlePreviewFeatures();
      const packagesInstallPaths = projectDirectories.map((projectDirectory => path.join(projectDirectory.fsPath, "dbt_packages"))), filteredProjectFiles = projectDirectories.filter((uri => !packagesInstallPaths.some((packageInstallPath => uri.fsPath.startsWith(packageInstallPath)))));
      return filteredProjectFiles.length > 20 && vscode_1.window.showWarningMessage(`dbt Power User detected ${filteredProjectFiles.length} projects in your work space, this will negatively affect performance.`), 
      filteredProjectFiles;
     }));
    }
    dispose() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {}));
    }
   };
   DBTCloudProjectDetection = DBTCloudProjectDetection_1 = tslib_1.__decorate([ (0, 
   utils_1.provideSingleton)(DBTCloudProjectDetection_1), tslib_1.__metadata("design:paramtypes", [ altimate_1.AltimateRequest ]) ], DBTCloudProjectDetection), 
   exports.DBTCloudProjectDetection = DBTCloudProjectDetection;
   let DBTCloudProjectIntegration = DBTCloudProjectIntegration_1 = class {
    constructor(executionInfrastructure, dbtCommandFactory, cliDBTCommandExecutionStrategyFactory, telemetry, pythonEnvironment, terminal, validationProvider, deferToProdService, projectRoot) {
     this.executionInfrastructure = executionInfrastructure, this.dbtCommandFactory = dbtCommandFactory, 
     this.cliDBTCommandExecutionStrategyFactory = cliDBTCommandExecutionStrategyFactory, 
     this.telemetry = telemetry, this.pythonEnvironment = pythonEnvironment, this.terminal = terminal, 
     this.validationProvider = validationProvider, this.deferToProdService = deferToProdService, 
     this.projectRoot = projectRoot, this.projectName = "unknown_" + crypto.randomUUID(), 
     this.adapterType = "unknown", this.dbtPath = "dbt", this.disposables = [], this.rebuildManifestDiagnostics = vscode_1.languages.createDiagnosticCollection("dbt"), 
     this.pythonBridgeDiagnostics = vscode_1.languages.createDiagnosticCollection("dbt"), 
     this.pathsInitalized = !1, this.terminal.debug("DBTCloudProjectIntegration", `Registering dbt cloud project at ${this.projectRoot}`), 
     this.python = this.executionInfrastructure.createPythonBridge(this.projectRoot.fsPath), 
     this.executionInfrastructure.createQueue(DBTCloudProjectIntegration_1.QUEUE_ALL), 
     this.disposables.push(this.pythonEnvironment.onPythonEnvironmentChanged((() => {
      this.python = this.executionInfrastructure.createPythonBridge(this.projectRoot.fsPath), 
      this.initializeProject();
     })), this.rebuildManifestDiagnostics, this.pythonBridgeDiagnostics);
    }
    refreshProjectConfig() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.pathsInitalized ? this.initializePaths() : (yield this.initializePaths(), this.pathsInitalized = !0), 
      "unknown" === this.adapterType && (yield this.findAdapterType()), this.version || (yield this.findVersion());
     }));
    }
    executeSQL(query, limit, modelName) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.throwIfNotAuthenticated(), this.throwBridgeErrorIfAvailable();
      const showCommand = this.dbtCloudCommand(new dbtIntegration_1.DBTCommand("Running sql...", [ "show", "--log-level", "debug", "--inline", query, "--limit", limit.toString(), "--output", "json", "--log-format", "json" ])), cancellationTokenSource = new vscode_1.CancellationTokenSource;
      return showCommand.setToken(cancellationTokenSource.token), new dbtIntegration_1.QueryExecution((() => tslib_1.__awaiter(this, void 0, void 0, (function*() {
       cancellationTokenSource.cancel();
      }))), (() => tslib_1.__awaiter(this, void 0, void 0, (function*() {
       const {stdout, stderr} = yield showCommand.execute(cancellationTokenSource.token), exception = this.processJSONErrors(stderr);
       if (exception) throw exception;
       const parsedLines = stdout.trim().split("\n").map((line => JSON.parse(line.trim()))), previewLine = parsedLines.filter((line => line.hasOwnProperty("data") && line.data.hasOwnProperty("preview"))), compiledSqlLines = parsedLines.filter((line => line.hasOwnProperty("data") && line.data.hasOwnProperty("sql")));
       if (0 === previewLine.length) throw new Error("Could not find previewLine in " + stdout);
       const preview = JSON.parse(previewLine[0].data.preview);
       if (0 === compiledSqlLines.length) throw new Error("Could not find compiledSqlLine in " + stdout);
       const compiledSql = compiledSqlLines[compiledSqlLines.length - 1].data.sql;
       return {
        table: {
         column_names: preview.length > 0 ? Object.keys(preview[0]) : [],
         column_types: preview.length > 0 ? Object.keys(preview[0]).map((obj => "string")) : [],
         rows: preview.map((obj => Object.values(obj)))
        },
        compiled_sql: compiledSql,
        raw_sql: query,
        modelName
       };
      }))));
     }));
    }
    initializeProject() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      try {
       yield this.python.ex`from dbt_cloud_integration import *`, yield this.python.ex`from dbt_healthcheck import *`;
      } catch (error) {
       this.terminal.error("dbtCloudIntegration", "Could not initalize Python environemnt", error), 
       vscode_1.window.showErrorMessage("Error occurred while initializing Python environment: " + error);
      }
      this.dbtPath = getDBTPath(this.pythonEnvironment, this.terminal);
     }));
    }
    setSelectedTarget(targetName) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      throw new Error("Method not implemented.");
     }));
    }
    getTargetNames() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      throw new Error("Method not implemented.");
     }));
    }
    getSelectedTarget() {
     throw new Error("Method not implemented.");
    }
    getTargetPath() {
     return this.targetPath;
    }
    getModelPaths() {
     return this.modelPaths;
    }
    getSeedPaths() {
     return this.seedPaths;
    }
    getMacroPaths() {
     return this.macroPaths;
    }
    getPackageInstallPath() {
     return this.packagesInstallPath;
    }
    getAdapterType() {
     return this.adapterType;
    }
    getVersion() {
     return this.version || [ 0, 0, 0 ];
    }
    getProjectName() {
     return this.projectName;
    }
    getPythonBridgeStatus() {
     return this.python.connected;
    }
    getAllDiagnostic() {
     return [ ...this.pythonBridgeDiagnostics.get(this.projectRoot) || [], ...this.rebuildManifestDiagnostics.get(this.projectRoot) || [] ];
    }
    rebuildManifest(retryCount = 0) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.rebuildManifestCancellationTokenSource && (this.rebuildManifestCancellationTokenSource.cancel(), 
      this.rebuildManifestCancellationTokenSource = void 0);
      const command = this.dbtCloudCommand(this.dbtCommandFactory.createParseCommand());
      command.addArgument("--log-format"), command.addArgument("json"), command.downloadArtifacts = !0, 
      this.rebuildManifestCancellationTokenSource = new vscode_1.CancellationTokenSource, 
      command.setToken(this.rebuildManifestCancellationTokenSource.token);
      try {
       const stderr = (yield command.execute()).stderr;
       this.telemetry.sendTelemetryEvent("dbtCloudParseProjectUserError", {
        error: stderr,
        adapter: this.getAdapterType() || "unknown"
       }), this.terminal.info("dbtCloudParseProject", "dbt cloud cli response", !1, {
        command: command.getCommandAsString(),
        stderr
       });
       const errorsAndWarnings = stderr.trim().split("\n").map((line => line.trim())).filter((line => Boolean(line))).map((line => this.parseJSON("RebuildManifestErrorsAndWarningsJSONParsing", line, !1))), errors = errorsAndWarnings.filter((line => line && line.hasOwnProperty("info") && line.info.hasOwnProperty("level") && line.info.hasOwnProperty("msg") && [ "error", "fatal" ].includes(line.info.level))).map((line => line.info.msg)), warnings = errorsAndWarnings.filter((line => line && line.hasOwnProperty("info") && line.info.hasOwnProperty("level") && line.info.hasOwnProperty("msg") && "warn" === line.info.level)).map((line => line.info.msg));
       this.rebuildManifestDiagnostics.clear();
       const diagnostics = errors.map((error => new vscode_1.Diagnostic(new vscode_1.Range(0, 0, 999, 999), error, vscode_1.DiagnosticSeverity.Error))).concat(warnings.map((warning => new vscode_1.Diagnostic(new vscode_1.Range(0, 0, 999, 999), warning, vscode_1.DiagnosticSeverity.Warning))));
       diagnostics && this.rebuildManifestDiagnostics.set(vscode_1.Uri.joinPath(this.projectRoot, dbtProject_1.DBTProject.DBT_PROJECT_FILE), diagnostics);
      } catch (error) {
       this.telemetry.sendTelemetryError("dbtCloudCannotParseProjectCommandExecuteError", error, {
        adapter: this.getAdapterType() || "unknown",
        command: command.getCommandAsString()
       }), this.rebuildManifestDiagnostics.set(vscode_1.Uri.joinPath(this.projectRoot, dbtProject_1.DBTProject.DBT_PROJECT_FILE), [ new vscode_1.Diagnostic(new vscode_1.Range(0, 0, 999, 999), "Unable to parse dbt cloud cli response. If the problem persists please reach out to us: " + error, vscode_1.DiagnosticSeverity.Error) ]);
      }
     }));
    }
    runModel(command) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.addCommandToQueue(DBTCloudProjectIntegration_1.QUEUE_ALL, yield this.addDeferParams(this.dbtCloudCommand(command)));
     }));
    }
    buildModel(command) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.addCommandToQueue(DBTCloudProjectIntegration_1.QUEUE_ALL, yield this.addDeferParams(this.dbtCloudCommand(command)));
     }));
    }
    buildProject(command) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.addCommandToQueue(DBTCloudProjectIntegration_1.QUEUE_ALL, yield this.addDeferParams(this.dbtCloudCommand(command)));
     }));
    }
    runTest(command) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.addCommandToQueue(DBTCloudProjectIntegration_1.QUEUE_ALL, yield this.addDeferParams(this.dbtCloudCommand(command)));
     }));
    }
    runModelTest(command) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.addCommandToQueue(DBTCloudProjectIntegration_1.QUEUE_ALL, yield this.addDeferParams(this.dbtCloudCommand(command)));
     }));
    }
    compileModel(command) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.addCommandToQueue(DBTCloudProjectIntegration_1.QUEUE_ALL, yield this.addDeferParams(this.dbtCloudCommand(command)));
     }));
    }
    generateDocs(command) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.addCommandToQueue(DBTCloudProjectIntegration_1.QUEUE_ALL, this.dbtCloudCommand(command));
     }));
    }
    executeCommandImmediately(command) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      return yield this.dbtCloudCommand(command).execute();
     }));
    }
    deps(command) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      throw new Error("dbt deps is not supported in dbt cloud");
     }));
    }
    debug(command) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      command.args = [ "environment", "show" ];
      const {stdout, stderr} = yield this.dbtCloudCommand(command).execute();
      if (stderr) throw new Error(stderr);
      return stdout;
     }));
    }
    getDeferParams() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.throwIfNotAuthenticated();
      const deferConfig = this.deferToProdService.getDeferConfigByProjectRoot(this.projectRoot.fsPath), {deferToProduction} = deferConfig;
      return deferToProduction ? [] : (this.terminal.debug("Defer to Prod", "defer to prod not enabled"), 
      [ "--no-defer" ]);
     }));
    }
    addDeferParams(command) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      return (yield this.getDeferParams()).forEach((param => command.addArgument(param))), 
      command;
     }));
    }
    dbtCloudCommand(command) {
     command.setExecutionStrategy(this.cliDBTCommandExecutionStrategyFactory(this.projectRoot, this.dbtPath)), 
     command.addArgument("--source"), command.addArgument("dbt-power-user");
     const currentVersion = this.getVersion().map((part => new String(part))).join(".");
     return semver.gte(currentVersion, "0.37.20") && command.downloadArtifacts && command.addArgument("--download-artifacts"), 
     command;
    }
    addCommandToQueue(queueName, command) {
     try {
      this.throwIfNotAuthenticated(), this.executionInfrastructure.addCommandToQueue(queueName, command);
     } catch (e) {
      vscode_1.window.showErrorMessage(e.message);
     }
    }
    unsafeCompileNode(modelName) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.throwIfNotAuthenticated(), this.throwBridgeErrorIfAvailable();
      const compileQueryCommand = this.dbtCloudCommand(new dbtIntegration_1.DBTCommand("Compiling model...", [ "compile", "--model", modelName, "--output", "json", "--log-format", "json" ])), {stdout, stderr} = yield compileQueryCommand.execute(), compiledLine = stdout.trim().split("\n").map((line => JSON.parse(line.trim()))).filter((line => line.data.hasOwnProperty("compiled"))), exception = this.processJSONErrors(stderr);
      if (exception) throw exception;
      return compiledLine[0].data.compiled;
     }));
    }
    unsafeCompileQuery(query) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.throwIfNotAuthenticated(), this.throwBridgeErrorIfAvailable();
      const compileQueryCommand = this.dbtCloudCommand(new dbtIntegration_1.DBTCommand("Compiling sql...", [ "compile", "--inline", query, "--output", "json", "--log-format", "json" ])), {stdout, stderr} = yield compileQueryCommand.execute(), compiledLine = stdout.trim().split("\n").map((line => JSON.parse(line.trim()))).filter((line => line.data.hasOwnProperty("compiled"))), exception = this.processJSONErrors(stderr);
      if (exception) throw exception;
      return compiledLine[0].data.compiled;
     }));
    }
    validateSql(query, dialect, models) {
     var _a;
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.throwIfNotAuthenticated(), this.throwBridgeErrorIfAvailable();
      return yield null === (_a = this.python) || void 0 === _a ? void 0 : _a.lock((python => python`to_dict(validate_sql(${query}, ${dialect}, ${models}))`));
     }));
    }
    validateSQLDryRun(query) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.throwIfNotAuthenticated(), this.throwBridgeErrorIfAvailable();
      const validateSqlCommand = this.dbtCloudCommand(new dbtIntegration_1.DBTCommand("Estimating BigQuery cost...", [ "compile", "--inline", `{{ validate_sql('${query}') }}`, "--output", "json", "--log-format", "json" ])), {stdout, stderr} = yield validateSqlCommand.execute(), compiledLine = stdout.trim().split("\n").map((line => JSON.parse(line.trim()))).filter((line => line.data.hasOwnProperty("compiled"))), exception = this.processJSONErrors(stderr);
      if (exception) throw exception;
      return JSON.parse(compiledLine[0].data.compiled);
     }));
    }
    getColumnsOfSource(sourceName, tableName) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.throwIfNotAuthenticated(), this.throwBridgeErrorIfAvailable();
      const compileQueryCommand = this.dbtCloudCommand(new dbtIntegration_1.DBTCommand("Getting columns of source...", [ "compile", "--inline", `{% set output = [] %}{% for result in adapter.get_columns_in_relation(source('${sourceName}', '${tableName}')) %} {% do output.append({"column": result.name, "dtype": result.dtype}) %} {% endfor %} {{ tojson(output) }}`, "--output", "json", "--log-format", "json" ])), {stdout, stderr} = yield compileQueryCommand.execute(), compiledLine = stdout.trim().split("\n").map((line => JSON.parse(line.trim()))).filter((line => line.data.hasOwnProperty("compiled"))), exception = this.processJSONErrors(stderr);
      if (exception) throw exception;
      return JSON.parse(compiledLine[0].data.compiled);
     }));
    }
    getColumnsOfModel(modelName) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.throwIfNotAuthenticated(), this.throwBridgeErrorIfAvailable();
      const compileQueryCommand = this.dbtCloudCommand(new dbtIntegration_1.DBTCommand("Getting columns of model...", [ "compile", "--inline", `{% set output = [] %}{% for result in adapter.get_columns_in_relation(ref('${modelName}')) %} {% do output.append({"column": result.name, "dtype": result.dtype}) %} {% endfor %} {{ tojson(output) }}`, "--output", "json", "--log-format", "json" ])), {stdout, stderr} = yield compileQueryCommand.execute(), compiledLine = stdout.trim().split("\n").map((line => JSON.parse(line.trim()))).filter((line => line.data.hasOwnProperty("compiled"))), exception = this.processJSONErrors(stderr);
      if (exception) throw exception;
      return JSON.parse(compiledLine[0].data.compiled);
     }));
    }
    validateWhetherSqlHasColumns(sql, dialect) {
     var _a;
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      return this.throwBridgeErrorIfAvailable(), null === (_a = this.python) || void 0 === _a ? void 0 : _a.lock((python => python`to_dict(validate_whether_sql_has_columns(${sql}, ${dialect}))`));
     }));
    }
    fetchSqlglotSchema(sql, dialect) {
     var _a;
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      return this.throwBridgeErrorIfAvailable(), null === (_a = this.python) || void 0 === _a ? void 0 : _a.lock((python => python`to_dict(fetch_schema_from_sql(${sql}, ${dialect}))`));
     }));
    }
    getBulkCompiledSQL(models) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const currentVersion = this.getVersion().map((part => new String(part))).join(".");
      if (semver.gte(currentVersion, "0.37.20")) {
       const compileQueryCommand = this.dbtCloudCommand(new dbtIntegration_1.DBTCommand("Getting catalog...", [ "compile", "--download-artifacts", "--model", `"${models.map((item => item.name)).join(" ")}"`, "--output", "json", "--log-format", "json" ])), {stderr} = yield compileQueryCommand.execute((new vscode_1.CancellationTokenSource).token), exception = this.processJSONErrors(stderr);
       if (exception) throw exception;
      }
      const result = {};
      for (const node of models) {
       try {
        const query = (yield vscode_1.workspace.fs.readFile(vscode_1.Uri.file(node.compiled_path))).toString();
        result[node.uniqueId] = query;
        continue;
       } catch (e) {
        this.terminal.error("getBulkCompiledSQL", `Unable to find compiled sql file for model ${node.uniqueId}`, e, !0);
       }
       try {
        result[node.uniqueId] = yield this.unsafeCompileNode(node.name);
       } catch (e) {
        this.terminal.error("getBulkCompiledSQL", `Unable to compile sql for model ${node.uniqueId}`, e, !0);
       }
      }
      return result;
     }));
    }
    getBulkSchemaFromDB(nodes, cancellationToken) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      if (0 === nodes.length) return {};
      this.throwIfNotAuthenticated(), this.throwBridgeErrorIfAvailable();
      const bulkModelQuery = `\n{% set result = {} %}\n{% for n in ${JSON.stringify(nodes)} %}\n  {% set columns = adapter.get_columns_in_relation(ref(n["name"])) %}\n  {% set new_columns = [] %}\n  {% for column in columns %}\n    {% do new_columns.append({"column": column.name, "dtype": column.dtype}) %}\n  {% endfor %}\n  {% do result.update({n["unique_id"]:new_columns}) %}\n{% endfor %}\n{% for n in graph.sources.values() %}\n  {% set columns = adapter.get_columns_in_relation(source(n["source_name"], n["identifier"])) %}\n  {% set new_columns = [] %}\n  {% for column in columns %}\n    {% do new_columns.append({"column": column.name, "dtype": column.dtype}) %}\n  {% endfor %}\n  {% do result.update({n["unique_id"]:new_columns}) %}\n{% endfor %}\n{{ tojson(result) }}`;
      console.log(bulkModelQuery);
      const compileQueryCommand = this.dbtCloudCommand(new dbtIntegration_1.DBTCommand("Getting catalog...", [ "compile", "--inline", bulkModelQuery.trim().split("\n").join(""), "--output", "json", "--log-format", "json" ])), {stdout, stderr} = yield compileQueryCommand.execute(cancellationToken), compiledLine = stdout.trim().split("\n").map((line => JSON.parse(line.trim()))).filter((line => line.data.hasOwnProperty("compiled"))), exception = this.processJSONErrors(stderr);
      if (exception) throw exception;
      return JSON.parse(compiledLine[0].data.compiled);
     }));
    }
    getCatalog() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.throwIfNotAuthenticated(), this.throwBridgeErrorIfAvailable();
      const bulkModelQuery = '\n{% set result = [] %}\n{% for n in graph.nodes.values() %}\n  {% if n.resource_type == "test" or \n  n.resource_type == "analysis" or \n  n.resource_type == "sql_operation" or \n  n.config.materialized == "ephemeral" %}\n    {% continue %}\n  {% endif %}\n  {% set columns = adapter.get_columns_in_relation(ref(n["name"])) %}\n  {% for column in columns %}\n    {% do result.append({\n      "table_database": n.database,\n      "table_schema": n.schema,\n      "table_name": n.name,\n      "column_name": column.name,\n      "column_type": column.dtype,\n    }) %}\n  {% endfor %}\n{% endfor %}\n{% for n in graph.sources.values() %}\n  {% set columns = adapter.get_columns_in_relation(source(n["source_name"], n["identifier"])) %}\n  {% for column in columns %}\n    {% do result.append({\n      "table_database": n.database,\n      "table_schema": n.schema,\n      "table_name": n.name,\n      "column_name": column.name,\n      "column_type": column.dtype,\n    }) %}\n  {% endfor %}\n{% endfor %}\n{{ tojson(result) }}', compileQueryCommand = this.dbtCloudCommand(new dbtIntegration_1.DBTCommand("Getting catalog...", [ "compile", "--inline", bulkModelQuery.trim().split("\n").join(""), "--output", "json", "--log-format", "json" ])), {stdout, stderr} = yield compileQueryCommand.execute(), compiledLine = stdout.trim().split("\n").map((line => JSON.parse(line.trim()))).filter((line => line.data.hasOwnProperty("compiled"))), exception = this.processJSONErrors(stderr);
      if (exception) throw exception;
      return JSON.parse(compiledLine[0].data.compiled);
     }));
    }
    getDebounceForRebuildManifest() {
     return 500;
    }
    initializePaths() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const packagePathsCommand = this.dbtCloudCommand(new dbtIntegration_1.DBTCommand("Getting paths...", [ "environment", "show", "--project-paths" ]));
      try {
       const {stdout, stderr} = yield packagePathsCommand.execute();
       stderr && this.terminal.warn("DbtCloudIntegrationInitializePathsStdError", "packaging paths command returns warning, ignoring", !0, stderr);
       const lookupEntries = lookupString => {
        const matches = new RegExp(`${lookupString}\\s*\\[(.*)\\]`, "gm").exec(stdout);
        if (2 === (null == matches ? void 0 : matches.length)) return matches[1].split(",").map((m => m.slice(1, -1)));
        throw new Error(`Could not find any entries for ${lookupString}`);
       };
       this.targetPath = (0, path_1.join)(this.projectRoot.fsPath, "target"), this.modelPaths = lookupEntries("Model paths").map((p => (0, 
       path_1.join)(this.projectRoot.fsPath, p))), this.seedPaths = lookupEntries("Seed paths").map((p => (0, 
       path_1.join)(this.projectRoot.fsPath, p))), this.macroPaths = lookupEntries("Macro paths").map((p => (0, 
       path_1.join)(this.projectRoot.fsPath, p))), this.packagesInstallPath = (0, path_1.join)(this.projectRoot.fsPath, "dbt_packages");
      } catch (error) {
       this.terminal.warn("DbtCloudIntegrationInitializePathsExceptionError", "dbt environment show not returning required info, ignoring", !0, error), 
       this.targetPath = (0, path_1.join)(this.projectRoot.fsPath, "target"), this.modelPaths = [ (0, 
       path_1.join)(this.projectRoot.fsPath, "models") ], this.seedPaths = [ (0, path_1.join)(this.projectRoot.fsPath, "seeds") ], 
       this.macroPaths = [ (0, path_1.join)(this.projectRoot.fsPath, "macros") ], this.packagesInstallPath = (0, 
       path_1.join)(this.projectRoot.fsPath, "dbt_packages");
      }
      try {
       const projectConfig = dbtProject_1.DBTProject.readAndParseProjectConfig(this.projectRoot);
       this.projectName = projectConfig.name;
      } catch (error) {
       this.terminal.warn("DbtCloudIntegrationProjectNameFromConfigExceptionError", "project name could not be read from dbt_project.yml, ignoring", !0, error);
      }
     }));
    }
    findAdapterType() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const adapterTypeCommand = this.dbtCloudCommand(new dbtIntegration_1.DBTCommand("Getting adapter type...", [ "compile", "--inline", "{{ adapter.type() }}", "--output", "json", "--log-format", "json" ]));
      try {
       const {stdout, stderr} = yield adapterTypeCommand.execute();
       stderr && this.terminal.warn("DbtCloudIntegrationAdapterDetectionStdError", "adapter type returns stderr, ignoring", !0, stderr);
       const compiledLine = stdout.trim().split("\n").map((line => JSON.parse(line.trim()))).filter((line => line.data.hasOwnProperty("compiled")));
       this.adapterType = compiledLine[0].data.compiled, this.terminal.debug("dbtCloudIntegration", `Set adapter type to ${this.adapterType}`);
      } catch (error) {
       this.terminal.warn("DbtCloudIntegrationAdapterDetectionExceptionError", "adapter type throws error, ignoring", !0, error);
      }
     }));
    }
    findVersion() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      try {
       const versionCommand = this.dbtCloudCommand(new dbtIntegration_1.DBTCommand("Getting version...", [ "--version" ])), {stdout} = yield versionCommand.execute();
       if (stdout.includes("dbt Cloud CLI")) {
        const matches = /dbt Cloud CLI - (\d*\.\d*\.\d*)/gm.exec(stdout);
        2 === (null == matches ? void 0 : matches.length) ? this.version = matches[1].split(".").map((part => parseInt(part))) : this.terminal.debug("DBTCLIDetectionFailed", "dbt cloud cli was not found. Detection command returned :  " + stdout);
       }
      } catch (error) {
       this.terminal.warn("findVersion", "Version lookup failed with error : " + error.message);
      }
     }));
    }
    processJSONErrors(jsonErrors) {
     if (jsonErrors) try {
      const errorLines = [];
      if (errorLines.push.apply(errorLines, jsonErrors.trim().split("\n").map((line => JSON.parse(line.trim()))).filter((line => "error" === line.info.level || "fatal" === line.info.level)).map((line => line.info.msg))), 
      errorLines.length) return new Error(errorLines.join(", "));
     } catch (error) {
      return new Error("Could not process " + jsonErrors + ": " + error);
     }
    }
    throwIfNotAuthenticated() {
     this.validationProvider.throwIfNotAuthenticated();
    }
    dispose() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      try {
       yield this.executionInfrastructure.closePythonBridge(this.python);
      } catch (error) {}
      for (this.rebuildManifestDiagnostics.clear(), this.pythonBridgeDiagnostics.clear(); this.disposables.length; ) {
       const x = this.disposables.pop();
       x && x.dispose();
      }
     }));
    }
    findPackageVersion(_packageName) {}
    throwBridgeErrorIfAvailable() {
     const allDiagnostics = [ this.pythonBridgeDiagnostics, this.rebuildManifestDiagnostics ];
     for (const diagnosticCollection of allDiagnostics) for (const [_, diagnostics] of diagnosticCollection) {
      const error = diagnostics.find((diagnostic => diagnostic.severity === vscode_1.DiagnosticSeverity.Error));
      if (error) throw new Error(error.message);
     }
    }
    performDatapilotHealthcheck({manifestPath, catalogPath, config, configPath}) {
     var _a;
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.throwBridgeErrorIfAvailable();
      return yield null === (_a = this.python) || void 0 === _a ? void 0 : _a.lock((python => python`to_dict(project_healthcheck(${manifestPath}, ${catalogPath}, ${configPath}, ${config}))`));
     }));
    }
    applyDeferConfig() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {}));
    }
    applySelectedTarget() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {}));
    }
    throwDiagnosticsErrorIfAvailable() {
     this.throwBridgeErrorIfAvailable();
    }
    parseJSON(contextName, json, throw_ = !0) {
     try {
      return JSON.parse(json);
     } catch (error) {
      if (this.terminal.error("dbtCloud" + contextName + "Error", "An error occured while parsing following json: " + json, error), 
      throw_) throw error;
     }
    }
   };
   DBTCloudProjectIntegration.QUEUE_ALL = "all", DBTCloudProjectIntegration = DBTCloudProjectIntegration_1 = tslib_1.__decorate([ (0, 
   utils_1.provideSingleton)(DBTCloudProjectIntegration_1), tslib_1.__metadata("design:paramtypes", [ dbtIntegration_1.DBTCommandExecutionInfrastructure, dbtIntegration_1.DBTCommandFactory, Function, telemetry_1.TelemetryService, pythonEnvironment_1.PythonEnvironment, dbtTerminal_1.DBTTerminal, validation_provider_1.ValidationProvider, deferToProdService_1.DeferToProdService, vscode_1.Uri ]) ], DBTCloudProjectIntegration), 
   exports.DBTCloudProjectIntegration = DBTCloudProjectIntegration;
  },
  71636: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var DBTCoreDetection_1, DBTCoreProjectDetection_1, DBTCoreProjectIntegration_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.DBTCoreProjectIntegration = exports.DBTCoreProjectDetection = exports.DBTCoreDetection = void 0;
   const tslib_1 = __webpack_require__(31635), vscode_1 = __webpack_require__(54980), utils_1 = __webpack_require__(86185), dbtIntegration_1 = __webpack_require__(22373), pythonEnvironment_1 = __webpack_require__(88103), commandProcessExecution_1 = __webpack_require__(7824), python_bridge_1 = __webpack_require__(63283), path = __webpack_require__(16928), dbtProject_1 = __webpack_require__(38821), fs_1 = __webpack_require__(79896), yaml_1 = __webpack_require__(91198), telemetry_1 = __webpack_require__(22644), altimate_1 = __webpack_require__(91741), dbtProjectContainer_1 = __webpack_require__(82018), constants_1 = __webpack_require__(96921), dbtTerminal_1 = __webpack_require__(83683), validation_provider_1 = __webpack_require__(79262), deferToProdService_1 = __webpack_require__(2826), crypto = __webpack_require__(76982), DEFAULT_QUERY_TEMPLATE = "select * from ({query}) as query limit {limit}";
   let DBTCoreDetection = DBTCoreDetection_1 = class {
    constructor(pythonEnvironment, commandProcessExecutionFactory) {
     this.pythonEnvironment = pythonEnvironment, this.commandProcessExecutionFactory = commandProcessExecutionFactory;
    }
    detectDBT() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      try {
       const checkDBTInstalledProcess = this.commandProcessExecutionFactory.createCommandProcessExecution({
        command: this.pythonEnvironment.pythonPath,
        args: [ "-c", "import dbt" ],
        cwd: (0, utils_1.getFirstWorkspacePath)(),
        envVars: this.pythonEnvironment.environmentVariables
       }), {stderr} = yield checkDBTInstalledProcess.complete();
       if (stderr) throw new Error(stderr);
       return !0;
      } catch (error) {
       return !1;
      }
     }));
    }
   };
   DBTCoreDetection = DBTCoreDetection_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(DBTCoreDetection_1), tslib_1.__metadata("design:paramtypes", [ pythonEnvironment_1.PythonEnvironment, commandProcessExecution_1.CommandProcessExecutionFactory ]) ], DBTCoreDetection), 
   exports.DBTCoreDetection = DBTCoreDetection;
   let DBTCoreProjectDetection = DBTCoreProjectDetection_1 = class {
    constructor(executionInfrastructure, dbtTerminal) {
     this.executionInfrastructure = executionInfrastructure, this.dbtTerminal = dbtTerminal;
    }
    getPackageInstallPathFallback(projectDirectory, packageInstallPath) {
     const dbtProjectFile = path.join(projectDirectory.fsPath, "dbt_project.yml");
     if ((0, fs_1.existsSync)(dbtProjectFile)) {
      const packagesInstallPath = (0, yaml_1.parse)((0, fs_1.readFileSync)(dbtProjectFile, "utf8"))["packages-install-path"];
      if (packagesInstallPath) return path.isAbsolute(packagesInstallPath) ? packagesInstallPath : path.join(projectDirectory.fsPath, packagesInstallPath);
     }
     return packageInstallPath;
    }
    discoverProjects(projectDirectories) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      let python, packagesInstallPaths = projectDirectories.map((projectDirectory => path.join(projectDirectory.fsPath, "dbt_packages")));
      try {
       python = this.executionInfrastructure.createPythonBridge((0, utils_1.getFirstWorkspacePath)()), 
       yield python.ex`from dbt_core_integration import *`;
       const packagesInstallPathsFromPython = yield python.lock((python => python`to_dict(find_package_paths(${projectDirectories.map((projectDirectory => projectDirectory.fsPath))}))`));
       packagesInstallPaths = packagesInstallPaths.map(((packageInstallPath, index) => {
        const packageInstallPathFromPython = packagesInstallPathsFromPython[index];
        return packageInstallPathFromPython ? vscode_1.Uri.file(packageInstallPathFromPython).fsPath : packageInstallPath;
       }));
      } catch (error) {
       this.dbtTerminal.debug("dbtCoreIntegration:discoverProjects", "An error occured while finding package paths: " + error), 
       packagesInstallPaths = projectDirectories.map(((projectDirectory, idx) => this.getPackageInstallPathFallback(projectDirectory, packagesInstallPaths[idx])));
      } finally {
       python && this.executionInfrastructure.closePythonBridge(python);
      }
      const filteredProjectFiles = projectDirectories.filter((uri => !packagesInstallPaths.some((packageInstallPath => uri.fsPath.startsWith(packageInstallPath)))));
      return filteredProjectFiles.length > 20 && vscode_1.window.showWarningMessage(`dbt Power User detected ${filteredProjectFiles.length} projects in your work space, this will negatively affect performance.`), 
      filteredProjectFiles;
     }));
    }
    dispose() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {}));
    }
   };
   DBTCoreProjectDetection = DBTCoreProjectDetection_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(DBTCoreProjectDetection_1), tslib_1.__metadata("design:paramtypes", [ dbtIntegration_1.DBTCommandExecutionInfrastructure, dbtTerminal_1.DBTTerminal ]) ], DBTCoreProjectDetection), 
   exports.DBTCoreProjectDetection = DBTCoreProjectDetection;
   let DBTCoreProjectIntegration = DBTCoreProjectIntegration_1 = class {
    constructor(executionInfrastructure, pythonEnvironment, telemetry, pythonDBTCommandExecutionStrategy, dbtProjectContainer, altimateRequest, dbtTerminal, validationProvider, deferToProdService, projectRoot, projectConfigDiagnostics) {
     this.executionInfrastructure = executionInfrastructure, this.pythonEnvironment = pythonEnvironment, 
     this.telemetry = telemetry, this.pythonDBTCommandExecutionStrategy = pythonDBTCommandExecutionStrategy, 
     this.dbtProjectContainer = dbtProjectContainer, this.altimateRequest = altimateRequest, 
     this.dbtTerminal = dbtTerminal, this.validationProvider = validationProvider, this.deferToProdService = deferToProdService, 
     this.projectRoot = projectRoot, this.projectConfigDiagnostics = projectConfigDiagnostics, 
     this.projectName = "unknown_" + crypto.randomUUID(), this.disposables = [], this.rebuildManifestDiagnostics = vscode_1.languages.createDiagnosticCollection("dbt"), 
     this.pythonBridgeDiagnostics = vscode_1.languages.createDiagnosticCollection("dbt"), 
     this.dbtTerminal.debug("DBTCoreProjectIntegration", `Registering dbt core project at ${this.projectRoot}`), 
     this.python = this.executionInfrastructure.createPythonBridge(this.projectRoot.fsPath), 
     this.executionInfrastructure.createQueue(DBTCoreProjectIntegration_1.QUEUE_ALL), 
     this.disposables.push(this.pythonEnvironment.onPythonEnvironmentChanged((() => {
      this.python = this.executionInfrastructure.createPythonBridge(this.projectRoot.fsPath);
     })), this.rebuildManifestDiagnostics, this.pythonBridgeDiagnostics), this.isDbtLoomInstalled().then((isInstalled => {
      this.telemetry.setTelemetryCustomAttribute("dbtLoomInstalled", `${isInstalled}`);
     }));
    }
    isDbtLoomInstalled() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      try {
       return yield this.python.ex`from dbt_loom import *`, !0;
      } catch (error) {
       return !1;
      }
     }));
    }
    removeTrailingSlashes(input) {
     return null == input ? void 0 : input.replace(/\\+$/, "");
    }
    getLimitQuery(queryTemplate, query, limit) {
     return queryTemplate.replace("{query}", (() => query)).replace("{limit}", (() => limit.toString()));
    }
    getQuery(query, limit) {
     var _a;
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      try {
       const dbtVersion = yield this.version;
       if (dbtVersion && dbtVersion[0] >= 1 && dbtVersion[1] >= 5) {
        const args = {
         compiled_code: query,
         limit
        }, queryTemplateFromMacro = yield null === (_a = this.python) || void 0 === _a ? void 0 : _a.lock((python => python`to_dict(project.execute_macro('get_show_sql', ${args}, ${query}))`));
        return this.dbtTerminal.debug("DBTCoreProjectIntegration", "Using query template from macro", queryTemplateFromMacro), 
        {
         queryTemplate: queryTemplateFromMacro,
         limitQuery: queryTemplateFromMacro
        };
       }
      } catch (err) {
       console.error("Error while getting get_show_sql macro", err), this.telemetry.sendTelemetryError("executeMacroGetLimitSubquerySQLError", err, {
        adapter: this.adapterType || "unknown"
       });
      }
      const queryTemplate = vscode_1.workspace.getConfiguration("dbt").get("queryTemplate");
      if (queryTemplate && queryTemplate !== DEFAULT_QUERY_TEMPLATE) {
       console.log("Using user provided query template", queryTemplate);
       return {
        queryTemplate,
        limitQuery: this.getLimitQuery(queryTemplate, query, limit)
       };
      }
      return {
       queryTemplate: DEFAULT_QUERY_TEMPLATE,
       limitQuery: this.getLimitQuery(DEFAULT_QUERY_TEMPLATE, query, limit)
      };
     }));
    }
    refreshProjectConfig() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      yield this.createPythonDbtProject(this.python), yield this.python.ex`project.init_project()`, 
      this.targetName = yield this.findSelectedTarget(), this.targetPath = yield this.findTargetPath(), 
      this.modelPaths = yield this.findModelPaths(), this.seedPaths = yield this.findSeedPaths(), 
      this.macroPaths = yield this.findMacroPaths(), this.packagesInstallPath = yield this.findPackagesInstallPath(), 
      this.version = yield this.findVersion(), this.projectName = yield this.findProjectName(), 
      this.adapterType = yield this.findAdapterType();
     }));
    }
    findSelectedTarget() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      return yield this.python.lock((python => python`to_dict(project.config.target_name)`));
     }));
    }
    setSelectedTarget(targetName) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      yield this.python.lock((python => python`project.set_selected_target(${targetName})`)), 
      yield this.refreshProjectConfig();
     }));
    }
    getTargetNames() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      return yield this.python.lock((python => python`to_dict(project.get_target_names())`));
     }));
    }
    executeSQL(query, limit, modelName) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.throwBridgeErrorIfAvailable();
      const {limitQuery} = yield this.getQuery(query, limit), queryThread = this.executionInfrastructure.createPythonBridge(this.projectRoot.fsPath);
      return new dbtIntegration_1.QueryExecution((() => tslib_1.__awaiter(this, void 0, void 0, (function*() {
       queryThread.kill(2);
      }))), (() => tslib_1.__awaiter(this, void 0, void 0, (function*() {
       let result;
       yield this.createPythonDbtProject(queryThread), yield queryThread.ex`project.init_project()`;
       const compiledQuery = yield this.unsafeCompileQuery(limitQuery, modelName);
       try {
        result = yield queryThread.lock((python => python`to_dict(project.execute_sql(${compiledQuery}))`));
        const {manifestPathType} = this.deferToProdService.getDeferConfigByProjectRoot(this.projectRoot.fsPath);
        manifestPathType === constants_1.ManifestPathType.REMOTE && this.altimateRequest.sendDeferToProdEvent(constants_1.ManifestPathType.REMOTE);
       } catch (err) {
        const message = `Error while executing sql: ${compiledQuery}`;
        if (this.dbtTerminal.error("dbtCore:executeSQL", message, err), err instanceof python_bridge_1.PythonException) throw new dbtIntegration_1.ExecuteSQLError(err.exception.message, compiledQuery);
        throw new dbtIntegration_1.ExecuteSQLError(err.message, compiledQuery);
       } finally {
        yield queryThread.end();
       }
       return Object.assign(Object.assign({}, result), {
        compiled_stmt: compiledQuery,
        modelName
       });
      }))));
     }));
    }
    createPythonDbtProject(bridge) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      yield bridge.ex`from dbt_core_integration import *`;
      const targetPath = this.removeTrailingSlashes(yield bridge.lock((python => python`target_path(${this.projectRoot.fsPath})`))), {deferToProduction, manifestPath, favorState} = yield this.getDeferConfig();
      yield bridge.ex`project = DbtProject(project_dir=${this.projectRoot.fsPath}, profiles_dir=${this.profilesDir}, target_path=${targetPath}, defer_to_prod=${deferToProduction}, manifest_path=${manifestPath}, favor_state=${favorState}) if 'project' not in locals() else project`;
     }));
    }
    initializeProject() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      try {
       if (yield this.python.ex`from dbt_core_integration import default_profiles_dir`, 
       yield this.python.ex`from dbt_healthcheck import *`, this.profilesDir = this.removeTrailingSlashes(yield this.python.lock((python => python`default_profiles_dir(${this.projectRoot.fsPath})`))), 
       this.profilesDir) {
        const dbtProfileWatcher = vscode_1.workspace.createFileSystemWatcher(new vscode_1.RelativePattern(this.profilesDir, DBTCoreProjectIntegration_1.DBT_PROFILES_FILE));
        this.disposables.push(dbtProfileWatcher, ...(0, utils_1.setupWatcherHandler)(dbtProfileWatcher, (() => this.rebuildManifest())));
       }
       yield this.createPythonDbtProject(this.python), this.pythonBridgeDiagnostics.clear();
      } catch (exc) {
       if (exc instanceof python_bridge_1.PythonException) {
        if (exc.message.includes("No module named 'dbt'")) return;
        let errorMessage = "An error occured while initializing the dbt project: " + exc.exception.message;
        "dbt.exceptions" === exc.exception.type.module && (errorMessage = "An error occured while initializing the dbt project, dbt found following issue: " + exc.exception.message), 
        this.pythonBridgeDiagnostics.set(vscode_1.Uri.joinPath(this.projectRoot, dbtProject_1.DBTProject.DBT_PROJECT_FILE), [ new vscode_1.Diagnostic(new vscode_1.Range(0, 0, 999, 999), errorMessage) ]), 
        this.telemetry.sendTelemetryError("pythonBridgeInitPythonError", exc);
       } else vscode_1.window.showErrorMessage((0, utils_1.extendErrorWithSupportLinks)("An unexpected error occured while initializing the dbt project at " + this.projectRoot + ": " + exc + ".")), 
       this.telemetry.sendTelemetryError("pythonBridgeInitError", exc);
      }
     }));
    }
    getSelectedTarget() {
     return this.targetName;
    }
    getTargetPath() {
     return this.targetPath;
    }
    getModelPaths() {
     return this.modelPaths;
    }
    getSeedPaths() {
     return this.seedPaths;
    }
    getMacroPaths() {
     return this.macroPaths;
    }
    getPackageInstallPath() {
     return this.packagesInstallPath;
    }
    getAdapterType() {
     return this.adapterType;
    }
    getVersion() {
     return this.version;
    }
    getProjectName() {
     return this.projectName;
    }
    findAdapterType() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      return this.python.lock((python => python`project.config.credentials.type`));
     }));
    }
    getPythonBridgeStatus() {
     return this.python.connected;
    }
    getAllDiagnostic() {
     const projectURI = vscode_1.Uri.joinPath(this.projectRoot, dbtProject_1.DBTProject.DBT_PROJECT_FILE);
     return [ ...this.pythonBridgeDiagnostics.get(projectURI) || [], ...this.projectConfigDiagnostics.get(projectURI) || [], ...this.rebuildManifestDiagnostics.get(projectURI) || [] ];
    }
    rebuildManifest() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const errors = this.projectConfigDiagnostics.get(vscode_1.Uri.joinPath(this.projectRoot, dbtProject_1.DBTProject.DBT_PROJECT_FILE));
      if (!(void 0 !== errors && errors.length > 0)) try {
       yield this.python.lock((python => python`to_dict(project.safe_parse_project())`)), 
       this.rebuildManifestDiagnostics.clear();
      } catch (exc) {
       if (exc instanceof python_bridge_1.PythonException) return this.rebuildManifestDiagnostics.set(vscode_1.Uri.joinPath(this.projectRoot, dbtProject_1.DBTProject.DBT_PROJECT_FILE), [ new vscode_1.Diagnostic(new vscode_1.Range(0, 0, 999, 999), "There is a problem in your dbt project. Compilation failed: " + exc.exception.message) ]), 
       void this.telemetry.sendTelemetryEvent("pythonBridgeCannotParseProjectUserError", {
        error: exc.exception.message,
        adapter: this.getAdapterType() || "unknown"
       });
       this.telemetry.sendTelemetryError("pythonBridgeCannotParseProjectUnknownError", exc, {
        adapter: this.adapterType || "unknown"
       }), vscode_1.window.showErrorMessage((0, utils_1.extendErrorWithSupportLinks)("An error occured while rebuilding the dbt manifest: " + exc + "."));
      }
     }));
    }
    runModel(command) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.addCommandToQueue(yield this.addDeferParams(this.dbtCoreCommand(command)));
     }));
    }
    buildModel(command) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.addCommandToQueue(yield this.addDeferParams(this.dbtCoreCommand(command)));
     }));
    }
    buildProject(command) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.addCommandToQueue(yield this.addDeferParams(this.dbtCoreCommand(command)));
     }));
    }
    runTest(command) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.addCommandToQueue(yield this.addDeferParams(this.dbtCoreCommand(command)));
     }));
    }
    runModelTest(command) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.addCommandToQueue(yield this.addDeferParams(this.dbtCoreCommand(command)));
     }));
    }
    compileModel(command) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.addCommandToQueue(yield this.addDeferParams(this.dbtCoreCommand(command)));
     }));
    }
    generateDocs(command) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.addCommandToQueue(this.dbtCoreCommand(command));
     }));
    }
    executeCommandImmediately(command) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      return yield this.dbtCoreCommand(command).execute();
     }));
    }
    deps(command) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const {stdout, stderr} = yield this.dbtCoreCommand(command).execute();
      if (stderr) throw new Error(stderr);
      return stdout;
     }));
    }
    debug(command) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const {stdout, stderr} = yield this.dbtCoreCommand(command).execute();
      if (stderr) throw new Error(stderr);
      return stdout;
     }));
    }
    addCommandToQueue(command) {
     this.dbtProjectContainer.showErrorIfDbtOrPythonNotInstalled() && this.executionInfrastructure.addCommandToQueue(DBTCoreProjectIntegration_1.QUEUE_ALL, command);
    }
    getDeferManifestPath(manifestPathType, manifestPathForDeferral, dbtCoreIntegrationId) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      if (!manifestPathType) {
       throw new Error("Please configure defer to production functionality by specifying manifest path in Actions panel before using it.");
      }
      if (manifestPathType === constants_1.ManifestPathType.LOCAL) {
       if (!manifestPathForDeferral) {
        const configNotPresent = new Error("manifestPathForDeferral config is not present, use the actions panel to set the Defer to production configuration.");
        throw this.dbtTerminal.error("manifestPathForDeferral", "manifestPathForDeferral is not present", configNotPresent), 
        configNotPresent;
       }
       return manifestPathForDeferral;
      }
      if (manifestPathType === constants_1.ManifestPathType.REMOTE) {
       try {
        this.validationProvider.throwIfNotAuthenticated();
       } catch (err) {
        throw new Error("Defer to production is currently enabled with 'DataPilot dbt integration' mode. It requires a valid Altimate AI API key and instance name in the settings. In order to run dbt commands, please either switch to Local Path mode or disable the feature or add an API key / instance name.");
       }
       this.dbtTerminal.debug("remoteManifest", `fetching artifact url for dbtCoreIntegrationId: ${dbtCoreIntegrationId}`);
       try {
        const response = yield this.altimateRequest.fetchArtifactUrl("manifest", dbtCoreIntegrationId), manifestPath = yield this.altimateRequest.downloadFileLocally(response.url, this.projectRoot);
        return console.log(`Set remote manifest path: ${manifestPath}`), manifestPath;
       } catch (error) {
        if (error instanceof altimate_1.NotFoundError) {
         const manifestNotFoundError = new Error("Unable to download remote manifest file. Did you upload your manifest using the Altimate DataPilot CLI?");
         throw this.dbtTerminal.error("remoteManifestError", "Unable to download remote manifest file.", manifestNotFoundError), 
         manifestNotFoundError;
        }
        throw error;
       }
      }
      throw new Error(`Invalid manifestPathType: ${manifestPathType}`);
     }));
    }
    getDeferParams() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const deferConfig = this.deferToProdService.getDeferConfigByProjectRoot(this.projectRoot.fsPath), {deferToProduction, manifestPathForDeferral, favorState, manifestPathType, dbtCoreIntegrationId} = deferConfig;
      if (!deferToProduction) return this.dbtTerminal.debug("deferToProd", "defer to prod not enabled"), 
      [];
      const args = [ "--defer", "--state", yield this.getDeferManifestPath(manifestPathType, manifestPathForDeferral, dbtCoreIntegrationId) ];
      return favorState && args.push("--favor-state"), this.dbtTerminal.debug("deferToProd", `executing dbt command with defer params ${manifestPathType} mode`, !0, args), 
      manifestPathType === constants_1.ManifestPathType.REMOTE && this.altimateRequest.sendDeferToProdEvent(constants_1.ManifestPathType.REMOTE), 
      args;
     }));
    }
    addDeferParams(command) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      return (yield this.getDeferParams()).forEach((param => command.addArgument(param))), 
      command;
     }));
    }
    dbtCoreCommand(command) {
     return command.addArgument("--project-dir"), command.addArgument(this.projectRoot.fsPath), 
     this.profilesDir && (command.addArgument("--profiles-dir"), command.addArgument(this.profilesDir)), 
     this.targetName && (command.addArgument("--target"), command.addArgument(this.targetName)), 
     command.setExecutionStrategy(this.pythonDBTCommandExecutionStrategy), command;
    }
    unsafeCompileNode(modelName) {
     var _a;
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.throwBridgeErrorIfAvailable();
      return (yield null === (_a = this.python) || void 0 === _a ? void 0 : _a.lock((python => python`to_dict(project.compile_node(project.get_ref_node(${modelName})))`))).compiled_sql;
     }));
    }
    unsafeCompileQuery(query, originalModelName = void 0) {
     var _a;
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.throwBridgeErrorIfAvailable();
      return (yield null === (_a = this.python) || void 0 === _a ? void 0 : _a.lock((python => python`to_dict(project.compile_sql(${query}, ${originalModelName}))`))).compiled_sql;
     }));
    }
    validateSql(query, dialect, models) {
     var _a;
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.throwBridgeErrorIfAvailable();
      return yield null === (_a = this.python) || void 0 === _a ? void 0 : _a.lock((python => python`to_dict(validate_sql(${query}, ${dialect}, ${models}))`));
     }));
    }
    validateSQLDryRun(query) {
     var _a;
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.throwBridgeErrorIfAvailable();
      return yield null === (_a = this.python) || void 0 === _a ? void 0 : _a.lock((python => python`to_dict(project.validate_sql_dry_run(${query}))`));
     }));
    }
    getColumnsOfModel(modelName) {
     var _a;
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.throwBridgeErrorIfAvailable();
      const node = yield null === (_a = this.python) || void 0 === _a ? void 0 : _a.lock((python => python`to_dict(project.get_ref_node(${modelName}))`));
      return node ? this.getColumsOfRelation(node.database, node.schema, node.alias || modelName) : [];
     }));
    }
    getColumnsOfSource(sourceName, tableName) {
     var _a;
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.throwBridgeErrorIfAvailable();
      const node = yield null === (_a = this.python) || void 0 === _a ? void 0 : _a.lock((python => python`to_dict(project.get_source_node(${sourceName}, ${tableName}))`));
      return node ? this.getColumsOfRelation(node.database, node.schema, node.identifier) : [];
     }));
    }
    getColumsOfRelation(database, schema, objectName) {
     var _a;
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      return this.throwBridgeErrorIfAvailable(), null === (_a = this.python) || void 0 === _a ? void 0 : _a.lock((python => python`to_dict(project.get_columns_in_relation(project.create_relation(${database}, ${schema}, ${objectName})))`));
     }));
    }
    getBulkCompiledSQL(models) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const result = {};
      for (const m of models) try {
       const compiledSQL = yield this.unsafeCompileNode(m.name);
       result[m.uniqueId] = compiledSQL;
      } catch (e) {
       this.dbtTerminal.error("getBulkCompiledSQL", `Unable to compile sql for model ${m.uniqueId}`, e, !0);
      }
      return result;
     }));
    }
    getBulkSchemaFromDB(nodes, cancellationToken) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      if (0 === nodes.length) return {};
      const result = {};
      for (const n of nodes) {
       if (cancellationToken.isCancellationRequested) break;
       if (n.resource_type === dbtProject_1.DBTProject.RESOURCE_TYPE_SOURCE) {
        const source = n;
        result[n.unique_id] = yield this.getColumnsOfSource(source.name, source.table);
       } else {
        const model = n;
        result[n.unique_id] = yield this.getColumnsOfModel(model.name);
       }
      }
      return result;
     }));
    }
    validateWhetherSqlHasColumns(sql, dialect) {
     var _a;
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      return this.throwBridgeErrorIfAvailable(), null === (_a = this.python) || void 0 === _a ? void 0 : _a.lock((python => python`to_dict(validate_whether_sql_has_columns(${sql}, ${dialect}))`));
     }));
    }
    fetchSqlglotSchema(sql, dialect) {
     var _a;
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      return this.throwBridgeErrorIfAvailable(), null === (_a = this.python) || void 0 === _a ? void 0 : _a.lock((python => python`to_dict(fetch_schema_from_sql(${sql}, ${dialect}))`));
     }));
    }
    getCatalog() {
     var _a;
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      return this.throwBridgeErrorIfAvailable(), yield null === (_a = this.python) || void 0 === _a ? void 0 : _a.lock((python => python`to_dict(project.get_catalog())`));
     }));
    }
    findModelPaths() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      return (yield this.python.lock((python => python`to_dict(project.config.model_paths)`))).map((modelPath => path.isAbsolute(modelPath) ? modelPath : path.join(this.projectRoot.fsPath, modelPath)));
     }));
    }
    findSeedPaths() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      return (yield this.python.lock((python => python`to_dict(project.config.seed_paths)`))).map((seedPath => path.isAbsolute(seedPath) ? seedPath : path.join(this.projectRoot.fsPath, seedPath)));
     }));
    }
    getDebounceForRebuildManifest() {
     return 2e3;
    }
    findMacroPaths() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      return (yield this.python.lock((python => python`to_dict(project.config.macro_paths)`))).map((macroPath => path.isAbsolute(macroPath) ? macroPath : path.join(this.projectRoot.fsPath, macroPath)));
     }));
    }
    findTargetPath() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      let targetPath = yield this.python.lock((python => python`to_dict(project.config.target_path)`));
      return path.isAbsolute(targetPath) || (targetPath = path.join(this.projectRoot.fsPath, targetPath)), 
      targetPath;
     }));
    }
    findPackagesInstallPath() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      let packageInstallPath = yield this.python.lock((python => python`to_dict(project.config.packages_install_path)`));
      return path.isAbsolute(packageInstallPath) || (packageInstallPath = path.join(this.projectRoot.fsPath, packageInstallPath)), 
      packageInstallPath;
     }));
    }
    findVersion() {
     var _a;
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      return null === (_a = this.python) || void 0 === _a ? void 0 : _a.lock((python => python`to_dict(project.get_dbt_version())`));
     }));
    }
    findProjectName() {
     var _a;
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      return null === (_a = this.python) || void 0 === _a ? void 0 : _a.lock((python => python`to_dict(project.config.project_name)`));
     }));
    }
    throwBridgeErrorIfAvailable() {
     const allDiagnostics = [ this.pythonBridgeDiagnostics, this.projectConfigDiagnostics, this.rebuildManifestDiagnostics ];
     for (const diagnosticCollection of allDiagnostics) for (const [_, diagnostics] of diagnosticCollection) {
      const error = diagnostics.find((diagnostic => diagnostic.severity === vscode_1.DiagnosticSeverity.Error));
      if (error) throw new Error(error.message);
     }
    }
    findPackageVersion(packageName) {
     if (!this.packagesInstallPath) throw new Error("Missing packages install path");
     if (!packageName) throw new Error("Invalid package name");
     const dbtProjectYmlFilePath = path.join(this.packagesInstallPath, packageName, "dbt_project.yml");
     if (!(0, fs_1.existsSync)(dbtProjectYmlFilePath)) throw new Error("Package not installed");
     const fileContents = (0, fs_1.readFileSync)(dbtProjectYmlFilePath, {
      encoding: "utf-8"
     });
     if (!fileContents) throw new Error(`${packageName} has empty dbt_project.yml`);
     const parsedConfig = (0, yaml_1.parse)(fileContents, {
      strict: !1,
      uniqueKeys: !1,
      maxAliasCount: -1
     });
     if (!(null == parsedConfig ? void 0 : parsedConfig.version)) throw new Error(`Missing version in ${dbtProjectYmlFilePath}`);
     return parsedConfig.version;
    }
    dispose() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      try {
       yield this.executionInfrastructure.closePythonBridge(this.python);
      } catch (error) {}
      for (this.rebuildManifestDiagnostics.clear(), this.pythonBridgeDiagnostics.clear(); this.disposables.length; ) {
       const x = this.disposables.pop();
       x && x.dispose();
      }
     }));
    }
    performDatapilotHealthcheck({manifestPath, catalogPath, config, configPath}) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.throwBridgeErrorIfAvailable();
      const healthCheckThread = this.executionInfrastructure.createPythonBridge(this.projectRoot.fsPath);
      try {
       yield this.createPythonDbtProject(healthCheckThread), yield healthCheckThread.ex`from dbt_healthcheck import *`;
       return yield healthCheckThread.lock((python => python`to_dict(project_healthcheck(${manifestPath}, ${catalogPath}, ${configPath}, ${config}))`));
      } finally {
       healthCheckThread.end();
      }
     }));
    }
    getDeferConfig() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      try {
       const root = (0, utils_1.getProjectRelativePath)(this.projectRoot), currentConfig = this.deferToProdService.getDeferConfigByWorkspace(), {deferToProduction, manifestPathForDeferral, favorState, manifestPathType, dbtCoreIntegrationId} = currentConfig[root], manifestFolder = yield this.getDeferManifestPath(manifestPathType, manifestPathForDeferral, dbtCoreIntegrationId);
       return {
        deferToProduction,
        manifestPath: path.join(manifestFolder, dbtProject_1.DBTProject.MANIFEST_FILE),
        favorState
       };
      } catch (error) {
       this.dbtTerminal.debug("dbtCoreIntegration:getDeferConfig", "An error occured while getting defer config: " + error.message);
      }
      return {
       deferToProduction: !1,
       manifestPath: null,
       favorState: !1
      };
     }));
    }
    applyDeferConfig() {
     var _a;
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const {deferToProduction, manifestPath, favorState} = yield this.getDeferConfig();
      yield null === (_a = this.python) || void 0 === _a ? void 0 : _a.lock((python => python`project.set_defer_config(${deferToProduction}, ${manifestPath}, ${favorState})`)), 
      yield this.refreshProjectConfig(), yield this.rebuildManifest();
     }));
    }
    applySelectedTarget() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      yield this.refreshProjectConfig(), yield this.rebuildManifest();
     }));
    }
    throwDiagnosticsErrorIfAvailable() {
     this.throwBridgeErrorIfAvailable();
    }
   };
   DBTCoreProjectIntegration.DBT_PROFILES_FILE = "profiles.yml", DBTCoreProjectIntegration.QUEUE_ALL = "all", 
   DBTCoreProjectIntegration = DBTCoreProjectIntegration_1 = tslib_1.__decorate([ (0, 
   utils_1.provideSingleton)(DBTCoreProjectIntegration_1), tslib_1.__metadata("design:paramtypes", [ dbtIntegration_1.DBTCommandExecutionInfrastructure, pythonEnvironment_1.PythonEnvironment, telemetry_1.TelemetryService, dbtIntegration_1.PythonDBTCommandExecutionStrategy, dbtProjectContainer_1.DBTProjectContainer, altimate_1.AltimateRequest, dbtTerminal_1.DBTTerminal, validation_provider_1.ValidationProvider, deferToProdService_1.DeferToProdService, vscode_1.Uri, Object ]) ], DBTCoreProjectIntegration), 
   exports.DBTCoreProjectIntegration = DBTCoreProjectIntegration;
  },
  22373: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var CLIDBTCommandExecutionStrategy_1, PythonDBTCommandExecutionStrategy_1, DBTCommandExecutionInfrastructure_1, DBTCommandFactory_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.DBTCommandFactory = exports.DBTCommandExecutionInfrastructure = exports.QueryExecution = exports.DBTIntegrationUnknownError = exports.DBTIntegrationError = exports.ExecuteSQLError = exports.DBTCommand = exports.PythonDBTCommandExecutionStrategy = exports.CLIDBTCommandExecutionStrategy = void 0;
   const tslib_1 = __webpack_require__(31635), vscode_1 = __webpack_require__(54980), utils_1 = __webpack_require__(86185), python_bridge_1 = __webpack_require__(63283), inversify_binding_decorators_1 = __webpack_require__(25567), commandProcessExecution_1 = __webpack_require__(7824), pythonEnvironment_1 = __webpack_require__(88103), fs_1 = __webpack_require__(79896), telemetry_1 = __webpack_require__(22644), dbtTerminal_1 = __webpack_require__(83683), altimate_1 = __webpack_require__(91741);
   let CLIDBTCommandExecutionStrategy = CLIDBTCommandExecutionStrategy_1 = class {
    constructor(commandProcessExecutionFactory, pythonEnvironment, terminal, telemetry, cwd, dbtPath) {
     this.commandProcessExecutionFactory = commandProcessExecutionFactory, this.pythonEnvironment = pythonEnvironment, 
     this.terminal = terminal, this.telemetry = telemetry, this.cwd = cwd, this.dbtPath = dbtPath;
    }
    execute(command, token) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const commandExecution = this.executeCommand(command, token);
      return command.logToTerminal ? (yield commandExecution).completeWithTerminalOutput() : (yield commandExecution).complete();
     }));
    }
    executeCommand(command, token) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      command.logToTerminal && command.focus && (yield this.terminal.show(!0)), this.telemetry.sendTelemetryEvent("dbtCommand", {
       command: command.getCommandAsString()
      }), command.logToTerminal && this.terminal.log(`> Executing task: ${command.getCommandAsString()}\n\r`);
      const {args} = command;
      if (!this.pythonEnvironment.pythonPath || !this.pythonEnvironment.environmentVariables) throw Error("Could not launch command as python environment is not available");
      const tokens = [];
      return void 0 !== token && tokens.push(token), void 0 !== command.token && tokens.push(command.token), 
      this.commandProcessExecutionFactory.createCommandProcessExecution({
       command: this.dbtPath,
       args,
       tokens,
       cwd: this.cwd.fsPath,
       envVars: this.pythonEnvironment.environmentVariables
      });
     }));
    }
   };
   CLIDBTCommandExecutionStrategy = CLIDBTCommandExecutionStrategy_1 = tslib_1.__decorate([ (0, 
   utils_1.provideSingleton)(CLIDBTCommandExecutionStrategy_1), tslib_1.__metadata("design:paramtypes", [ commandProcessExecution_1.CommandProcessExecutionFactory, pythonEnvironment_1.PythonEnvironment, dbtTerminal_1.DBTTerminal, telemetry_1.TelemetryService, vscode_1.Uri, String ]) ], CLIDBTCommandExecutionStrategy), 
   exports.CLIDBTCommandExecutionStrategy = CLIDBTCommandExecutionStrategy;
   let PythonDBTCommandExecutionStrategy = PythonDBTCommandExecutionStrategy_1 = class {
    constructor(commandProcessExecutionFactory, pythonEnvironment, terminal, telemetry) {
     this.commandProcessExecutionFactory = commandProcessExecutionFactory, this.pythonEnvironment = pythonEnvironment, 
     this.terminal = terminal, this.telemetry = telemetry;
    }
    execute(command, token) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      return (yield this.executeCommand(command, token)).completeWithTerminalOutput();
     }));
    }
    executeCommand(command, token) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.terminal.log(`> Executing task: ${command.getCommandAsString()}\n\r`), this.telemetry.sendTelemetryEvent("dbtCommand", {
       command: command.getCommandAsString()
      }), command.focus && (yield this.terminal.show(!0));
      const {args} = command;
      if (!this.pythonEnvironment.pythonPath || !this.pythonEnvironment.environmentVariables) throw Error("Could not launch command as python environment is not available");
      const tokens = [];
      return void 0 !== token && tokens.push(token), void 0 !== command.token && tokens.push(command.token), 
      this.commandProcessExecutionFactory.createCommandProcessExecution({
       command: this.pythonEnvironment.pythonPath,
       args: [ "-c", this.dbtCommand(args) ],
       tokens,
       cwd: (0, utils_1.getFirstWorkspacePath)(),
       envVars: this.pythonEnvironment.environmentVariables
      });
     }));
    }
    dbtCommand(args) {
     args = args.map((arg => `r'${arg}'`));
     return `has_dbt_runner = True\ntry: \n    ${vscode_1.workspace.getConfiguration("dbt").get("dbtCustomRunnerImport", "from dbt.cli.main import dbtRunner")}\nexcept:\n    has_dbt_runner = False\nif has_dbt_runner:\n    dbt_cli = dbtRunner()\n    dbt_cli.invoke([${args}])\nelse:\n    import dbt.main\n    dbt.main.main([${args}])`;
    }
   };
   PythonDBTCommandExecutionStrategy = PythonDBTCommandExecutionStrategy_1 = tslib_1.__decorate([ (0, 
   utils_1.provideSingleton)(PythonDBTCommandExecutionStrategy_1), tslib_1.__metadata("design:paramtypes", [ commandProcessExecution_1.CommandProcessExecutionFactory, pythonEnvironment_1.PythonEnvironment, dbtTerminal_1.DBTTerminal, telemetry_1.TelemetryService ]) ], PythonDBTCommandExecutionStrategy), 
   exports.PythonDBTCommandExecutionStrategy = PythonDBTCommandExecutionStrategy;
   class DBTCommand {
    constructor(statusMessage, args, focus = !1, showProgress = !1, logToTerminal = !1, executionStrategy, token, downloadArtifacts = !1) {
     this.statusMessage = statusMessage, this.args = args, this.focus = focus, this.showProgress = showProgress, 
     this.logToTerminal = logToTerminal, this.executionStrategy = executionStrategy, 
     this.token = token, this.downloadArtifacts = downloadArtifacts;
    }
    addArgument(arg) {
     this.args.push(arg);
    }
    getCommandAsString() {
     return "dbt " + this.args.join(" ");
    }
    setExecutionStrategy(executionStrategy) {
     this.executionStrategy = executionStrategy;
    }
    execute(token) {
     if (void 0 === this.executionStrategy) throw new Error("Execution strategy is required to run dbt commands");
     return this.executionStrategy.execute(this, token);
    }
    setToken(token) {
     this.token = token;
    }
   }
   exports.DBTCommand = DBTCommand;
   class ExecuteSQLError extends Error {
    constructor(message, compiled_sql) {
     super(message), this.compiled_sql = compiled_sql;
    }
   }
   exports.ExecuteSQLError = ExecuteSQLError;
   class DBTIntegrationError extends Error {}
   exports.DBTIntegrationError = DBTIntegrationError;
   class DBTIntegrationUnknownError extends Error {}
   exports.DBTIntegrationUnknownError = DBTIntegrationUnknownError;
   exports.QueryExecution = class {
    constructor(cancelFunc, queryResult) {
     this.cancelFunc = cancelFunc, this.queryResult = queryResult;
    }
    cancel() {
     return this.cancelFunc();
    }
    executeQuery() {
     return this.queryResult();
    }
   };
   let DBTCommandExecutionInfrastructure = DBTCommandExecutionInfrastructure_1 = class {
    constructor(pythonEnvironment, telemetry, altimate, terminal) {
     this.pythonEnvironment = pythonEnvironment, this.telemetry = telemetry, this.altimate = altimate, 
     this.terminal = terminal, this.queues = new Map, this.queueStates = new Map;
    }
    createPythonBridge(cwd) {
     let pythonPath = this.pythonEnvironment.pythonPath;
     const envVars = this.pythonEnvironment.environmentVariables;
     if (pythonPath.endsWith("python.exe")) {
      const pythonwPath = pythonPath.replace("python.exe", "pythonw.exe");
      (0, fs_1.existsSync)(pythonwPath) && (this.terminal.debug("DBTCommandExecutionInfrastructure", `Changing python path to ${pythonwPath}`), 
      pythonPath = pythonwPath);
     }
     return this.terminal.debug("DBTCommandExecutionInfrastructure", "Starting python bridge", {
      pythonPath,
      cwd
     }), (0, python_bridge_1.pythonBridge)({
      python: pythonPath,
      cwd,
      env: Object.assign(Object.assign({}, envVars), {
       PYTHONPATH: __dirname
      }),
      detached: !0
     });
    }
    closePythonBridge(bridge) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.terminal.debug("dbtIntegration", "Closing python bridge");
      try {
       yield bridge.disconnect(), yield bridge.end();
      } catch (_) {}
     }));
    }
    createQueue(queueName) {
     this.queues.set(queueName, []);
    }
    addCommandToQueue(queueName, command) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.queues.get(queueName).push({
       command: token => tslib_1.__awaiter(this, void 0, void 0, (function*() {
        yield command.execute(token);
       })),
       statusMessage: command.statusMessage,
       focus: command.focus,
       token: command.token,
       showProgress: command.showProgress
      }), this.pickCommandToRun(queueName);
     }));
    }
    pickCommandToRun(queueName) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const queue = this.queues.get(queueName);
      if (!this.queueStates.get(queueName) && queue.length > 0) {
       this.queueStates.set(queueName, !0);
       const {command, statusMessage, focus, showProgress} = queue.shift(), commandExecution = token => tslib_1.__awaiter(this, void 0, void 0, (function*() {
        try {
         yield command(token);
        } catch (error) {
         if (error instanceof altimate_1.NoCredentialsError) return void this.altimate.handlePreviewFeatures();
         vscode_1.window.showErrorMessage((0, utils_1.extendErrorWithSupportLinks)(`Could not run command '${statusMessage}': ` + error + ".")), 
         this.telemetry.sendTelemetryError("queueRunCommandError", error, {
          command: statusMessage
         });
        }
       }));
       showProgress ? yield vscode_1.window.withProgress({
        location: focus ? vscode_1.ProgressLocation.Notification : vscode_1.ProgressLocation.Window,
        cancellable: !0,
        title: statusMessage
       }, ((_, token) => tslib_1.__awaiter(this, void 0, void 0, (function*() {
        yield commandExecution(token);
       })))) : yield commandExecution(), this.queueStates.set(queueName, !1), this.pickCommandToRun(queueName);
      }
     }));
    }
    runCommand(command) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const commandExecution = {
       command: token => tslib_1.__awaiter(this, void 0, void 0, (function*() {
        yield command.execute(token);
       })),
       statusMessage: command.statusMessage,
       focus: command.focus
      };
      yield vscode_1.window.withProgress({
       location: commandExecution.focus ? vscode_1.ProgressLocation.Notification : vscode_1.ProgressLocation.Window,
       cancellable: !0,
       title: commandExecution.statusMessage
      }, ((_, token) => tslib_1.__awaiter(this, void 0, void 0, (function*() {
       try {
        return yield commandExecution.command(token);
       } catch (error) {
        vscode_1.window.showErrorMessage((0, utils_1.extendErrorWithSupportLinks)(`Could not run command '${commandExecution.statusMessage}': ` + error.message + ".")), 
        this.telemetry.sendTelemetryError("runCommandError", error, {
         command: commandExecution.statusMessage
        });
       }
      }))));
     }));
    }
   };
   DBTCommandExecutionInfrastructure = DBTCommandExecutionInfrastructure_1 = tslib_1.__decorate([ (0, 
   inversify_binding_decorators_1.provide)(DBTCommandExecutionInfrastructure_1), tslib_1.__metadata("design:paramtypes", [ pythonEnvironment_1.PythonEnvironment, telemetry_1.TelemetryService, altimate_1.AltimateRequest, dbtTerminal_1.DBTTerminal ]) ], DBTCommandExecutionInfrastructure), 
   exports.DBTCommandExecutionInfrastructure = DBTCommandExecutionInfrastructure;
   let DBTCommandFactory = DBTCommandFactory_1 = class {
    createVersionCommand() {
     return new DBTCommand("Detecting dbt version...", [ "--version" ]);
    }
    createParseCommand() {
     return new DBTCommand("Parsing dbt project...", [ "parse" ]);
    }
    createRunModelCommand(params) {
     const {plusOperatorLeft, modelName, plusOperatorRight} = params, buildModelCommandAdditionalParams = vscode_1.workspace.getConfiguration("dbt").get("runModelCommandAdditionalParams", []);
     return new DBTCommand("Running dbt model...", [ "run", "--select", `${plusOperatorLeft}${modelName}${plusOperatorRight}`, ...buildModelCommandAdditionalParams ], !0, !0, !0);
    }
    createBuildModelCommand(params) {
     const {plusOperatorLeft, modelName, plusOperatorRight} = params, buildModelCommandAdditionalParams = vscode_1.workspace.getConfiguration("dbt").get("buildModelCommandAdditionalParams", []);
     return new DBTCommand("Building dbt model...", [ "build", "--select", `${plusOperatorLeft}${modelName}${plusOperatorRight}`, ...buildModelCommandAdditionalParams ], !0, !0, !0);
    }
    createBuildProjectCommand() {
     return new DBTCommand("Building dbt project...", [ "build" ], !0, !0, !0);
    }
    createTestModelCommand(testName) {
     const testModelCommandAdditionalParams = vscode_1.workspace.getConfiguration("dbt").get("testModelCommandAdditionalParams", []);
     return new DBTCommand("Testing dbt model...", [ "test", "--select", testName, ...testModelCommandAdditionalParams ], !0, !0, !0);
    }
    createCompileModelCommand(params) {
     const {plusOperatorLeft, modelName, plusOperatorRight} = params;
     return new DBTCommand("Compiling dbt models...", [ "compile", "--select", `${plusOperatorLeft}${modelName}${plusOperatorRight}` ], !0, !0, !0);
    }
    createDocsGenerateCommand() {
     return new DBTCommand("Generating dbt Docs...", [ "docs", "generate" ], !0, !0, !0);
    }
    createInstallDepsCommand() {
     return new DBTCommand("Installing packages...", [ "deps" ], !0, !0, !0);
    }
    createAddPackagesCommand(packages) {
     return new DBTCommand("Installing packages...", [ "deps", "--add-package", ...packages ], !0, !0, !0);
    }
    createDebugCommand() {
     return new DBTCommand("Debugging...", [ "debug" ], !0, !0, !0);
    }
   };
   DBTCommandFactory = DBTCommandFactory_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(DBTCommandFactory_1) ], DBTCommandFactory), 
   exports.DBTCommandFactory = DBTCommandFactory;
  },
  83683: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var DBTTerminal_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.DBTTerminal = void 0;
   const tslib_1 = __webpack_require__(31635), vscode_1 = __webpack_require__(54980), utils_1 = __webpack_require__(86185), telemetry_1 = __webpack_require__(22644), python_bridge_1 = __webpack_require__(63283);
   let DBTTerminal = DBTTerminal_1 = class {
    constructor(telemetry) {
     this.telemetry = telemetry, this.disposables = [], this.writeEmitter = new vscode_1.EventEmitter, 
     this.outputChannel = vscode_1.window.createOutputChannel("Log - dbt", {
      log: !0
     });
    }
    show(status) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      status && (yield this.requireTerminal(), this.terminal.show(!status));
     }));
    }
    logNewLine() {
     this.log("\r\n");
    }
    logLine(line) {
     this.log(line), this.logNewLine();
    }
    logHorizontalRule() {
     this.logLine("--------------------------------------------------------------------------");
    }
    logBlock(block) {
     this.logHorizontalRule();
     for (const line of block) line && this.logLine(line);
     this.logHorizontalRule();
    }
    logBlockWithHeader(header, block) {
     this.logHorizontalRule();
     for (const line of header) this.logLine(line);
     this.logHorizontalRule();
     for (const line of block) this.logLine(line);
     this.logHorizontalRule();
    }
    log(message, ...args) {
     this.outputChannel.info((0, utils_1.stripANSI)(message), args), console.log((0, 
     utils_1.stripANSI)(message), args), void 0 !== this.terminal && this.writeEmitter.fire(message);
    }
    trace(message) {
     var _a;
     null === (_a = this.outputChannel) || void 0 === _a || _a.appendLine((0, utils_1.stripANSI)(message)), 
     console.log(message);
    }
    debug(name, message, ...args) {
     var _a;
     null === (_a = this.outputChannel) || void 0 === _a || _a.debug(`${name}:${(0, utils_1.stripANSI)(message)}`, args), 
     console.debug(message, args);
    }
    info(name, message, sendTelemetry = !0, ...args) {
     var _a;
     null === (_a = this.outputChannel) || void 0 === _a || _a.info(`${name}:${(0, utils_1.stripANSI)(message)}`, args), 
     console.info(`${name}:${message}`, args), sendTelemetry && this.telemetry.sendTelemetryEvent(name, {
      message,
      level: "info"
     });
    }
    warn(name, message, sendTelemetry = !0, ...args) {
     var _a;
     null === (_a = this.outputChannel) || void 0 === _a || _a.warn(`${name}:${(0, utils_1.stripANSI)(message)}`, args), 
     console.warn(`${name}:${message}`, args), sendTelemetry && this.telemetry.sendTelemetryEvent(name, {
      message,
      level: "warn"
     });
    }
    error(name, message, e, sendTelemetry = !0, ...args) {
     var _a;
     e instanceof python_bridge_1.PythonException ? message += `:${e.exception.message}` : e instanceof Error ? message += `:${e.message}` : message += `:${e}`, 
     null === (_a = this.outputChannel) || void 0 === _a || _a.error(`${name}:${(0, utils_1.stripANSI)(message)}`, args), 
     console.error(`${name}:${message}`, args), sendTelemetry && this.telemetry.sendTelemetryError(name, e, {
      message
     });
    }
    dispose() {
     for (;this.disposables.length; ) {
      const x = this.disposables.pop();
      null == x || x.dispose();
     }
    }
    requireTerminal() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      void 0 === this.terminal && (this.terminal = vscode_1.window.createTerminal({
       name: "Tasks - dbt",
       pty: {
        onDidWrite: this.writeEmitter.event,
        open: () => this.writeEmitter.fire(""),
        close: () => {
         var _a;
         null === (_a = this.terminal) || void 0 === _a || _a.dispose(), this.terminal = void 0;
        }
       }
      }), yield new Promise((resolve => setTimeout(resolve, 100))));
     }));
    }
   };
   DBTTerminal = DBTTerminal_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(DBTTerminal_1), tslib_1.__metadata("design:paramtypes", [ telemetry_1.TelemetryService ]) ], DBTTerminal), 
   exports.DBTTerminal = DBTTerminal;
  },
  78629: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var DBTClient_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.DBTClient = void 0;
   const tslib_1 = __webpack_require__(31635), vscode_1 = __webpack_require__(54980), pythonEnvironment_1 = __webpack_require__(88103), utils_1 = __webpack_require__(86185), fs_1 = __webpack_require__(79896), dbtCoreIntegration_1 = __webpack_require__(71636), dbtCloudIntegration_1 = __webpack_require__(54958);
   var DbtInstallationPromptAnswer, PythonInterpreterPromptAnswer;
   !function(DbtInstallationPromptAnswer) {
    DbtInstallationPromptAnswer.INSTALL = "Install dbt core", DbtInstallationPromptAnswer.INSTALL_CLOUD = "Install dbt Cloud";
   }(DbtInstallationPromptAnswer || (DbtInstallationPromptAnswer = {})), function(PythonInterpreterPromptAnswer) {
    PythonInterpreterPromptAnswer.SELECT = "Select Python interpreter";
   }(PythonInterpreterPromptAnswer || (PythonInterpreterPromptAnswer = {}));
   let DBTClient = DBTClient_1 = class {
    get dbtInstalled() {
     return this._dbtInstalled;
    }
    get pythonInstalled() {
     return this._pythonInstalled;
    }
    constructor(pythonEnvironment, dbtCoreDetection, dbtCloudDetection) {
     if (this.pythonEnvironment = pythonEnvironment, this.dbtCoreDetection = dbtCoreDetection, 
     this.dbtCloudDetection = dbtCloudDetection, this._onDBTInstallationVerificationEvent = new vscode_1.EventEmitter, 
     this.onDBTInstallationVerification = this._onDBTInstallationVerificationEvent.event, 
     this.disposables = [ this._onDBTInstallationVerificationEvent ], this.shownError = !1, 
     this.dbtIntegrationMode = "core", this.dbtIntegrationMode = vscode_1.workspace.getConfiguration("dbt").get("dbtIntegration", "core"), 
     "cloud" === this.dbtIntegrationMode) this.dbtDetection = this.dbtCloudDetection; else this.dbtDetection = this.dbtCoreDetection;
    }
    dispose() {
     for (;this.disposables.length; ) {
      const x = this.disposables.pop();
      x && x.dispose();
     }
    }
    detectDBT() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      yield this.pythonEnvironment.initialize(), this.disposables.push(this.pythonEnvironment.onPythonEnvironmentChanged((() => {
       this.checkAllInstalled();
      }))), yield this.checkAllInstalled();
     }));
    }
    checkAllInstalled() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this._onDBTInstallationVerificationEvent.fire({
       inProgress: !0
      }), this.shownError = !1, this._dbtInstalled = void 0, this._pythonInstalled = this.pythonPathExists(), 
      this._dbtInstalled = yield this.dbtDetection.detectDBT(), this._onDBTInstallationVerificationEvent.fire({
       inProgress: !1,
       installed: this._dbtInstalled
      }), vscode_1.commands.executeCommand("setContext", "dbtPowerUser.dbtInstalled", this._dbtInstalled), 
      this._dbtInstalled || this.showErrorIfDbtOrPythonNotInstalled();
     }));
    }
    showErrorIfDbtOrPythonNotInstalled() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      if (!this._pythonInstalled) {
       if (!this.shownError) {
        this.shownError = !0;
        (yield vscode_1.window.showErrorMessage("No Python interpreter is selected or Python is not installed", PythonInterpreterPromptAnswer.SELECT)) === PythonInterpreterPromptAnswer.SELECT && vscode_1.commands.executeCommand("python.setInterpreter");
       }
       return !1;
      }
      if (!this.pythonEnvironment.isPython3) {
       return (yield vscode_1.window.showErrorMessage("Only Python 3 is supported by dbt, please select a Python 3 interpreter", PythonInterpreterPromptAnswer.SELECT)) === PythonInterpreterPromptAnswer.SELECT && vscode_1.commands.executeCommand("python.setInterpreter"), 
       !1;
      }
      return this.showErrorIfDbtIsNotInstalled();
     }));
    }
    executeInstallDbtCommand(message, option) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const dbtIntegration = vscode_1.workspace.getConfiguration("dbt").get("dbtIntegration", "core"), answer = yield vscode_1.window.showErrorMessage(message, option, "cloud" === dbtIntegration ? "Switch to dbt core" : "Switch to dbt cloud");
      answer === option && vscode_1.commands.executeCommand("dbtPowerUser.installDbt"), 
      (null == answer ? void 0 : answer.includes("Switch")) && vscode_1.commands.executeCommand("dbtPowerUser.switchDbtIntegration");
     }));
    }
    showErrorIfDbtIsNotInstalled() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      return !!this._dbtInstalled || (this.shownError || (this.shownError = !0, "cloud" === this.dbtIntegrationMode ? yield this.executeInstallDbtCommand("Please ensure dbt cloud cli is installed.", DbtInstallationPromptAnswer.INSTALL_CLOUD) : yield this.executeInstallDbtCommand("Please ensure dbt is installed.", DbtInstallationPromptAnswer.INSTALL)), 
      !1);
     }));
    }
    getPythonEnvironment() {
     return this.pythonEnvironment;
    }
    pythonPathExists() {
     return void 0 !== this.pythonEnvironment.pythonPath && (0, fs_1.existsSync)(this.pythonEnvironment.pythonPath);
    }
   };
   DBTClient = DBTClient_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(DBTClient_1), tslib_1.__metadata("design:paramtypes", [ pythonEnvironment_1.PythonEnvironment, dbtCoreIntegration_1.DBTCoreDetection, dbtCloudIntegration_1.DBTCloudDetection ]) ], DBTClient), 
   exports.DBTClient = DBTClient;
  },
  44614: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var DocDefinitionProvider_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.DocDefinitionProvider = void 0;
   const tslib_1 = __webpack_require__(31635), vscode_1 = __webpack_require__(54980), dbtProjectContainer_1 = __webpack_require__(82018), utils_1 = __webpack_require__(86185), telemetry_1 = __webpack_require__(22644);
   let DocDefinitionProvider = DocDefinitionProvider_1 = class {
    constructor(dbtProjectContainer, telemetry) {
     this.dbtProjectContainer = dbtProjectContainer, this.telemetry = telemetry, this.docToLocationMap = new Map, 
     this.disposables = [], this.disposables.push(dbtProjectContainer.onManifestChanged((event => this.onManifestCacheChanged(event))));
    }
    dispose() {
     for (;this.disposables.length; ) {
      const x = this.disposables.pop();
      x && x.dispose();
     }
    }
    provideDefinition(document, position) {
     return new Promise((resolve => {
      const range = document.getWordRangeAtPosition(position, DocDefinitionProvider_1.IS_DOC), word = document.getText(range);
      if (word) {
       this.dbtProjectContainer.getPackageName(document.uri);
       const docName = word.match(DocDefinitionProvider_1.GET_DOC_INFO);
       if (null == docName) return void resolve(void 0);
       const definition = this.getDocDefinition(docName[0], document.uri);
       if (void 0 !== definition) return resolve(definition), void this.telemetry.sendTelemetryEvent("provideDocDefinition");
      }
      resolve(void 0);
     }));
    }
    onManifestCacheChanged(event) {
     var _a, _b;
     null === (_a = event.added) || void 0 === _a || _a.forEach((added => {
      this.docToLocationMap.set(added.project.projectRoot.fsPath, added.docMetaMap);
     })), null === (_b = event.removed) || void 0 === _b || _b.forEach((removed => {
      this.docToLocationMap.delete(removed.projectRoot.fsPath);
     }));
    }
    getDocDefinition(docName, currentFilePath) {
     const projectRootpath = this.dbtProjectContainer.getProjectRootpath(currentFilePath);
     if (void 0 === projectRootpath) return;
     const docMap = this.docToLocationMap.get(projectRootpath.fsPath);
     if (void 0 === docMap) return;
     const location = docMap.get(docName);
     return location ? new vscode_1.Location(vscode_1.Uri.file(location.path), new vscode_1.Position(location.line, location.character)) : void 0;
    }
   };
   DocDefinitionProvider.IS_DOC = /(doc)\([^)]*\)/, DocDefinitionProvider.GET_DOC_INFO = /(?!['"])(\w+)(?=['"])/g, 
   DocDefinitionProvider = DocDefinitionProvider_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(DocDefinitionProvider_1), tslib_1.__metadata("design:paramtypes", [ dbtProjectContainer_1.DBTProjectContainer, telemetry_1.TelemetryService ]) ], DocDefinitionProvider), 
   exports.DocDefinitionProvider = DocDefinitionProvider;
  },
  45608: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var DefinitionProviders_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.DefinitionProviders = void 0;
   const tslib_1 = __webpack_require__(31635), vscode_1 = __webpack_require__(54980), dbtPowerUserExtension_1 = __webpack_require__(29597), utils_1 = __webpack_require__(86185), docDefinitionProvider_1 = __webpack_require__(44614), macroDefinitionProvider_1 = __webpack_require__(12136), modelDefinitionProvider_1 = __webpack_require__(72049), sourceDefinitionProvider_1 = __webpack_require__(66831);
   let DefinitionProviders = DefinitionProviders_1 = class {
    constructor(modelDefinitionProvider, macroDefinitionProvider, sourceDefinitionProvider, docDefinitionsProvider) {
     this.modelDefinitionProvider = modelDefinitionProvider, this.macroDefinitionProvider = macroDefinitionProvider, 
     this.sourceDefinitionProvider = sourceDefinitionProvider, this.docDefinitionsProvider = docDefinitionsProvider, 
     this.disposables = [], this.disposables.push(vscode_1.languages.registerDefinitionProvider(dbtPowerUserExtension_1.DBTPowerUserExtension.DBT_YAML_SQL_SELECTOR, this.modelDefinitionProvider), vscode_1.languages.registerDefinitionProvider(dbtPowerUserExtension_1.DBTPowerUserExtension.DBT_SQL_SELECTOR, this.macroDefinitionProvider), vscode_1.languages.registerDefinitionProvider(dbtPowerUserExtension_1.DBTPowerUserExtension.DBT_YAML_SQL_SELECTOR, this.sourceDefinitionProvider), vscode_1.languages.registerDefinitionProvider(dbtPowerUserExtension_1.DBTPowerUserExtension.DBT_YAML_SQL_SELECTOR, this.docDefinitionsProvider));
    }
    dispose() {
     for (;this.disposables.length; ) {
      const x = this.disposables.pop();
      x && x.dispose();
     }
    }
   };
   DefinitionProviders = DefinitionProviders_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(DefinitionProviders_1), tslib_1.__metadata("design:paramtypes", [ modelDefinitionProvider_1.ModelDefinitionProvider, macroDefinitionProvider_1.MacroDefinitionProvider, sourceDefinitionProvider_1.SourceDefinitionProvider, docDefinitionProvider_1.DocDefinitionProvider ]) ], DefinitionProviders), 
   exports.DefinitionProviders = DefinitionProviders;
  },
  12136: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var MacroDefinitionProvider_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.MacroDefinitionProvider = void 0;
   const tslib_1 = __webpack_require__(31635), vscode_1 = __webpack_require__(54980), dbtProjectContainer_1 = __webpack_require__(82018), utils_1 = __webpack_require__(86185), telemetry_1 = __webpack_require__(22644);
   let MacroDefinitionProvider = MacroDefinitionProvider_1 = class {
    constructor(dbtProjectContainer, telemetry) {
     this.dbtProjectContainer = dbtProjectContainer, this.telemetry = telemetry, this.macroToLocationMap = new Map, 
     this.disposables = [], this.disposables.push(dbtProjectContainer.onManifestChanged((event => this.onManifestCacheChanged(event))));
    }
    dispose() {
     for (;this.disposables.length; ) {
      const x = this.disposables.pop();
      x && x.dispose();
     }
    }
    provideDefinition(document, position) {
     return new Promise((resolve => {
      const textLine = document.lineAt(position).text, range = document.getWordRangeAtPosition(position, MacroDefinitionProvider_1.IS_MACRO), word = document.getText(range);
      if (range && "(" === textLine[range.end.character] && (0, utils_1.isEnclosedWithinCodeBlock)(document, range)) {
       const packageName = this.dbtProjectContainer.getPackageName(document.uri), macroName = void 0 === packageName || word.includes(".") ? word : `${packageName}.${word}`, definition = this.getMacroDefinition(macroName, document.uri);
       if (void 0 !== definition) return resolve(definition), void this.telemetry.sendTelemetryEvent("provideMacroDefinition");
      }
      resolve(void 0);
     }));
    }
    onManifestCacheChanged(event) {
     var _a, _b;
     null === (_a = event.added) || void 0 === _a || _a.forEach((added => {
      this.macroToLocationMap.set(added.project.projectRoot.fsPath, added.macroMetaMap);
     })), null === (_b = event.removed) || void 0 === _b || _b.forEach((removed => {
      this.macroToLocationMap.delete(removed.projectRoot.fsPath);
     }));
    }
    getMacroDefinition(macroName, currentFilePath) {
     const projectRootpath = this.dbtProjectContainer.getProjectRootpath(currentFilePath);
     if (void 0 === projectRootpath) return;
     const macroMap = this.macroToLocationMap.get(projectRootpath.fsPath);
     if (void 0 === macroMap) return;
     const location = macroMap.get(macroName);
     return location && location.path ? new vscode_1.Location(vscode_1.Uri.file(location.path), new vscode_1.Position(location.line, location.character)) : void 0;
    }
   };
   MacroDefinitionProvider.IS_MACRO = /\w+\.?\w+/, MacroDefinitionProvider = MacroDefinitionProvider_1 = tslib_1.__decorate([ (0, 
   utils_1.provideSingleton)(MacroDefinitionProvider_1), tslib_1.__metadata("design:paramtypes", [ dbtProjectContainer_1.DBTProjectContainer, telemetry_1.TelemetryService ]) ], MacroDefinitionProvider), 
   exports.MacroDefinitionProvider = MacroDefinitionProvider;
  },
  72049: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var ModelDefinitionProvider_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.ModelDefinitionProvider = void 0;
   const tslib_1 = __webpack_require__(31635), vscode_1 = __webpack_require__(54980), dbtProjectContainer_1 = __webpack_require__(82018), utils_1 = __webpack_require__(86185), telemetry_1 = __webpack_require__(22644), dbtTerminal_1 = __webpack_require__(83683);
   let ModelDefinitionProvider = ModelDefinitionProvider_1 = class {
    constructor(dbtProjectContainer, telemetry, dbtTerminal) {
     this.dbtProjectContainer = dbtProjectContainer, this.telemetry = telemetry, this.dbtTerminal = dbtTerminal, 
     this.modelToLocationMap = new Map, this.disposables = [], this.disposables.push(dbtProjectContainer.onManifestChanged((event => this.onManifestCacheChanged(event))));
    }
    dispose() {
     for (;this.disposables.length; ) {
      const x = this.disposables.pop();
      x && x.dispose();
     }
    }
    provideDefinition(document, position, token) {
     return new Promise((resolve => {
      const hover = document.getText(document.getWordRangeAtPosition(position)), word = document.getText(document.getWordRangeAtPosition(position, ModelDefinitionProvider_1.IS_REF)), project = this.dbtProjectContainer.findDBTProject(document.uri);
      if (project) {
       if (void 0 !== word && "ref" !== hover) {
        const dbtModel = word.match(ModelDefinitionProvider_1.GET_DBT_MODEL);
        if (dbtModel && 1 === dbtModel.length) {
         return resolve(this.getDefinitionFor(project.getProjectName(), dbtModel[0], document.uri)), 
         void this.telemetry.sendTelemetryEvent("provideModelDefinition", {
          type: "single"
         });
        }
        if (dbtModel && 3 === dbtModel.length) {
         const definition = this.getDefinitionFor(dbtModel[0], dbtModel[2], document.uri);
         return this.telemetry.sendTelemetryEvent("provideModelDefinition", {
          type: "dual"
         }), void resolve(definition);
        }
       }
       resolve(void 0);
      } else this.dbtTerminal.debug("modelDefinitionProvider:provideDefinition", "Could not load definition provider, project not found in container for " + document.uri.fsPath);
     }));
    }
    onManifestCacheChanged(event) {
     var _a, _b;
     null === (_a = event.added) || void 0 === _a || _a.forEach((added => {
      this.modelToLocationMap.set(added.project.projectRoot.fsPath, added.nodeMetaMap);
     })), null === (_b = event.removed) || void 0 === _b || _b.forEach((removed => {
      this.modelToLocationMap.delete(removed.projectRoot.fsPath);
     }));
    }
    getDefinitionFor(projectName, modelName, currentFilePath) {
     const projectRootpath = this.dbtProjectContainer.getProjectRootpath(currentFilePath);
     if (void 0 === projectRootpath) return;
     const nodeMap = this.modelToLocationMap.get(projectRootpath.fsPath);
     if (void 0 === nodeMap) return;
     const location = nodeMap.lookupByBaseName(modelName);
     return location && location.path ? new vscode_1.Location(vscode_1.Uri.file(location.path), new vscode_1.Range(0, 0, 999, 999)) : void 0;
    }
   };
   ModelDefinitionProvider.IS_REF = /(ref)\([^)]*\)/, ModelDefinitionProvider.GET_DBT_MODEL = /(?!'|")([^(?!'|")]*)(?='|")/gi, 
   ModelDefinitionProvider = ModelDefinitionProvider_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(ModelDefinitionProvider_1), tslib_1.__metadata("design:paramtypes", [ dbtProjectContainer_1.DBTProjectContainer, telemetry_1.TelemetryService, dbtTerminal_1.DBTTerminal ]) ], ModelDefinitionProvider), 
   exports.ModelDefinitionProvider = ModelDefinitionProvider;
  },
  66831: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var SourceDefinitionProvider_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.SourceDefinitionProvider = void 0;
   const tslib_1 = __webpack_require__(31635), fs_1 = __webpack_require__(79896), vscode_1 = __webpack_require__(54980), dbtProjectContainer_1 = __webpack_require__(82018), utils_1 = __webpack_require__(86185), telemetry_1 = __webpack_require__(22644);
   let SourceDefinitionProvider = SourceDefinitionProvider_1 = class {
    constructor(dbtProjectContainer, telemetry) {
     this.dbtProjectContainer = dbtProjectContainer, this.telemetry = telemetry, this.sourceMetaMap = new Map, 
     this.disposables = [], this.disposables.push(dbtProjectContainer.onManifestChanged((event => this.onManifestCacheChanged(event))));
    }
    dispose() {
     for (;this.disposables.length; ) {
      const x = this.disposables.pop();
      x && x.dispose();
     }
    }
    provideDefinition(document, position, token) {
     return new Promise((resolve => {
      const hover = document.getText(document.getWordRangeAtPosition(position)), range = document.getWordRangeAtPosition(position, SourceDefinitionProvider_1.IS_SOURCE), word = document.getText(range), linePrefix = document.lineAt(position).text.substr(0, position.character);
      if (!(0, utils_1.isEnclosedWithinCodeBlock)(document, position) || !linePrefix.includes("source") || "source" === hover) return void resolve(void 0);
      const source = word.match(SourceDefinitionProvider_1.GET_SOURCE_INFO);
      if (null == source) return void resolve(void 0);
      if (source.length < 2) return void resolve(void 0);
      const definition = this.getSourceDefinition(source[0], document.uri, source[1]);
      this.telemetry.sendTelemetryEvent("provideSourceDefinition"), resolve(definition);
     }));
    }
    onManifestCacheChanged(event) {
     var _a, _b;
     null === (_a = event.added) || void 0 === _a || _a.forEach((added => {
      this.sourceMetaMap.set(added.project.projectRoot.fsPath, added.sourceMetaMap);
     })), null === (_b = event.removed) || void 0 === _b || _b.forEach((removed => {
      this.sourceMetaMap.delete(removed.projectRoot.fsPath);
     }));
    }
    getSourceDefinition(sourceName, currentFilePath, tableName) {
     var _a;
     const projectRootpath = this.dbtProjectContainer.getProjectRootpath(currentFilePath);
     if (void 0 === projectRootpath) return;
     const sourceMap = this.sourceMetaMap.get(projectRootpath.fsPath);
     if (void 0 === sourceMap) return;
     const location = null === (_a = sourceMap.get(sourceName)) || void 0 === _a ? void 0 : _a.tables.find((table => table.name === tableName));
     if (location && location.path) {
      const sourceFileLines = (0, fs_1.readFileSync)(location.path).toString("utf8").split("\n");
      for (let index = 0; index < sourceFileLines.length; index++) {
       const currentLine = sourceFileLines[index];
       if (currentLine.includes(tableName)) return new vscode_1.Location(vscode_1.Uri.file(location.path), new vscode_1.Position(index, currentLine.indexOf(tableName)));
      }
     }
    }
   };
   SourceDefinitionProvider.IS_SOURCE = /(source)\([^)]*\)/, SourceDefinitionProvider.GET_SOURCE_INFO = /(?!['"])(\w+)(?=['"])/g, 
   SourceDefinitionProvider = SourceDefinitionProvider_1 = tslib_1.__decorate([ (0, 
   utils_1.provideSingleton)(SourceDefinitionProvider_1), tslib_1.__metadata("design:paramtypes", [ dbtProjectContainer_1.DBTProjectContainer, telemetry_1.TelemetryService ]) ], SourceDefinitionProvider), 
   exports.SourceDefinitionProvider = SourceDefinitionProvider;
  },
  63144: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var DbtDocumentFormattingEditProvider_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.DbtDocumentFormattingEditProvider = void 0;
   const tslib_1 = __webpack_require__(31635), parseDiff = __webpack_require__(54856), vscode_1 = __webpack_require__(54980), which = __webpack_require__(77242), commandProcessExecution_1 = __webpack_require__(7824), utils_1 = __webpack_require__(86185), telemetry_1 = __webpack_require__(22644), pythonEnvironment_1 = __webpack_require__(88103);
   let DbtDocumentFormattingEditProvider = DbtDocumentFormattingEditProvider_1 = class {
    constructor(commandProcessExecutionFactory, telemetry, pythonEnvironment) {
     this.commandProcessExecutionFactory = commandProcessExecutionFactory, this.telemetry = telemetry, 
     this.pythonEnvironment = pythonEnvironment;
    }
    provideDocumentFormattingEdits(document, options, token) {
     return this.executeSqlFmt(document);
    }
    executeSqlFmt(document) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const sqlFmtPathSetting = this.pythonEnvironment.getResolvedConfigValue("sqlFmtPath"), sqlFmtArgs = [ "-", "--diff", "--no-progressbar", "--quiet", ...vscode_1.workspace.getConfiguration("dbt").get("sqlFmtAdditionalParams", []).join(" ").split(" ").filter((s => "" !== s)) ];
      try {
       const sqlFmtPath = sqlFmtPathSetting || (yield which("sqlfmt"));
       this.telemetry.sendTelemetryEvent("formatDbtModel", {
        sqlFmtPath: sqlFmtPathSetting ? "setting" : "path"
       });
       try {
        const {stderr} = yield this.commandProcessExecutionFactory.createCommandProcessExecution({
         command: sqlFmtPath,
         args: sqlFmtArgs,
         stdin: document.getText()
        }).complete();
        if (stderr) throw new Error(stderr);
        return [];
       } catch (e) {
        try {
         return this.processDiffOutput(document, e.message);
        } catch (error) {
         this.telemetry.sendTelemetryError("formatDbtModelApplyDiffFailed", error), vscode_1.window.showErrorMessage((0, 
         utils_1.extendErrorWithSupportLinks)("Could not process difference output from sqlfmt. Detailed error: " + error + "."));
        }
       }
      } catch (error) {
       this.telemetry.sendTelemetryError("formatDbtModelApplyDiffFailed", error), vscode_1.window.showErrorMessage((0, 
       utils_1.extendErrorWithSupportLinks)("Could not run sqlfmt. Did you install sqlfmt? Detailed error: " + error + "."));
      }
      return [];
     }));
    }
    processDiffOutput(document, diffOutput) {
     const textEdits = [];
     return parseDiff(diffOutput).forEach((diff => {
      let lastChunk;
      diff.chunks.forEach((chunk => {
       if (lastChunk) for (let index = lastChunk.oldStart + lastChunk.oldLines, lineNb = 0; index < chunk.oldStart; index++, 
       lineNb++) textEdits.push(...this.replace(document, index - 1, lastChunk.newStart + lastChunk.newLines - 2 + lineNb, document.lineAt(index - 1).text + "\n"));
       const oldBoundChunk = chunk.oldLines + chunk.oldStart - 1;
       chunk.changes.forEach((change => {
        this.isAddChange(change) && textEdits.push(vscode_1.TextEdit.insert(document.lineAt(Math.min(change.ln, oldBoundChunk) - 1).range.start, change.content.slice(1) + "\n")), 
        this.isNormalChange(change) && textEdits.push(...this.replace(document, change.ln1 - 1, Math.min(change.ln2, oldBoundChunk) - 1, change.content.slice(1) + "\n")), 
        this.isDeleteChange(change) && textEdits.push(vscode_1.TextEdit.delete(document.lineAt(change.ln - 1).rangeIncludingLineBreak));
       })), lastChunk = chunk;
      }));
     })), textEdits;
    }
    replace(document, lineToDelete, lineToInsert, newText) {
     return [ vscode_1.TextEdit.delete(document.lineAt(lineToDelete).rangeIncludingLineBreak), vscode_1.TextEdit.insert(document.lineAt(lineToInsert).range.start, newText) ];
    }
    isAddChange(change) {
     return "add" === change.type;
    }
    isNormalChange(change) {
     return "normal" === change.type;
    }
    isDeleteChange(change) {
     return "del" === change.type && "\\ No newline at end of file" !== change.content;
    }
   };
   DbtDocumentFormattingEditProvider = DbtDocumentFormattingEditProvider_1 = tslib_1.__decorate([ (0, 
   utils_1.provideSingleton)(DbtDocumentFormattingEditProvider_1), tslib_1.__metadata("design:paramtypes", [ commandProcessExecution_1.CommandProcessExecutionFactory, telemetry_1.TelemetryService, pythonEnvironment_1.PythonEnvironment ]) ], DbtDocumentFormattingEditProvider), 
   exports.DbtDocumentFormattingEditProvider = DbtDocumentFormattingEditProvider;
  },
  5113: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var DocumentFormattingEditProviders_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.DocumentFormattingEditProviders = void 0;
   const tslib_1 = __webpack_require__(31635), vscode_1 = __webpack_require__(54980), dbtPowerUserExtension_1 = __webpack_require__(29597), utils_1 = __webpack_require__(86185), dbtDocumentFormattingEditProvider_1 = __webpack_require__(63144);
   let DocumentFormattingEditProviders = DocumentFormattingEditProviders_1 = class {
    constructor(dbtDocumentFormattingProvider) {
     this.dbtDocumentFormattingProvider = dbtDocumentFormattingProvider, this.disposables = [], 
     this.disposables.push(vscode_1.languages.registerDocumentFormattingEditProvider(dbtPowerUserExtension_1.DBTPowerUserExtension.DBT_SQL_SELECTOR, this.dbtDocumentFormattingProvider));
    }
    dispose() {
     for (;this.disposables.length; ) {
      const x = this.disposables.pop();
      x && x.dispose();
     }
    }
   };
   DocumentFormattingEditProviders = DocumentFormattingEditProviders_1 = tslib_1.__decorate([ (0, 
   utils_1.provideSingleton)(DocumentFormattingEditProviders_1), tslib_1.__metadata("design:paramtypes", [ dbtDocumentFormattingEditProvider_1.DbtDocumentFormattingEditProvider ]) ], DocumentFormattingEditProviders), 
   exports.DocumentFormattingEditProviders = DocumentFormattingEditProviders;
  },
  97066: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.RunModelType = exports.Source = exports.Snapshot = exports.Metric = exports.Exposure = exports.Analysis = exports.Test = exports.Seed = exports.Model = exports.Node = void 0;
   const path = __webpack_require__(16928);
   class Node {
    constructor(label, key, url) {
     this.iconPath = {
      light: path.join(path.resolve(__dirname), "../media/images/model_light.svg"),
      dark: path.join(path.resolve(__dirname), "../media/images/model_dark.svg")
     }, this.displayInModelTree = !0, this.label = label, this.key = key, this.url = url;
    }
   }
   exports.Node = Node;
   exports.Model = class extends Node {};
   exports.Seed = class extends Node {};
   exports.Test = class extends Node {
    constructor() {
     super(...arguments), this.iconPath = {
      light: path.join(path.resolve(__dirname), "../media/images/source_light.svg"),
      dark: path.join(path.resolve(__dirname), "../media/images/source_dark.svg")
     };
    }
   };
   exports.Analysis = class extends Node {
    constructor() {
     super(...arguments), this.displayInModelTree = !0;
    }
   };
   exports.Exposure = class extends Node {
    constructor() {
     super(...arguments), this.displayInModelTree = !0;
    }
   };
   exports.Metric = class extends Node {
    constructor() {
     super(...arguments), this.displayInModelTree = !1;
    }
   };
   exports.Snapshot = class extends Node {};
   exports.Source = class extends Node {
    constructor() {
     super(...arguments), this.iconPath = {
      light: path.join(path.resolve(__dirname), "../media/images/source_light.svg"),
      dark: path.join(path.resolve(__dirname), "../media/images/source_dark.svg")
     };
    }
   }, function(RunModelType) {
    RunModelType[RunModelType.RUN_PARENTS = 0] = "RUN_PARENTS", RunModelType[RunModelType.RUN_CHILDREN = 1] = "RUN_CHILDREN", 
    RunModelType[RunModelType.BUILD_PARENTS = 2] = "BUILD_PARENTS", RunModelType[RunModelType.BUILD_CHILDREN = 3] = "BUILD_CHILDREN", 
    RunModelType[RunModelType.BUILD_CHILDREN_PARENTS = 4] = "BUILD_CHILDREN_PARENTS", 
    RunModelType[RunModelType.TEST = 5] = "TEST", RunModelType[RunModelType.SNAPSHOT = 6] = "SNAPSHOT";
   }(exports.RunModelType || (exports.RunModelType = {}));
  },
  47248: (__unused_webpack_module, exports) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.ExecutionsExhaustedException = void 0;
   class ExecutionsExhaustedException extends Error {
    constructor(msg) {
     super(msg), Object.setPrototypeOf(this, ExecutionsExhaustedException.prototype);
    }
   }
   exports.ExecutionsExhaustedException = ExecutionsExhaustedException;
  },
  46055: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   });
   const tslib_1 = __webpack_require__(31635);
   tslib_1.__exportStar(__webpack_require__(42261), exports), tslib_1.__exportStar(__webpack_require__(47248), exports);
  },
  42261: (__unused_webpack_module, exports) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.RateLimitException = void 0;
   class RateLimitException extends Error {
    constructor(msg, retryAfter) {
     super(msg), this.retryAfter = retryAfter, Object.setPrototypeOf(this, RateLimitException.prototype);
    }
   }
   exports.RateLimitException = RateLimitException;
  },
  93875: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var HoverProviders_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.HoverProviders = void 0;
   const tslib_1 = __webpack_require__(31635), vscode_1 = __webpack_require__(54980), dbtPowerUserExtension_1 = __webpack_require__(29597), utils_1 = __webpack_require__(86185), modelHoverProvider_1 = __webpack_require__(78635), sourceHoverProvider_1 = __webpack_require__(49891), macroHoverProvider_1 = __webpack_require__(64016);
   let HoverProviders = HoverProviders_1 = class {
    constructor(modelHoverProvider, sourceHoverProvider, macroHoverProvider) {
     this.modelHoverProvider = modelHoverProvider, this.sourceHoverProvider = sourceHoverProvider, 
     this.macroHoverProvider = macroHoverProvider, this.disposables = [], this.disposables.push(vscode_1.languages.registerHoverProvider(dbtPowerUserExtension_1.DBTPowerUserExtension.DBT_SQL_SELECTOR, this.modelHoverProvider)), 
     this.disposables.push(vscode_1.languages.registerHoverProvider(dbtPowerUserExtension_1.DBTPowerUserExtension.DBT_SQL_SELECTOR, this.sourceHoverProvider)), 
     this.disposables.push(vscode_1.languages.registerHoverProvider(dbtPowerUserExtension_1.DBTPowerUserExtension.DBT_SQL_SELECTOR, this.macroHoverProvider));
    }
    dispose() {
     for (;this.disposables.length; ) {
      const x = this.disposables.pop();
      x && x.dispose();
     }
    }
   };
   HoverProviders = HoverProviders_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(HoverProviders_1), tslib_1.__metadata("design:paramtypes", [ modelHoverProvider_1.ModelHoverProvider, sourceHoverProvider_1.SourceHoverProvider, macroHoverProvider_1.MacroHoverProvider ]) ], HoverProviders), 
   exports.HoverProviders = HoverProviders;
  },
  64016: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var MacroHoverProvider_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.MacroHoverProvider = void 0;
   const tslib_1 = __webpack_require__(31635), vscode_1 = __webpack_require__(54980), telemetry_1 = __webpack_require__(22644), utils_1 = __webpack_require__(78026), dbtTerminal_1 = __webpack_require__(83683), queryManifestService_1 = __webpack_require__(59269), utils_2 = __webpack_require__(86185);
   let MacroHoverProvider = MacroHoverProvider_1 = class {
    constructor(telemetry, dbtTerminal, queryManifestService) {
     this.telemetry = telemetry, this.dbtTerminal = dbtTerminal, this.queryManifestService = queryManifestService, 
     this.disposables = [];
    }
    dispose() {
     for (;this.disposables.length; ) {
      const x = this.disposables.pop();
      x && x.dispose();
     }
    }
    provideHover(document, position, token) {
     const hoverText = document.getText(document.getWordRangeAtPosition(position));
     this.dbtTerminal.debug("MacroHoverProvider", `checking: ${hoverText}`);
     const eventResult = this.queryManifestService.getEventByDocument(document.uri);
     if (!eventResult) return;
     const {macroMetaMap, nodeMetaMap} = eventResult, macroMeta = macroMetaMap.get(hoverText);
     if (!macroMeta) return null;
     const referencedBy = this.getNodesReferencingMacro(macroMeta.uniqueId, macroMetaMap, nodeMetaMap), hoverContent = (0, 
     utils_1.generateMacroHoverMarkdown)(macroMeta, referencedBy, eventResult);
     return this.telemetry.sendTelemetryEvent("provideMacroHover"), new vscode_1.Hover(hoverContent);
    }
    getNodesReferencingMacro(macroMetaName, macroMetaMap, nodeMetaMap) {
     const referencedBy = [];
     return [ ...macroMetaMap.values(), ...nodeMetaMap.nodes() ].forEach((node => {
      node.depends_on.macros.includes(macroMetaName) && referencedBy.push(node);
     })), referencedBy;
    }
   };
   MacroHoverProvider = MacroHoverProvider_1 = tslib_1.__decorate([ (0, utils_2.provideSingleton)(MacroHoverProvider_1), tslib_1.__metadata("design:paramtypes", [ telemetry_1.TelemetryService, dbtTerminal_1.DBTTerminal, queryManifestService_1.QueryManifestService ]) ], MacroHoverProvider), 
   exports.MacroHoverProvider = MacroHoverProvider;
  },
  78635: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var ModelHoverProvider_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.ModelHoverProvider = void 0;
   const tslib_1 = __webpack_require__(31635), vscode_1 = __webpack_require__(54980), dbtProjectContainer_1 = __webpack_require__(82018), utils_1 = __webpack_require__(86185), telemetry_1 = __webpack_require__(22644), utils_2 = __webpack_require__(78026), dbtTerminal_1 = __webpack_require__(83683);
   let ModelHoverProvider = ModelHoverProvider_1 = class {
    constructor(dbtProjectContainer, telemetry, dbtTerminal) {
     this.dbtProjectContainer = dbtProjectContainer, this.telemetry = telemetry, this.dbtTerminal = dbtTerminal, 
     this.modelToLocationMap = new Map, this.disposables = [], this.disposables.push(dbtProjectContainer.onManifestChanged((event => this.onManifestCacheChanged(event))));
    }
    dispose() {
     for (;this.disposables.length; ) {
      const x = this.disposables.pop();
      x && x.dispose();
     }
    }
    getProject(uri) {
     const projectByUri = this.dbtProjectContainer.findDBTProject(uri);
     if (projectByUri) return projectByUri;
     const project = this.dbtProjectContainer.getFromWorkspaceState("dbtPowerUser.projectSelected");
     return (null == project ? void 0 : project.uri) ? this.dbtProjectContainer.findDBTProject(null == project ? void 0 : project.uri) : void 0;
    }
    provideHover(document, position, token) {
     return new Promise((resolve => {
      const hover = document.getText(document.getWordRangeAtPosition(position)), range = document.getWordRangeAtPosition(position, ModelHoverProvider_1.IS_REF);
      range || resolve(void 0);
      const word = document.getText(range), project = this.getProject(document.uri);
      if (project) {
       if (void 0 !== word && "ref" !== hover) {
        const dbtModel = word.match(ModelHoverProvider_1.GET_DBT_MODEL);
        if (dbtModel && 1 === dbtModel.length) {
         const mdString = this.getHoverMarkdownFor(dbtModel[0], project.projectRoot);
         if (void 0 !== mdString) {
          resolve(new vscode_1.Hover(mdString, new vscode_1.Range(position, position)));
         }
         return void this.telemetry.sendTelemetryEvent("provideModelHover", {
          type: "single"
         });
        }
        if (dbtModel && 3 === dbtModel.length) {
         const mdString = this.getHoverMarkdownFor(dbtModel[2], project.projectRoot);
         if (void 0 !== mdString) {
          resolve(new vscode_1.Hover(mdString, new vscode_1.Range(position, position)));
         }
         return void this.telemetry.sendTelemetryEvent("provideModelHover", {
          type: "dual"
         });
        }
       }
       resolve(void 0);
      } else this.dbtTerminal.debug("modeHoverProvider:provideHover", "Could not load hover provider, project not found in container for " + document.uri.fsPath);
     }));
    }
    onManifestCacheChanged(event) {
     var _a, _b;
     null === (_a = event.added) || void 0 === _a || _a.forEach((added => {
      this.modelToLocationMap.set(added.project.projectRoot.fsPath, added.nodeMetaMap);
     })), null === (_b = event.removed) || void 0 === _b || _b.forEach((removed => {
      this.modelToLocationMap.delete(removed.projectRoot.fsPath);
     }));
    }
    getHoverMarkdownFor(modelName, currentFilePath) {
     const projectRootpath = this.dbtProjectContainer.getProjectRootpath(currentFilePath);
     if (void 0 === projectRootpath) return;
     const nodeMap = this.modelToLocationMap.get(projectRootpath.fsPath);
     if (void 0 === nodeMap) return;
     const node = nodeMap.lookupByBaseName(modelName);
     return node ? (0, utils_2.generateHoverMarkdownString)(node, "ref") : void 0;
    }
   };
   ModelHoverProvider.IS_REF = /(ref)\([^)]*\)/, ModelHoverProvider.GET_DBT_MODEL = /(?!'|")([^(?!'|")]*)(?='|")/gi, 
   ModelHoverProvider = ModelHoverProvider_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(ModelHoverProvider_1), tslib_1.__metadata("design:paramtypes", [ dbtProjectContainer_1.DBTProjectContainer, telemetry_1.TelemetryService, dbtTerminal_1.DBTTerminal ]) ], ModelHoverProvider), 
   exports.ModelHoverProvider = ModelHoverProvider;
  },
  49891: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var SourceHoverProvider_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.SourceHoverProvider = void 0;
   const tslib_1 = __webpack_require__(31635), vscode_1 = __webpack_require__(54980), dbtProjectContainer_1 = __webpack_require__(82018), utils_1 = __webpack_require__(86185), telemetry_1 = __webpack_require__(22644), utils_2 = __webpack_require__(78026);
   let SourceHoverProvider = SourceHoverProvider_1 = class {
    constructor(dbtProjectContainer, telemetry) {
     this.dbtProjectContainer = dbtProjectContainer, this.telemetry = telemetry, this.sourceMetaMap = new Map, 
     this.disposables = [], this.disposables.push(dbtProjectContainer.onManifestChanged((event => this.onManifestCacheChanged(event))));
    }
    dispose() {
     for (;this.disposables.length; ) {
      const x = this.disposables.pop();
      x && x.dispose();
     }
    }
    provideHover(document, position, token) {
     return new Promise((resolve => {
      const hover = document.getText(document.getWordRangeAtPosition(position)), range = document.getWordRangeAtPosition(position, SourceHoverProvider_1.IS_SOURCE), word = document.getText(range), linePrefix = document.lineAt(position).text.substr(0, position.character);
      if (!(0, utils_1.isEnclosedWithinCodeBlock)(document, position) || !linePrefix.includes("source") || "source" === hover) return void resolve(void 0);
      const source = word.match(SourceHoverProvider_1.GET_SOURCE_INFO);
      if (null == source) return void resolve(void 0);
      if (source.length < 2) return void resolve(void 0);
      const mdString = this.getSourceHover(source[0], document.uri, source[1]);
      if (void 0 !== mdString) {
       resolve(new vscode_1.Hover(mdString));
      }
      this.telemetry.sendTelemetryEvent("provideSourceHover");
     }));
    }
    onManifestCacheChanged(event) {
     var _a, _b;
     null === (_a = event.added) || void 0 === _a || _a.forEach((added => {
      this.sourceMetaMap.set(added.project.projectRoot.fsPath, added.sourceMetaMap);
     })), null === (_b = event.removed) || void 0 === _b || _b.forEach((removed => {
      this.sourceMetaMap.delete(removed.projectRoot.fsPath);
     }));
    }
    getSourceHover(sourceName, currentFilePath, tableName) {
     var _a;
     const projectRootpath = this.dbtProjectContainer.getProjectRootpath(currentFilePath);
     if (void 0 === projectRootpath) return;
     const sourceMap = this.sourceMetaMap.get(projectRootpath.fsPath);
     if (void 0 === sourceMap) return;
     const node = null === (_a = sourceMap.get(sourceName)) || void 0 === _a ? void 0 : _a.tables.find((table => table.name === tableName));
     return node ? (0, utils_2.generateHoverMarkdownString)(node, "source") : void 0;
    }
   };
   SourceHoverProvider.IS_SOURCE = /(source)\([^)]*\)/, SourceHoverProvider.GET_SOURCE_INFO = /(?!['"])(\w+)(?=['"])/g, 
   SourceHoverProvider = SourceHoverProvider_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(SourceHoverProvider_1), tslib_1.__metadata("design:paramtypes", [ dbtProjectContainer_1.DBTProjectContainer, telemetry_1.TelemetryService ]) ], SourceHoverProvider), 
   exports.SourceHoverProvider = SourceHoverProvider;
  },
  78026: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.generateMacroHoverMarkdown = exports.generateHoverMarkdownString = void 0;
   const vscode_1 = __webpack_require__(54980);
   exports.generateHoverMarkdownString = function(node, nodeType) {
    const content = new vscode_1.MarkdownString;
    content.supportHtml = !0, content.isTrusted = !0, content.appendMarkdown(`<span style="color:#347890;">(${nodeType})&nbsp;</span><span><strong>${node.name}</strong></span>`), 
    "" !== node.description && content.appendMarkdown(`</br><span>${node.description}</span>`), 
    addSeparator(content);
    for (const colKey in node.columns) {
     const column = node.columns[colKey];
     content.appendMarkdown(`<span style="color:#347890;">(column)&nbsp;</span><span>${column.name} &nbsp;</span>`), 
     null !== column.data_type && content.appendMarkdown(`<span>-&nbsp;${column.data_type.toLowerCase()}</span>`), 
     "" !== column.description && content.appendMarkdown(`<br/><span><em>${column.description}</em></span>`), 
     content.appendMarkdown("</br>");
    }
    return content;
   };
   exports.generateMacroHoverMarkdown = (node, referencedBy, event) => {
    var _a, _b, _c, _d, _e;
    const content = new vscode_1.MarkdownString;
    if (content.supportHtml = !0, content.isTrusted = !0, content.appendMarkdown(`<span style="color:#347890;">(Macro)&nbsp;</span><span><strong>${node.name}</strong></span>`), 
    "" !== node.description && content.appendMarkdown(`</br><span>${node.description}</span>`), 
    addSeparator(content), null === (_a = node.arguments) || void 0 === _a || _a.forEach((macroArg => {
     content.appendMarkdown(`<span style="color:#347890;">(argument)&nbsp;</span><span>${macroArg.name} &nbsp;</span>`), 
     null !== macroArg.type && content.appendMarkdown(`<span>-&nbsp;${macroArg.type.toLowerCase()}</span>`), 
     "" !== macroArg.description && content.appendMarkdown(`<br/><span><em>${macroArg.description}</em></span>`), 
     content.appendMarkdown("</br>");
    })), referencedBy.length && (addSeparator(content), content.appendMarkdown(`<span style="color:#347890;">(Referenced by)&nbsp;</span><span>${referencedBy.map((node => buildLink(node))).join(",&nbsp;")}</span>`), 
    content.appendMarkdown("</br>")), (null === (_b = node.depends_on.macros) || void 0 === _b ? void 0 : _b.length) || (null === (_c = node.depends_on.nodes) || void 0 === _c ? void 0 : _c.length)) {
     const dependsOn = [ ...(null === (_d = node.depends_on.macros) || void 0 === _d ? void 0 : _d.map((m => [ ...event.macroMetaMap.values() ].find((macro => macro.uniqueId === m))))) || [], ...(null === (_e = node.depends_on.nodes) || void 0 === _e ? void 0 : _e.map((m => [ ...event.nodeMetaMap.nodes() ].find((macro => macro.uniqueId === m))))) || [] ];
     addSeparator(content), content.appendMarkdown(`<span style="color:#347890;">(Depends on)&nbsp;</span><span>${dependsOn.map((node => buildLink(node))).join(",&nbsp;")}</span>`);
    }
    return content;
   };
   const addSeparator = content => {
    content.appendText("\n"), content.appendText("\n"), content.appendMarkdown("---"), 
    content.appendText("\n"), content.appendText("\n");
   }, buildLink = node => {
    if (node) return node.path ? `[${node.name}](${vscode_1.Uri.file(node.path)} "${node.uniqueId}")` : node.name;
   };
  },
  49757: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.container = void 0;
   const inversify_1 = __webpack_require__(25891), inversify_binding_decorators_1 = __webpack_require__(25567), dbtTerminal_1 = __webpack_require__(83683), dbtProject_1 = __webpack_require__(38821), dbtProjectContainer_1 = __webpack_require__(82018), dbtWorkspaceFolder_1 = __webpack_require__(7881), dbtProjectLog_1 = __webpack_require__(75717), sourceFileWatchers_1 = __webpack_require__(29390), targetWatchers_1 = __webpack_require__(55216), pythonEnvironment_1 = __webpack_require__(88103), telemetry_1 = __webpack_require__(22644), dbtCoreIntegration_1 = __webpack_require__(71636), dbtIntegration_1 = __webpack_require__(22373), dbtCloudIntegration_1 = __webpack_require__(54958), commandProcessExecution_1 = __webpack_require__(7824), altimate_1 = __webpack_require__(91741), validation_provider_1 = __webpack_require__(79262), deferToProdService_1 = __webpack_require__(2826), sharedStateService_1 = __webpack_require__(37712), _lib_1 = __webpack_require__(17176);
   exports.container = new inversify_1.Container, exports.container.load((0, inversify_binding_decorators_1.buildProviderModule)()), 
   exports.container.bind("Factory<DBTWorkspaceFolder>").toFactory((context => (workspaceFolder, _onManifestChanged, _onProjectRegisteredUnregistered) => {
    const {container} = context;
    return new dbtWorkspaceFolder_1.DBTWorkspaceFolder(container.get("Factory<DBTProject>"), container.get(dbtCoreIntegration_1.DBTCoreProjectDetection), container.get(dbtCloudIntegration_1.DBTCloudProjectDetection), container.get(telemetry_1.TelemetryService), container.get(dbtTerminal_1.DBTTerminal), workspaceFolder, _onManifestChanged, _onProjectRegisteredUnregistered);
   })), exports.container.bind("Factory<DBTCoreProjectIntegration>").toFactory((context => (projectRoot, projectConfigDiagnostics) => {
    const {container} = context;
    return new dbtCoreIntegration_1.DBTCoreProjectIntegration(container.get(dbtIntegration_1.DBTCommandExecutionInfrastructure), container.get(pythonEnvironment_1.PythonEnvironment), container.get(telemetry_1.TelemetryService), container.get(dbtIntegration_1.PythonDBTCommandExecutionStrategy), container.get(dbtProjectContainer_1.DBTProjectContainer), container.get(altimate_1.AltimateRequest), container.get(dbtTerminal_1.DBTTerminal), container.get(validation_provider_1.ValidationProvider), container.get(deferToProdService_1.DeferToProdService), projectRoot, projectConfigDiagnostics);
   })), exports.container.bind("Factory<CLIDBTCommandExecutionStrategy>").toFactory((context => (projectRoot, dbtPath) => {
    const {container} = context;
    return new dbtIntegration_1.CLIDBTCommandExecutionStrategy(container.get(commandProcessExecution_1.CommandProcessExecutionFactory), container.get(pythonEnvironment_1.PythonEnvironment), container.get(dbtTerminal_1.DBTTerminal), container.get(telemetry_1.TelemetryService), projectRoot, dbtPath);
   })), exports.container.bind("Factory<DBTCloudProjectIntegration>").toFactory((context => projectRoot => {
    const {container} = context;
    return new dbtCloudIntegration_1.DBTCloudProjectIntegration(container.get(dbtIntegration_1.DBTCommandExecutionInfrastructure), container.get(dbtIntegration_1.DBTCommandFactory), container.get("Factory<CLIDBTCommandExecutionStrategy>"), container.get(telemetry_1.TelemetryService), container.get(pythonEnvironment_1.PythonEnvironment), container.get(dbtTerminal_1.DBTTerminal), container.get(validation_provider_1.ValidationProvider), container.get(deferToProdService_1.DeferToProdService), projectRoot);
   })), exports.container.bind("Factory<DBTProject>").toFactory((context => (path, projectConfig, _onManifestChanged) => {
    const {container} = context;
    return new dbtProject_1.DBTProject(container.get(pythonEnvironment_1.PythonEnvironment), container.get(sourceFileWatchers_1.SourceFileWatchersFactory), container.get(dbtProjectLog_1.DBTProjectLogFactory), container.get(targetWatchers_1.TargetWatchersFactory), container.get(dbtIntegration_1.DBTCommandFactory), container.get(dbtTerminal_1.DBTTerminal), container.get(sharedStateService_1.SharedStateService), container.get(telemetry_1.TelemetryService), container.get("Factory<DBTCoreProjectIntegration>"), container.get("Factory<DBTCloudProjectIntegration>"), container.get(altimate_1.AltimateRequest), container.get(validation_provider_1.ValidationProvider), path, projectConfig, _onManifestChanged);
   })), exports.container.bind("Factory<NotebookClient>").toFactory((context => path => {
    const {container} = context;
    return new _lib_1.NotebookKernelClient(path, container.get(dbtIntegration_1.DBTCommandExecutionInfrastructure), container.get(_lib_1.NotebookDependencies), container.get(dbtTerminal_1.DBTTerminal));
   }));
  },
  38821: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.DBTProject = void 0;
   const tslib_1 = __webpack_require__(31635), fs_1 = __webpack_require__(79896), path = __webpack_require__(16928), python_bridge_1 = __webpack_require__(63283), vscode_1 = __webpack_require__(54980), yaml_1 = __webpack_require__(91198), utils_1 = __webpack_require__(86185), projectConfigChangedEvent_1 = __webpack_require__(49984), crypto = __webpack_require__(76982), altimate_1 = __webpack_require__(91741), events_1 = __webpack_require__(91723);
   class DBTProject {
    constructor(PythonEnvironment, sourceFileWatchersFactory, dbtProjectLogFactory, targetWatchersFactory, dbtCommandFactory, terminal, eventEmitterService, telemetry, dbtCoreIntegrationFactory, dbtCloudIntegrationFactory, altimate, validationProvider, path, projectConfig, _onManifestChanged) {
     this.PythonEnvironment = PythonEnvironment, this.sourceFileWatchersFactory = sourceFileWatchersFactory, 
     this.dbtProjectLogFactory = dbtProjectLogFactory, this.targetWatchersFactory = targetWatchersFactory, 
     this.dbtCommandFactory = dbtCommandFactory, this.terminal = terminal, this.eventEmitterService = eventEmitterService, 
     this.telemetry = telemetry, this.dbtCoreIntegrationFactory = dbtCoreIntegrationFactory, 
     this.dbtCloudIntegrationFactory = dbtCloudIntegrationFactory, this.altimate = altimate, 
     this.validationProvider = validationProvider, this._onProjectConfigChanged = new vscode_1.EventEmitter, 
     this.onProjectConfigChanged = this._onProjectConfigChanged.event, this._onRunResults = new vscode_1.EventEmitter, 
     this.onRunResults = this._onRunResults.event, this.disposables = [ this._onProjectConfigChanged ], 
     this.projectConfigDiagnostics = vscode_1.languages.createDiagnosticCollection("dbt"), 
     this.projectHealth = vscode_1.languages.createDiagnosticCollection("dbt"), this._onRebuildManifestStatusChange = new vscode_1.EventEmitter, 
     this.onRebuildManifestStatusChange = this._onRebuildManifestStatusChange.event, 
     this.dbSchemaCache = {}, this.projectRoot = path, this.projectConfig = projectConfig, 
     this.validationProvider.validateCredentialsSilently(), this.sourceFileWatchers = this.sourceFileWatchersFactory.createSourceFileWatchers(this.onProjectConfigChanged), 
     this.onSourceFileChanged = this.sourceFileWatchers.onSourceFileChanged;
     const dbtIntegrationMode = vscode_1.workspace.getConfiguration("dbt").get("dbtIntegration", "core");
     if ("cloud" === dbtIntegrationMode) this.dbtProjectIntegration = this.dbtCloudIntegrationFactory(this.projectRoot); else this.dbtProjectIntegration = this.dbtCoreIntegrationFactory(this.projectRoot, this.projectConfigDiagnostics);
     this.disposables.push(this.dbtProjectIntegration, this.targetWatchersFactory.createTargetWatchers(_onManifestChanged, this._onRunResults, this.onProjectConfigChanged), this.PythonEnvironment.onPythonEnvironmentChanged((() => this.onPythonEnvironmentChanged())), this.sourceFileWatchers, this.projectConfigDiagnostics, this.onRunResults((event => {
      this.invalidateCacheUsingLastRun(event.file);
     }))), this.terminal.debug("DbtProject", `Created ${dbtIntegrationMode} dbt project ${this.getProjectName()} at ${this.projectRoot}`);
    }
    invalidateCacheUsingLastRun(file) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const fileContent = (0, fs_1.readFileSync)(file.fsPath, "utf8").toString();
      if (fileContent) try {
       const runResults = JSON.parse(fileContent);
       for (const n of runResults.results) n.unique_id in this.dbSchemaCache && delete this.dbSchemaCache[n.unique_id];
      } catch (e) {
       this.terminal.error("invalidateCacheUsingLastRun", `Unable to parse run_results.json ${e}`, e, !0);
      }
     }));
    }
    getProjectName() {
     return this.dbtProjectIntegration.getProjectName();
    }
    getSelectedTarget() {
     return this.dbtProjectIntegration.getSelectedTarget();
    }
    getTargetNames() {
     return this.dbtProjectIntegration.getTargetNames();
    }
    setSelectedTarget(targetName) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      yield vscode_1.window.withProgress({
       location: vscode_1.ProgressLocation.Notification,
       title: "Changing target...",
       cancellable: !1
      }, (() => tslib_1.__awaiter(this, void 0, void 0, (function*() {
       yield this.dbtProjectIntegration.setSelectedTarget(targetName), yield this.dbtProjectIntegration.applySelectedTarget();
      }))));
     }));
    }
    getDBTProjectFilePath() {
     return path.join(this.projectRoot.fsPath, DBTProject.DBT_PROJECT_FILE);
    }
    getTargetPath() {
     return this.dbtProjectIntegration.getTargetPath();
    }
    getPackageInstallPath() {
     return this.dbtProjectIntegration.getPackageInstallPath();
    }
    getModelPaths() {
     return this.dbtProjectIntegration.getModelPaths();
    }
    getSeedPaths() {
     return this.dbtProjectIntegration.getSeedPaths();
    }
    getMacroPaths() {
     return this.dbtProjectIntegration.getMacroPaths();
    }
    getManifestPath() {
     const targetPath = this.getTargetPath();
     if (targetPath) return path.join(targetPath, DBTProject.MANIFEST_FILE);
    }
    getCatalogPath() {
     const targetPath = this.getTargetPath();
     if (targetPath) return path.join(targetPath, DBTProject.CATALOG_FILE);
    }
    getPythonBridgeStatus() {
     return this.dbtProjectIntegration.getPythonBridgeStatus();
    }
    getAllDiagnostic() {
     return this.dbtProjectIntegration.getAllDiagnostic();
    }
    performDatapilotHealthcheck(args) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const manifestPath = this.getManifestPath();
      if (!manifestPath) throw new Error(`Unable to find manifest path for project ${this.getProjectName()}`);
      const healthcheckArgs = {
       manifestPath
      };
      if ("Manual" === args.configType) healthcheckArgs.configPath = args.configPath; else if ("Saas" === args.configType && (healthcheckArgs.config = args.config), 
      "All" === args.configType || args.config_schema.some((i => i.files_required.includes("Catalog")))) {
       const docsGenerateCommand = this.dbtCommandFactory.createDocsGenerateCommand();
       if (docsGenerateCommand.focus = !1, docsGenerateCommand.logToTerminal = !1, docsGenerateCommand.showProgress = !1, 
       yield this.dbtProjectIntegration.executeCommandImmediately(docsGenerateCommand), 
       healthcheckArgs.catalogPath = this.getCatalogPath(), !healthcheckArgs.catalogPath) throw new Error(`Unable to find catalog path for project ${this.getProjectName()}`);
      }
      this.terminal.debug("performDatapilotHealthcheck", "Performing healthcheck", healthcheckArgs);
      const projectHealthcheck = yield this.dbtProjectIntegration.performDatapilotHealthcheck(healthcheckArgs);
      for (const key in projectHealthcheck.model_insights) for (const item of projectHealthcheck.model_insights[key]) item.path = path.join(this.projectRoot.fsPath, item.original_file_path);
      return projectHealthcheck;
     }));
    }
    initialize() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const dbtProjectConfigWatcher = vscode_1.workspace.createFileSystemWatcher(new vscode_1.RelativePattern(this.projectRoot, DBTProject.DBT_PROJECT_FILE));
      (0, utils_1.setupWatcherHandler)(dbtProjectConfigWatcher, (() => tslib_1.__awaiter(this, void 0, void 0, (function*() {
       yield this.refreshProjectConfig(), this.rebuildManifest();
      })))), yield this.dbtProjectIntegration.initializeProject(), yield this.refreshProjectConfig(), 
      this.rebuildManifest(), this.dbtProjectLog = this.dbtProjectLogFactory.createDBTProjectLog(this.onProjectConfigChanged), 
      this.disposables.push(this.dbtProjectLog, dbtProjectConfigWatcher, this.onSourceFileChanged((0, 
      utils_1.debounce)((() => tslib_1.__awaiter(this, void 0, void 0, (function*() {
       this.terminal.debug("DBTProject", `SourceFileChanged event fired for "${this.getProjectName()}" at ${this.projectRoot}`), 
       yield this.rebuildManifest();
      }))), this.dbtProjectIntegration.getDebounceForRebuildManifest()))), this.terminal.debug("DbtProject", `Initialized dbt project ${this.getProjectName()} at ${this.projectRoot}`);
     }));
    }
    onPythonEnvironmentChanged() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.terminal.debug("DbtProject", `Python environment for dbt project ${this.getProjectName()} at ${this.projectRoot} has changed`), 
      yield this.initialize();
     }));
    }
    refreshProjectConfig() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.terminal.debug("DBTProject", `Going to refresh the project "${this.getProjectName()}" at ${this.projectRoot} configuration`);
      try {
       this.projectConfig = DBTProject.readAndParseProjectConfig(this.projectRoot), yield this.dbtProjectIntegration.refreshProjectConfig(), 
       this.projectConfigDiagnostics.clear();
      } catch (error) {
       error instanceof yaml_1.YAMLError ? this.projectConfigDiagnostics.set(vscode_1.Uri.joinPath(this.projectRoot, DBTProject.DBT_PROJECT_FILE), [ new vscode_1.Diagnostic(new vscode_1.Range(0, 0, 999, 999), "dbt_project.yml is invalid : " + error.message) ]) : error instanceof python_bridge_1.PythonException && this.projectConfigDiagnostics.set(vscode_1.Uri.joinPath(this.projectRoot, DBTProject.DBT_PROJECT_FILE), [ new vscode_1.Diagnostic(new vscode_1.Range(0, 0, 999, 999), "dbt configuration is invalid : " + error.exception.message) ]), 
       this.terminal.debug("DBTProject", `An error occurred while trying to refresh the project "${this.getProjectName()}" at ${this.projectRoot} configuration`, error), 
       this.telemetry.sendTelemetryError("projectConfigRefreshError", error);
      }
      const sourcePaths = this.getModelPaths();
      void 0 === sourcePaths && this.terminal.debug("DBTProject", "sourcePaths is not defined in project in " + this.projectRoot.fsPath);
      const macroPaths = this.getMacroPaths();
      void 0 === macroPaths && this.terminal.debug("DBTProject", "macroPaths is not defined in " + this.projectRoot.fsPath);
      const seedPaths = this.getSeedPaths();
      if (void 0 === seedPaths && this.terminal.debug("DBTProject", "macroPaths is not defined in " + this.projectRoot.fsPath), 
      sourcePaths && macroPaths && seedPaths) {
       const event = new projectConfigChangedEvent_1.ProjectConfigChangedEvent(this);
       this._onProjectConfigChanged.fire(event), this.terminal.debug("DBTProject", `firing ProjectConfigChanged event for the project "${this.getProjectName()}" at ${this.projectRoot} configuration`, "targetPaths", this.getTargetPath(), "modelPaths", this.getModelPaths(), "seedPaths", this.getSeedPaths(), "macroPaths", this.getMacroPaths(), "packagesInstallPath", this.getPackageInstallPath(), "version", this.getDBTVersion(), "adapterType", this.getAdapterType());
      } else this.terminal.warn("DBTProject", "Could not send out ProjectConfigChangedEvent because project is not initialized properly. dbt path settings cannot be determined");
     }));
    }
    getAdapterType() {
     return this.dbtProjectIntegration.getAdapterType() || "unknown";
    }
    findPackageName(uri) {
     const pathSegments = uri.path.replace(new RegExp(this.projectRoot.path + "/", "g"), "").split("/"), packagesInstallPath = this.getPackageInstallPath();
     if (packagesInstallPath && uri.fsPath.startsWith(packagesInstallPath)) return pathSegments[1];
    }
    contains(uri) {
     return uri.fsPath === this.projectRoot.fsPath || uri.fsPath.startsWith(this.projectRoot.fsPath + path.sep);
    }
    rebuildManifest() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.terminal.debug("DBTProject", `Going to rebuild the manifest for "${this.getProjectName()}" at ${this.projectRoot}`), 
      this._onRebuildManifestStatusChange.fire({
       project: this,
       inProgress: !0
      }), yield this.dbtProjectIntegration.rebuildManifest(), this._onRebuildManifestStatusChange.fire({
       project: this,
       inProgress: !1
      }), this.terminal.debug("DBTProject", `Finished rebuilding the manifest for "${this.getProjectName()}" at ${this.projectRoot}`);
     }));
    }
    runModel(runModelParams) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      try {
       const runModelCommand = this.dbtCommandFactory.createRunModelCommand(runModelParams);
       yield this.dbtProjectIntegration.runModel(runModelCommand), this.telemetry.sendTelemetryEvent("runModel");
      } catch (error) {
       this.handleNoCredentialsError(error);
      }
     }));
    }
    buildModel(runModelParams) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      try {
       const buildModelCommand = this.dbtCommandFactory.createBuildModelCommand(runModelParams);
       yield this.dbtProjectIntegration.buildModel(buildModelCommand), this.telemetry.sendTelemetryEvent("buildModel");
      } catch (error) {
       this.handleNoCredentialsError(error);
      }
     }));
    }
    buildProject() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      try {
       const buildProjectCommand = this.dbtCommandFactory.createBuildProjectCommand();
       yield this.dbtProjectIntegration.buildProject(buildProjectCommand), this.telemetry.sendTelemetryEvent("buildProject");
      } catch (error) {
       this.handleNoCredentialsError(error);
      }
     }));
    }
    runTest(testName) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      try {
       const testModelCommand = this.dbtCommandFactory.createTestModelCommand(testName);
       yield this.dbtProjectIntegration.runTest(testModelCommand), this.telemetry.sendTelemetryEvent("runTest");
      } catch (error) {
       this.handleNoCredentialsError(error);
      }
     }));
    }
    runModelTest(modelName) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      try {
       const testModelCommand = this.dbtCommandFactory.createTestModelCommand(modelName);
       this.dbtProjectIntegration.runModelTest(testModelCommand), yield this.telemetry.sendTelemetryEvent("runModelTest");
      } catch (error) {
       this.handleNoCredentialsError(error);
      }
     }));
    }
    handleNoCredentialsError(error) {
     error instanceof altimate_1.NoCredentialsError ? this.altimate.handlePreviewFeatures() : vscode_1.window.showErrorMessage(error.message);
    }
    compileModel(runModelParams) {
     const compileModelCommand = this.dbtCommandFactory.createCompileModelCommand(runModelParams);
     this.dbtProjectIntegration.compileModel(compileModelCommand), this.telemetry.sendTelemetryEvent("compileModel");
    }
    generateDocsImmediately(args) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const docsGenerateCommand = this.dbtCommandFactory.createDocsGenerateCommand();
      null == args || args.forEach((arg => docsGenerateCommand.addArgument(arg))), docsGenerateCommand.focus = !1, 
      docsGenerateCommand.logToTerminal = !1, yield this.dbtProjectIntegration.executeCommandImmediately(docsGenerateCommand), 
      this.telemetry.sendTelemetryEvent("generateDocsImmediately");
     }));
    }
    generateDocs() {
     const docsGenerateCommand = this.dbtCommandFactory.createDocsGenerateCommand();
     this.dbtProjectIntegration.generateDocs(docsGenerateCommand), this.telemetry.sendTelemetryEvent("generateDocs");
    }
    debug() {
     const debugCommand = this.dbtCommandFactory.createDebugCommand();
     return this.telemetry.sendTelemetryEvent("debug"), this.dbtProjectIntegration.debug(debugCommand);
    }
    installDbtPackages(packages) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.telemetry.sendTelemetryEvent("installDbtPackages");
      const installPackagesCommand = this.dbtCommandFactory.createAddPackagesCommand(packages);
      return yield this.dbtProjectIntegration.deps(installPackagesCommand), yield this.dbtProjectIntegration.deps(this.dbtCommandFactory.createInstallDepsCommand());
     }));
    }
    installDeps() {
     this.telemetry.sendTelemetryEvent("installDeps");
     const installDepsCommand = this.dbtCommandFactory.createInstallDepsCommand();
     return this.dbtProjectIntegration.deps(installDepsCommand);
    }
    compileNode(modelName) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.telemetry.sendTelemetryEvent("compileNode");
      try {
       return yield this.dbtProjectIntegration.unsafeCompileNode(modelName);
      } catch (exc) {
       return exc instanceof python_bridge_1.PythonException ? (vscode_1.window.showErrorMessage((0, 
       utils_1.extendErrorWithSupportLinks)(`An error occured while trying to compile your node: ${modelName}` + exc.exception.message + ".")), 
       this.telemetry.sendTelemetryError("compileNodePythonError", exc), "Exception: " + exc.exception.message + "\n\nDetailed error information:\n" + exc) : (this.telemetry.sendTelemetryError("compileNodeUnknownError", exc), 
       vscode_1.window.showErrorMessage((0, utils_1.extendErrorWithSupportLinks)("Could not compile model " + modelName + ": " + exc.message + ".")), 
       "Detailed error information:\n" + exc);
      }
     }));
    }
    unsafeCompileNode(modelName) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      return this.telemetry.sendTelemetryEvent("unsafeCompileNode"), yield this.dbtProjectIntegration.unsafeCompileNode(modelName);
     }));
    }
    validateSql(request) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      try {
       const {sql, dialect, models} = request;
       return this.dbtProjectIntegration.validateSql(sql, dialect, models);
      } catch (exc) {
       vscode_1.window.showErrorMessage((0, utils_1.extendErrorWithSupportLinks)("Could not validate sql." + exc)), 
       this.telemetry.sendTelemetryError("validateSQLError", {
        error: exc
       });
      }
     }));
    }
    validateSQLDryRun(query) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      try {
       return this.dbtProjectIntegration.validateSQLDryRun(query);
      } catch (exc) {
       const exception = exc;
       vscode_1.window.showErrorMessage(exception.exception.message || "Could not validate sql with dry run."), 
       this.telemetry.sendTelemetryError("validateSQLDryRunError", {
        error: exc
       });
      }
     }));
    }
    getDBTVersion() {
     try {
      return this.dbtProjectIntegration.getVersion();
     } catch (exc) {
      vscode_1.window.showErrorMessage((0, utils_1.extendErrorWithSupportLinks)("Could not get dbt version." + exc)), 
      this.telemetry.sendTelemetryError("getDBTVersionError", {
       error: exc
      });
     }
    }
    compileQuery(query, originalModelName = void 0) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.telemetry.sendTelemetryEvent("compileQuery");
      try {
       return yield this.dbtProjectIntegration.unsafeCompileQuery(query, originalModelName);
      } catch (exc) {
       return exc instanceof python_bridge_1.PythonException ? (vscode_1.window.showErrorMessage((0, 
       utils_1.extendErrorWithSupportLinks)("An error occured while trying to compile your query: " + exc.exception.message + ".")), 
       void this.telemetry.sendTelemetryError("compileQueryPythonError", exc)) : (this.telemetry.sendTelemetryError("compileQueryUnknownError", exc), 
       void vscode_1.window.showErrorMessage((0, utils_1.extendErrorWithSupportLinks)("Could not compile query: " + exc.message)));
      }
     }));
    }
    showCompiledSql(modelPath) {
     this.findModelInTargetfolder(modelPath, "compiled");
    }
    showRunSQL(modelPath) {
     this.findModelInTargetfolder(modelPath, "run");
    }
    createYMLContent(columnsInRelation, modelName) {
     let yamlString = "version: 2\n\nmodels:\n";
     yamlString += `  - name: ${modelName}\n    description: ""\n    columns:\n`;
     for (const item of columnsInRelation) yamlString += `    - name: ${item.column}\n      description: ""\n`;
     return yamlString;
    }
    unsafeCompileQuery(query, originalModelName = void 0) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      return this.dbtProjectIntegration.unsafeCompileQuery(query, originalModelName);
     }));
    }
    getColumnsOfModel(modelName) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      return this.dbtProjectIntegration.getColumnsOfModel(modelName);
     }));
    }
    getColumnsOfSource(sourceName, tableName) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      return this.dbtProjectIntegration.getColumnsOfSource(sourceName, tableName);
     }));
    }
    getColumnValues(model, column) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.telemetry.startTelemetryEvent(events_1.TelemetryEvents["DocumentationEditor/GetDistinctColumnValues"], {
       column,
       model
      });
      try {
       this.terminal.debug("getColumnValues", "finding distinct values for column", !0, {
        model,
        column
       });
       const query = `select ${column} from {{ ref('${model}')}} group by ${column}`, queryExecution = yield this.dbtProjectIntegration.executeSQL(query, 100, model), result = yield queryExecution.executeQuery();
       return this.telemetry.endTelemetryEvent(events_1.TelemetryEvents["DocumentationEditor/GetDistinctColumnValues"], void 0, {
        column,
        model
       }), result.table.rows.flat();
      } catch (error) {
       this.telemetry.endTelemetryEvent(events_1.TelemetryEvents["DocumentationEditor/GetDistinctColumnValues"], error, {
        column,
        model
       });
      }
     }));
    }
    getBulkSchemaFromDB(req, cancellationToken) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      return this.dbtProjectIntegration.getBulkSchemaFromDB(req, cancellationToken);
     }));
    }
    validateWhetherSqlHasColumns(sql) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const dialect = this.getAdapterType();
      try {
       return yield this.dbtProjectIntegration.validateWhetherSqlHasColumns(sql, dialect);
      } catch (e) {
       return this.terminal.error("validateWhetherSqlHasColumnsError", "Error while validating whether sql has columns", e, !0), 
       !1;
      }
     }));
    }
    getCatalog() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      try {
       return this.dbtProjectIntegration.getCatalog();
      } catch (exc) {
       return exc instanceof python_bridge_1.PythonException ? (this.telemetry.sendTelemetryError("catalogPythonError", exc, {
        adapter: this.getAdapterType()
       }), vscode_1.window.showErrorMessage("Some of the scans could not run as connectivity to database for the project " + this.getProjectName() + " is not available. "), 
       []) : (this.telemetry.sendTelemetryError("catalogUnknownError", exc, {
        adapter: this.getAdapterType()
       }), vscode_1.window.showErrorMessage("Some of the scans could not run as connectivity to database for the project " + this.getProjectName() + " is not available. "), 
       []);
      }
     }));
    }
    generateSchemaYML(modelPath, modelName) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      try {
       const currentDir = path.dirname(modelPath.fsPath), location = path.join(currentDir, modelName + "_schema.yml");
       if ((0, fs_1.existsSync)(location)) vscode_1.window.showErrorMessage(`A file called ${modelName}_schema.yml already exists in ${currentDir}. If you want to generate the schema yml, please rename the other file or delete it if you want to generate the yml again.`); else {
        this.telemetry.sendTelemetryEvent("generateSchemaYML", {
         adapter: this.getAdapterType()
        });
        const columnsInRelation = yield this.getColumnsOfModel(modelName), fileContents = this.createYMLContent(columnsInRelation, modelName);
        (0, fs_1.writeFileSync)(location, fileContents);
        const doc = yield vscode_1.workspace.openTextDocument(vscode_1.Uri.file(location));
        vscode_1.window.showTextDocument(doc);
       }
      } catch (exc) {
       exc instanceof python_bridge_1.PythonException && (this.telemetry.sendTelemetryError("generateSchemaYMLPythonError", exc, {
        adapter: this.getAdapterType()
       }), vscode_1.window.showErrorMessage((0, utils_1.extendErrorWithSupportLinks)("An error occured while trying to generate the schema yml " + exc.exception.message + "."))), 
       this.telemetry.sendTelemetryError("generateSchemaYMLUnknownError", exc, {
        adapter: this.getAdapterType()
       }), vscode_1.window.showErrorMessage((0, utils_1.extendErrorWithSupportLinks)("Could not generate schema yaml: " + exc.message));
      }
     }));
    }
    generateModel(sourceName, tableName, sourcePath) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      try {
       const prefix = vscode_1.workspace.getConfiguration("dbt").get("prefixGenerateModel", "base"), fileNameTemplateMap = {
        "{prefix}_{sourceName}_{tableName}": `${prefix}_${sourceName}_${tableName}`,
        "{prefix}_{sourceName}__{tableName}": `${prefix}_${sourceName}__${tableName}`,
        "{prefix}_{tableName}": `${prefix}_${tableName}`,
        "{tableName}": `${tableName}`
       };
       let fileName = `${prefix}_${sourceName}_${tableName}`;
       const fileNameTemplate = vscode_1.workspace.getConfiguration("dbt").get("fileNameTemplateGenerateModel", "{prefix}_{sourceName}_{tableName}");
       this.telemetry.sendTelemetryEvent("generateModel", {
        prefix,
        filenametemplate: fileNameTemplate,
        adapter: this.getAdapterType()
       }), fileNameTemplate in fileNameTemplateMap && (fileName = fileNameTemplateMap[fileNameTemplate]);
       const location = path.join(sourcePath, fileName + ".sql");
       if ((0, fs_1.existsSync)(location)) vscode_1.window.showErrorMessage(`A model called ${fileName} already exists in ${sourcePath}. If you want to generate the model, please rename the other model or delete it if you want to generate the model again.`); else {
        const columnsInRelation = yield this.getColumnsOfSource(sourceName, tableName);
        this.terminal.debug("dbtProject:generateModel", `Generating columns for source ${sourceName} and table ${tableName}`, columnsInRelation);
        const fileContents = `with source as (\n      select * from {{ source('${sourceName}', '${tableName}') }}\n),\nrenamed as (\n    select\n        ${columnsInRelation.map((column => `{{ adapter.quote("${column.column}") }}`)).join(",\n        ")}\n\n    from source\n)\nselect * from renamed\n  `;
        (0, fs_1.writeFileSync)(location, fileContents);
        const doc = yield vscode_1.workspace.openTextDocument(vscode_1.Uri.file(location));
        vscode_1.window.showTextDocument(doc);
       }
      } catch (exc) {
       exc instanceof python_bridge_1.PythonException && (this.telemetry.sendTelemetryError("generateModelPythonError", exc, {
        adapter: this.getAdapterType()
       }), vscode_1.window.showErrorMessage("An error occured while trying to generate the model " + exc.exception.message)), 
       this.telemetry.sendTelemetryError("generateModelUnknownError", exc, {
        adapter: this.getAdapterType()
       }), vscode_1.window.showErrorMessage((0, utils_1.extendErrorWithSupportLinks)("An error occured while trying to generate the model:" + exc + "."));
      }
     }));
    }
    executeSQL(query, modelName, returnImmediately) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      query = query.replace(/;\s*$/, "");
      const limit = vscode_1.workspace.getConfiguration("dbt").get("queryLimit", 500);
      if (limit <= 0) vscode_1.window.showErrorMessage("Please enter a positive number for query limit"); else {
       if (this.telemetry.sendTelemetryEvent("executeSQL", {
        adapter: this.getAdapterType(),
        limit: limit.toString()
       }), this.terminal.debug("executeSQL", query, {
        adapter: this.getAdapterType(),
        limit: limit.toString()
       }), returnImmediately) {
        const execution = yield this.dbtProjectIntegration.executeSQL(query, limit, modelName), result = yield execution.executeQuery(), rows = [];
        for (let i = 0; i < result.table.rows.length; i++) result.table.rows[i].forEach(((value, j) => {
         rows[i] = Object.assign(Object.assign({}, rows[i]), {
          [result.table.column_names[j]]: value
         });
        }));
        return {
         columnNames: result.table.column_names,
         columnTypes: result.table.column_types,
         data: rows,
         raw_sql: query,
         compiled_sql: result.compiled_sql
        };
       }
       this.eventEmitterService.fire({
        command: "executeQuery",
        payload: {
         query,
         fn: this.dbtProjectIntegration.executeSQL(query, limit, modelName),
         projectName: this.getProjectName()
        }
       });
      }
     }));
    }
    dispose() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      for (;this.disposables.length; ) {
       const x = this.disposables.pop();
       x && x.dispose();
      }
     }));
    }
    static readAndParseProjectConfig(projectRoot) {
     const dbtProjectConfigLocation = path.join(projectRoot.fsPath, DBTProject.DBT_PROJECT_FILE), dbtProjectYamlFile = (0, 
     fs_1.readFileSync)(dbtProjectConfigLocation, "utf8");
     return (0, yaml_1.parse)(dbtProjectYamlFile, {
      strict: !1,
      uniqueKeys: !1,
      maxAliasCount: -1
     });
    }
    static hashProjectRoot(projectRoot) {
     return crypto.createHash("md5").update(projectRoot).digest("hex");
    }
    findModelInTargetfolder(modelPath, type) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const targetPath = this.getTargetPath();
      if (!targetPath) return;
      const relativePath = path.relative(this.projectRoot.fsPath, modelPath.fsPath), targetModels = yield vscode_1.workspace.findFiles(new vscode_1.RelativePattern(targetPath, path.join(type, "**", relativePath)));
      targetModels.length > 0 && vscode_1.commands.executeCommand("vscode.open", targetModels[0], {
       preview: !1,
       preserveFocus: !0,
       viewColumn: vscode_1.ViewColumn.Beside
      });
     }));
    }
    static isResourceNode(resource_type) {
     return resource_type === DBTProject.RESOURCE_TYPE_MODEL || resource_type === DBTProject.RESOURCE_TYPE_SEED || resource_type === DBTProject.RESOURCE_TYPE_ANALYSIS || resource_type === DBTProject.RESOURCE_TYPE_SNAPSHOT;
    }
    static isResourceHasDbColumns(resource_type) {
     return resource_type === DBTProject.RESOURCE_TYPE_MODEL || resource_type === DBTProject.RESOURCE_TYPE_SEED || resource_type === DBTProject.RESOURCE_TYPE_SNAPSHOT;
    }
    static getNonEphemeralParents(event, keys) {
     var _a;
     const {nodeMetaMap, graphMetaMap} = event, {parents} = graphMetaMap, parentSet = new Set, queue = keys, visited = {};
     for (;queue.length > 0; ) {
      const curr = queue.shift();
      if (visited[curr]) continue;
      visited[curr] = !0;
      const parent = parents.get(curr);
      if (parent) for (const n of parent.nodes) {
       n.key.split(".")[0] === DBTProject.RESOURCE_TYPE_MODEL ? "ephemeral" === (null === (_a = nodeMetaMap.lookupByUniqueId(n.key)) || void 0 === _a ? void 0 : _a.config.materialized) ? queue.push(n.key) : parentSet.add(n.key) : parentSet.add(n.key);
      }
     }
     return Array.from(parentSet);
    }
    mergeColumnsFromDB(node, columnsFromDB) {
     var _a, _b;
     if (!columnsFromDB || 0 === columnsFromDB.length) return !1;
     columnsFromDB.length > 100 && this.telemetry.sendTelemetryEvent("excessiveColumnsFetchedFromDB");
     const columnsFromManifest = {};
     Object.entries(node.columns).forEach((([k, v]) => {
      columnsFromManifest[(0, utils_1.getColumnNameByCase)(k, this.getAdapterType())] = v;
     }));
     for (const c of columnsFromDB) {
      const columnNameFromDB = (0, utils_1.getColumnNameByCase)(c.column, this.getAdapterType()), existing_column = columnsFromManifest[columnNameFromDB];
      existing_column ? existing_column.data_type = null === (_a = existing_column.data_type || c.dtype) || void 0 === _a ? void 0 : _a.toLowerCase() : node.columns[columnNameFromDB] = {
       name: columnNameFromDB,
       data_type: null === (_b = c.dtype) || void 0 === _b ? void 0 : _b.toLowerCase(),
       description: ""
      };
     }
     return Object.keys(node.columns).length > columnsFromDB.length && this.telemetry.sendTelemetryEvent("possibleStaleSchema"), 
     !0;
    }
    findPackageVersion(packageName) {
     const version = this.dbtProjectIntegration.findPackageVersion(packageName);
     return this.terminal.debug("dbtProject:findPackageVersion", `found ${packageName} version: ${version}`), 
     version;
    }
    getBulkCompiledSql(event, models) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      if (0 === models.length) return {};
      const {nodeMetaMap} = event;
      return this.dbtProjectIntegration.getBulkCompiledSQL(models.map((m => nodeMetaMap.lookupByUniqueId(m))).filter(Boolean));
     }));
    }
    getNodesWithDBColumns(event, modelsToFetch, cancellationToken) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const mappedNode = {}, relationsWithoutColumns = [];
      if (0 === modelsToFetch.length) return {
       mappedNode,
       relationsWithoutColumns,
       mappedCompiledSql: {}
      };
      const {nodeMetaMap, sourceMetaMap} = event, bulkSchemaRequest = [];
      for (const key of modelsToFetch) {
       if (this.dbSchemaCache[key]) {
        this.telemetry.sendTelemetryEvent("dbSchemaCacheHit", {
         model: key
        }), mappedNode[key] = this.dbSchemaCache[key];
        continue;
       }
       const splits = key.split("."), resource_type = splits[0];
       if (resource_type === DBTProject.RESOURCE_TYPE_SOURCE) {
        const source = sourceMetaMap.get(splits[2]), tableName = splits[3];
        if (!source) continue;
        const table = null == source ? void 0 : source.tables.find((t => t.name === tableName));
        if (!table) continue;
        bulkSchemaRequest.push({
         unique_id: key,
         name: source.name,
         resource_type,
         table: table.name
        });
        const node = {
         database: source.database,
         schema: source.schema,
         name: table.name,
         alias: table.identifier,
         uniqueId: key,
         columns: table.columns,
         path: table.path
        };
        mappedNode[key] = node;
       } else if (DBTProject.isResourceNode(resource_type)) {
        const node = nodeMetaMap.lookupByUniqueId(key);
        if (!node) continue;
        DBTProject.isResourceHasDbColumns(resource_type) && bulkSchemaRequest.push({
         unique_id: key,
         name: node.name,
         resource_type
        }), mappedNode[key] = node;
       }
      }
      const dbSchemaRequest = bulkSchemaRequest.filter((r => r.resource_type !== DBTProject.RESOURCE_TYPE_MODEL)), sqlglotSchemaRequest = bulkSchemaRequest.filter((r => r.resource_type === DBTProject.RESOURCE_TYPE_MODEL));
      let startTime = Date.now();
      const sqlglotSchemaResponse = yield this.getBulkCompiledSql(event, sqlglotSchemaRequest.map((r => r.unique_id))), compiledSqlTime = Date.now() - startTime;
      if (cancellationToken.isCancellationRequested) return {
       mappedNode,
       relationsWithoutColumns,
       mappedCompiledSql: sqlglotSchemaResponse
      };
      const sqlglotSchemas = {}, dialect = this.getAdapterType();
      startTime = Date.now();
      for (const r of sqlglotSchemaRequest) if (sqlglotSchemaResponse[r.unique_id]) try {
       const columns = yield this.dbtProjectIntegration.fetchSqlglotSchema(sqlglotSchemaResponse[r.unique_id], dialect);
       sqlglotSchemas[r.unique_id] = columns.map((c => ({
        column: c,
        dtype: "string"
       })));
      } catch (e) {
       this.terminal.warn("sqlglotSchemaFetchingFailed", `Error while sqlglot schema fetching for ${r.unique_id}`, !0, e), 
       dbSchemaRequest.push(r);
      } else dbSchemaRequest.push(r);
      const sqlglotSchemaTime = Date.now() - startTime;
      if (cancellationToken.isCancellationRequested) return {
       mappedNode,
       relationsWithoutColumns,
       mappedCompiledSql: sqlglotSchemaResponse
      };
      startTime = Date.now();
      const dbSchemaResponse = yield this.dbtProjectIntegration.getBulkSchemaFromDB(dbSchemaRequest, cancellationToken), dbFetchTime = Date.now() - startTime, bulkSchemaResponse = Object.assign(Object.assign({}, dbSchemaResponse), sqlglotSchemas);
      for (const key of modelsToFetch) {
       if (!bulkSchemaRequest.find((r => r.unique_id === key))) continue;
       const node = mappedNode[key];
       if (!node) continue;
       this.mergeColumnsFromDB(node, bulkSchemaResponse[key]) ? this.dbSchemaCache[key] = mappedNode[key] : relationsWithoutColumns.push(key);
      }
      return console.log("getNodesWithDBColumnsTimings", {
       compiledSqlTime,
       sqlglotSchemaTime,
       dbFetchTime,
       modelInfosLength: modelsToFetch.length
      }), this.telemetry.sendTelemetryEvent("getNodesWithDBColumnsTimings", {
       compiledSqlTime: compiledSqlTime.toString(),
       sqlglotSchemaTime: sqlglotSchemaTime.toString(),
       dbFetchTime: dbFetchTime.toString(),
       modelInfosLength: modelsToFetch.length.toString()
      }), {
       mappedNode,
       relationsWithoutColumns,
       mappedCompiledSql: sqlglotSchemaResponse
      };
     }));
    }
    applyDeferConfig() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      yield this.dbtProjectIntegration.applyDeferConfig();
     }));
    }
    throwDiagnosticsErrorIfAvailable() {
     this.dbtProjectIntegration.throwDiagnosticsErrorIfAvailable();
    }
   }
   exports.DBTProject = DBTProject, DBTProject.DBT_PROJECT_FILE = "dbt_project.yml", 
   DBTProject.MANIFEST_FILE = "manifest.json", DBTProject.CATALOG_FILE = "catalog.json", 
   DBTProject.RESOURCE_TYPE_MODEL = "model", DBTProject.RESOURCE_TYPE_MACRO = "macro", 
   DBTProject.RESOURCE_TYPE_ANALYSIS = "analysis", DBTProject.RESOURCE_TYPE_SOURCE = "source", 
   DBTProject.RESOURCE_TYPE_EXPOSURE = "exposure", DBTProject.RESOURCE_TYPE_SEED = "seed", 
   DBTProject.RESOURCE_TYPE_SNAPSHOT = "snapshot", DBTProject.RESOURCE_TYPE_TEST = "test", 
   DBTProject.RESOURCE_TYPE_METRIC = "semantic_model";
  },
  82018: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var DBTProjectContainer_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.DBTProjectContainer = void 0;
   const tslib_1 = __webpack_require__(31635), inversify_1 = __webpack_require__(25891), path_1 = __webpack_require__(16928), vscode_1 = __webpack_require__(54980), dbt_client_1 = __webpack_require__(78629), domain_1 = __webpack_require__(97066), utils_1 = __webpack_require__(86185), dbtTerminal_1 = __webpack_require__(83683), datapilot_1 = __webpack_require__(98439), altimate_1 = __webpack_require__(91741);
   var PromptAnswer;
   !function(PromptAnswer) {
    PromptAnswer.YES = "Yes", PromptAnswer.IGNORE = "Ignore";
   }(PromptAnswer || (PromptAnswer = {}));
   let DBTProjectContainer = DBTProjectContainer_1 = class {
    constructor(dbtClient, dbtWorkspaceFolderFactory, dbtTerminal, altimateDatapilot, altimate) {
     this.dbtClient = dbtClient, this.dbtWorkspaceFolderFactory = dbtWorkspaceFolderFactory, 
     this.dbtTerminal = dbtTerminal, this.altimateDatapilot = altimateDatapilot, this.altimate = altimate, 
     this.onDBTInstallationVerification = this.dbtClient.onDBTInstallationVerification, 
     this._onDBTProjectsInitializationEvent = new vscode_1.EventEmitter, this.onDBTProjectsInitialization = this._onDBTProjectsInitializationEvent.event, 
     this.dbtWorkspaceFolders = [], this._onManifestChanged = new vscode_1.EventEmitter, 
     this._onProjectRegisteredUnregistered = new vscode_1.EventEmitter, this.onManifestChanged = this._onManifestChanged.event, 
     this.disposables = [ this._onManifestChanged, this._onProjectRegisteredUnregistered ], 
     this.projects = new Map, this._onRebuildManifestStatusChange = new vscode_1.EventEmitter, 
     this.onRebuildManifestStatusChange = this._onRebuildManifestStatusChange.event, 
     this.rebuildManifestStatusChangeMap = new Map, this.getPackageName = uri => {
      var _a;
      return null === (_a = this.findDBTProject(uri)) || void 0 === _a ? void 0 : _a.findPackageName(uri);
     }, this.getProjectRootpath = uri => {
      var _a;
      return null === (_a = this.findDBTProject(uri)) || void 0 === _a ? void 0 : _a.projectRoot;
     }, this.disposables.push(vscode_1.workspace.onDidChangeWorkspaceFolders((event => tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const {added, removed} = event;
      yield Promise.all(added.map((folder => tslib_1.__awaiter(this, void 0, void 0, (function*() {
       return yield this.registerWorkspaceFolder(folder);
      }))))), removed.forEach((removedWorkspaceFolder => this.unregisterWorkspaceFolder(removedWorkspaceFolder)));
     }))))), this._onProjectRegisteredUnregistered.event((event => {
      event.registered ? this.projects.set(event.root, event.name) : this.projects.delete(event.root);
      const projects = Array.from(this.projects.entries());
      vscode_1.commands.executeCommand("setContext", "dbtPowerUser.projectCount", projects.length), 
      1 === projects.length ? (this.setToWorkspaceState("dbtPowerUser.projectSelected", {
       label: projects[0][1],
       description: projects[0][0].fsPath,
       uri: projects[0][0]
      }), vscode_1.commands.executeCommand("setContext", "dbtPowerUser.walkthroughProjectSelected", !0)) : (this.setToWorkspaceState("dbtPowerUser.projectSelected", null), 
      vscode_1.commands.executeCommand("setContext", "dbtPowerUser.walkthroughProjectSelected", !1));
     }));
    }
    setContext(context) {
     this.context = context;
    }
    showErrorIfDbtOrPythonNotInstalled() {
     return this.dbtClient.showErrorIfDbtOrPythonNotInstalled();
    }
    showErrorIfDbtIsNotInstalled() {
     return this.dbtClient.showErrorIfDbtIsNotInstalled();
    }
    initializeDBTProjects() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const folders = vscode_1.workspace.workspaceFolders;
      void 0 !== folders && (yield Promise.all(folders.map((folder => this.registerWorkspaceFolder(folder)))), 
      this._onDBTProjectsInitializationEvent.fire({}));
     }));
    }
    showWalkthrough() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const answer = yield vscode_1.window.showInformationMessage("Thanks for installing dbt Power User. Do you need help setting up the extension?", PromptAnswer.YES, PromptAnswer.IGNORE);
      vscode_1.commands.executeCommand("setContext", "dbtPowerUser.showSetupWalkthrough", !1), 
      answer === PromptAnswer.YES && vscode_1.commands.executeCommand("dbtPowerUser.openSetupWalkthrough"), 
      this.setToGlobalState("showSetupWalkthrough", !1);
     }));
    }
    initializeWalkthrough() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const isWalkthroughDisabledFromSettings = vscode_1.workspace.getConfiguration("dbt").get("hideWalkthrough", !1), showSetupWalkthrough = this.getFromGlobalState("showSetupWalkthrough");
      isWalkthroughDisabledFromSettings || void 0 !== showSetupWalkthrough && !0 !== showSetupWalkthrough || (this.dbtTerminal.debug("dbtProjectContainer:setupWalkthroughDisplayed", "showing SetupWalkthrough: value of showSetupWalkthrough is" + showSetupWalkthrough), 
      this.showWalkthrough());
      const allProjects = yield this.getProjects();
      this.dbtTerminal.debug("dbtProjectContainer:initializeWalkthrough", "getProjects", allProjects), 
      vscode_1.commands.executeCommand("setContext", "dbtPowerUser.projectCount", allProjects.length);
      const existingAssociations = vscode_1.workspace.getConfiguration("files").get("associations", {});
      this.dbtTerminal.debug("dbtProjectContainer:fileAssociationsCheck", "already existing fileAssociations", existingAssociations);
      let showFileAssociationsStep = !1;
      Object.entries({
       "*.sql": [ "jinja-sql", "sql" ],
       "*.yml": [ "jinja-yaml", "yaml" ]
      }).forEach((([key, value]) => {
       void 0 === existingAssociations[key] && (showFileAssociationsStep || (showFileAssociationsStep = !0)), 
       showFileAssociationsStep || (showFileAssociationsStep = !value.includes(existingAssociations[key]));
      })), vscode_1.commands.executeCommand("setContext", "dbtPowerUser.showFileAssociationStep", showFileAssociationsStep);
     }));
    }
    get extensionUri() {
     return this.context.extensionUri;
    }
    get extensionVersion() {
     return this.context.extension.packageJSON.version;
    }
    setToWorkspaceState(key, value) {
     this.context.workspaceState.update(key, value);
    }
    getFromWorkspaceState(key) {
     return this.context.workspaceState.get(key);
    }
    setToGlobalState(key, value) {
     this.context.globalState.update(key, value);
    }
    getFromGlobalState(key) {
     return this.context.globalState.get(key);
    }
    get extensionId() {
     var _a;
     return (null === (_a = this.context) || void 0 === _a ? void 0 : _a.extension.id.toString()) || "";
    }
    detectDBT() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      yield this.dbtClient.detectDBT();
     }));
    }
    initialize() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.getProjects().forEach((project => project.initialize()));
     }));
    }
    executeSQL(uri, query, modelName) {
     var _a;
     null === (_a = this.findDBTProject(uri)) || void 0 === _a || _a.executeSQL(query, modelName);
    }
    runModel(modelPath, type) {
     var _a;
     null === (_a = this.findDBTProject(modelPath)) || void 0 === _a || _a.runModel(this.createModelParams(modelPath, type));
    }
    buildModel(modelPath, type) {
     var _a;
     null === (_a = this.findDBTProject(modelPath)) || void 0 === _a || _a.buildModel(this.createModelParams(modelPath, type));
    }
    buildProject(modelPath, type) {
     var _a;
     null === (_a = this.findDBTProject(modelPath)) || void 0 === _a || _a.buildProject();
    }
    runTest(modelPath, testName) {
     var _a;
     null === (_a = this.findDBTProject(modelPath)) || void 0 === _a || _a.runTest(testName);
    }
    runModelTest(modelPath, modelName) {
     var _a;
     null === (_a = this.findDBTProject(modelPath)) || void 0 === _a || _a.runModelTest(modelName);
    }
    compileModel(modelPath, type) {
     var _a;
     null === (_a = this.findDBTProject(modelPath)) || void 0 === _a || _a.compileModel(this.createModelParams(modelPath, type));
    }
    generateDocs(modelPath) {
     var _a;
     null === (_a = this.findDBTProject(modelPath)) || void 0 === _a || _a.generateDocs();
    }
    compileQuery(modelPath, query) {
     var _a;
     null === (_a = this.findDBTProject(modelPath)) || void 0 === _a || _a.compileQuery(query);
    }
    showRunSQL(modelPath) {
     var _a;
     null === (_a = this.findDBTProject(modelPath)) || void 0 === _a || _a.showRunSQL(modelPath);
    }
    showCompiledSQL(modelPath) {
     var _a;
     null === (_a = this.findDBTProject(modelPath)) || void 0 === _a || _a.showCompiledSql(modelPath);
    }
    generateSchemaYML(modelPath, modelName) {
     var _a;
     null === (_a = this.findDBTProject(modelPath)) || void 0 === _a || _a.generateSchemaYML(modelPath, modelName);
    }
    findDBTProject(uri) {
     var _a;
     return null === (_a = this.findDBTWorkspaceFolder(uri)) || void 0 === _a ? void 0 : _a.findDBTProject(uri);
    }
    getProjects() {
     return this.dbtWorkspaceFolders.flatMap((workspaceFolder => workspaceFolder.getProjects()));
    }
    getAdapters() {
     return Array.from(new Set(this.dbtWorkspaceFolders.flatMap((workspaceFolder => workspaceFolder.getAdapters()))));
    }
    getPythonEnvironment() {
     return this.dbtClient.getPythonEnvironment();
    }
    dispose() {
     for (this.dbtWorkspaceFolders.forEach((workspaceFolder => workspaceFolder.dispose())); this.disposables.length; ) {
      const x = this.disposables.pop();
      x && x.dispose();
     }
    }
    createModelParams(modelPath, type) {
     const modelName = (0, path_1.basename)(modelPath.fsPath, ".sql");
     return {
      plusOperatorLeft: type === domain_1.RunModelType.RUN_PARENTS || type === domain_1.RunModelType.BUILD_PARENTS || type === domain_1.RunModelType.BUILD_CHILDREN_PARENTS ? "+" : "",
      modelName,
      plusOperatorRight: type === domain_1.RunModelType.RUN_CHILDREN || type === domain_1.RunModelType.BUILD_CHILDREN || type === domain_1.RunModelType.BUILD_CHILDREN_PARENTS ? "+" : ""
     };
    }
    registerWorkspaceFolder(workspaceFolder) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const dbtProjectWorkspaceFolder = this.dbtWorkspaceFolderFactory(workspaceFolder, this._onManifestChanged, this._onProjectRegisteredUnregistered);
      this.disposables.push(dbtProjectWorkspaceFolder.onRebuildManifestStatusChange((e => {
       this.rebuildManifestStatusChangeMap.set(e.project.projectRoot.fsPath, e.inProgress);
       const inProgressProjects = Array.from(this.rebuildManifestStatusChangeMap.entries()).filter((([_, inProgress]) => inProgress)).map((([root, _]) => root)).map((root => this.findDBTProject(vscode_1.Uri.file(root)))).filter((project => void 0 !== project));
       this._onRebuildManifestStatusChange.fire({
        projects: inProgressProjects,
        inProgress: inProgressProjects.length > 0
       });
      }))), this.dbtWorkspaceFolders.push(dbtProjectWorkspaceFolder), this.dbtTerminal.debug("dbtProjectContainer:registerWorkspaceFolder", "dbtWorkspaceFolders", this.dbtWorkspaceFolders), 
      yield dbtProjectWorkspaceFolder.discoverProjects();
     }));
    }
    unregisterWorkspaceFolder(workspaceFolder) {
     const folderToDelete = this.findDBTWorkspaceFolder(workspaceFolder.uri);
     void 0 !== folderToDelete && (this.dbtWorkspaceFolders.splice(this.dbtWorkspaceFolders.indexOf(folderToDelete)), 
     folderToDelete.dispose());
    }
    findDBTWorkspaceFolder(uri) {
     return this.dbtWorkspaceFolders.find((folder => folder.contains(uri)));
    }
    checkIfAltimateDatapilotInstalled() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const datapilotVersion = yield this.altimateDatapilot.checkIfAltimateDatapilotInstalled(), {altimate_datapilot_version} = yield this.altimate.getDatapilotVersion(this.extensionVersion);
      return datapilotVersion === altimate_datapilot_version;
     }));
    }
    installAltimateDatapilot() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const {altimate_datapilot_version} = yield this.altimate.getDatapilotVersion(this.extensionVersion);
      yield this.altimateDatapilot.installAltimateDatapilot(altimate_datapilot_version);
     }));
    }
    executeAltimateDatapilotHealthcheck(args) {
     const project = this.getProjects().find((p => p.projectRoot.fsPath.toString() === args.projectRoot));
     if (!project) throw new Error(`Unable to find project ${args.projectRoot}`);
     return project.performDatapilotHealthcheck(args);
    }
   };
   DBTProjectContainer = DBTProjectContainer_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(DBTProjectContainer_1), tslib_1.__param(1, (0, 
   inversify_1.inject)("Factory<DBTWorkspaceFolder>")), tslib_1.__metadata("design:paramtypes", [ dbt_client_1.DBTClient, Function, dbtTerminal_1.DBTTerminal, datapilot_1.AltimateDatapilot, altimate_1.AltimateRequest ]) ], DBTProjectContainer), 
   exports.DBTProjectContainer = DBTProjectContainer;
  },
  7881: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.DBTWorkspaceFolder = void 0;
   const tslib_1 = __webpack_require__(31635), fs_1 = __webpack_require__(79896), inversify_1 = __webpack_require__(25891), path = __webpack_require__(16928), vscode_1 = __webpack_require__(54980), dbtProject_1 = __webpack_require__(38821), telemetry_1 = __webpack_require__(22644), yaml_1 = __webpack_require__(91198), dbtCoreIntegration_1 = __webpack_require__(71636), dbtCloudIntegration_1 = __webpack_require__(54958), dbtTerminal_1 = __webpack_require__(83683);
   let DBTWorkspaceFolder = class {
    constructor(dbtProjectFactory, dbtCoreProjectDetection, dbtCloudProjectDetection, telemetry, dbtTerminal, workspaceFolder, _onManifestChanged, _onProjectRegisteredUnregistered) {
     this.dbtProjectFactory = dbtProjectFactory, this.dbtCoreProjectDetection = dbtCoreProjectDetection, 
     this.dbtCloudProjectDetection = dbtCloudProjectDetection, this.telemetry = telemetry, 
     this.dbtTerminal = dbtTerminal, this.workspaceFolder = workspaceFolder, this._onManifestChanged = _onManifestChanged, 
     this._onProjectRegisteredUnregistered = _onProjectRegisteredUnregistered, this.projectDiscoveryDiagnostics = vscode_1.languages.createDiagnosticCollection("dbt"), 
     this.dbtProjects = [], this.disposables = [], this._onRebuildManifestStatusChange = new vscode_1.EventEmitter, 
     this.onRebuildManifestStatusChange = this._onRebuildManifestStatusChange.event, 
     this.watcher = this.createConfigWatcher(), this.disposables.push(this.watcher);
    }
    getAllowListFolders() {
     const nonFilteredAlolowListFolders = vscode_1.workspace.getConfiguration("dbt").get("allowListFolders", []).map((folder => path.isAbsolute(folder) ? folder : path.join(this.workspaceFolder.uri.fsPath, folder))), allowListFolders = nonFilteredAlolowListFolders.filter((folder => (0, 
     fs_1.existsSync)(folder)));
     return nonFilteredAlolowListFolders.length === allowListFolders.length && (console.warn("filtered out non-existing allowListFolders", allowListFolders, nonFilteredAlolowListFolders), 
     this.telemetry.sendTelemetryEvent("nonExistingAllowListFolders")), allowListFolders;
    }
    discoverProjects() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const dbtProjectFiles = yield vscode_1.workspace.findFiles(new vscode_1.RelativePattern(this.workspaceFolder, `**/${dbtProject_1.DBTProject.DBT_PROJECT_FILE}`), new vscode_1.RelativePattern(this.workspaceFolder, "**/{dbt_packages,site-packages}"));
      this.dbtTerminal.info("discoverProjects", "foundProjects", !1, dbtProjectFiles);
      const allowListFolders = this.getAllowListFolders();
      this.dbtTerminal.info("discoverProjects", "allowListFolders", !1, allowListFolders);
      const projectDirectories = dbtProjectFiles.filter((uri => (0, fs_1.existsSync)(uri.fsPath) && (0, 
      fs_1.statSync)(uri.fsPath).isFile())).filter((uri => this.notInVenv(uri.fsPath))).filter((uri => 0 === allowListFolders.length || allowListFolders.some((folder => uri.fsPath.startsWith(folder))))).map((uri => vscode_1.Uri.file(uri.path.split("/").slice(0, -1).join("/"))));
      this.dbtTerminal.info("discoverProjects", "foundProjectsAfterFilter", !1, projectDirectories), 
      this.telemetry.sendTelemetryEvent("discoverProjects", {}, {
       numProjects: projectDirectories.length
      });
      let dbtProjectDetection;
      if ("cloud" === vscode_1.workspace.getConfiguration("dbt").get("dbtIntegration", "core")) dbtProjectDetection = this.dbtCloudProjectDetection; else dbtProjectDetection = this.dbtCoreProjectDetection;
      const filteredProjects = yield dbtProjectDetection.discoverProjects(projectDirectories);
      this.dbtTerminal.info("discoverProjects", "foundProjectsAfterProjectIntegrationFilter", !1, filteredProjects), 
      yield Promise.all(filteredProjects.map((uri => tslib_1.__awaiter(this, void 0, void 0, (function*() {
       yield this.registerDBTProject(uri);
      })))));
     }));
    }
    findDBTProject(uri) {
     return this.dbtProjects.find((project => project.contains(uri)));
    }
    getProjects() {
     return this.dbtProjects;
    }
    contains(uri) {
     return uri.fsPath === this.workspaceFolder.uri.fsPath || uri.fsPath.startsWith(this.workspaceFolder.uri.fsPath + path.sep);
    }
    getAdapters() {
     return Array.from(new Set(this.dbtProjects.map((project => project.getAdapterType()))));
    }
    dispose() {
     for (this.dbtProjects.forEach((project => project.dispose())); this.disposables.length; ) {
      const x = this.disposables.pop();
      x && x.dispose();
     }
    }
    registerDBTProject(uri) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      try {
       const projectConfig = dbtProject_1.DBTProject.readAndParseProjectConfig(uri), dbtProject = this.dbtProjectFactory(uri, projectConfig, this._onManifestChanged);
       this.disposables.push(dbtProject.onRebuildManifestStatusChange((e => {
        this._onRebuildManifestStatusChange.fire(e);
       }))), this.dbtProjects.push(dbtProject), this.dbtProjects.sort(((a, b) => -a.projectRoot.fsPath.localeCompare(b.projectRoot.fsPath))), 
       yield dbtProject.initialize(), this.projectDiscoveryDiagnostics.clear(), this._onProjectRegisteredUnregistered.fire({
        root: uri,
        name: dbtProject.getProjectName(),
        registered: !0
       });
      } catch (error) {
       this.dbtTerminal.error("registerDBTProject", `Unable to register dbt project for ${uri.fsPath}`, error), 
       error instanceof yaml_1.YAMLError && this.projectDiscoveryDiagnostics.set(vscode_1.Uri.joinPath(uri, dbtProject_1.DBTProject.DBT_PROJECT_FILE), [ new vscode_1.Diagnostic(new vscode_1.Range(0, 0, 999, 999), error.message) ]), 
       vscode_1.window.showErrorMessage(`Skipping project: could not parse dbt_project_config.yml at '${uri}': ${error}`), 
       this.telemetry.sendTelemetryError("registerDBTProjectError", error);
      }
     }));
    }
    unregisterDBTProject(uri) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const projectToDelete = this.dbtProjects.find((dbtProject => dbtProject.projectRoot.fsPath === uri.fsPath));
      void 0 !== projectToDelete && (this.dbtProjects.splice(this.dbtProjects.indexOf(projectToDelete), 1), 
      this._onProjectRegisteredUnregistered.fire({
       root: uri,
       name: projectToDelete.getProjectName(),
       registered: !1
      }), yield projectToDelete.dispose());
     }));
    }
    createConfigWatcher() {
     const watcher = vscode_1.workspace.createFileSystemWatcher(new vscode_1.RelativePattern(this.workspaceFolder, `**/${dbtProject_1.DBTProject.DBT_PROJECT_FILE}`)), dirName = uri => vscode_1.Uri.file(path.dirname(uri.fsPath));
     return watcher.onDidCreate((uri => {
      const allowListFolders = this.getAllowListFolders();
      (0, fs_1.existsSync)(uri.fsPath) && (0, fs_1.statSync)(uri.fsPath).isFile() && this.notInVenv(uri.fsPath) && this.notInDBtPackages(uri.fsPath, this.dbtProjects.map((project => project.getPackageInstallPath()))) && (0 === allowListFolders.length || allowListFolders.some((folder => uri.fsPath.startsWith(folder)))) && this.registerDBTProject(dirName(uri));
     })), watcher.onDidDelete((uri => this.unregisterDBTProject(dirName(uri)))), this.disposables.push(watcher), 
     watcher;
    }
    notInVenv(path) {
     const notInVenv = !path.includes("site-packages");
     return notInVenv || this.dbtTerminal.info("discoverProjects", "foundProjectInVenv", !1, path), 
     notInVenv;
    }
    notInDBtPackages(uri, packagesInstallPaths) {
     for (const packagesInstallPath of packagesInstallPaths) if (packagesInstallPath && uri.startsWith(packagesInstallPath)) return !1;
     return !0;
    }
   };
   DBTWorkspaceFolder = tslib_1.__decorate([ tslib_1.__param(0, (0, inversify_1.inject)("DBTProjectFactory")), tslib_1.__metadata("design:paramtypes", [ Function, dbtCoreIntegration_1.DBTCoreProjectDetection, dbtCloudIntegration_1.DBTCloudProjectDetection, telemetry_1.TelemetryService, dbtTerminal_1.DBTTerminal, Object, vscode_1.EventEmitter, vscode_1.EventEmitter ]) ], DBTWorkspaceFolder), 
   exports.DBTWorkspaceFolder = DBTWorkspaceFolder;
  },
  49984: (__unused_webpack_module, exports) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.ProjectConfigChangedEvent = void 0;
   exports.ProjectConfigChangedEvent = class {
    constructor(project) {
     this.project = project;
    }
   };
  },
  75717: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var DBTProjectLogFactory_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.DBTProjectLog = exports.DBTProjectLogFactory = void 0;
   const tslib_1 = __webpack_require__(31635), fs_1 = __webpack_require__(79896), path = __webpack_require__(16928), vscode_1 = __webpack_require__(54980), utils_1 = __webpack_require__(86185);
   let DBTProjectLogFactory = DBTProjectLogFactory_1 = class {
    createDBTProjectLog(onProjectConfigChanged) {
     return new DBTProjectLog(onProjectConfigChanged);
    }
   };
   DBTProjectLogFactory = DBTProjectLogFactory_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(DBTProjectLogFactory_1) ], DBTProjectLogFactory), 
   exports.DBTProjectLogFactory = DBTProjectLogFactory;
   class DBTProjectLog {
    constructor(onProjectConfigChanged) {
     this.logPosition = 0, this.disposables = [], this.disposables.push(onProjectConfigChanged((event => this.onProjectConfigChanged(event))));
    }
    onProjectConfigChanged(event) {
     const projectRoot = event.project.projectRoot, projectName = event.project.getProjectName();
     void 0 === this.outputChannel && (this.outputChannel = vscode_1.window.createOutputChannel(`${projectName} dbt logs`), 
     this.readLogFileFromLastPosition(event), this.logFileWatcher = vscode_1.workspace.createFileSystemWatcher(new vscode_1.RelativePattern(projectRoot.path, `${DBTProjectLog.LOG_PATH}/${DBTProjectLog.LOG_FILE}`)), 
     (0, utils_1.setupWatcherHandler)(this.logFileWatcher, (() => this.readLogFileFromLastPosition(event))), 
     this.currentProjectName = projectName), this.currentProjectName !== projectName && (this.outputChannel.dispose(), 
     this.outputChannel = vscode_1.window.createOutputChannel(`${projectName} dbt logs`), 
     this.logPosition = 0, this.readLogFileFromLastPosition(event), this.currentProjectName = projectName);
    }
    readLogFileFromLastPosition(event) {
     const {project: {projectRoot}} = event, logPath = path.join(projectRoot.fsPath, DBTProjectLog.LOG_PATH, DBTProjectLog.LOG_FILE);
     if (this.outputChannel && (0, fs_1.existsSync)(logPath)) {
      let fileHandle;
      try {
       fileHandle = (0, fs_1.openSync)(logPath, "r");
       const chunkSize = 1048576, buffer = Buffer.alloc(chunkSize);
       for (;;) {
        const bytesRead = (0, fs_1.readSync)(fileHandle, buffer, 0, buffer.length, this.logPosition);
        if (!bytesRead) break;
        this.logPosition += bytesRead, this.outputChannel.appendLine((0, utils_1.stripANSI)(buffer.toString("utf8", 0, bytesRead)));
       }
      } catch (error) {
       console.log("Could not read log file", error);
      } finally {
       fileHandle && (0, fs_1.closeSync)(fileHandle);
      }
     }
    }
    dispose() {
     for (void 0 !== this.outputChannel && this.outputChannel.dispose(); this.disposables.length; ) {
      const x = this.disposables.pop();
      x && x.dispose();
     }
    }
   }
   exports.DBTProjectLog = DBTProjectLog, DBTProjectLog.LOG_PATH = "logs", DBTProjectLog.LOG_FILE = "dbt.log";
  },
  29390: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var SourceFileWatchersFactory_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.SourceFileWatchers = exports.SourceFileWatchersFactory = void 0;
   const tslib_1 = __webpack_require__(31635), vscode_1 = __webpack_require__(54980), utils_1 = __webpack_require__(86185), dbtTerminal_1 = __webpack_require__(83683);
   let SourceFileWatchersFactory = SourceFileWatchersFactory_1 = class {
    constructor(terminal) {
     this.terminal = terminal;
    }
    createSourceFileWatchers(onProjectConfigChanged) {
     return new SourceFileWatchers(onProjectConfigChanged, this.terminal);
    }
   };
   SourceFileWatchersFactory = SourceFileWatchersFactory_1 = tslib_1.__decorate([ (0, 
   utils_1.provideSingleton)(SourceFileWatchersFactory_1), tslib_1.__metadata("design:paramtypes", [ dbtTerminal_1.DBTTerminal ]) ], SourceFileWatchersFactory), 
   exports.SourceFileWatchersFactory = SourceFileWatchersFactory;
   class SourceFileWatchers {
    constructor(onProjectConfigChanged, terminal) {
     this.terminal = terminal, this._onSourceFileChanged = new vscode_1.EventEmitter, 
     this.onSourceFileChanged = this._onSourceFileChanged.event, this.watchers = [], 
     this.disposables = [ this._onSourceFileChanged ], this.disposables.push(onProjectConfigChanged((event => this.onProjectConfigChanged(event))));
    }
    dispose() {
     for (;this.disposables.length; ) {
      const x = this.disposables.pop();
      x && x.dispose();
     }
     this.disposeWatchers();
    }
    disposeWatchers() {
     this.watchers.forEach((watcher => watcher.dispose()));
    }
    onProjectConfigChanged(event) {
     const project = event.project, sourcePaths = project.getModelPaths();
     if (void 0 === sourcePaths) throw new Error("sourcePaths is not defined in project in " + project.projectRoot.fsPath);
     const macroPaths = project.getMacroPaths();
     if (void 0 === macroPaths) throw new Error("macroPaths is not defined in " + project.projectRoot.fsPath);
     const seedPaths = project.getSeedPaths();
     if (void 0 === seedPaths) throw new Error("seedPaths is not defined in " + project.projectRoot.fsPath);
     const paths = sourcePaths.concat(macroPaths).concat(seedPaths);
     this.terminal.debug("SourceFileWatchers", "watching following source paths for changes", paths), 
     void 0 !== this.currentSourcePaths && (0, utils_1.arrayEquals)(this.currentSourcePaths, sourcePaths) || (this.disposeWatchers(), 
     this.watchers = [], paths.forEach((sourcePath => {
      const sourceFolderWatcher = vscode_1.workspace.createFileSystemWatcher(new vscode_1.RelativePattern(sourcePath, "**/*.{sql,yml,yaml,csv}")), debouncedSourceFileChangedEvent = (0, 
      utils_1.debounce)((() => this._onSourceFileChanged.fire()), 500);
      sourceFolderWatcher.onDidChange((() => debouncedSourceFileChangedEvent())), this.watchers.push(sourceFolderWatcher);
     })), this.currentSourcePaths = sourcePaths);
    }
   }
   exports.SourceFileWatchers = SourceFileWatchers;
  },
  55216: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var TargetWatchersFactory_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.TargetWatchers = exports.TargetWatchersFactory = void 0;
   const tslib_1 = __webpack_require__(31635), vscode_1 = __webpack_require__(54980), utils_1 = __webpack_require__(86185), dbtProject_1 = __webpack_require__(38821), parsers_1 = __webpack_require__(12847), dbtTerminal_1 = __webpack_require__(83683);
   let TargetWatchersFactory = TargetWatchersFactory_1 = class {
    constructor(manifestParser, dbtTerminal) {
     this.manifestParser = manifestParser, this.dbtTerminal = dbtTerminal;
    }
    createTargetWatchers(_onManifestChanged, _onRunResults, onProjectConfigChanged) {
     return new TargetWatchers(_onManifestChanged, _onRunResults, onProjectConfigChanged, this.manifestParser, this.dbtTerminal);
    }
   };
   TargetWatchersFactory = TargetWatchersFactory_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(TargetWatchersFactory_1), tslib_1.__metadata("design:paramtypes", [ parsers_1.ManifestParser, dbtTerminal_1.DBTTerminal ]) ], TargetWatchersFactory), 
   exports.TargetWatchersFactory = TargetWatchersFactory;
   class TargetWatchers {
    constructor(_onManifestChanged, _onRunResults, onProjectConfigChanged, manifestParser, terminal) {
     this.manifestParser = manifestParser, this.terminal = terminal, this.disposables = [], 
     this.watchers = [], this._onManifestChanged = _onManifestChanged, this._onRunResults = _onRunResults, 
     this.disposables.push(onProjectConfigChanged((event => this.onProjectConfigChanged(event))));
    }
    dispose() {
     for (;this.disposables.length; ) {
      const x = this.disposables.pop();
      x && x.dispose();
     }
     this.disposeWatchers();
    }
    disposeWatchers() {
     this.watchers.forEach((watcher => watcher.dispose()));
    }
    onProjectConfigChanged(event) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const projectName = event.project.getProjectName(), targetPath = event.project.getTargetPath();
      if (targetPath) {
       if (this.terminal.debug("ManifestParser", `Evaluating if project config has changed "${event.project.getProjectName()}" at ${event.project.projectRoot}`, {
        currentTargetPath: this.currentTargetPath,
        targetPath,
        currentProjectName: this.currentProjectName,
        projectName
       }), void 0 === this.currentTargetPath || this.currentTargetPath !== targetPath || void 0 === this.currentProjectName || this.currentProjectName !== projectName) {
        this.disposeWatchers(), this.watchers = [];
        const handler = () => tslib_1.__awaiter(this, void 0, void 0, (function*() {
         const manifestCacheChangedEvent = yield this.manifestParser.parseManifest(event.project);
         manifestCacheChangedEvent && (this.terminal.debug("ManifestParser", `Firing ManifestCacheChangedEvent event from watcher event for "${event.project.getProjectName()}" at ${event.project.projectRoot}`), 
         this._onManifestChanged.fire(manifestCacheChangedEvent));
        }));
        this.manifestWatcher = this.createManifestWatcher(event), (0, utils_1.setupWatcherHandler)(this.manifestWatcher, (() => handler())), 
        this.targetFolderWatcher = this.createTargetFolderWatcher(event), this.targetFolderWatcher.onDidDelete((() => () => handler())), 
        this.runResultsWatcher = this.createLastRunResultsWatcher(event), this.currentTargetPath = targetPath, 
        this.currentProjectName = projectName, this.watchers.push(this.manifestWatcher, this.targetFolderWatcher, this.runResultsWatcher);
        const manifestCacheChangedEvent = yield this.manifestParser.parseManifest(event.project);
        manifestCacheChangedEvent && (this.terminal.debug("ManifestParser", `Firing ManifestCacheChangedEvent event from initialization for "${event.project.getProjectName()}" at ${event.project.projectRoot}`), 
        this._onManifestChanged.fire(manifestCacheChangedEvent));
       }
      } else this.terminal.debug("targetWatchers:onProjectConfigChanged", "targetPath should be defined at this stage for project " + event.project.projectRoot.fsPath);
     }));
    }
    createManifestWatcher(event) {
     const targetPath = event.project.getTargetPath();
     if (!targetPath) {
      const error = new Error("targetPath is undefined in " + event.project.projectRoot.fsPath);
      throw this.terminal.error("createManifestWatcherError", "targetPath is undefined", error), 
      error;
     }
     this.terminal.debug("ManifestParser", `Create ManifestWatcher for "${event.project.getProjectName()}" at ${event.project.projectRoot}`, targetPath);
     return vscode_1.workspace.createFileSystemWatcher(new vscode_1.RelativePattern(targetPath, dbtProject_1.DBTProject.MANIFEST_FILE));
    }
    createTargetFolderWatcher(event) {
     const targetPath = event.project.getTargetPath();
     if (!targetPath) {
      const error = new Error("targetPath is undefined in " + event.project.projectRoot.fsPath);
      throw this.terminal.error("createTargetFolderWatcherError", "targetPath is undefined", error), 
      error;
     }
     const targetFolderWatcher = vscode_1.workspace.createFileSystemWatcher(new vscode_1.RelativePattern(targetPath, "*"));
     return this.terminal.debug("ManifestParser", `Create TargetFolderWatcher for "${event.project.getProjectName()}" at ${event.project.projectRoot}`, targetPath), 
     targetFolderWatcher;
    }
    createLastRunResultsWatcher(event) {
     {
      const targetPath = event.project.getTargetPath();
      if (!targetPath) {
       const error = new Error("targetPath is undefined in " + event.project.projectRoot.fsPath);
       throw this.terminal.error("createTargetFolderWatcherError", "targetPath is undefined", error), 
       error;
      }
      const watcher = vscode_1.workspace.createFileSystemWatcher(new vscode_1.RelativePattern(targetPath, "run_results.json"));
      return watcher.onDidChange((e => this._onRunResults.fire({
       project: event.project,
       file: e
      }))), watcher.onDidCreate((e => this._onRunResults.fire({
       project: event.project,
       file: e
      }))), watcher;
     }
    }
   }
   exports.TargetWatchers = TargetWatchers;
  },
  62210: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var DocParser_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.DocParser = void 0;
   const tslib_1 = __webpack_require__(31635), fs_1 = __webpack_require__(79896), inversify_binding_decorators_1 = __webpack_require__(25567), dbtTerminal_1 = __webpack_require__(83683), _1 = __webpack_require__(12847);
   let DocParser = DocParser_1 = class {
    constructor(terminal) {
     this.terminal = terminal;
    }
    createDocMetaMap(docs, project) {
     return new Promise((resolve => tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.terminal.debug("DocParser", `Parsing docs for "${project.getProjectName()}" at ${project.projectRoot}`);
      const docMetaMap = new Map;
      if (null != docs) if ("function" == typeof docs[Symbol.iterator]) {
       for (const doc of docs) {
        const {package_name, name, original_file_path} = doc, packageName = package_name, projectName = project.getProjectName(), packagePath = project.getPackageInstallPath();
        if (void 0 === packagePath) throw new Error("packagePath is not defined in " + project.projectRoot.fsPath);
        const docName = packageName === projectName ? name : `${packageName}.${name}`, fullPath = (0, 
        _1.createFullPathForNode)(projectName, project.projectRoot.fsPath, packageName, packagePath, original_file_path);
        if (!fullPath) return;
        try {
         const macroFileLines = (0, fs_1.readFileSync)(fullPath).toString("utf8").split("\n");
         for (let index = 0; index < macroFileLines.length; index++) {
          const currentLine = macroFileLines[index];
          if (currentLine.match(new RegExp(`docs\\s${name}`))) {
           docMetaMap.set(docName, {
            path: fullPath,
            line: index,
            character: currentLine.indexOf(name)
           });
           break;
          }
         }
        } catch (error) {
         this.terminal.debug("DocParser", `File not found at '${fullPath}', probably compiled is outdated, error is ignored`, error);
        }
       }
       this.terminal.debug("DocParser", `Returning docs for "${project.getProjectName()}" at ${project.projectRoot}`, docMetaMap), 
       resolve(docMetaMap);
      } else resolve(docMetaMap); else resolve(docMetaMap);
     }))));
    }
   };
   DocParser = DocParser_1 = tslib_1.__decorate([ (0, inversify_binding_decorators_1.provide)(DocParser_1), tslib_1.__metadata("design:paramtypes", [ dbtTerminal_1.DBTTerminal ]) ], DocParser), 
   exports.DocParser = DocParser;
  },
  68149: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var ExposureParser_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.ExposureParser = void 0;
   const tslib_1 = __webpack_require__(31635), inversify_binding_decorators_1 = __webpack_require__(25567), path = __webpack_require__(16928), dbtProject_1 = __webpack_require__(38821), dbtTerminal_1 = __webpack_require__(83683);
   let ExposureParser = ExposureParser_1 = class {
    constructor(terminal) {
     this.terminal = terminal;
    }
    createExposureMetaMap(exposuresMap, project) {
     return new Promise((resolve => {
      this.terminal.debug("ExposureParser", `Parsing exposures for "${project.getProjectName()}" at ${project.projectRoot}`);
      const exposureMetaMap = new Map;
      null == exposuresMap && resolve(exposureMetaMap), Object.values(exposuresMap).filter((exposure => exposure.resource_type === dbtProject_1.DBTProject.RESOURCE_TYPE_EXPOSURE)).forEach((exposure => {
       const fullPath = path.join(project.projectRoot.fsPath, exposure.original_file_path);
       exposureMetaMap.set(exposure.name, Object.assign(Object.assign({}, exposure), {
        path: fullPath
       }));
      })), this.terminal.debug("ExposureParser", `Returning exposures for "${project.getProjectName()}" at ${project.projectRoot}`, exposureMetaMap), 
      resolve(exposureMetaMap);
     }));
    }
   };
   ExposureParser = ExposureParser_1 = tslib_1.__decorate([ (0, inversify_binding_decorators_1.provide)(ExposureParser_1), tslib_1.__metadata("design:paramtypes", [ dbtTerminal_1.DBTTerminal ]) ], ExposureParser), 
   exports.ExposureParser = ExposureParser;
  },
  500: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var GraphParser_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.GraphParser = void 0;
   const tslib_1 = __webpack_require__(31635), inversify_binding_decorators_1 = __webpack_require__(25567), domain_1 = __webpack_require__(97066), utils_1 = __webpack_require__(86185), dbtTerminal_1 = __webpack_require__(83683);
   let GraphParser = GraphParser_1 = class {
    constructor(terminal) {
     this.terminal = terminal;
    }
    createGraphMetaMap(project, parentMap, childrenMap, nodeMetaMap, sourceMetaMap, testMetaMap, metricMetaMap) {
     this.terminal.debug("GraphParser", `Parsing graph for "${project.getProjectName()}" at ${project.projectRoot}`);
     const graph = {
      parents: Object.entries(parentMap).reduce(((map, [nodeName, nodes]) => {
       const currentNodes = nodes.map(this.mapToNode(sourceMetaMap, nodeMetaMap, testMetaMap, metricMetaMap)).filter(utils_1.notEmpty);
       return map.set(nodeName, {
        nodes: currentNodes
       }), map;
      }), new Map),
      children: Object.entries(childrenMap).reduce(((map, [nodeName, nodes]) => {
       const currentNodes = nodes.map(this.mapToNode(sourceMetaMap, nodeMetaMap, testMetaMap, metricMetaMap)).filter((n => !(n instanceof domain_1.Test))).filter(utils_1.notEmpty);
       return map.set(nodeName, {
        nodes: currentNodes
       }), map;
      }), new Map),
      tests: Object.entries(childrenMap).reduce(((map, [nodeName, nodes]) => {
       const currentNodes = nodes.map(this.mapToNode(sourceMetaMap, nodeMetaMap, testMetaMap, metricMetaMap)).filter((n => n instanceof domain_1.Test)).filter(utils_1.notEmpty);
       return map.set(nodeName, {
        nodes: currentNodes
       }), map;
      }), new Map),
      metrics: Object.entries(childrenMap).reduce(((map, [nodeName, nodes]) => {
       const currentNodes = nodes.map(this.mapToNode(sourceMetaMap, nodeMetaMap, testMetaMap, metricMetaMap)).filter((n => n instanceof domain_1.Metric)).filter(utils_1.notEmpty);
       return map.set(nodeName, {
        nodes: currentNodes
       }), map;
      }), new Map)
     };
     return this.terminal.debug("GraphParser", `Returning graph for "${project.getProjectName()}" at ${project.projectRoot}`, graph), 
     graph;
    }
    mapToNode(sourceMetaMap, nodeMetaMap, testMetaMap, metricMetaMap) {
     return parentNodeName => {
      var _a, _b, _c, _d, _e, _f;
      const [nodeType, nodePackage, ...restNodeName] = parentNodeName.split("."), nodeName = restNodeName.join(".");
      switch (nodeType) {
      case "source":
       {
        const [sourceName, tableName] = nodeName.split("."), url = null === (_b = null === (_a = sourceMetaMap.get(sourceName)) || void 0 === _a ? void 0 : _a.tables.find((table => table.name === tableName))) || void 0 === _b ? void 0 : _b.path;
        return new domain_1.Source(`${tableName} (${sourceName})`, parentNodeName, url);
       }

      case "model":
       {
        const model = nodeMetaMap.lookupByUniqueId(parentNodeName);
        if (!model) return;
        const url = null == model ? void 0 : model.path;
        return new domain_1.Model(model.alias, parentNodeName, url);
       }

      case "seed":
       {
        const model = nodeMetaMap.lookupByUniqueId(parentNodeName);
        if (!model) return;
        const url = null == model ? void 0 : model.path;
        return new domain_1.Seed(model.alias, parentNodeName, url);
       }

      case "test":
       {
        const url = null === (_c = testMetaMap.get(nodeName.split(".")[0])) || void 0 === _c ? void 0 : _c.path;
        return new domain_1.Test(nodeName, parentNodeName, null != url ? url : "");
       }

      case "analysis":
       {
        const url = null === (_d = nodeMetaMap.lookupByBaseName(nodeName)) || void 0 === _d ? void 0 : _d.path;
        return new domain_1.Analysis(nodeName, parentNodeName, url);
       }

      case "snapshot":
       {
        const url = null === (_e = nodeMetaMap.lookupByBaseName(nodeName)) || void 0 === _e ? void 0 : _e.path;
        return new domain_1.Snapshot(nodeName, parentNodeName, url);
       }

      case "exposure":
       {
        const url = null === (_f = nodeMetaMap.lookupByBaseName(nodeName)) || void 0 === _f ? void 0 : _f.path;
        return new domain_1.Exposure(nodeName, parentNodeName, url);
       }

      case "semantic_model":
       return new domain_1.Metric(nodeName, parentNodeName);

      default:
       return void console.log(`Node Type '${nodeType}' not implemented!`);
      }
     };
    }
   };
   GraphParser = GraphParser_1 = tslib_1.__decorate([ (0, inversify_binding_decorators_1.provide)(GraphParser_1), tslib_1.__metadata("design:paramtypes", [ dbtTerminal_1.DBTTerminal ]) ], GraphParser), 
   exports.GraphParser = GraphParser;
  },
  12847: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var ManifestParser_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.createFullPathForNode = exports.ManifestParser = void 0;
   const tslib_1 = __webpack_require__(31635), fs_1 = __webpack_require__(79896), inversify_binding_decorators_1 = __webpack_require__(25567), path = __webpack_require__(16928), dbtTerminal_1 = __webpack_require__(83683), dbtProject_1 = __webpack_require__(38821), docParser_1 = __webpack_require__(62210), graphParser_1 = __webpack_require__(500), macroParser_1 = __webpack_require__(54176), nodeParser_1 = __webpack_require__(66144), sourceParser_1 = __webpack_require__(38417), testParser_1 = __webpack_require__(41708), telemetry_1 = __webpack_require__(22644), exposureParser_1 = __webpack_require__(68149), metricParser_1 = __webpack_require__(696);
   let ManifestParser = ManifestParser_1 = class {
    constructor(nodeParser, macroParser, metricParser, graphParser, sourceParser, testParser, exposureParser, docParser, terminal, telemetry) {
     this.nodeParser = nodeParser, this.macroParser = macroParser, this.metricParser = metricParser, 
     this.graphParser = graphParser, this.sourceParser = sourceParser, this.testParser = testParser, 
     this.exposureParser = exposureParser, this.docParser = docParser, this.terminal = terminal, 
     this.telemetry = telemetry;
    }
    parseManifest(project) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.terminal.debug("ManifestParser", `Going to parse manifest for "${project.getProjectName()}" at ${project.projectRoot}`);
      const targetPath = project.getTargetPath();
      if (!targetPath) return void this.terminal.debug("ManifestParser", "targetPath should be defined at this stage for project " + project.projectRoot.fsPath);
      const projectRoot = project.projectRoot, manifest = this.readAndParseManifest(projectRoot, targetPath);
      if (void 0 === manifest) {
       return {
        added: [ {
         project,
         nodeMetaMap: new nodeParser_1.NodeMetaMapImpl,
         macroMetaMap: new Map,
         metricMetaMap: new Map,
         sourceMetaMap: new Map,
         testMetaMap: new Map,
         graphMetaMap: {
          parents: new Map,
          children: new Map,
          tests: new Map,
          metrics: new Map
         },
         docMetaMap: new Map,
         exposureMetaMap: new Map
        } ]
       };
      }
      const {nodes, sources, macros, semantic_models, parent_map, child_map, docs, exposures} = manifest, nodeMetaMapPromise = this.nodeParser.createNodeMetaMap(nodes, project), macroMetaMapPromise = this.macroParser.createMacroMetaMap(macros, project), metricMetaMapPromise = this.metricParser.createMetricMetaMap(semantic_models, project), sourceMetaMapPromise = this.sourceParser.createSourceMetaMap(sources, project), testMetaMapPromise = this.testParser.createTestMetaMap(nodes, project), exposuresMetaMapPromise = this.exposureParser.createExposureMetaMap(exposures, project), docMetaMapPromise = this.docParser.createDocMetaMap(docs, project), [nodeMetaMap, macroMetaMap, metricMetaMap, sourceMetaMap, testMetaMap, docMetaMap, exposureMetaMap] = yield Promise.all([ nodeMetaMapPromise, macroMetaMapPromise, metricMetaMapPromise, sourceMetaMapPromise, testMetaMapPromise, docMetaMapPromise, exposuresMetaMapPromise ]), graphMetaMap = this.graphParser.createGraphMetaMap(project, parent_map, child_map, nodeMetaMap, sourceMetaMap, testMetaMap, metricMetaMap), nodeCounts = Object.values(nodes).reduce(((map, node) => {
       const key = node.resource_type + "_count";
       return map.has(key) || map.set(key, 0), map.set(key, map.get(key) + 1), map;
      }), new Map), parseManifestProps = Object.assign(Object.assign({}, Object.fromEntries(nodeCounts.entries())), {
       sources_count: sourceMetaMap.size,
       macros_count: macroMetaMap.size
      });
      void 0 !== this.lastSentParseManifestProps && Object.entries(this.lastSentParseManifestProps).toString() === Object.entries(parseManifestProps).toString() || (this.telemetry.sendTelemetryEvent("parseManifest", {
       project: dbtProject_1.DBTProject.hashProjectRoot(projectRoot.fsPath)
      }, parseManifestProps), this.lastSentParseManifestProps = parseManifestProps);
      return {
       added: [ {
        project,
        nodeMetaMap,
        macroMetaMap,
        metricMetaMap,
        sourceMetaMap,
        graphMetaMap,
        testMetaMap,
        docMetaMap,
        exposureMetaMap
       } ]
      };
     }));
    }
    readAndParseManifest(projectRoot, targetPath) {
     const pathParts = [ targetPath ];
     path.isAbsolute(targetPath) || pathParts.unshift(projectRoot.fsPath);
     const manifestLocation = path.join(...pathParts, dbtProject_1.DBTProject.MANIFEST_FILE);
     this.terminal.debug("ManifestParser", `Reading manifest at ${manifestLocation} for project at ${projectRoot}`);
     try {
      const manifestFile = (0, fs_1.readFileSync)(manifestLocation, "utf8");
      return JSON.parse(manifestFile);
     } catch (error) {
      this.terminal.error("ManifestParser", `Could not read manifest file at ${manifestLocation}, ignoring error`, error);
     }
    }
   };
   ManifestParser = ManifestParser_1 = tslib_1.__decorate([ (0, inversify_binding_decorators_1.provide)(ManifestParser_1), tslib_1.__metadata("design:paramtypes", [ nodeParser_1.NodeParser, macroParser_1.MacroParser, metricParser_1.MetricParser, graphParser_1.GraphParser, sourceParser_1.SourceParser, testParser_1.TestParser, exposureParser_1.ExposureParser, docParser_1.DocParser, dbtTerminal_1.DBTTerminal, telemetry_1.TelemetryService ]) ], ManifestParser), 
   exports.ManifestParser = ManifestParser;
   exports.createFullPathForNode = (projectName, rootPath, packageName, packagePath, relativeFilePath) => {
    if (packageName !== projectName) {
     const rootPathWithPackage = path.join(packagePath, packageName, relativeFilePath);
     return (0, fs_1.existsSync)(rootPathWithPackage) ? rootPathWithPackage : void 0;
    }
    return path.join(rootPath, relativeFilePath);
   };
  },
  54176: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var MacroParser_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.MacroParser = void 0;
   const tslib_1 = __webpack_require__(31635), fs_1 = __webpack_require__(79896), inversify_binding_decorators_1 = __webpack_require__(25567), dbtTerminal_1 = __webpack_require__(83683), _1 = __webpack_require__(12847);
   let MacroParser = MacroParser_1 = class {
    constructor(terminal) {
     this.terminal = terminal;
    }
    createMacroMetaMap(macros, project) {
     return new Promise((resolve => tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.terminal.debug("MacroParser", `Parsing macros for "${project.getProjectName()}" at ${project.projectRoot}`);
      const macroMetaMap = new Map;
      null == macros && resolve(macroMetaMap);
      const rootPath = project.projectRoot.fsPath, projectName = project.getProjectName(), packagePath = project.getPackageInstallPath();
      if (void 0 === packagePath) throw new Error("packagePath is not defined in " + project.projectRoot.fsPath);
      for (const key in macros) {
       const macro = macros[key], {package_name, name, original_file_path, depends_on} = macro, packageName = package_name, macroName = packageName === projectName ? name : `${packageName}.${name}`, fullPath = (0, 
       _1.createFullPathForNode)(projectName, rootPath, packageName, packagePath, original_file_path);
       if (fullPath) try {
        const macroFileLines = (0, fs_1.readFileSync)(fullPath).toString("utf8").split("\n");
        for (let index = 0; index < macroFileLines.length; index++) {
         const currentLine = macroFileLines[index];
         if (currentLine.match(new RegExp(`macro\\s${name}\\(`)) || currentLine.match(new RegExp(`test\\s${name.replace("test_", "")}\\(`))) {
          macroMetaMap.set(macroName, {
           path: fullPath,
           line: index,
           character: currentLine.indexOf(name),
           uniqueId: key,
           description: macro.description,
           arguments: macro.arguments,
           name,
           depends_on
          });
          break;
         }
        }
       } catch (error) {
        this.terminal.debug("MacroParser", `File not found at '${fullPath}', probably compiled is outdated.`, error);
       }
      }
      this.terminal.debug("MacroParser", `Returning macros for "${project.getProjectName()}" at ${project.projectRoot}`, macroMetaMap), 
      resolve(macroMetaMap);
     }))));
    }
   };
   MacroParser = MacroParser_1 = tslib_1.__decorate([ (0, inversify_binding_decorators_1.provide)(MacroParser_1), tslib_1.__metadata("design:paramtypes", [ dbtTerminal_1.DBTTerminal ]) ], MacroParser), 
   exports.MacroParser = MacroParser;
  },
  696: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var MetricParser_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.MetricParser = void 0;
   const tslib_1 = __webpack_require__(31635), inversify_binding_decorators_1 = __webpack_require__(25567), dbtTerminal_1 = __webpack_require__(83683);
   let MetricParser = MetricParser_1 = class {
    constructor(terminal) {
     this.terminal = terminal;
    }
    createMetricMetaMap(metrics, project) {
     return new Promise((resolve => tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.terminal.debug("MetricParser", `Parsing metrics for "${project.getProjectName()}" at ${project.projectRoot}`);
      const metricMetaMap = new Map;
      null == metrics && resolve(metricMetaMap);
      for (const key in metrics) {
       const metric = metrics[key];
       metricMetaMap.set(metric.name, {
        name: metric.name
       });
      }
      this.terminal.debug("MetricParser", `Returning metrics for "${project.getProjectName()}" at ${project.projectRoot}`, metricMetaMap), 
      resolve(metricMetaMap);
     }))));
    }
   };
   MetricParser = MetricParser_1 = tslib_1.__decorate([ (0, inversify_binding_decorators_1.provide)(MetricParser_1), tslib_1.__metadata("design:paramtypes", [ dbtTerminal_1.DBTTerminal ]) ], MetricParser), 
   exports.MetricParser = MetricParser;
  },
  66144: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var NodeParser_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.NodeParser = exports.NodeMetaMapImpl = void 0;
   const tslib_1 = __webpack_require__(31635), inversify_binding_decorators_1 = __webpack_require__(25567), dbtProject_1 = __webpack_require__(38821), _1 = __webpack_require__(12847), dbtTerminal_1 = __webpack_require__(83683), utils_1 = __webpack_require__(86185), path = __webpack_require__(16928), path_1 = __webpack_require__(16928);
   class NodeMetaMapImpl {
    constructor(latestVersionLookupMap = new Map, modelNameLookupMap = new Map, modelMetadataLookupMap = new Map) {
     this.latestVersionLookupMap = latestVersionLookupMap, this.modelNameLookupMap = modelNameLookupMap, 
     this.modelMetadataLookupMap = modelMetadataLookupMap;
    }
    lookupByBaseName(modelBaseName) {
     const uniqueId = this.modelNameLookupMap.get(modelBaseName);
     if (uniqueId) return this.lookupByUniqueId(uniqueId);
    }
    lookupByUniqueId(uniqueId) {
     const latestVersionUniqueID = this.latestVersionLookupMap.get(uniqueId);
     return latestVersionUniqueID ? this.modelMetadataLookupMap.get(latestVersionUniqueID) : this.modelMetadataLookupMap.get(uniqueId);
    }
    nodes() {
     return this.modelMetadataLookupMap.values();
    }
   }
   exports.NodeMetaMapImpl = NodeMetaMapImpl;
   let NodeParser = NodeParser_1 = class {
    constructor(terminal) {
     this.terminal = terminal;
    }
    createNodeMetaMap(nodesMap, project) {
     return new Promise((resolve => tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.terminal.debug("NodeParser", `Parsing nodes for "${project.getProjectName()}" at ${project.projectRoot}`);
      const latestVersionLookupMap = new Map, modelMetadataLookupMap = new Map, modelNameLookupMap = new Map;
      null == nodesMap && resolve(new NodeMetaMapImpl(new Map, new Map));
      const nodesMaps = Object.values(nodesMap).filter((model => dbtProject_1.DBTProject.isResourceNode(model.resource_type))), rootPath = project.projectRoot.fsPath, projectName = project.getProjectName(), packagePath = project.getPackageInstallPath();
      if (void 0 === packagePath) throw new Error("packagePath is not defined " + project.projectRoot.fsPath);
      const externalProjectNames = (0, utils_1.getExternalProjectNamesFromDbtLoomConfig)(project.projectRoot.fsPath);
      for (const nodesMap of nodesMaps) {
       const {name, original_file_path, database, schema, alias, package_name, latest_version, version, unique_id, columns, description, patch_path, config, resource_type, depends_on} = nodesMap, fullPath = (0, 
       _1.createFullPathForNode)(projectName, rootPath, package_name, packagePath, original_file_path), targetPath = project.getTargetPath();
       if (fullPath && modelNameLookupMap.set((0, path_1.basename)(fullPath, ".sql"), unique_id), 
       version && latest_version && version === latest_version) {
        const parts = unique_id.split(".");
        parts.pop(), latestVersionLookupMap.set(parts.join("."), unique_id);
       }
       modelMetadataLookupMap.set(unique_id, {
        path: fullPath,
        database,
        schema,
        alias,
        name,
        package_name,
        uniqueId: unique_id,
        columns,
        description,
        patch_path,
        config,
        resource_type,
        depends_on,
        is_external_project: Boolean(null == externalProjectNames ? void 0 : externalProjectNames.includes(package_name)),
        compiled_path: targetPath ? path.join(targetPath, "compiled", package_name, original_file_path) : ""
       });
      }
      this.terminal.debug("NodeParser", `Returning nodes for "${project.getProjectName()}" at ${project.projectRoot}`, modelNameLookupMap, modelMetadataLookupMap);
      const nodeMetaMap = new NodeMetaMapImpl(latestVersionLookupMap, modelNameLookupMap, modelMetadataLookupMap);
      resolve(nodeMetaMap);
     }))));
    }
   };
   NodeParser = NodeParser_1 = tslib_1.__decorate([ (0, inversify_binding_decorators_1.provide)(NodeParser_1), tslib_1.__metadata("design:paramtypes", [ dbtTerminal_1.DBTTerminal ]) ], NodeParser), 
   exports.NodeParser = NodeParser;
  },
  38417: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var SourceParser_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.SourceParser = void 0;
   const tslib_1 = __webpack_require__(31635), inversify_binding_decorators_1 = __webpack_require__(25567), path = __webpack_require__(16928), dbtTerminal_1 = __webpack_require__(83683), dbtProject_1 = __webpack_require__(38821), utils_1 = __webpack_require__(86185);
   let SourceParser = SourceParser_1 = class {
    constructor(terminal) {
     this.terminal = terminal;
    }
    createSourceMetaMap(sourcesMap, project) {
     return new Promise((resolve => {
      this.terminal.debug("SourceParser", `Parsing sources for "${project.getProjectName()}" at ${project.projectRoot}`);
      const sourceMetaMap = new Map;
      null == sourcesMap && resolve(sourceMetaMap);
      const rootPath = project.projectRoot.fsPath;
      project.getProjectName();
      if (void 0 === project.getPackageInstallPath()) throw new Error("packagePath is not defined in " + project.projectRoot.fsPath);
      const externalProjectNames = (0, utils_1.getExternalProjectNamesFromDbtLoomConfig)(project.projectRoot.fsPath);
      Object.values(sourcesMap).filter((source => source.resource_type === dbtProject_1.DBTProject.RESOURCE_TYPE_SOURCE)).reduce(((previousValue, {source_name, database, schema, name, original_file_path, unique_id, description, columns, identifier, package_name}) => {
       let source = previousValue.get(source_name);
       source || (source = {
        tables: [],
        uniqueId: unique_id,
        name: source_name,
        database,
        schema,
        package_name,
        is_external_project: Boolean(null == externalProjectNames ? void 0 : externalProjectNames.includes(package_name))
       }, previousValue.set(source_name, source));
       const fullPath = path.join(rootPath, original_file_path);
       return source.tables.push({
        name,
        identifier,
        path: fullPath,
        description,
        columns
       }), previousValue;
      }), sourceMetaMap), this.terminal.debug("SourceParser", `Returning sources for "${project.getProjectName()}" at ${project.projectRoot}`, sourceMetaMap), 
      resolve(sourceMetaMap);
     }));
    }
   };
   SourceParser = SourceParser_1 = tslib_1.__decorate([ (0, inversify_binding_decorators_1.provide)(SourceParser_1), tslib_1.__metadata("design:paramtypes", [ dbtTerminal_1.DBTTerminal ]) ], SourceParser), 
   exports.SourceParser = SourceParser;
  },
  41708: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var TestParser_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.TestParser = void 0;
   const tslib_1 = __webpack_require__(31635), inversify_binding_decorators_1 = __webpack_require__(25567), path = __webpack_require__(16928), dbtProject_1 = __webpack_require__(38821), dbtTerminal_1 = __webpack_require__(83683);
   let TestParser = TestParser_1 = class {
    constructor(terminal) {
     this.terminal = terminal;
    }
    getColumnNameWithoutQuotes(columnName) {
     if (columnName) return columnName.startsWith('"') && columnName.endsWith('"') ? columnName.slice(1, -1) : columnName;
    }
    createTestMetaMap(testsMap, project) {
     return new Promise((resolve => {
      this.terminal.debug("TestParser", `Parsing tests for "${project.getProjectName()}" at ${project.projectRoot}`);
      const testMetaMap = new Map;
      null == testsMap && resolve(testMetaMap);
      const rootPath = project.projectRoot.fsPath;
      Object.values(testsMap).filter((test => test.resource_type === dbtProject_1.DBTProject.RESOURCE_TYPE_TEST)).forEach((({name, raw_sql, original_file_path, database, schema, alias, column_name, test_metadata, attached_node, depends_on, unique_id}) => {
       const fullPath = path.join(rootPath, original_file_path);
       testMetaMap.set(name, {
        path: fullPath,
        raw_sql,
        database,
        schema,
        alias,
        column_name: this.getColumnNameWithoutQuotes(column_name),
        test_metadata,
        attached_node,
        depends_on,
        uniqueId: unique_id
       });
      })), this.terminal.debug("TestParser", `Returning tests for "${project.getProjectName()}" at ${project.projectRoot}`, testMetaMap), 
      resolve(testMetaMap);
     }));
    }
   };
   TestParser = TestParser_1 = tslib_1.__decorate([ (0, inversify_binding_decorators_1.provide)(TestParser_1), tslib_1.__metadata("design:paramtypes", [ dbtTerminal_1.DBTTerminal ]) ], TestParser), 
   exports.TestParser = TestParser;
  },
  88103: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var PythonEnvironment_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.PythonEnvironment = void 0;
   const tslib_1 = __webpack_require__(31635), vscode_1 = __webpack_require__(54980), utils_1 = __webpack_require__(86185), telemetry_1 = __webpack_require__(22644), commandProcessExecution_1 = __webpack_require__(7824), dbtTerminal_1 = __webpack_require__(83683);
   let PythonEnvironment = PythonEnvironment_1 = class {
    constructor(telemetry, commandProcessExecutionFactory, dbtTerminal) {
     this.telemetry = telemetry, this.commandProcessExecutionFactory = commandProcessExecutionFactory, 
     this.dbtTerminal = dbtTerminal, this.disposables = [], this.environmentVariableSource = {}, 
     this.allPythonPaths = [], this.isPython3 = !0;
    }
    dispose() {
     for (;this.disposables.length; ) {
      const x = this.disposables.pop();
      x && x.dispose();
     }
    }
    printEnvVars() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      yield this.dbtTerminal.show(!0);
      const envVars = this.environmentVariables;
      this.dbtTerminal.log("Printing environment variables...\r\n");
      for (const key in envVars) this.dbtTerminal.log(`${key}=${envVars[key]}\t\tsource:${this.environmentVariableSource[key]}\r\n`);
     }));
    }
    get pythonPath() {
     return this.getResolvedConfigValue("dbtPythonPathOverride") || this.executionDetails.getPythonPath();
    }
    get environmentVariables() {
     if (!this.executionDetails) throw new Error("executionDetails is undefined, cannot retrieve environment variables");
     return this.executionDetails.getEnvVars();
    }
    get onPythonEnvironmentChanged() {
     return this.executionDetails.onDidChangeExecutionDetails;
    }
    initialize() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      void 0 === this.executionDetails && (this.executionDetails = yield this.activatePythonExtension());
     }));
    }
    getResolvedConfigValue(key) {
     const value = vscode_1.workspace.getConfiguration("dbt").get(key, "");
     return this.substituteSettingsVariables(value, this.environmentVariables);
    }
    substituteSettingsVariables(value, vsCodeEnv) {
     if (!value) return value;
     if ("string" != typeof value) return value;
     const regexVsCodeEnv = /\$\{env\:(.*?)\}/gm;
     let matchResult;
     for (;null !== (matchResult = regexVsCodeEnv.exec(value)); ) matchResult.index === regexVsCodeEnv.lastIndex && regexVsCodeEnv.lastIndex++, 
     void 0 !== vsCodeEnv[matchResult[1]] && (value = value.replace(new RegExp(`\\$\\{env\\:${matchResult[1]}\\}`, "gm"), vsCodeEnv[matchResult[1]]), 
     this.dbtTerminal.debug("pythonEnvironment:substituteSettingsVariables", `Picking env var ${matchResult[1]} from ${this.environmentVariableSource[matchResult[1]]}`));
     return value = value.replace("${workspaceFolder}", vscode_1.workspace.workspaceFolders[0].uri.fsPath);
    }
    activatePythonExtension() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const extension = vscode_1.extensions.getExtension("ms-python.python");
      extension.isActive || (yield extension.activate()), yield extension.exports.ready;
      const api = extension.exports;
      this.allPythonPaths = yield api.environment.getEnvironmentPaths();
      const pythonPath = api.settings.getExecutionDetails(vscode_1.workspace.workspaceFile).execCommand[0], envDetails = yield api.environment.getEnvironmentDetails(pythonPath);
      this.isPython3 = "3" === (null == envDetails ? void 0 : envDetails.version[0]);
      const dbtInstalledPythonPath = [];
      return this.executionDetails = {
       getPythonPath: () => dbtInstalledPythonPath.length > 0 ? dbtInstalledPythonPath[0] : api.settings.getExecutionDetails(vscode_1.workspace.workspaceFile).execCommand[0],
       onDidChangeExecutionDetails: api.settings.onDidChangeExecutionDetails,
       getEnvVars: () => {
        const envVars = {};
        for (const key in process.env) envVars[key] = process.env[key], this.environmentVariableSource[key] = "process";
        try {
         const integratedEnv = vscode_1.workspace.getConfiguration("terminal").get("integrated.env");
         if (integratedEnv) for (const prop in integratedEnv) if ([ "osx", "windows", "linux" ].includes(prop)) {
          this.dbtTerminal.debug("pythonEnvironment:envVars", "Loading env vars from config.terminal.integrated.env", "Merging from " + prop, Object.keys(integratedEnv[prop]));
          for (const key in integratedEnv[prop]) envVars[key] = this.substituteSettingsVariables(integratedEnv[prop][key], process.env), 
          this.environmentVariableSource[key] = "integrated";
         } else this.dbtTerminal.debug("pythonEnvironment:envVars", "Loading env vars from config.terminal.integrated.env", "Ignoring invalid property " + prop);
         if (api.environment) {
          const workspacePath = vscode_1.workspace.workspaceFolders[0];
          this.dbtTerminal.debug("pythonEnvironment:envVars", `workspacePath:${workspacePath.uri.fsPath}`);
          const workspaceEnv = api.environments.getEnvironmentVariables(workspacePath);
          this.dbtTerminal.debug("pythonEnvironment:envVars", `workspaceEnv:${Object.keys(workspaceEnv)}`);
          for (const key in workspaceEnv) key in envVars && workspaceEnv[key] === envVars[key] || (envVars[key] = workspaceEnv[key], 
          this.environmentVariableSource[key] = "dotenv");
         }
        } catch (e) {
         this.dbtTerminal.error("getEnvVarsError", "Could not call environment api", e);
        }
        return envVars;
       }
      };
     }));
    }
   };
   PythonEnvironment = PythonEnvironment_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(PythonEnvironment_1), tslib_1.__metadata("design:paramtypes", [ telemetry_1.TelemetryService, commandProcessExecution_1.CommandProcessExecutionFactory, dbtTerminal_1.DBTTerminal ]) ], PythonEnvironment), 
   exports.PythonEnvironment = PythonEnvironment;
  },
  80537: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.DBTProject = exports.QueryManifestService = exports.DBTProjectContainer = exports.CommandProcessExecutionFactory = exports.PythonEnvironment = exports.provideSingleton = exports.AltimateRequest = exports.getFirstWorkspacePath = exports.extendErrorWithSupportLinks = exports.DBTCommandExecutionInfrastructure = exports.DBTTerminal = exports.TelemetryEvents = exports.TelemetryService = void 0;
   var telemetry_1 = __webpack_require__(22644);
   Object.defineProperty(exports, "TelemetryService", {
    enumerable: !0,
    get: function() {
     return telemetry_1.TelemetryService;
    }
   });
   var events_1 = __webpack_require__(91723);
   Object.defineProperty(exports, "TelemetryEvents", {
    enumerable: !0,
    get: function() {
     return events_1.TelemetryEvents;
    }
   });
   var dbtTerminal_1 = __webpack_require__(83683);
   Object.defineProperty(exports, "DBTTerminal", {
    enumerable: !0,
    get: function() {
     return dbtTerminal_1.DBTTerminal;
    }
   });
   var dbtIntegration_1 = __webpack_require__(22373);
   Object.defineProperty(exports, "DBTCommandExecutionInfrastructure", {
    enumerable: !0,
    get: function() {
     return dbtIntegration_1.DBTCommandExecutionInfrastructure;
    }
   });
   var utils_1 = __webpack_require__(86185);
   Object.defineProperty(exports, "extendErrorWithSupportLinks", {
    enumerable: !0,
    get: function() {
     return utils_1.extendErrorWithSupportLinks;
    }
   }), Object.defineProperty(exports, "getFirstWorkspacePath", {
    enumerable: !0,
    get: function() {
     return utils_1.getFirstWorkspacePath;
    }
   });
   var altimate_1 = __webpack_require__(91741);
   Object.defineProperty(exports, "AltimateRequest", {
    enumerable: !0,
    get: function() {
     return altimate_1.AltimateRequest;
    }
   });
   var utils_2 = __webpack_require__(86185);
   Object.defineProperty(exports, "provideSingleton", {
    enumerable: !0,
    get: function() {
     return utils_2.provideSingleton;
    }
   });
   var pythonEnvironment_1 = __webpack_require__(88103);
   Object.defineProperty(exports, "PythonEnvironment", {
    enumerable: !0,
    get: function() {
     return pythonEnvironment_1.PythonEnvironment;
    }
   });
   var commandProcessExecution_1 = __webpack_require__(7824);
   Object.defineProperty(exports, "CommandProcessExecutionFactory", {
    enumerable: !0,
    get: function() {
     return commandProcessExecution_1.CommandProcessExecutionFactory;
    }
   });
   var dbtProjectContainer_1 = __webpack_require__(82018);
   Object.defineProperty(exports, "DBTProjectContainer", {
    enumerable: !0,
    get: function() {
     return dbtProjectContainer_1.DBTProjectContainer;
    }
   });
   var queryManifestService_1 = __webpack_require__(59269);
   Object.defineProperty(exports, "QueryManifestService", {
    enumerable: !0,
    get: function() {
     return queryManifestService_1.QueryManifestService;
    }
   });
   var dbtProject_1 = __webpack_require__(38821);
   Object.defineProperty(exports, "DBTProject", {
    enumerable: !0,
    get: function() {
     return dbtProject_1.DBTProject;
    }
   });
  },
  25809: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var DbtPowerUserActionsCenter_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.DbtPowerUserActionsCenter = void 0;
   const tslib_1 = __webpack_require__(31635), vscode_1 = __webpack_require__(54980), utils_1 = __webpack_require__(86185), puQuickPick_1 = __webpack_require__(86134), projectQuickPick_1 = __webpack_require__(28448), dbtProjectContainer_1 = __webpack_require__(82018), sqlQuickPick_1 = __webpack_require__(92579);
   let DbtPowerUserActionsCenter = DbtPowerUserActionsCenter_1 = class {
    constructor(puLaunchQuickPick, projectQuickPick, dbtProjectContainer, sqlQuickPick) {
     this.puLaunchQuickPick = puLaunchQuickPick, this.projectQuickPick = projectQuickPick, 
     this.dbtProjectContainer = dbtProjectContainer, this.sqlQuickPick = sqlQuickPick, 
     this.disposables = [], vscode_1.commands.registerCommand("dbtPowerUser.puQuickPick", (() => tslib_1.__awaiter(this, void 0, void 0, (function*() {
      yield this.puLaunchQuickPick.openPuQuickPick();
     })))), vscode_1.commands.registerCommand("dbtPowerUser.openInsights", (() => tslib_1.__awaiter(this, void 0, void 0, (function*() {
      yield vscode_1.commands.executeCommand("dbtPowerUser.Insights.focus");
     })))), vscode_1.commands.registerCommand("dbtPowerUser.sqlQuickPick", (() => tslib_1.__awaiter(this, void 0, void 0, (function*() {
      yield this.sqlQuickPick.openQuickPick();
     })))), vscode_1.commands.registerCommand("dbtPowerUser.pickProject", (() => tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const pickedProject = yield this.projectQuickPick.projectPicker(yield this.dbtProjectContainer.getProjects());
      pickedProject && (this.dbtProjectContainer.setToWorkspaceState("dbtPowerUser.projectSelected", pickedProject), 
      vscode_1.commands.executeCommand("setContext", "dbtPowerUser.walkthroughProjectSelected", !0), 
      vscode_1.window.showInformationMessage("You have succesfully selected " + pickedProject.label + "."));
     }))));
    }
    dispose() {
     for (;this.disposables.length; ) {
      const x = this.disposables.pop();
      x && x.dispose();
     }
    }
   };
   DbtPowerUserActionsCenter = DbtPowerUserActionsCenter_1 = tslib_1.__decorate([ (0, 
   utils_1.provideSingleton)(DbtPowerUserActionsCenter_1), tslib_1.__metadata("design:paramtypes", [ puQuickPick_1.DbtPowerUserControlCenterAction, projectQuickPick_1.ProjectQuickPick, dbtProjectContainer_1.DBTProjectContainer, sqlQuickPick_1.DbtSQLAction ]) ], DbtPowerUserActionsCenter), 
   exports.DbtPowerUserActionsCenter = DbtPowerUserActionsCenter;
  },
  28448: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var ProjectQuickPick_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.ProjectQuickPick = void 0;
   const tslib_1 = __webpack_require__(31635), vscode_1 = __webpack_require__(54980), utils_1 = __webpack_require__(86185);
   let ProjectQuickPick = ProjectQuickPick_1 = class {
    projectPicker(projects) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const options = projects.map((item => ({
       label: item.getProjectName(),
       description: item.projectRoot.fsPath,
       uri: item.projectRoot
      }))), pick = yield vscode_1.window.showQuickPick(options, {
       title: "Select a Project",
       canPickMany: !1
      });
      if (pick) return pick;
     }));
    }
   };
   ProjectQuickPick = ProjectQuickPick_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(ProjectQuickPick_1) ], ProjectQuickPick), 
   exports.ProjectQuickPick = ProjectQuickPick;
  },
  86134: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var DbtPowerUserControlCenterAction_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.DbtPowerUserControlCenterAction = void 0;
   const tslib_1 = __webpack_require__(31635), vscode_1 = __webpack_require__(54980), utils_1 = __webpack_require__(86185);
   let DbtPowerUserControlCenterAction = DbtPowerUserControlCenterAction_1 = class {
    openPuQuickPick() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const disposables = [], dbtIntegration = vscode_1.workspace.getConfiguration("dbt").get("dbtIntegration", "core");
      try {
       return yield new Promise(((resolve, reject) => {
        const dbtpuquickpick = vscode_1.window.createQuickPick();
        dbtpuquickpick.title = "dbt Power User Control Panel", dbtpuquickpick.items = [ new DbtPowerUserControlPanelItem("core" === dbtIntegration ? "Switch to dbt cloud" : "Switch to dbt core", "compare-changes", "core" === dbtIntegration ? "Are you using dbt cloud?" : "Are you using dbt core?", "dbtPowerUser.switchDbtIntegration"), new DbtPowerUserControlPanelItem("Setup Extension", "debug", "Open the extension setup walkthrough", "dbtPowerUser.openSetupWalkthrough"), new DbtPowerUserControlPanelItem("dbt Power User Tutorials", "book", "Open the dbt Power User Tutorials", "dbtPowerUser.openTutorialWalkthrough"), new DbtPowerUserControlPanelItem("Documentation", "link-external", "View the detailed Documentation for the extension", "vscode.open", [ vscode_1.Uri.parse("https://docs.myaltimate.com") ]), {
         label: "",
         kind: vscode_1.QuickPickItemKind.Separator
        }, new DbtPowerUserControlPanelItem("Run Project Healthcheck", "debug-start", "Run the Project healthcheck", "dbtPowerUser.altimateScan"), new DbtPowerUserControlPanelItem("Clear Healthcheck Results", "debug-stop", "Clear all problems", "dbtPowerUser.clearAltimateScanResults"), new DbtPowerUserControlPanelItem("Diagnostics", "tools", "Run diagnostics on the dbt project", "dbtPowerUser.diagnostics"), {
         label: "",
         kind: vscode_1.QuickPickItemKind.Separator
        }, new DbtPowerUserControlPanelItem("Join the Community", "add", "Join our slack community", "vscode.open", [ vscode_1.Uri.parse("https://getdbt.slack.com/archives/C05KPDGRMDW") ]), new DbtPowerUserControlPanelItem("Feedback", "feed", "Give us Feedback!", "vscode.open", [ vscode_1.Uri.parse("https://docs.google.com/forms/d/e/1FAIpQLSf7X2nQ3cfqpP6-uYSTE-mFg41ZKigCh2ytPUuX1jz7FoZOnw/viewform?usp=sf_link") ]) ], 
        disposables.push(dbtpuquickpick.onDidChangeValue((value => {
         dbtpuquickpick.busy = !0;
        })), dbtpuquickpick.onDidChangeSelection((items => {
         const item = items[0];
         item instanceof DbtPowerUserControlPanelItem && (vscode_1.commands.executeCommand(item.command, ...item.commandArgs), 
         dbtpuquickpick.hide());
        })), dbtpuquickpick.onDidHide((() => {
         resolve(void 0), dbtpuquickpick.dispose();
        }))), dbtpuquickpick.show();
       }));
      } finally {
       disposables.forEach((d => d.dispose()));
      }
     }));
    }
   };
   DbtPowerUserControlCenterAction = DbtPowerUserControlCenterAction_1 = tslib_1.__decorate([ (0, 
   utils_1.provideSingleton)(DbtPowerUserControlCenterAction_1) ], DbtPowerUserControlCenterAction), 
   exports.DbtPowerUserControlCenterAction = DbtPowerUserControlCenterAction;
   class DbtPowerUserControlPanelItem {
    constructor(label, iconPath = "", description, commandStr, commandArgs) {
     this.label = label, this.iconPath = new vscode_1.ThemeIcon(iconPath), this.description = description || "", 
     this.command = commandStr || "", this.commandArgs = commandArgs || [];
    }
   }
  },
  92579: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var DbtSQLAction_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.DbtSQLAction = void 0;
   const tslib_1 = __webpack_require__(31635), vscode_1 = __webpack_require__(54980), utils_1 = __webpack_require__(86185), dbtProjectContainer_1 = __webpack_require__(82018), path = __webpack_require__(16928);
   let DbtSQLAction = DbtSQLAction_1 = class {
    constructor(dbtProjectContainer) {
     this.dbtProjectContainer = dbtProjectContainer;
    }
    getProject() {
     var _a;
     const currentFilePath = null === (_a = vscode_1.window.activeTextEditor) || void 0 === _a ? void 0 : _a.document.uri;
     if (currentFilePath) return this.dbtProjectContainer.findDBTProject(currentFilePath);
    }
    openQuickPick() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const disposables = [];
      try {
       return yield new Promise(((resolve, reject) => tslib_1.__awaiter(this, void 0, void 0, (function*() {
        const dbtpuquickpick = vscode_1.window.createQuickPick();
        dbtpuquickpick.title = "SQL Actions";
        const items = [ new SQLActionItem("Validate SQL", new vscode_1.ThemeIcon("check-all"), "Validate the sql query", "dbtPowerUser.validateSql"), new SQLActionItem("Explain query", {
         light: vscode_1.Uri.file(path.join(path.resolve(__dirname), "../media/images/lightbulb_light.svg")),
         dark: vscode_1.Uri.file(path.join(path.resolve(__dirname), "../media/images/lightbulb_dark.svg"))
        }, "Explain the sql query (Preview feature)", "dbtPowerUser.summarizeQuery"), new SQLActionItem("Sql to Model", {
         light: vscode_1.Uri.file(path.join(path.resolve(__dirname), "../media/images/preview-dbt-light.svg")),
         dark: vscode_1.Uri.file(path.join(path.resolve(__dirname), "../media/images/preview-dbt-dark.svg"))
        }, "Convert sql to dbt model (Preview feature)", "dbtPowerUser.sqlToModel"), new SQLActionItem("Visualize SQL", new vscode_1.ThemeIcon("preview"), "Visualize the sql query", "dbtPowerUser.sqlLineage") ], project = this.getProject();
        if (project) {
         const adapter = project.getAdapterType(), dbtVersion = project.getDBTVersion();
         "bigquery" === adapter && dbtVersion && dbtVersion[0] >= 1 && dbtVersion[1] >= 6 && items.push(new SQLActionItem("BigQuery Cost Estimate", new vscode_1.ThemeIcon("dashboard"), "Estimate cost for BigQuery", "dbtPowerUser.bigqueryCostEstimate", [ !0 ]));
        }
        dbtpuquickpick.items = items, disposables.push(dbtpuquickpick.onDidChangeValue((value => {
         dbtpuquickpick.busy = !0;
        })), dbtpuquickpick.onDidChangeSelection((items => {
         const item = items[0];
         item instanceof SQLActionItem && (vscode_1.commands.executeCommand(item.command, ...item.commandArgs), 
         dbtpuquickpick.hide());
        })), dbtpuquickpick.onDidHide((() => {
         resolve(void 0), dbtpuquickpick.dispose();
        }))), dbtpuquickpick.show();
       }))));
      } finally {
       disposables.forEach((d => d.dispose()));
      }
     }));
    }
   };
   DbtSQLAction = DbtSQLAction_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(DbtSQLAction_1), tslib_1.__metadata("design:paramtypes", [ dbtProjectContainer_1.DBTProjectContainer ]) ], DbtSQLAction), 
   exports.DbtSQLAction = DbtSQLAction;
   class SQLActionItem {
    constructor(label, iconPath, description, commandStr, commandArgs) {
     this.label = label, this.iconPath = iconPath, this.description = description || "", 
     this.command = commandStr || "", this.commandArgs = commandArgs || [];
    }
   }
  },
  99311: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var ConversationService_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.ConversationService = void 0;
   const tslib_1 = __webpack_require__(31635), os = __webpack_require__(70857), vscode_1 = __webpack_require__(54980), utils_1 = __webpack_require__(86185), queryManifestService_1 = __webpack_require__(59269), dbtProject_1 = __webpack_require__(38821), path = __webpack_require__(16928), dbtTerminal_1 = __webpack_require__(83683), altimate_1 = __webpack_require__(91741), fs_1 = __webpack_require__(79896);
   let ConversationService = ConversationService_1 = class {
    constructor(queryManifestService, dbtTerminal, altimateRequest) {
     this.queryManifestService = queryManifestService, this.dbtTerminal = dbtTerminal, 
     this.altimateRequest = altimateRequest, this.sharedDocs = [], this.conversationsBySharedDoc = {};
    }
    getConversations() {
     return this.conversationsBySharedDoc;
    }
    loadSharedDocs() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      try {
       if (this.altimateRequest.getCredentialsMessage()) return void this.dbtTerminal.debug("ConversationService:loadSharedDocs", "Missing credentials. skipping loadSharedDocs");
       const projectNames = this.queryManifestService.getProjectNamesInWorkspace();
       if (!(null == projectNames ? void 0 : projectNames.length)) return void this.dbtTerminal.debug("ConversationService:loadSharedDocs", "no valid project names. skipping loadSharedDocs");
       const shares = yield this.altimateRequest.getAllSharedDbtDocs(projectNames);
       return this.sharedDocs = shares || [], shares.forEach((share => {
        this.conversationsBySharedDoc[share.share_id] = share.conversation_group;
       })), this.sharedDocs;
      } catch (err) {
       this.dbtTerminal.error("ConversationService:loadSharedDocs", "Unable to load shared docs", err);
      }
     }));
    }
    getAppUrlByShareId(shareId) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      try {
       if (!this.altimateRequest.handlePreviewFeatures()) return;
       return this.altimateRequest.getAppUrlByShareId(shareId);
      } catch (err) {
       this.dbtTerminal.error("ConversationService:getAppUrlByShareId", "Unable to get url", err), 
       vscode_1.window.showErrorMessage((0, utils_1.extendErrorWithSupportLinks)(`Unable to get shareable url. Error: ${err.message}`));
      }
     }));
    }
    createConversationGroup(shareId, data) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      try {
       if (!this.altimateRequest.handlePreviewFeatures()) return;
       return this.altimateRequest.createConversationGroup(shareId, data);
      } catch (err) {
       this.dbtTerminal.error("ConversationService:createConversationGroup", "Unable to create conversation group", err), 
       vscode_1.window.showErrorMessage((0, utils_1.extendErrorWithSupportLinks)(`Unable to save your comment. Error: ${err.message}`));
      }
     }));
    }
    addConversationToGroup(shareId, conversationGroupId, message) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      try {
       if (!this.altimateRequest.handlePreviewFeatures()) return;
       const result = yield this.altimateRequest.addConversationToGroup(shareId, conversationGroupId, message);
       return this.dbtTerminal.debug("ConversationService:addConversationToGroup", "added new conversation", conversationGroupId), 
       result;
      } catch (err) {
       this.dbtTerminal.error("ConversationService:addConversationToGroup", "Unable to add reply to conversation", err), 
       vscode_1.window.showErrorMessage((0, utils_1.extendErrorWithSupportLinks)(`Unable to save your reply. Error: ${err.message}`));
      }
     }));
    }
    resolveConversation(shareId, conversationGroupId) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      try {
       if (!this.altimateRequest.handlePreviewFeatures()) return;
       return yield this.altimateRequest.resolveConversation(shareId, conversationGroupId);
      } catch (err) {
       this.dbtTerminal.error("ConversationService:resolveConversation", "Unable to resolve conversation group", err), 
       vscode_1.window.showErrorMessage((0, utils_1.extendErrorWithSupportLinks)(`Unable to resolve conversation. Error: ${err.message}`));
      }
     }));
    }
    loadConversationsByShareId(shareId) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      if (!this.altimateRequest.handlePreviewFeatures()) return;
      const conversations = yield this.altimateRequest.loadConversationsByShareId(shareId);
      return this.conversationsBySharedDoc[shareId] = conversations.dbt_docs_share_conversations, 
      conversations.dbt_docs_share_conversations;
     }));
    }
    shareDbtDocs(data) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      if (this.altimateRequest.handlePreviewFeatures()) return new Promise(((resolve, reject) => {
       vscode_1.window.withProgress({
        title: "",
        location: vscode_1.ProgressLocation.Notification,
        cancellable: !1
       }, (progress => tslib_1.__awaiter(this, void 0, void 0, (function*() {
        const project = this.queryManifestService.getProjectByUri(data.uri);
        if (!project) return void reject(new Error("Invalid dbt project"));
        progress.report({
         message: "Generating dbt docs..."
        });
        const hashedProjectRoot = dbtProject_1.DBTProject.hashProjectRoot(project.projectRoot.fsPath), tmpDirPath = path.join(os.tmpdir(), hashedProjectRoot);
        try {
         const args = data.model ? [ "--target-path", tmpDirPath, "--models", `+${data.model}+` ] : [ "--target-path", tmpDirPath ];
         this.dbtTerminal.debug("docGenService:shareDbtDocs", "generating docs in path:", args), 
         yield project.generateDocsImmediately(args), this.dbtTerminal.debug("docGenService:shareDbtDocs", "generated docs in path:", tmpDirPath), 
         this.dbtTerminal.debug("docGenService:shareDbtDocs", "creating dbt share id", data), 
         progress.report({
          message: "Creating dbt_docs_share record..."
         });
         const createShareResult = yield this.altimateRequest.createDbtDocsShare(data, project.getProjectName());
         this.dbtTerminal.debug("docGenService:shareDbtDocs", "created dbt share id", createShareResult);
         const filePathMapping = {
          "manifest.json": "manifest_presigned_url",
          "catalog.json": "catalog_presigned_url"
         };
         progress.report({
          message: "Uploading artifacts..."
         });
         if (2 !== (yield Promise.all(Object.keys(filePathMapping).map((file => tslib_1.__awaiter(this, void 0, void 0, (function*() {
          const url = createShareResult[filePathMapping[file]];
          if (!url) throw new Error(`Invalid presigned url for ${file}`);
          return this.altimateRequest.uploadToS3(url, {}, path.join(tmpDirPath, file));
         })))))).length) return void reject(new Error("Unable to upload required artifacts. Please try again later."));
         progress.report({
          message: "Verifying uploads..."
         });
         const verifyResult = yield this.altimateRequest.verifyDbtDocsUpload(createShareResult.share_id);
         if (!verifyResult.dbt_docs_share_url) return void reject(new Error("Unable to verify uploads. Please try again."));
         progress.report({
          message: "Resolving..."
         }), resolve({
          shareUrl: verifyResult.dbt_docs_share_url,
          shareId: createShareResult.share_id
         });
        } catch (err) {
         reject(err);
        } finally {
         this.dbtTerminal.debug("docGenService:shareDbtDocs", "deleting docs tmp directory", tmpDirPath), 
         (0, fs_1.rmSync)(tmpDirPath, {
          force: !0,
          recursive: !0
         });
        }
       }))));
      }));
     }));
    }
   };
   ConversationService = ConversationService_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(ConversationService_1), tslib_1.__metadata("design:paramtypes", [ queryManifestService_1.QueryManifestService, dbtTerminal_1.DBTTerminal, altimate_1.AltimateRequest ]) ], ConversationService), 
   exports.ConversationService = ConversationService;
  },
  45451: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var DbtLineageService_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.DbtLineageService = exports.CllEvents = void 0;
   const tslib_1 = __webpack_require__(31635), _extension_1 = __webpack_require__(80537), utils_1 = __webpack_require__(86185), vscode_1 = __webpack_require__(54980), node_fetch_1 = __webpack_require__(82065);
   var CllEvents;
   !function(CllEvents) {
    CllEvents.START = "start", CllEvents.END = "end", CllEvents.CANCEL = "cancel";
   }(CllEvents = exports.CllEvents || (exports.CllEvents = {}));
   const CAN_COMPILE_SQL_NODE = [ _extension_1.DBTProject.RESOURCE_TYPE_MODEL, _extension_1.DBTProject.RESOURCE_TYPE_SNAPSHOT, _extension_1.DBTProject.RESOURCE_TYPE_ANALYSIS ];
   class DerivedCancellationTokenSource extends vscode_1.CancellationTokenSource {
    constructor(linkedToken) {
     super(), linkedToken.onCancellationRequested((() => {
      super.cancel();
     }));
    }
   }
   let DbtLineageService = DbtLineageService_1 = class {
    constructor(altimateRequest, telemetry, dbtTerminal, queryManifestService) {
     this.altimateRequest = altimateRequest, this.telemetry = telemetry, this.dbtTerminal = dbtTerminal, 
     this.queryManifestService = queryManifestService, this.cllProgressResolve = () => {};
    }
    handleColumnLineage({event}, onCancel) {
     var _a, _b, _c;
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      if (event !== CllEvents.START) return null === (_a = this.cancellationTokenSource) || void 0 === _a || _a.token.onCancellationRequested((e => {
       console.log(e);
      })), event === CllEvents.END ? (this.cllProgressResolve(), void (null === (_b = this.cancellationTokenSource) || void 0 === _b || _b.dispose())) : event === CllEvents.CANCEL ? (this.cllProgressResolve(), 
      void (null === (_c = this.cancellationTokenSource) || void 0 === _c || _c.cancel())) : void 0;
      vscode_1.window.withProgress({
       title: "Retrieving column level lineage",
       location: vscode_1.ProgressLocation.Notification,
       cancellable: !0
      }, ((_, token) => tslib_1.__awaiter(this, void 0, void 0, (function*() {
       yield new Promise((resolve => {
        this.cancellationTokenSource = new DerivedCancellationTokenSource(token), this.cllProgressResolve = resolve, 
        token.onCancellationRequested((() => {
         onCancel();
        }));
       }));
      }))));
     }));
    }
    getUpstreamTables({table}) {
     return {
      tables: this.getConnectedTables("children", table)
     };
    }
    getDownstreamTables({table}) {
     return {
      tables: this.getConnectedTables("parents", table)
     };
    }
    getConnectedTables(key, table) {
     const _event = this.queryManifestService.getEventByCurrentProject();
     if (!_event) return;
     const {event} = _event;
     if (!event) return;
     const {graphMetaMap} = event, node = graphMetaMap[key].get(table);
     if (!node) return;
     const tables = new Map;
     return node.nodes.forEach((({url, key}) => {
      const _node = this.createTable(event, url, key);
      _node && (tables.has(_node.table) || tables.set(_node.table, _node));
     })), Array.from(tables.values()).sort(((a, b) => a.table.localeCompare(b.table)));
    }
    createTable(event, tableUrl, key) {
     var _a, _b;
     const splits = key.split("."), nodeType = splits[0], {graphMetaMap, testMetaMap} = event, upstreamCount = this.getConnectedNodeCount(graphMetaMap.children, key), downstreamCount = this.getConnectedNodeCount(graphMetaMap.parents, key);
     if (nodeType === _extension_1.DBTProject.RESOURCE_TYPE_SOURCE) {
      const {sourceMetaMap} = event, schema = splits[2], table = splits[3], _node = sourceMetaMap.get(schema);
      if (!_node) return;
      const _table = _node.tables.find((t => t.name === table));
      if (!_table) return;
      return {
       table: key,
       label: table,
       url: tableUrl,
       upstreamCount,
       downstreamCount,
       nodeType,
       isExternalProject: _node.is_external_project,
       tests: ((null === (_a = graphMetaMap.tests.get(key)) || void 0 === _a ? void 0 : _a.nodes) || []).map((n => {
        const testKey = n.label.split(".")[0];
        return Object.assign(Object.assign({}, testMetaMap.get(testKey)), {
         key: testKey
        });
       })),
       columns: _table.columns,
       description: null == _table ? void 0 : _table.description,
       packageName: _node.package_name
      };
     }
     if (nodeType === _extension_1.DBTProject.RESOURCE_TYPE_METRIC) return {
      table: key,
      label: splits[2],
      url: tableUrl,
      upstreamCount,
      downstreamCount,
      nodeType,
      materialization: void 0,
      tests: [],
      columns: {},
      isExternalProject: !1
     };
     const {nodeMetaMap} = event, table = splits[2];
     if (nodeType === _extension_1.DBTProject.RESOURCE_TYPE_EXPOSURE) return {
      table: key,
      label: table,
      url: tableUrl,
      upstreamCount,
      downstreamCount,
      nodeType,
      materialization: void 0,
      tests: [],
      columns: {},
      isExternalProject: !1
     };
     const node = nodeMetaMap.lookupByUniqueId(key);
     if (!node) return;
     const materialization = node.config.materialized;
     return {
      table: key,
      label: node.alias,
      url: tableUrl,
      upstreamCount,
      downstreamCount,
      isExternalProject: node.is_external_project,
      nodeType,
      materialization,
      description: node.description,
      columns: node.columns,
      patchPath: node.patch_path,
      tests: ((null === (_b = graphMetaMap.tests.get(key)) || void 0 === _b ? void 0 : _b.nodes) || []).map((n => {
       const testKey = n.label.split(".")[0];
       return Object.assign(Object.assign({}, testMetaMap.get(testKey)), {
        key: testKey
       });
      })),
      packageName: node.package_name
     };
    }
    getConnectedNodeCount(g, key) {
     var _a;
     return (null === (_a = g.get(key)) || void 0 === _a ? void 0 : _a.nodes.length) || 0;
    }
    getConnectedColumns({targets, upstreamExpansion, currAnd1HopTables, selectedColumn, showIndirectEdges, eventType}) {
     var _a, _b;
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const _event = this.queryManifestService.getEventByCurrentProject();
      if (!_event) return;
      const {event} = _event;
      if (!event) return;
      const project = this.queryManifestService.getProject();
      if (!project) return;
      const modelInfos = [];
      let upstream_models = [], auxiliaryTables = [], sqlTables = [];
      currAnd1HopTables = Array.from(new Set(currAnd1HopTables));
      const currTables = new Set(targets.map((t => t[0])));
      if (upstreamExpansion) {
       const hop1Tables = currAnd1HopTables.filter((t => !currTables.has(t)));
       upstream_models = [ ...hop1Tables ], sqlTables = [ ...hop1Tables ], auxiliaryTables = _extension_1.DBTProject.getNonEphemeralParents(event, hop1Tables);
      } else auxiliaryTables = _extension_1.DBTProject.getNonEphemeralParents(event, Array.from(currTables)), 
      sqlTables = Array.from(currTables);
      currAnd1HopTables = Array.from(new Set(currAnd1HopTables));
      const modelsToFetch = Array.from(new Set([ ...currAnd1HopTables, ...auxiliaryTables, selectedColumn.table ])), {mappedNode, relationsWithoutColumns, mappedCompiledSql} = yield project.getNodesWithDBColumns(event, modelsToFetch, this.cancellationTokenSource.token), selected_column = {
       model_node: mappedNode[selectedColumn.table],
       column: selectedColumn.name
      };
      if (null === (_a = this.cancellationTokenSource) || void 0 === _a ? void 0 : _a.token.isCancellationRequested) return {
       column_lineage: []
      };
      const modelsToCompile = modelsToFetch.filter((key => {
       if (!sqlTables.includes(key)) return !1;
       return !!(nodeType => CAN_COMPILE_SQL_NODE.includes(nodeType))(key.split(".")[0]);
      })), bulkCompiledSql = yield project.getBulkCompiledSql(event, modelsToCompile.filter((m => !mappedCompiledSql[m])));
      for (const key of modelsToFetch) {
       const node = mappedNode[key];
       if (node) if (modelsToCompile.includes(key)) {
        let rawSql = "";
        if (node.path) try {
         rawSql = (yield vscode_1.workspace.fs.readFile(vscode_1.Uri.file(node.path))).toString();
        } catch (e) {
         this.dbtTerminal.warn("readRawSql", `Unable to read raw sql file ${node.path}`);
        }
        modelInfos.push({
         model_node: node,
         compiled_sql: mappedCompiledSql[key] || bulkCompiledSql[key],
         raw_sql: rawSql
        });
       } else modelInfos.push({
        model_node: node
       });
      }
      0 !== relationsWithoutColumns.length && vscode_1.window.showErrorMessage((0, utils_1.extendErrorWithSupportLinks)("Failed to fetch columns for " + relationsWithoutColumns.join(", ") + ". Probably the dbt models are not yet materialized."));
      const targetTables = Array.from(new Set(targets.map((t => t[0]))));
      if (0 === targets.length || modelInfos.length < targetTables.length) return this.telemetry.sendTelemetryError("columnLineageLogicError", {
       targets,
       modelInfos,
       upstreamExpansion,
       currAnd1HopTables,
       selectedColumn
      }), {
       column_lineage: []
      };
      if (modelInfos.length === targetTables.length) return {
       column_lineage: []
      };
      const models = modelInfos.map((m => m.model_node.uniqueId));
      if (!targets.every((t => models.includes(t[0])))) return {
       column_lineage: []
      };
      const modelDialect = project.getAdapterType();
      try {
       if (null === (_b = this.cancellationTokenSource) || void 0 === _b ? void 0 : _b.token.isCancellationRequested) return {
        column_lineage: []
       };
       const sessionId = `${vscode_1.env.sessionId}-${selectedColumn.table}-${selectedColumn.name}`, request = {
        model_dialect: modelDialect,
        model_info: modelInfos,
        upstream_expansion: upstreamExpansion,
        upstream_models,
        targets: targets.map((t => ({
         uniqueId: t[0],
         column_name: t[1]
        }))),
        selected_column,
        session_id: sessionId,
        show_indirect_edges: showIndirectEdges,
        event_type: eventType
       };
       this.dbtTerminal.debug("newLineagePanel:getConnectedColumns", "request", request);
       const startTime = Date.now(), result = yield this.altimateRequest.getColumnLevelLineage(request), apiTime = Date.now() - startTime;
       this.dbtTerminal.debug("newLineagePanel:getConnectedColumns", "response", result), 
       this.telemetry.sendTelemetryEvent("columnLineageTimes", {
        apiTime: apiTime.toString(),
        modelInfosLength: modelInfos.length.toString()
       }), console.log("lineageTimings:", {
        apiTime: apiTime.toString(),
        modelInfosLength: modelInfos.length.toString()
       }), !result.errors_dict && result.errors && result.errors.length > 0 && (vscode_1.window.showErrorMessage((0, 
       utils_1.extendErrorWithSupportLinks)(result.errors.join("\n"))), this.telemetry.sendTelemetryError("columnLineageApiError", {
        errors: result.errors
       }));
       return {
        column_lineage: result.column_lineage.map((c => ({
         source: [ c.source.uniqueId, c.source.column_name ],
         target: [ c.target.uniqueId, c.target.column_name ],
         type: c.type,
         viewsType: c.views_type,
         viewsCode: c.views_code
        }))) || [],
        confidence: result.confidence,
        errors: result.errors_dict
       };
      } catch (error) {
       return error instanceof node_fetch_1.AbortError ? (vscode_1.window.showErrorMessage((0, 
       utils_1.extendErrorWithSupportLinks)("Fetching column level lineage timed out.")), 
       void this.telemetry.sendTelemetryError("columnLevelLineageRequestTimeout", error)) : (vscode_1.window.showErrorMessage((0, 
       utils_1.extendErrorWithSupportLinks)("Could not generate column level lineage: " + error.message)), 
       void this.telemetry.sendTelemetryError("ColumnLevelLineageError", error));
      }
     }));
    }
   };
   DbtLineageService = DbtLineageService_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(DbtLineageService_1), tslib_1.__metadata("design:paramtypes", [ _extension_1.AltimateRequest, _extension_1.TelemetryService, _extension_1.DBTTerminal, _extension_1.QueryManifestService ]) ], DbtLineageService), 
   exports.DbtLineageService = DbtLineageService;
  },
  2188: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var DbtTestService_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.DbtTestService = void 0;
   const tslib_1 = __webpack_require__(31635), vscode_1 = __webpack_require__(54980), altimate_1 = __webpack_require__(91741), utils_1 = __webpack_require__(86185), docGenService_1 = __webpack_require__(88642), streamingService_1 = __webpack_require__(33846), queryManifestService_1 = __webpack_require__(59269), path = __webpack_require__(16928), dbtTerminal_1 = __webpack_require__(83683), yaml_1 = __webpack_require__(91198), fs_1 = __webpack_require__(79896);
   let DbtTestService = DbtTestService_1 = class {
    constructor(docGenService, streamingService, altimateRequest, queryManifestService, dbtTerminal) {
     this.docGenService = docGenService, this.streamingService = streamingService, this.altimateRequest = altimateRequest, 
     this.queryManifestService = queryManifestService, this.dbtTerminal = dbtTerminal, 
     this.filterAndStringifyTest = (testsPerColumnOrModelFromYml, test) => {
      if (!(null == testsPerColumnOrModelFromYml ? void 0 : testsPerColumnOrModelFromYml.length)) return;
      const ignoredFields = [ "model", "column_name", "field", "to", "values" ];
      if (!test.test_metadata) return;
      const {name, namespace} = test.test_metadata, fullName = namespace ? `${namespace}.${name}` : name, existingConfig = (0, 
      utils_1.getColumnTestConfigFromYml)(testsPerColumnOrModelFromYml, test.test_metadata.kwargs, fullName);
      if (!existingConfig) return void this.dbtTerminal.debug("getDbtTestCode", "no test available in yml");
      this.dbtTerminal.debug("getDbtTestCode", "sending selected config from yml", existingConfig);
      const filteredConfig = Object.entries(existingConfig).reduce(((acc, [key, value]) => (ignoredFields.includes(key) || (acc[key] = value), 
      acc)), {}), refinedTestConfig = namespace ? {
       [fullName]: filteredConfig
      } : filteredConfig;
      return (0, yaml_1.stringify)(refinedTestConfig);
     }, this.getMacroFilePath = (macros, projectName, macroMetaMap, testName) => {
      var _a;
      if (!testName) return;
      if (macros.find((m => m === `macro.${projectName}.test_${testName}`))) {
       const macroData = macroMetaMap.get(`test_${testName}`);
       return (null === (_a = null == macroData ? void 0 : macroData.path) || void 0 === _a ? void 0 : _a.endsWith(".sql")) ? null == macroData ? void 0 : macroData.path : void 0;
      }
     };
    }
    getConfigByTest(test, modelName, columnNameFromTestMetadata) {
     var _a, _b;
     const eventResult = this.queryManifestService.getEventByCurrentProject();
     if (!(null == eventResult ? void 0 : eventResult.event)) return;
     const {event: {nodeMetaMap}} = eventResult, node = nodeMetaMap.lookupByBaseName(modelName);
     if (!node) return;
     const project = this.queryManifestService.getProject();
     if (!project) return;
     const patchPath = (null === (_a = null == node ? void 0 : node.patch_path) || void 0 === _a ? void 0 : _a.includes("://")) ? path.join(project.projectRoot.fsPath, node.patch_path.split("://")[1]) : node.patch_path;
     if (!patchPath) return this.dbtTerminal.debug("getDbtTestCode", "unable to find patch path", patchPath), 
     null;
     this.dbtTerminal.debug("getDbtTestCode", "finding test from yaml", patchPath);
     const parsedDocFile = (0, yaml_1.parse)((0, fs_1.readFileSync)(patchPath, {
      encoding: "utf-8"
     }), {
      strict: !1,
      uniqueKeys: !1,
      maxAliasCount: -1
     });
     if (!parsedDocFile) return this.dbtTerminal.debug("getDbtTestCode", "yml file does not have any content", patchPath), 
     null;
     const model = null === (_b = parsedDocFile.models) || void 0 === _b ? void 0 : _b.find((m => m.name === modelName));
     if (!columnNameFromTestMetadata) return this.dbtTerminal.debug("getDbtTestCode", "finding model test from yml", parsedDocFile, model), 
     this.filterAndStringifyTest(null == model ? void 0 : model.tests, test);
     const column = model.columns && model.columns.find((yamlColumn => (0, utils_1.isColumnNameEqual)(yamlColumn.name, columnNameFromTestMetadata)));
     return this.dbtTerminal.debug("getDbtTestCode", "finding column test from yml", parsedDocFile, model, column), 
     this.filterAndStringifyTest(null == column ? void 0 : column.tests, test);
    }
    createTest(params, syncRequestId) {
     var _a;
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      if (!this.altimateRequest.handlePreviewFeatures()) return;
      const {session_id} = params;
      if (!session_id) throw new altimate_1.UserInputError("Invalid session id");
      if (!params.filePath) throw new altimate_1.UserInputError("Invalid file path");
      const dbtProject = this.queryManifestService.getProject();
      if (!dbtProject) throw new Error("Invalid dbt project");
      const adapter = dbtProject.getAdapterType(), {documentation} = yield this.docGenService.getDocumentation(params.filePath);
      if (!documentation) throw new Error("Unable to find documentation for the model");
      const queryText = null === (_a = vscode_1.window.activeTextEditor) || void 0 === _a ? void 0 : _a.document.getText();
      return this.streamingService.fetchAsStream({
       endpoint: "dbt/v2/dbt-test",
       syncRequestId,
       request: Object.assign(Object.assign({}, params), {
        session_id,
        column_name: params.column,
        model: {
         model_name: documentation.name,
         adapter,
         compiled_sql: yield dbtProject.unsafeCompileQuery(queryText || ""),
         columns: documentation.columns.map((c => ({
          column_name: c.name,
          data_type: c.type
         })))
        }
       })
      });
     }));
    }
    getTestsForCurrentModel() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const eventResult = this.queryManifestService.getEventByCurrentProject();
      if (!(null == eventResult ? void 0 : eventResult.event) || !(null == eventResult ? void 0 : eventResult.currentDocument)) return;
      if (!this.queryManifestService.getProject()) return;
      const {currentDocument} = eventResult, modelName = path.basename(currentDocument.uri.fsPath, ".sql");
      return this.getTestsForModel(modelName);
     }));
    }
    getTestsForModel(modelName) {
     var _a;
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const eventResult = this.queryManifestService.getEventByCurrentProject();
      if (!(null == eventResult ? void 0 : eventResult.event) || !(null == eventResult ? void 0 : eventResult.currentDocument)) return;
      const project = this.queryManifestService.getProject();
      if (!project) return;
      const projectName = project.getProjectName(), {event: {nodeMetaMap, graphMetaMap, testMetaMap, macroMetaMap}} = eventResult;
      this.dbtTerminal.debug("dbtTests", "getting tests by modelName:", !1, modelName);
      const _node = nodeMetaMap.lookupByBaseName(modelName);
      if (!_node) return void this.dbtTerminal.debug("no node for tableName:", modelName);
      const key = _node.uniqueId;
      return ((null === (_a = graphMetaMap.tests.get(key)) || void 0 === _a ? void 0 : _a.nodes) || []).map((n => {
       const testKey = n.label.split(".")[0], testData = testMetaMap.get(testKey);
       if (!testData) return null;
       if (!testData.attached_node) return Object.assign(Object.assign({}, testData), {
        key: testKey
       });
       if (testData.attached_node !== key) return null;
       const {depends_on: {macros}, test_metadata} = testData, macroFilepath = this.getMacroFilePath(macros, projectName, macroMetaMap, null == test_metadata ? void 0 : test_metadata.name);
       return Object.assign(Object.assign({}, testData), {
        path: macroFilepath || testData.path,
        key: testKey
       });
      })).filter((t => Boolean(t)));
     }));
    }
   };
   DbtTestService = DbtTestService_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(DbtTestService_1), tslib_1.__metadata("design:paramtypes", [ docGenService_1.DocGenService, streamingService_1.StreamingService, altimate_1.AltimateRequest, queryManifestService_1.QueryManifestService, dbtTerminal_1.DBTTerminal ]) ], DbtTestService), 
   exports.DbtTestService = DbtTestService;
  },
  2826: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var DeferToProdService_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.DeferToProdService = void 0;
   const tslib_1 = __webpack_require__(31635), vscode_1 = __webpack_require__(54980), utils_1 = __webpack_require__(86185);
   let DeferToProdService = DeferToProdService_1 = class {
    getDeferConfigByWorkspace() {
     var _a;
     const currentDocument = null === (_a = vscode_1.window.activeTextEditor) || void 0 === _a ? void 0 : _a.document;
     return vscode_1.workspace.getConfiguration("dbt", null == currentDocument ? void 0 : currentDocument.uri).get("deferConfigPerProject", {});
    }
    getDeferConfigByProjectRoot(projectRoot) {
     const relativePath = (0, utils_1.getProjectRelativePath)(vscode_1.Uri.file(projectRoot)), currentConfig = this.getDeferConfigByWorkspace();
     if ("core" === vscode_1.workspace.getConfiguration("dbt").get("dbtIntegration", "core") || currentConfig[relativePath]) {
      const coreConfig = currentConfig[relativePath];
      return coreConfig || {};
     }
     return {
      deferToProduction: !0
     };
    }
   };
   DeferToProdService = DeferToProdService_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(DeferToProdService_1) ], DeferToProdService), 
   exports.DeferToProdService = DeferToProdService;
  },
  88642: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var DocGenService_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.DocGenService = void 0;
   const tslib_1 = __webpack_require__(31635), path = __webpack_require__(16928), vscode_1 = __webpack_require__(54980), altimate_1 = __webpack_require__(91741), dbtTerminal_1 = __webpack_require__(83683), exceptions_1 = __webpack_require__(46055), dbtProjectContainer_1 = __webpack_require__(82018), telemetry_1 = __webpack_require__(22644), utils_1 = __webpack_require__(86185), docsEditPanel_1 = __webpack_require__(17215), queryManifestService_1 = __webpack_require__(59269), events_1 = __webpack_require__(91723);
   let DocGenService = DocGenService_1 = class {
    constructor(altimateRequest, dbtProjectContainer, telemetry, queryManifestService, dbtTerminal) {
     this.altimateRequest = altimateRequest, this.dbtProjectContainer = dbtProjectContainer, 
     this.telemetry = telemetry, this.queryManifestService = queryManifestService, this.dbtTerminal = dbtTerminal;
    }
    generateDocsForColumn(documentation, compiledSql, adapter, message, columns, columnIndexCount = void 0, sessionID = void 0, isBulkGen = !1) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      return new Promise(((resolve, reject) => tslib_1.__awaiter(this, void 0, void 0, (function*() {
       if (!documentation) return resolve(void 0);
       try {
        const result = yield this.altimateRequest.generateModelDocsV2({
         columns,
         dbt_model: {
          model_name: documentation.name,
          model_description: message.description,
          compiled_sql: compiledSql,
          columns: message.columns.map((column => ({
           column_name: column.name,
           description: column.description,
           data_type: column.type
          }))),
          adapter
         },
         gen_model_description: !1,
         user_instructions: message.user_instructions,
         follow_up_instructions: message.follow_up_instructions,
         column_index_count: columnIndexCount,
         session_id: sessionID,
         is_bulk_gen: isBulkGen
        });
        return resolve(result);
       } catch (err) {
        if (this.dbtTerminal.debug("docGenService:generateDocsForColumn", "error while generating column doc" + err, columns), 
        err instanceof exceptions_1.RateLimitException) return void setTimeout((() => tslib_1.__awaiter(this, void 0, void 0, (function*() {
         return this.dbtTerminal.debug("docGenService:generateDocsForColumn", "retrying generating column doc", columns), 
         resolve(yield this.generateDocsForColumn(documentation, compiledSql, adapter, message, columns));
        }))), err.retryAfter);
        reject(err);
       }
      }))));
     }));
    }
    transmitAIGeneratedColumnDocs(panel, generatedColumnDescriptions, syncRequestId) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      if (panel) {
       const result = syncRequestId ? {
        command: "response",
        args: {
         body: {
          columns: generatedColumnDescriptions
         },
         syncRequestId,
         status: !0
        }
       } : {
        command: "renderAIGeneratedColumnDocs",
        columns: generatedColumnDescriptions
       };
       yield panel.webview.postMessage(result);
      }
     }));
    }
    transmitError(panel) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      panel && (yield panel.webview.postMessage({
       command: "renderError"
      }));
     }));
    }
    transmitAIGeneratedModelDocs(response, syncRequestId, panel) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      if (panel) {
       const result = syncRequestId ? {
        command: "response",
        args: {
         body: response,
         syncRequestId,
         status: !0
        }
       } : {
        command: "renderAIGeneratedModelDocs",
        response
       };
       yield panel.webview.postMessage(result);
      }
     }));
    }
    getDocumentationForCurrentActiveFile() {
     var _a, _b;
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      return this.getDocumentation(null === (_b = null === (_a = vscode_1.window.activeTextEditor) || void 0 === _a ? void 0 : _a.document) || void 0 === _b ? void 0 : _b.uri.fsPath);
     }));
    }
    getMissingDocumentationMessage(filePath) {
     var _a;
     const message = "A valid dbt model file needs to be open and active in the editor area above to view documentation for that model.";
     if (!filePath) return {
      message,
      type: "warning"
     };
     try {
      null === (_a = this.queryManifestService.getProjectByUri(vscode_1.Uri.file(filePath))) || void 0 === _a || _a.throwDiagnosticsErrorIfAvailable();
     } catch (err) {
      return {
       message: err.message,
       type: "error"
      };
     }
     return {
      message,
      type: "warning"
     };
    }
    getDocumentation(filePath) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const eventResult = this.queryManifestService.getEventByCurrentProject();
      if (!eventResult) return {
       documentation: void 0,
       message: this.getMissingDocumentationMessage(filePath)
      };
      const {event} = eventResult;
      if (!event || !filePath) return {
       documentation: void 0,
       message: this.getMissingDocumentationMessage(filePath)
      };
      const modelName = path.basename(filePath, ".sql"), currentNode = event.nodeMetaMap.lookupByBaseName(modelName);
      if (void 0 === currentNode) return {
       documentation: void 0,
       message: this.getMissingDocumentationMessage(filePath)
      };
      const docColumns = currentNode.columns;
      return {
       documentation: {
        aiEnabled: this.altimateRequest.enabled(),
        name: modelName,
        patchPath: currentNode.patch_path,
        description: currentNode.description,
        generated: !1,
        resource_type: currentNode.resource_type,
        uniqueId: currentNode.uniqueId,
        filePath,
        columns: Object.values(docColumns).map((column => {
         var _a;
         return {
          name: column.name,
          description: column.description,
          generated: !1,
          source: docsEditPanel_1.Source.YAML,
          type: null === (_a = column.data_type) || void 0 === _a ? void 0 : _a.toLowerCase()
         };
        }))
       }
      };
     }));
    }
    chunk(a, n) {
     return [ ...Array(Math.ceil(a.length / n)) ].map(((_, i) => a.slice(n * i, n + n * i)));
    }
    generateDocsForColumns({project, message, documentation, panel, isBulkGen}) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      if (!this.altimateRequest.handlePreviewFeatures()) return;
      if (!project || !vscode_1.window.activeTextEditor) return;
      const queryText = vscode_1.window.activeTextEditor.document.getText(), columns = message.columnName ? [ message.columnName ] : message.columnNames, chunks = this.chunk(columns, 3), telemetryEventName = isBulkGen ? message.isAll ? events_1.TelemetryEvents["DocumentationEditor/BulkGenerateAllClick"] : events_1.TelemetryEvents["DocumentationEditor/BulkGenerateMissingColumnsClick"] : events_1.TelemetryEvents["DocumentationEditor/GenerateDescForColumnClick"];
      this.telemetry.startTelemetryEvent(telemetryEventName, {
       model: (null == documentation ? void 0 : documentation.name) || "",
       columns: columns.join(",")
      }), vscode_1.window.withProgress({
       title: "",
       location: vscode_1.ProgressLocation.Notification,
       cancellable: !1
      }, (progress => tslib_1.__awaiter(this, void 0, void 0, (function*() {
       if (void 0 !== documentation) try {
        const results = [], progressMessage = columns.length > 3 ? `Generating documentation for ${columns.length} columns` : `Generating documentation for ${columns.length > 1 ? "columns" : "column"} ${columns.join(", ")}`;
        progress.report({
         message: progressMessage,
         increment: 0
        });
        const compiledSql = yield project.unsafeCompileQuery(queryText), columnIndexCount = isBulkGen ? 3 * chunks.length : 1, sessionID = `${vscode_1.env.sessionId}-${null == documentation ? void 0 : documentation.name}-numColumns-${columnIndexCount}-${Date.now()}`;
        yield Promise.all(chunks.map(((chunk, i) => tslib_1.__awaiter(this, void 0, void 0, (function*() {
         const chunkResult = yield this.generateDocsForColumn(documentation, compiledSql, project.getAdapterType(), message, chunk, 3 * i, sessionID, isBulkGen);
         results.push(chunkResult), this.dbtTerminal.debug("docGenService:generateDocsForColumns", "generate docs for columns chunk result", chunkResult), 
         progress.report({
          message: `Generated docs for ${Math.min(3 * results.length, columns.length)} of ${columns.length} columns`,
          increment: chunk.length / columns.length * 100
         });
        })))));
        const generatedDocsForColumn = {
         column_descriptions: results.map((response => null == response ? void 0 : response.column_descriptions)).filter((item => !!item)).flatMap((r => r))
        };
        if (!generatedDocsForColumn || !generatedDocsForColumn.column_descriptions) return;
        this.transmitAIGeneratedColumnDocs(panel, generatedDocsForColumn.column_descriptions.map((entry => ({
         name: entry.column_name,
         description: entry.column_description,
         citations: entry.column_citations
        }))), message.syncRequestId), this.telemetry.endTelemetryEvent(telemetryEventName, void 0, {
         model: (null == documentation ? void 0 : documentation.name) || "",
         columns: columns.join(",")
        });
       } catch (error) {
        this.transmitError(panel), vscode_1.window.showErrorMessage((0, utils_1.extendErrorWithSupportLinks)("Could not generate documentation: " + error.message)), 
        this.telemetry.endTelemetryEvent(telemetryEventName, error, {
         model: (null == documentation ? void 0 : documentation.name) || "",
         columns: columns.join(",")
        });
       }
      }))));
     }));
    }
    generateDocsForModel({documentation, queryText, project, message, panel, columnIndexCount, isBulkGen}) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.altimateRequest.handlePreviewFeatures() && project && (this.telemetry.startTelemetryEvent(events_1.TelemetryEvents["DocumentationEditor/GenerateDescForModelClick"], {
       model: (null == documentation ? void 0 : documentation.name) || ""
      }), vscode_1.window.withProgress({
       title: `Generating documentation for model ${null == documentation ? void 0 : documentation.name}`,
       location: vscode_1.ProgressLocation.Notification,
       cancellable: !1
      }, (() => tslib_1.__awaiter(this, void 0, void 0, (function*() {
       if (void 0 !== documentation) try {
        const compiledSql = yield project.unsafeCompileQuery(queryText), sessionID = `${vscode_1.env.sessionId}-${null == documentation ? void 0 : documentation.name}-numColumns-0-${Date.now()}`, generateDocsForModel = yield this.altimateRequest.generateModelDocsV2({
         columns: [],
         dbt_model: {
          model_name: null == documentation ? void 0 : documentation.name,
          model_description: message.description,
          compiled_sql: compiledSql,
          columns: message.columns.map((column => ({
           column_name: column.name,
           description: column.description,
           data_type: column.type,
           modelName: null == documentation ? void 0 : documentation.name
          }))),
          adapter: project.getAdapterType()
         },
         prompt_hint: message.promptHint || "generate",
         gen_model_description: !0,
         user_instructions: Object.assign(Object.assign({}, message.user_instructions), {
          prompt_hint: message.user_instructions.prompt_hint || "generate"
         }),
         follow_up_instructions: message.follow_up_instructions,
         column_index_count: columnIndexCount,
         session_id: sessionID,
         is_bulk_gen: isBulkGen
        });
        if (!generateDocsForModel || !generateDocsForModel.model_description) return;
        this.transmitAIGeneratedModelDocs(generateDocsForModel, message.syncRequestId, panel), 
        this.telemetry.endTelemetryEvent(events_1.TelemetryEvents["DocumentationEditor/GenerateDescForModelClick"], void 0, {
         model: (null == documentation ? void 0 : documentation.name) || ""
        });
       } catch (error) {
        this.transmitError(panel), vscode_1.window.showErrorMessage((0, utils_1.extendErrorWithSupportLinks)("Could not generate documentation: " + error.message)), 
        this.telemetry.endTelemetryEvent(events_1.TelemetryEvents["DocumentationEditor/GenerateDescForModelClick"], error, {
         model: (null == documentation ? void 0 : documentation.name) || ""
        });
       }
      })))));
     }));
    }
    sendFeedback({queryText, message, panel, syncRequestId}) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.telemetry.startTelemetryEvent(events_1.TelemetryEvents["Datapilot/Feedback"]), 
      vscode_1.window.withProgress({
       title: "Sending feedback",
       location: vscode_1.ProgressLocation.Notification,
       cancellable: !1
      }, (() => tslib_1.__awaiter(this, void 0, void 0, (function*() {
       try {
        const project = this.queryManifestService.getProject();
        if (!project) throw new Error("Unable to find project");
        const {documentation} = yield this.getDocumentation(), compiledSql = yield project.unsafeCompileQuery(queryText), request = message.data;
        request.feedback_text = message.comment, request.additional_prompt_inputs = {
         model_name: null == documentation ? void 0 : documentation.name,
         model_description: null == documentation ? void 0 : documentation.description,
         compiled_sql: compiledSql,
         columns: null == documentation ? void 0 : documentation.columns.map((column => ({
          column_name: column.name,
          description: column.description,
          data_type: column.type
         })))
        }, yield this.altimateRequest.sendFeedback({
         data: request,
         feedback_src: "dbtpu-extension",
         feedback_text: message.comment,
         feedback_value: message.rating
        }), panel && (yield panel.webview.postMessage({
         command: "response",
         args: {
          syncRequestId,
          body: {
           status: !0
          },
          status: !0
         }
        })), this.telemetry.endTelemetryEvent(events_1.TelemetryEvents["Datapilot/Feedback"]);
       } catch (error) {
        this.telemetry.endTelemetryEvent(events_1.TelemetryEvents["Datapilot/Feedback"], error), 
        this.transmitError(panel), vscode_1.window.showErrorMessage((0, utils_1.extendErrorWithSupportLinks)("Could not send feedback: " + error.message)), 
        this.telemetry.sendTelemetryError("altimateGenerateDocsSendFeedbackError", error);
       }
      }))));
     }));
    }
   };
   DocGenService = DocGenService_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(DocGenService_1), tslib_1.__metadata("design:paramtypes", [ altimate_1.AltimateRequest, dbtProjectContainer_1.DBTProjectContainer, telemetry_1.TelemetryService, queryManifestService_1.QueryManifestService, dbtTerminal_1.DBTTerminal ]) ], DocGenService), 
   exports.DocGenService = DocGenService;
  },
  69968: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var FileService_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.FileService = void 0;
   const tslib_1 = __webpack_require__(31635), vscode_1 = __webpack_require__(54980), utils_1 = __webpack_require__(86185);
   let FileService = FileService_1 = class {
    openFileByPath(path) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      return new Promise(((resolve, reject) => {
       path ? vscode_1.workspace.openTextDocument(vscode_1.Uri.file(path)).then((file => {
        vscode_1.window.showTextDocument(file, 1, !1).then((e => {
         resolve(e);
        }), (error => {
         reject(error);
        }));
       }), (error => {
        reject(error);
       })) : reject(new Error("Invalid file path"));
      }));
     }));
    }
   };
   FileService = FileService_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(FileService_1) ], FileService), 
   exports.FileService = FileService;
  },
  27312: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var QueryAnalysisService_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.QueryAnalysisService = void 0;
   const tslib_1 = __webpack_require__(31635), vscode_1 = __webpack_require__(54980), altimate_1 = __webpack_require__(91741), utils_1 = __webpack_require__(86185), queryManifestService_1 = __webpack_require__(59269), docGenService_1 = __webpack_require__(88642), streamingService_1 = __webpack_require__(33846), dbtTerminal_1 = __webpack_require__(83683), fileService_1 = __webpack_require__(69968);
   let QueryAnalysisService = QueryAnalysisService_1 = class {
    constructor(docGenService, streamingService, altimateRequest, queryManifestService, dbtTerminal, fileService) {
     this.docGenService = docGenService, this.streamingService = streamingService, this.altimateRequest = altimateRequest, 
     this.queryManifestService = queryManifestService, this.dbtTerminal = dbtTerminal, 
     this.fileService = fileService;
    }
    getSelectedQuery() {
     const editor = vscode_1.window.activeTextEditor;
     if (!editor) return null;
     const fileName = editor.document.fileName.split("/").pop(), selection = editor.selection;
     if (selection && !selection.isEmpty) {
      const selectionRange = new vscode_1.Range(selection.start.line, selection.start.character, selection.end.line, selection.end.character);
      return {
       query: editor.document.getText(selectionRange),
       fileName: `${fileName} (L${selection.start.line + 1}-L${selection.end.line + 1})`
      };
     }
     return {
      query: editor.document.getText(),
      fileName
     };
    }
    executeQueryTranslate(params) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      if (!this.altimateRequest.handlePreviewFeatures()) return;
      if (!params.filePath) throw new altimate_1.UserInputError("Invalid file. Please open a valid file with SQL");
      const sql = (yield this.fileService.openFileByPath(params.filePath)).document.getText();
      if (!params.source) throw new altimate_1.UserInputError("Invalid source dialect");
      if (!params.target) throw new altimate_1.UserInputError("Invalid target dialect");
      const dbtProject = this.queryManifestService.getProject();
      if (!dbtProject) {
       const error = new Error("Invalid dbt project");
       throw this.dbtTerminal.error("executeQueryAnalysisError", "Invalid dbt project", error), 
       error;
      }
      const compiledSql = yield dbtProject.unsafeCompileQuery(sql);
      return {
       translatedSql: (yield this.altimateRequest.fetch("dbt/v3/translate", {
        method: "POST",
        body: JSON.stringify({
         source_dialect: params.source,
         target_dialect: params.target,
         sql: compiledSql
        })
       })).translated_sql,
       userSql: compiledSql
      };
     }));
    }
    executeQueryTranslateExplanation(params, syncRequestId) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      if (this.altimateRequest.handlePreviewFeatures()) {
       if (!params.source) throw new altimate_1.UserInputError("Invalid source dialect");
       if (!params.target) throw new altimate_1.UserInputError("Invalid target dialect");
       return this.streamingService.fetchAsStream({
        endpoint: "dbt/v3/translate-explanation",
        syncRequestId,
        request: {
         source_dialect: params.source,
         target_dialect: params.target,
         translated_sql: params.translatedSql,
         user_sql: params.userSql
        }
       });
      }
     }));
    }
    executeQueryAnalysis(params, job_type, syncRequestId) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      if (!this.altimateRequest.handlePreviewFeatures()) return;
      const {session_id} = params;
      if (!session_id) {
       const error = new Error("Invalid session id");
       throw this.dbtTerminal.error("executeQueryAnalysisError", "Missing session id", error), 
       error;
      }
      const selectionData = this.getSelectedQuery();
      if (!selectionData) {
       const error = new Error("Invalid query");
       throw this.dbtTerminal.error("executeQueryAnalysisError", "Missing query", error), 
       error;
      }
      const {query} = selectionData, dbtProject = this.queryManifestService.getProject();
      if (!dbtProject) {
       const error = new Error("Invalid dbt project");
       throw this.dbtTerminal.error("executeQueryAnalysisError", "Invalid dbt project", error), 
       error;
      }
      const adapter = dbtProject.getAdapterType() || "unknown", {documentation} = yield this.docGenService.getDocumentation(params.filePath);
      if (!documentation) {
       const error = new Error("Invalid model");
       throw this.dbtTerminal.error("executeQueryAnalysisError", "Unable to find documentation for the model", error), 
       error;
      }
      return this.streamingService.fetchAsStream({
       endpoint: "dbt/v2/query-analysis",
       syncRequestId,
       request: Object.assign({
        session_id,
        job_type,
        model: {
         model_name: documentation.name,
         adapter,
         compiled_sql: yield dbtProject.unsafeCompileQuery(query),
         columns: documentation.columns.map((c => ({
          column_name: c.name,
          data_type: c.type
         })))
        }
       }, params)
      });
     }));
    }
    getFollowupQuestions({query, user_request, filePath}) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      if (!this.altimateRequest.handlePreviewFeatures()) return;
      const dbtProject = this.queryManifestService.getProject();
      if (!dbtProject) {
       const error = new Error("Invalid dbt project");
       throw this.dbtTerminal.error("getFollowupQuestionsError", "Invalid dbt project", error), 
       error;
      }
      const adapter = dbtProject.getAdapterType() || "unknown", {documentation} = yield this.docGenService.getDocumentation(filePath);
      if (!documentation) {
       const error = new Error("To use this feature, a valid model should be open in editor.");
       throw this.dbtTerminal.error("getFollowupQuestionsError", "Unable to find documentation for the model", error), 
       error;
      }
      return this.altimateRequest.fetch("dbt/v2/follow-up-questions", {
       method: "POST",
       body: JSON.stringify({
        model: {
         model_name: documentation.name,
         adapter,
         compiled_sql: yield dbtProject.unsafeCompileQuery(query),
         columns: documentation.columns.map((c => ({
          column_name: c.name,
          data_type: c.type
         })))
        },
        user_request
       })
      });
     }));
    }
   };
   QueryAnalysisService = QueryAnalysisService_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(QueryAnalysisService_1), tslib_1.__metadata("design:paramtypes", [ docGenService_1.DocGenService, streamingService_1.StreamingService, altimate_1.AltimateRequest, queryManifestService_1.QueryManifestService, dbtTerminal_1.DBTTerminal, fileService_1.FileService ]) ], QueryAnalysisService), 
   exports.QueryAnalysisService = QueryAnalysisService;
  },
  59269: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var QueryManifestService_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.QueryManifestService = void 0;
   const tslib_1 = __webpack_require__(31635), vscode_1 = __webpack_require__(54980), dbtTerminal_1 = __webpack_require__(83683), dbtProjectContainer_1 = __webpack_require__(82018), utils_1 = __webpack_require__(86185), sharedStateService_1 = __webpack_require__(37712), projectQuickPick_1 = __webpack_require__(28448);
   let QueryManifestService = QueryManifestService_1 = class {
    constructor(dbtProjectContainer, dbtTerminal, emitterService, projectQuickPick) {
     this.dbtProjectContainer = dbtProjectContainer, this.dbtTerminal = dbtTerminal, 
     this.emitterService = emitterService, this.projectQuickPick = projectQuickPick, 
     this.eventMap = new Map, dbtProjectContainer.onDBTProjectsInitialization((() => {
      this.emitterService.fire({
       command: "dbtProjectsInitialized",
       payload: {}
      });
     })), dbtProjectContainer.onManifestChanged((event => this.onManifestCacheChanged(event)));
    }
    onManifestCacheChanged(event) {
     var _a, _b;
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      null === (_a = event.added) || void 0 === _a || _a.forEach((added => {
       this.eventMap.set(added.project.projectRoot.fsPath, added);
      })), null === (_b = event.removed) || void 0 === _b || _b.forEach((removed => {
       this.eventMap.delete(removed.projectRoot.fsPath);
      }));
     }));
    }
    getProject() {
     var _a;
     return this.getProjectByUri(null === (_a = vscode_1.window.activeTextEditor) || void 0 === _a ? void 0 : _a.document.uri);
    }
    getProjectByUri(uri) {
     if (uri) return this.dbtProjectContainer.findDBTProject(uri);
    }
    getProjectNamesInWorkspace() {
     return [ ...new Set(this.dbtProjectContainer.getProjects().map((project => project.getProjectName()))) ];
    }
    getProjectByName(projectName) {
     return this.dbtProjectContainer.getProjects().find((project => project.getProjectName() === projectName));
    }
    getEventByCurrentProject() {
     if (void 0 === vscode_1.window.activeTextEditor || void 0 === this.eventMap) return;
     const currentDocument = vscode_1.window.activeTextEditor.document, currentFilePath = currentDocument.uri;
     return {
      event: this.getEventByDocument(currentFilePath),
      currentDocument
     };
    }
    getEventByDocument(currentFilePath) {
     this.dbtTerminal.debug("getting event for project, currentFilePath: ", currentFilePath.fsPath);
     const projectRootpath = this.dbtProjectContainer.getProjectRootpath(currentFilePath);
     if (void 0 === projectRootpath) return void this.dbtTerminal.debug("no project for currentFilePath: ", currentFilePath.fsPath);
     const event = this.eventMap.get(projectRootpath.fsPath);
     if (void 0 !== event) return event;
     this.dbtTerminal.debug("no event for project: ", projectRootpath.fsPath);
    }
    getSourcesInProject(currentFilePath) {
     if (!currentFilePath) return;
     const projectRootpath = this.dbtProjectContainer.getProjectRootpath(currentFilePath);
     if (void 0 === projectRootpath) return;
     const event = this.eventMap.get(projectRootpath.fsPath);
     if (!event) return;
     const sources = event.sourceMetaMap.entries();
     console.log(event.sourceMetaMap.size, sources);
     return Array.from(sources).map((([key, source]) => ({
      name: key,
      tables: source.tables.map((t => t.name))
     })));
    }
    getModelsInProject(currentFilePath) {
     if (!currentFilePath) return;
     const projectRootpath = this.dbtProjectContainer.getProjectRootpath(currentFilePath);
     if (void 0 === projectRootpath) return;
     const event = this.eventMap.get(projectRootpath.fsPath);
     return event ? Array.from(event.nodeMetaMap.nodes()).map((node => node.name)) : void 0;
    }
    getOrPickProjectFromWorkspace() {
     var _a, _b;
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const uri = (null === (_a = vscode_1.window.activeTextEditor) || void 0 === _a ? void 0 : _a.document.uri) || (null === (_b = vscode_1.window.activeNotebookEditor) || void 0 === _b ? void 0 : _b.notebook.uri), project = uri ? this.dbtProjectContainer.findDBTProject(uri) : null;
      if (project) return project;
      this.dbtTerminal.debug("getProject", "no project name provided, getting all projects in workspace");
      const projects = this.dbtProjectContainer.getProjects();
      if (1 === projects.length) return this.dbtTerminal.debug("getProject", `single project in workspace, returning project: ${projects[0].getProjectName()}`), 
      projects[0];
      this.dbtTerminal.debug("getProject", "multiple projects in workspace, prompting user to select project");
      const pickedProject = yield this.projectQuickPick.projectPicker(projects);
      if (pickedProject) return this.dbtTerminal.debug("getProject", `project selected: ${pickedProject.uri}`), 
      this.dbtProjectContainer.findDBTProject(pickedProject.uri);
      this.dbtTerminal.debug("getProject", "no project selected, returning");
     }));
    }
   };
   QueryManifestService = QueryManifestService_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(QueryManifestService_1), tslib_1.__metadata("design:paramtypes", [ dbtProjectContainer_1.DBTProjectContainer, dbtTerminal_1.DBTTerminal, sharedStateService_1.SharedStateService, projectQuickPick_1.ProjectQuickPick ]) ], QueryManifestService), 
   exports.QueryManifestService = QueryManifestService;
  },
  37712: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var SharedStateService_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.SharedStateService = void 0;
   const tslib_1 = __webpack_require__(31635), vscode_1 = __webpack_require__(54980), utils_1 = __webpack_require__(86185);
   let SharedStateService = SharedStateService_1 = class {
    constructor() {
     this.eventEmitter = new vscode_1.EventEmitter;
    }
    fire(data) {
     this.eventEmitter.fire(data);
    }
   };
   SharedStateService = SharedStateService_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(SharedStateService_1), tslib_1.__metadata("design:paramtypes", []) ], SharedStateService), 
   exports.SharedStateService = SharedStateService;
  },
  33846: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var StreamingService_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.StreamingService = void 0;
   const tslib_1 = __webpack_require__(31635), altimate_1 = __webpack_require__(91741), utils_1 = __webpack_require__(86185), sharedStateService_1 = __webpack_require__(37712);
   let StreamingService = StreamingService_1 = class {
    constructor(altimateRequest, emitterService) {
     this.altimateRequest = altimateRequest, this.emitterService = emitterService;
    }
    fetchAsStream({endpoint, syncRequestId, request}) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      return yield this.altimateRequest.fetchAsStream(endpoint, request, (chunk => {
       this.emitterService.fire({
        command: "stream:chunk",
        payload: {
         syncRequestId,
         body: {
          chunk
         },
         status: !0
        }
       });
      }));
     }));
    }
   };
   StreamingService = StreamingService_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(StreamingService_1), tslib_1.__metadata("design:paramtypes", [ altimate_1.AltimateRequest, sharedStateService_1.SharedStateService ]) ], StreamingService), 
   exports.StreamingService = StreamingService;
  },
  8502: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var UsersService_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.UsersService = void 0;
   const tslib_1 = __webpack_require__(31635), altimate_1 = __webpack_require__(91741), dbtTerminal_1 = __webpack_require__(83683), utils_1 = __webpack_require__(86185), dbtProjectContainer_1 = __webpack_require__(82018);
   let UsersService = UsersService_1 = class {
    constructor(dbtProjectContainer, dbtTerminal, altimateRequest) {
     this.dbtProjectContainer = dbtProjectContainer, this.dbtTerminal = dbtTerminal, 
     this.altimateRequest = altimateRequest, this.tenantUsers = {}, this.disposables = [], 
     this.disposables.push(this.dbtProjectContainer.onDBTInstallationVerification((e => this.onDBTInstallationVerification(e))));
    }
    dispose() {
     for (;this.disposables.length; ) {
      const x = this.disposables.pop();
      x && x.dispose();
     }
    }
    onDBTInstallationVerification(event) {
     event.installed && (this.loadCurrentUser(), this.loadUsersInTenant());
    }
    loadUsersInTenant() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      if (this.altimateRequest.getCredentialsMessage()) return void this.dbtTerminal.debug("UsersService:loadUsersInTenant", "Missing credentials. skipping loadUsersInTenant");
      this.dbtTerminal.debug("UsersService", "loading tenant users");
      const users = yield this.altimateRequest.getUsersInTenant();
      this.tenantUsers = users.reduce(((acc, user) => (acc[user.id] = user, acc)), {}), 
      this.dbtTerminal.debug("UsersService", "loaded tenant users", users.length);
     }));
    }
    loadCurrentUser() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      if (this.altimateRequest.getCredentialsMessage()) return void this.dbtTerminal.debug("UsersService:loadCurrentUser", "Missing credentials. skipping loadCurrentUser");
      this.dbtTerminal.debug("UsersService", "loading current user");
      const user = yield this.altimateRequest.getCurrentUser();
      this.tenantUser = user, this.dbtTerminal.debug("UsersService", "loaded current user", user);
     }));
    }
    getUserById(userId) {
     return this.tenantUsers[userId];
    }
    get user() {
     return this.tenantUser;
    }
    get users() {
     return Object.values(this.tenantUsers);
    }
   };
   UsersService = UsersService_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(UsersService_1), tslib_1.__metadata("design:paramtypes", [ dbtProjectContainer_1.DBTProjectContainer, dbtTerminal_1.DBTTerminal, altimate_1.AltimateRequest ]) ], UsersService), 
   exports.UsersService = UsersService;
  },
  87607: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var DeferToProductionStatusBar_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.DeferToProductionStatusBar = void 0;
   const tslib_1 = __webpack_require__(31635), vscode_1 = __webpack_require__(54980), deferToProdService_1 = __webpack_require__(2826), utils_1 = __webpack_require__(86185), dbtProjectContainer_1 = __webpack_require__(82018), dbtTerminal_1 = __webpack_require__(83683);
   let DeferToProductionStatusBar = DeferToProductionStatusBar_1 = class {
    constructor(deferToProdService, dbtProjectContainer, dbtTerminal) {
     this.deferToProdService = deferToProdService, this.dbtProjectContainer = dbtProjectContainer, 
     this.dbtTerminal = dbtTerminal, this.statusBar = vscode_1.window.createStatusBarItem(vscode_1.StatusBarAlignment.Left, 9), 
     this.disposables = [], this.disposables.push(vscode_1.workspace.onDidChangeConfiguration((e => tslib_1.__awaiter(this, void 0, void 0, (function*() {
      e.affectsConfiguration("dbt.deferConfigPerProject") && this.updateStatusBar();
     }))), this, this.disposables)), this.disposables.push(vscode_1.window.onDidChangeActiveTextEditor((event => tslib_1.__awaiter(this, void 0, void 0, (function*() {
      void 0 === event && this.statusBar.hide(), this.updateStatusBar();
     })))));
    }
    dispose() {
     for (;this.disposables.length; ) {
      const x = this.disposables.pop();
      x && x.dispose();
     }
     this.statusBar.dispose();
    }
    showTextInStatusBar(text) {
     this.statusBar.text = text, this.statusBar.command = {
      title: "Open Insights Panel",
      command: "dbtPowerUser.openInsights"
     }, this.statusBar.show();
    }
    updateStatusBar(projectRoot) {
     try {
      if (!projectRoot) {
       projectRoot = this.getCurrentProject().projectRoot.fsPath;
      }
      const config = this.deferToProdService.getDeferConfigByProjectRoot(projectRoot);
      if (null == config ? void 0 : config.deferToProduction) return this.showTextInStatusBar("$(sync) Defer"), 
      void this.statusBar.show();
      this.showTextInStatusBar("$(sync-ignored) Defer"), this.statusBar.show();
     } catch (err) {
      this.statusBar.hide(), this.dbtTerminal.debug("DeferToProductionStatusBar", "Unable to update defer status bar", err);
     }
    }
    getCurrentProject() {
     var _a;
     const projects = this.dbtProjectContainer.getProjects();
     if (1 === projects.length) return projects[0];
     const currentFilePath = null === (_a = vscode_1.window.activeTextEditor) || void 0 === _a ? void 0 : _a.document.uri;
     if (!currentFilePath) throw new Error("No file selected in the editor");
     const currentProject = this.dbtProjectContainer.findDBTProject(currentFilePath);
     if (!currentProject) throw new Error("no Project found for selected document");
     return currentProject;
    }
   };
   DeferToProductionStatusBar = DeferToProductionStatusBar_1 = tslib_1.__decorate([ (0, 
   utils_1.provideSingleton)(DeferToProductionStatusBar_1), tslib_1.__metadata("design:paramtypes", [ deferToProdService_1.DeferToProdService, dbtProjectContainer_1.DBTProjectContainer, dbtTerminal_1.DBTTerminal ]) ], DeferToProductionStatusBar), 
   exports.DeferToProductionStatusBar = DeferToProductionStatusBar;
  },
  58280: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var StatusBars_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.StatusBars = void 0;
   const tslib_1 = __webpack_require__(31635), utils_1 = __webpack_require__(86185), versionStatusBar_1 = __webpack_require__(32433), deferToProductionStatusBar_1 = __webpack_require__(87607), targetStatusBar_1 = __webpack_require__(86940);
   let StatusBars = StatusBars_1 = class {
    constructor(dbtStatusBar, deferToProductionStatusBar, targetStatusBar) {
     this.dbtStatusBar = dbtStatusBar, this.deferToProductionStatusBar = deferToProductionStatusBar, 
     this.targetStatusBar = targetStatusBar, this.disposables = [], this.disposables.push(this.dbtStatusBar), 
     this.disposables.push(this.deferToProductionStatusBar), this.disposables.push(this.targetStatusBar);
    }
    initialize() {
     this.deferToProductionStatusBar.updateStatusBar(), this.targetStatusBar.updateStatusBar();
    }
    dispose() {
     for (;this.disposables.length; ) {
      const x = this.disposables.pop();
      x && x.dispose();
     }
    }
   };
   StatusBars = StatusBars_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(StatusBars_1), tslib_1.__metadata("design:paramtypes", [ versionStatusBar_1.VersionStatusBar, deferToProductionStatusBar_1.DeferToProductionStatusBar, targetStatusBar_1.TargetStatusBar ]) ], StatusBars), 
   exports.StatusBars = StatusBars;
  },
  86940: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var TargetStatusBar_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.TargetStatusBar = void 0;
   const tslib_1 = __webpack_require__(31635), vscode_1 = __webpack_require__(54980), utils_1 = __webpack_require__(86185), dbtProjectContainer_1 = __webpack_require__(82018), dbtTerminal_1 = __webpack_require__(83683), _extension_1 = __webpack_require__(80537);
   let TargetStatusBar = TargetStatusBar_1 = class {
    constructor(dbtProjectContainer, dbtTerminal, queryManifestService) {
     this.dbtProjectContainer = dbtProjectContainer, this.dbtTerminal = dbtTerminal, 
     this.queryManifestService = queryManifestService, this.statusBar = vscode_1.window.createStatusBarItem(vscode_1.StatusBarAlignment.Left, 9), 
     this.disposables = [], this.disposables.push(vscode_1.window.onDidChangeActiveTextEditor((event => tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.updateStatusBar();
     })))));
    }
    dispose() {
     for (;this.disposables.length; ) {
      const x = this.disposables.pop();
      x && x.dispose();
     }
     this.statusBar.dispose();
    }
    updateStatusBar() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      try {
       const currentProject = this.getCurrentProject(), targets = yield currentProject.getTargetNames(), selectedTarget = yield currentProject.getSelectedTarget();
       if (selectedTarget) {
        const maxLength = 10;
        this.statusBar.text = `$(target) ${selectedTarget.length >= maxLength ? selectedTarget.substring(0, maxLength) + "..." : selectedTarget}`, 
        this.statusBar.tooltip = `The currently selected target for project ${currentProject.getProjectName()} is ${selectedTarget}`, 
        this.statusBar.command = {
         title: "Open Target selector",
         command: "dbtPowerUser.openTargetSelector",
         arguments: [ targets, currentProject, this ]
        }, this.statusBar.show();
       }
      } catch (err) {
       this.statusBar.hide(), this.dbtTerminal.debug("TargetStatusBar", "Unable to update target status bar", err);
      }
     }));
    }
    getCurrentProject() {
     var _a;
     const projects = this.dbtProjectContainer.getProjects();
     if (1 === projects.length) return projects[0];
     const currentFilePath = null === (_a = vscode_1.window.activeTextEditor) || void 0 === _a ? void 0 : _a.document.uri;
     if (!currentFilePath) throw new Error("No file selected in the editor");
     const currentProject = this.dbtProjectContainer.findDBTProject(currentFilePath);
     if (!currentProject) throw new Error("no Project found for selected document");
     return currentProject;
    }
   };
   TargetStatusBar = TargetStatusBar_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(TargetStatusBar_1), tslib_1.__metadata("design:paramtypes", [ dbtProjectContainer_1.DBTProjectContainer, dbtTerminal_1.DBTTerminal, _extension_1.QueryManifestService ]) ], TargetStatusBar), 
   exports.TargetStatusBar = TargetStatusBar;
  },
  32433: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var VersionStatusBar_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.VersionStatusBar = void 0;
   const tslib_1 = __webpack_require__(31635), vscode_1 = __webpack_require__(54980), dbtProjectContainer_1 = __webpack_require__(82018), utils_1 = __webpack_require__(86185);
   let VersionStatusBar = VersionStatusBar_1 = class {
    constructor(dbtProjectContainer) {
     this.dbtProjectContainer = dbtProjectContainer, this.statusBar = vscode_1.window.createStatusBarItem(vscode_1.StatusBarAlignment.Left, 10), 
     this.disposables = [], this.disposables.push(this.dbtProjectContainer.onDBTInstallationVerification((e => this.onDBTInstallationVerification(e))), this.dbtProjectContainer.onRebuildManifestStatusChange((e => this.onRebuildManifestStatusChange(e))));
    }
    dispose() {
     for (;this.disposables.length; ) {
      const x = this.disposables.pop();
      x && x.dispose();
     }
     this.statusBar.dispose();
    }
    getDbtText() {
     return "cloud" === vscode_1.workspace.getConfiguration("dbt").get("dbtIntegration", "core") ? "dbt cloud" : "dbt core";
    }
    onRebuildManifestStatusChange(event) {
     if (!event.inProgress) return this.installed ? void this.showTextInStatusBar(`$(check) ${this.getDbtText()}`) : void this.showTextInStatusBar(`$(error) ${this.getDbtText()} is not installed`);
     1 !== event.projects.length ? this.showTextInStatusBar("$(sync~spin) Parsing projects") : this.showTextInStatusBar(`$(sync~spin) Parsing ${event.projects[0].getProjectName()}`);
    }
    onDBTInstallationVerification(event) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.installed = event.installed, !0 !== event.inProgress ? event.installed ? this.showTextInStatusBar(`$(check) ${this.getDbtText()}`) : this.showTextInStatusBar(`$(error) ${this.getDbtText()} is not installed`) : this.showTextInStatusBar("$(sync~spin) Detecting dbt");
     }));
    }
    showTextInStatusBar(text, command) {
     this.statusBar.text = text, this.statusBar.command = command || {
      title: "Open Control Panel",
      command: "dbtPowerUser.puQuickPick"
     }, this.statusBar.show();
    }
   };
   VersionStatusBar = VersionStatusBar_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(VersionStatusBar_1), tslib_1.__metadata("design:paramtypes", [ dbtProjectContainer_1.DBTProjectContainer ]) ], VersionStatusBar), 
   exports.VersionStatusBar = VersionStatusBar;
  },
  91723: (__unused_webpack_module, exports) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.TelemetryEvents = exports.TelemetryEventPriority = void 0, function(TelemetryEventPriority) {
    TelemetryEventPriority.Critical = "Critical", TelemetryEventPriority.High = "High", 
    TelemetryEventPriority.Medium = "Medium", TelemetryEventPriority.Low = "Low";
   }(exports.TelemetryEventPriority || (exports.TelemetryEventPriority = {})), function(TelemetryEvents) {
    TelemetryEvents["Datapilot/Feedback"] = "Datapilot/Feedback", TelemetryEvents["DocumentationEditor/Load"] = "DocumentationEditor/Load", 
    TelemetryEvents["DocumentationEditor/SyncWithDBClick"] = "DocumentationEditor/SyncWithDBClick", 
    TelemetryEvents["DocumentationEditor/TestsTabClick"] = "DocumentationEditor/TestsTabClick", 
    TelemetryEvents["DocumentationEditor/SettingsOpen"] = "DocumentationEditor/SettingsOpen", 
    TelemetryEvents["DocumentationEditor/SettingsUpdate"] = "DocumentationEditor/SettingsUpdate", 
    TelemetryEvents["DocumentationEditor/HelpOpen"] = "DocumentationEditor/HelpOpen", 
    TelemetryEvents["DocumentationEditor/HelpTestsOpen"] = "DocumentationEditor/HelpTestsOpen", 
    TelemetryEvents["DocumentationEditor/HelpDocumentationLinkInDocumentationClick"] = "DocumentationEditor/HelpDocumentationLinkInDocumentationClick", 
    TelemetryEvents["DocumentationEditor/HelpContactusLinkInDocumentationClick"] = "DocumentationEditor/HelpContactusLinkInDocumentationClick", 
    TelemetryEvents["DocumentationEditor/HelpDocumentationLinkInTestsClick"] = "DocumentationEditor/HelpDocumentationLinkInTestsClick", 
    TelemetryEvents["DocumentationEditor/HelpContactusLinkInTestsClick"] = "DocumentationEditor/HelpContactusLinkInTestsClick", 
    TelemetryEvents["DocumentationEditor/FeedbackClick"] = "DocumentationEditor/FeedbackClick", 
    TelemetryEvents["DocumentationEditor/SaveClick"] = "DocumentationEditor/SaveClick", 
    TelemetryEvents["DocumentationEditor/SaveError"] = "DocumentationEditor/SaveError", 
    TelemetryEvents["DocumentationEditor/SaveNewFilePathSelect"] = "DocumentationEditor/SaveNewFilePathSelect", 
    TelemetryEvents["DocumentationEditor/BulkGenerateAllClick"] = "DocumentationEditor/BulkGenerateAllClick", 
    TelemetryEvents["DocumentationEditor/BulkGenerateAllError"] = "DocumentationEditor/BulkGenerateAllError", 
    TelemetryEvents["DocumentationEditor/BulkGenerateMissingColumnsClick"] = "DocumentationEditor/BulkGenerateMissingColumnsClick", 
    TelemetryEvents["DocumentationEditor/BulkGenerateMissingColumnsError"] = "DocumentationEditor/BulkGenerateMissingColumnsError", 
    TelemetryEvents["DocumentationEditor/GenerateDescForModelClick"] = "DocumentationEditor/GenerateDescForModelClick", 
    TelemetryEvents["DocumentationEditor/GenerateDescForColumnClick"] = "DocumentationEditor/GenerateDescForColumnClick", 
    TelemetryEvents["DocumentationEditor/GenerateDescByDatapilotForModelClick"] = "DocumentationEditor/GenerateDescByDatapilotForModelClick", 
    TelemetryEvents["DocumentationEditor/GenerateDescByDatapilotForColumnClick"] = "DocumentationEditor/GenerateDescByDatapilotForColumnClick", 
    TelemetryEvents["DocumentationEditor/ColumnTestClick"] = "DocumentationEditor/ColumnTestClick", 
    TelemetryEvents["DocumentationEditor/ModelTestClick"] = "DocumentationEditor/ModelTestClick", 
    TelemetryEvents["DocumentationEditor/AddTestClick"] = "DocumentationEditor/AddTestClick", 
    TelemetryEvents["DocumentationEditor/AddCustomTestClick"] = "DocumentationEditor/AddCustomTestClick", 
    TelemetryEvents["DocumentationEditor/GetDistinctColumnValues"] = "DocumentationEditor/GetDistinctColumnValues", 
    TelemetryEvents["DocumentationEditor/AcceptedValuesSaveClick"] = "DocumentationEditor/AcceptedValuesSaveClick", 
    TelemetryEvents["DocumentationEditor/RelationshipsToSelect"] = "DocumentationEditor/RelationshipsToSelect", 
    TelemetryEvents["DocumentationEditor/RelationshipsFieldSelect"] = "DocumentationEditor/RelationshipsFieldSelect", 
    TelemetryEvents["DocumentationEditor/RelationshipsSaveClick"] = "DocumentationEditor/RelationshipsSaveClick", 
    TelemetryEvents["DocumentationEditor/TestEditClick"] = "DocumentationEditor/TestEditClick", 
    TelemetryEvents["DocumentationEditor/TestEditCancel"] = "DocumentationEditor/TestEditCancel", 
    TelemetryEvents["DocumentationEditor/TestEditUpdateClick"] = "DocumentationEditor/TestEditUpdateClick", 
    TelemetryEvents["DocumentationEditor/TestDeleteClick"] = "DocumentationEditor/TestDeleteClick", 
    TelemetryEvents["DocumentationEditor/AddTestSelect"] = "DocumentationEditor/AddTestSelect", 
    TelemetryEvents["Notebook/DependenciesInstallCancelled"] = "Notebook/DependenciesInstallCancelled", 
    TelemetryEvents["Notebook/DependenciesInstalled"] = "Notebook/DependenciesInstalled", 
    TelemetryEvents["Notebook/DependenciesInstallError"] = "Notebook/DependenciesInstallError", 
    TelemetryEvents["Notebook/KernelInitializationError"] = "Notebook/KernelInitializationError", 
    TelemetryEvents["Notebook/KernelCloseError"] = "Notebook/KernelCloseError", TelemetryEvents["Notebook/Execute"] = "Notebook/Execute", 
    TelemetryEvents["Notebook/WidgetVersionError"] = "Notebook/WidgetVersionError", 
    TelemetryEvents["Notebook/SaveError"] = "Notebook/SaveError", TelemetryEvents["Notebook/Launch"] = "Notebook/Launch", 
    TelemetryEvents["Notebook/LaunchError"] = "Notebook/LaunchError", TelemetryEvents["Notebook/StoreDataInKernelError"] = "Notebook/StoreDataInKernelError", 
    TelemetryEvents["QueryHistory/Disabled"] = "QueryHistory/Disabled", TelemetryEvents["QueryHistory/Cleared"] = "QueryHistory/Cleared";
   }(exports.TelemetryEvents || (exports.TelemetryEvents = {}));
  },
  22644: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var TelemetryService_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.TelemetryService = void 0;
   const tslib_1 = __webpack_require__(31635), extension_telemetry_1 = __webpack_require__(81170), vscode = __webpack_require__(54980), utils_1 = __webpack_require__(86185);
   let TelemetryService = TelemetryService_1 = class {
    constructor() {
     this.customAttributes = {}, this.telemetryReporter = new extension_telemetry_1.default("50598369-dd83-4f9a-9a65-ca1fa6f1785c"), 
     this.eventMeasurements = new Map;
    }
    setTelemetryCustomAttribute(key, value) {
     this.customAttributes[key] = value;
    }
    startTelemetryEvent(eventName, properties, measurements) {
     this.eventMeasurements.set(eventName, (new Date).getTime()), this.sendTelemetryEvent(eventName, properties, measurements);
    }
    endTelemetryEvent(eventName, error, properties, measurements) {
     const start = this.eventMeasurements.get(eventName);
     error && this.sendTelemetryError(`${eventName}Error`, error, properties, Object.assign(Object.assign({}, measurements || {}), {
      duration: (new Date).getTime() - start
     }));
    }
    getFeatureName(eventName) {
     const [featureName, rest] = eventName.split("/");
     return rest ? {
      feature: featureName
     } : {};
    }
    sendTelemetryEvent(eventName, properties, measurements) {
     this.telemetryReporter.sendTelemetryEvent(eventName, Object.assign(Object.assign(Object.assign(Object.assign({}, this.getFeatureName(eventName)), properties), {
      instanceName: vscode.workspace.getConfiguration("dbt").get("altimateInstanceName"),
      dbtIntegrationMode: vscode.workspace.getConfiguration("dbt").get("dbtIntegration", "core"),
      localMode: vscode.workspace.getConfiguration("dbt").get("isLocalMode", !1) ? "true" : "false"
     }), this.customAttributes), measurements);
    }
    sendTelemetryError(eventName, error, properties, measurements) {
     this.telemetryReporter.sendTelemetryErrorEvent(eventName, Object.assign(Object.assign(Object.assign(Object.assign({}, this.getFeatureName(eventName)), properties), {
      instanceName: vscode.workspace.getConfiguration("dbt").get("altimateInstanceName"),
      dbtIntegrationMode: vscode.workspace.getConfiguration("dbt").get("dbtIntegration", "core"),
      localMode: vscode.workspace.getConfiguration("dbt").get("isLocalMode", !1) ? "true" : "false",
      stack: this.removeGenericSecretsFromStackTrace(void 0 !== error && error instanceof Error ? error.stack : JSON.stringify(error))
     }), this.customAttributes), measurements);
    }
    removeGenericSecretsFromStackTrace(error) {
     return error ? error.replace(/(key|token|sig|secret|signature|password|passwd|pwd|android:value)/i, "****") : "";
    }
    dispose() {
     var _a;
     null === (_a = this.telemetryReporter) || void 0 === _a || _a.dispose();
    }
   };
   TelemetryService = TelemetryService_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(TelemetryService_1) ], TelemetryService), 
   exports.TelemetryService = TelemetryService;
  },
  57052: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var TreeviewProviders_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.TreeviewProviders = void 0;
   const tslib_1 = __webpack_require__(31635), vscode_1 = __webpack_require__(54980), utils_1 = __webpack_require__(86185), modelTreeviewProvider_1 = __webpack_require__(14973);
   let TreeviewProviders = TreeviewProviders_1 = class {
    constructor(childrenModelTreeview, parentModelTreeview, testModelTreeview, documentationTreeView, iconActionsTreeview) {
     this.childrenModelTreeview = childrenModelTreeview, this.parentModelTreeview = parentModelTreeview, 
     this.testModelTreeview = testModelTreeview, this.documentationTreeView = documentationTreeView, 
     this.iconActionsTreeview = iconActionsTreeview, this.disposables = [], this.disposables.push(vscode_1.window.registerTreeDataProvider("model_test_treeview", this.testModelTreeview), vscode_1.window.registerTreeDataProvider("parent_model_treeview", this.parentModelTreeview), vscode_1.window.registerTreeDataProvider("children_model_treeview", this.childrenModelTreeview), vscode_1.window.registerTreeDataProvider("documentation_treeview", this.documentationTreeView), vscode_1.window.registerTreeDataProvider("icon_actions_treeview", this.iconActionsTreeview));
    }
    dispose() {
     for (;this.disposables.length; ) {
      const x = this.disposables.pop();
      x && x.dispose();
     }
    }
   };
   TreeviewProviders = TreeviewProviders_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(TreeviewProviders_1), tslib_1.__metadata("design:paramtypes", [ modelTreeviewProvider_1.ChildrenModelTreeview, modelTreeviewProvider_1.ParentModelTreeview, modelTreeviewProvider_1.ModelTestTreeview, modelTreeviewProvider_1.DocumentationTreeview, modelTreeviewProvider_1.IconActionsTreeview ]) ], TreeviewProviders), 
   exports.TreeviewProviders = TreeviewProviders;
  },
  14973: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var ModelTreeviewProvider_1, DocumentationTreeviewProvider_1, IconActionsTreeviewProvider_1, ModelTestTreeview_1, ParentModelTreeview_1, ChildrenModelTreeview_1, DocumentationTreeview_1, IconActionsTreeview_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.IconActionsTreeview = exports.DocumentationTreeview = exports.ChildrenModelTreeview = exports.ParentModelTreeview = exports.ModelTestTreeview = exports.ActionTreeItem = exports.NodeTreeItem = exports.DocNode = void 0;
   const tslib_1 = __webpack_require__(31635), inversify_1 = __webpack_require__(25891), inversify_binding_decorators_1 = __webpack_require__(25567), path = __webpack_require__(16928), vscode_1 = __webpack_require__(54980), domain_1 = __webpack_require__(97066), dbtProjectContainer_1 = __webpack_require__(82018), utils_1 = __webpack_require__(86185);
   let ModelTreeviewProvider = ModelTreeviewProvider_1 = class {
    constructor(dbtProjectContainer, treeType) {
     this.dbtProjectContainer = dbtProjectContainer, this.treeType = treeType, this.eventMap = new Map, 
     this._onDidChangeTreeData = new vscode_1.EventEmitter, this.onDidChangeTreeData = this._onDidChangeTreeData.event, 
     this.disposables = [ this._onDidChangeTreeData ], this.treeType = treeType, this.disposables.push(vscode_1.window.onDidChangeActiveTextEditor((() => {
      this._onDidChangeTreeData.fire();
     })), this.dbtProjectContainer.onManifestChanged((event => this.onManifestCacheChanged(event))));
    }
    dispose() {
     for (;this.disposables.length; ) {
      const x = this.disposables.pop();
      x && x.dispose();
     }
    }
    onManifestCacheChanged(event) {
     var _a, _b;
     null === (_a = event.added) || void 0 === _a || _a.forEach((added => {
      this.eventMap.set(added.project.projectRoot.fsPath, added);
     })), null === (_b = event.removed) || void 0 === _b || _b.forEach((removed => {
      this.eventMap.delete(removed.projectRoot.fsPath);
     })), this._onDidChangeTreeData.fire();
    }
    getTreeItem(element) {
     return element;
    }
    getChildren(element) {
     if (void 0 === vscode_1.window.activeTextEditor || void 0 === this.eventMap) return Promise.resolve([]);
     const currentFilePath = vscode_1.window.activeTextEditor.document.uri, projectRootpath = this.dbtProjectContainer.getProjectRootpath(currentFilePath);
     if (void 0 === projectRootpath) return Promise.resolve([]);
     const event = this.eventMap.get(projectRootpath.fsPath);
     if (void 0 === event) return Promise.resolve([]);
     if (null == element ? void 0 : element.key.startsWith("test.")) return Promise.resolve([]);
     if (element) return Promise.resolve(this.getTreeItems(element.key, event));
     const fileName = path.basename(vscode_1.window.activeTextEditor.document.fileName, ".sql"), model = event.nodeMetaMap.lookupByBaseName(fileName);
     return model ? Promise.resolve(this.getTreeItems(model.uniqueId, event)) : Promise.resolve([]);
    }
    getNodeTreeItem(node) {
     return node instanceof domain_1.Snapshot ? new SnapshotTreeItem(node) : node instanceof domain_1.Exposure ? new ExposureTreeItem(node) : node instanceof domain_1.Analysis ? new AnalysisTreeItem(node) : node instanceof domain_1.Test ? new TestTreeItem(node) : node instanceof domain_1.Source ? new SourceTreeItem(node) : node instanceof domain_1.Seed ? new SeedTreeItem(node) : new ModelTreeItem(node);
    }
    getTreeItems(elementName, event) {
     const {graphMetaMap} = event, parentModels = graphMetaMap[this.treeType].get(elementName);
     return void 0 === parentModels ? [] : parentModels.nodes.filter((node => node.displayInModelTree)).map((node => {
      var _a;
      const childNodes = null === (_a = graphMetaMap[this.treeType].get(node.key)) || void 0 === _a ? void 0 : _a.nodes.filter((node => node.displayInModelTree)), treeItem = this.getNodeTreeItem(node);
      return treeItem.collapsibleState = 0 !== (null == childNodes ? void 0 : childNodes.length) ? vscode_1.TreeItemCollapsibleState.Collapsed : vscode_1.TreeItemCollapsibleState.None, 
      treeItem;
     }));
    }
   };
   ModelTreeviewProvider = ModelTreeviewProvider_1 = tslib_1.__decorate([ (0, inversify_binding_decorators_1.provide)(ModelTreeviewProvider_1), tslib_1.__param(1, (0, 
   inversify_1.unmanaged)()), tslib_1.__metadata("design:paramtypes", [ dbtProjectContainer_1.DBTProjectContainer, Object ]) ], ModelTreeviewProvider);
   let DocumentationTreeviewProvider = DocumentationTreeviewProvider_1 = class {
    constructor(dbtProjectContainer) {
     this.dbtProjectContainer = dbtProjectContainer, this.eventMap = new Map, this._onDidChangeTreeData = new vscode_1.EventEmitter, 
     this.onDidChangeTreeData = this._onDidChangeTreeData.event, this.disposables = [ this._onDidChangeTreeData ], 
     this.disposables.push(vscode_1.window.onDidChangeActiveTextEditor((() => {
      this._onDidChangeTreeData.fire();
     })), this.dbtProjectContainer.onManifestChanged((event => this.onManifestCacheChanged(event))));
    }
    onManifestCacheChanged(event) {
     var _a, _b;
     null === (_a = event.added) || void 0 === _a || _a.forEach((added => {
      this.eventMap.set(added.project.projectRoot.fsPath, added);
     })), null === (_b = event.removed) || void 0 === _b || _b.forEach((removed => {
      this.eventMap.delete(removed.projectRoot.fsPath);
     })), this._onDidChangeTreeData.fire();
    }
    getTreeItem(element) {
     return {
      label: element.label,
      description: element.description,
      command: element.command,
      collapsibleState: element.children ? vscode_1.TreeItemCollapsibleState.Expanded : vscode_1.TreeItemCollapsibleState.None
     };
    }
    getChildren(element) {
     if (void 0 === vscode_1.window.activeTextEditor || void 0 === this.eventMap) return Promise.resolve([]);
     const currentFilePath = vscode_1.window.activeTextEditor.document.uri, projectRootpath = this.dbtProjectContainer.getProjectRootpath(currentFilePath);
     if (!projectRootpath) return Promise.resolve([]);
     const event = this.eventMap.get(projectRootpath.fsPath);
     if (void 0 === event) return Promise.resolve([]);
     const {nodeMetaMap} = event;
     if (!element) {
      const modelName = path.basename(vscode_1.window.activeTextEditor.document.fileName, ".sql"), currentNode = nodeMetaMap.lookupByBaseName(modelName);
      if (void 0 === currentNode) return Promise.resolve([]);
      const children = [];
      if (0 !== Object.keys(currentNode.columns).length) {
       for (const columnName in currentNode.columns) if (currentNode.columns.hasOwnProperty(columnName)) {
        const column = currentNode.columns[columnName], {description} = column, child = {
         label: columnName,
         description
        };
        children.push(child);
       }
       const url = null !== currentNode.patch_path ? path.join(projectRootpath.fsPath, currentNode.patch_path.split("://")[1]) : " ";
       0 === Object.keys(currentNode.columns).length && vscode_1.window.showWarningMessage(`Documentation View Warning: No columns found in manifest.json for ${modelName}, go edit the documentation in the documentation editor panel and run dbt docs generate`);
       const key = currentNode.uniqueId, label = currentNode.alias, description = `[ ${currentNode.config.materialized.toUpperCase()} ]  -  schema : ${currentNode.schema}`, nodeItem = new DocNode(label, key, url, description), treeItem = new DocTreeItem(nodeItem);
       return treeItem.children = children, [ treeItem ];
      }
      return [];
     }
     return element.children;
    }
    refresh() {
     this._onDidChangeTreeData.fire();
    }
   };
   DocumentationTreeviewProvider = DocumentationTreeviewProvider_1 = tslib_1.__decorate([ (0, 
   inversify_binding_decorators_1.provide)(DocumentationTreeviewProvider_1), tslib_1.__metadata("design:paramtypes", [ dbtProjectContainer_1.DBTProjectContainer ]) ], DocumentationTreeviewProvider);
   class DocTreeItem extends vscode_1.TreeItem {
    constructor(node) {
     super(node.label, vscode_1.TreeItemCollapsibleState.Collapsed), this.collapsibleState = vscode_1.TreeItemCollapsibleState.Collapsed, 
     this.description = void 0 !== node.description ? node.description : " ", node.url && (this.command = {
      command: "vscode.open",
      title: "Open YML",
      arguments: [ vscode_1.Uri.file(node.url) ]
     }), void 0 !== node.iconPath && (this.iconPath = node.iconPath);
    }
   }
   class DocNode extends domain_1.Node {
    constructor(label, key, url, description) {
     super(label, key, url), this.description = description;
    }
   }
   exports.DocNode = DocNode;
   class NodeTreeItem extends vscode_1.TreeItem {
    constructor(node) {
     super(node.label), this.collapsibleState = vscode_1.TreeItemCollapsibleState.Collapsed, 
     this.key = node.key, this.url = node.url, void 0 !== node.iconPath && (this.iconPath = node.iconPath), 
     node.url && (this.command = {
      command: "vscode.open",
      title: "Select Node",
      arguments: [ vscode_1.Uri.file(node.url) ]
     });
    }
   }
   exports.NodeTreeItem = NodeTreeItem;
   class ActionTreeItem extends vscode_1.TreeItem {
    constructor(label, icon, command, tooltip) {
     super(label), this.collapsibleState = vscode_1.TreeItemCollapsibleState.Collapsed, 
     this.iconPath = icon, this.command = command, this.tooltip = tooltip;
    }
   }
   exports.ActionTreeItem = ActionTreeItem;
   let IconActionsTreeviewProvider = IconActionsTreeviewProvider_1 = class {
    constructor() {
     this.collapsibleState = vscode_1.TreeItemCollapsibleState.Collapsed;
    }
    getTreeItem(element) {
     return element.collapsibleState = element.children ? vscode_1.TreeItemCollapsibleState.Collapsed : vscode_1.TreeItemCollapsibleState.None, 
     element.iconPath = element.children ? void 0 : element.iconPath, element;
    }
    getChildren(element) {
     if (!element) {
      const scanItem = new ActionTreeItem("Project Health Check", void 0, void 0, "Find issues in dbt projects");
      return scanItem.children = [ new ActionTreeItem("Start Scan", new vscode_1.ThemeIcon("search-view-icon"), {
       command: "dbtPowerUser.altimateScan",
       title: "Project Health Check",
       arguments: []
      }, "Scan all projects for issues"), new ActionTreeItem("Clear Problems", new vscode_1.ThemeIcon("search-stop"), {
       command: "dbtPowerUser.clearAltimateScanResults",
       title: "Clear All Problems",
       arguments: []
      }, "Clear issues from problems panel"), new ActionTreeItem("Send Feedback", void 0, {
       command: "vscode.open",
       title: "Send Feedback",
       arguments: [ vscode_1.Uri.parse("https://docs.google.com/forms/d/e/1FAIpQLSdw7QEvM84FX0KQT1ADhxVsdHk81cdDp_a930Ggym5_Fk1vWg/viewform") ]
      }) ], Promise.resolve([ scanItem ]);
     }
     return element.children;
    }
   };
   IconActionsTreeviewProvider = IconActionsTreeviewProvider_1 = tslib_1.__decorate([ (0, 
   inversify_binding_decorators_1.provide)(IconActionsTreeviewProvider_1) ], IconActionsTreeviewProvider);
   class ModelTreeItem extends NodeTreeItem {
    constructor() {
     super(...arguments), this.contextValue = "model";
    }
   }
   class SourceTreeItem extends NodeTreeItem {
    constructor() {
     super(...arguments), this.iconPath = {
      light: path.join(path.resolve(__dirname), "../media/images/source_light.svg"),
      dark: path.join(path.resolve(__dirname), "../media/images/source_dark.svg")
     }, this.contextValue = "source";
    }
   }
   class SeedTreeItem extends NodeTreeItem {
    constructor() {
     super(...arguments), this.iconPath = {
      light: path.join(path.resolve(__dirname), "../media/images/seed_light.svg"),
      dark: path.join(path.resolve(__dirname), "../media/images/seed_dark.svg")
     }, this.contextValue = "seed";
    }
   }
   class SnapshotTreeItem extends NodeTreeItem {
    constructor() {
     super(...arguments), this.contextValue = "snapshot", this.iconPath = {
      light: path.join(path.resolve(__dirname), "../media/images/snapshot_light.svg"),
      dark: path.join(path.resolve(__dirname), "../media/images/snapshot_dark.svg")
     };
    }
   }
   class ExposureTreeItem extends NodeTreeItem {
    constructor() {
     super(...arguments), this.contextValue = "exposure", this.iconPath = {
      light: path.join(path.resolve(__dirname), "../media/images/exposure_light.svg"),
      dark: path.join(path.resolve(__dirname), "../media/images/exposure_dark.svg")
     };
    }
   }
   class AnalysisTreeItem extends NodeTreeItem {
    constructor() {
     super(...arguments), this.contextValue = "analysis";
    }
   }
   class TestTreeItem extends NodeTreeItem {
    constructor() {
     super(...arguments), this.iconPath = {
      light: path.join(path.resolve(__dirname), "../media/images/tests_light.svg"),
      dark: path.join(path.resolve(__dirname), "../media/images/tests_dark.svg")
     }, this.contextValue = "test";
    }
   }
   let ModelTestTreeview = ModelTestTreeview_1 = class extends ModelTreeviewProvider {
    constructor(dbtProjectContainer) {
     super(dbtProjectContainer, "tests");
    }
   };
   ModelTestTreeview = ModelTestTreeview_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(ModelTestTreeview_1), tslib_1.__metadata("design:paramtypes", [ dbtProjectContainer_1.DBTProjectContainer ]) ], ModelTestTreeview), 
   exports.ModelTestTreeview = ModelTestTreeview;
   let ParentModelTreeview = ParentModelTreeview_1 = class extends ModelTreeviewProvider {
    constructor(dbtProjectContainer) {
     super(dbtProjectContainer, "parents");
    }
   };
   ParentModelTreeview = ParentModelTreeview_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(ParentModelTreeview_1), tslib_1.__metadata("design:paramtypes", [ dbtProjectContainer_1.DBTProjectContainer ]) ], ParentModelTreeview), 
   exports.ParentModelTreeview = ParentModelTreeview;
   let ChildrenModelTreeview = ChildrenModelTreeview_1 = class extends ModelTreeviewProvider {
    constructor(dbtProjectContainer) {
     super(dbtProjectContainer, "children");
    }
   };
   ChildrenModelTreeview = ChildrenModelTreeview_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(ChildrenModelTreeview_1), tslib_1.__metadata("design:paramtypes", [ dbtProjectContainer_1.DBTProjectContainer ]) ], ChildrenModelTreeview), 
   exports.ChildrenModelTreeview = ChildrenModelTreeview;
   let DocumentationTreeview = DocumentationTreeview_1 = class extends DocumentationTreeviewProvider {
    constructor(dbtProjectContainer) {
     super(dbtProjectContainer);
    }
   };
   DocumentationTreeview = DocumentationTreeview_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(DocumentationTreeview_1), tslib_1.__metadata("design:paramtypes", [ dbtProjectContainer_1.DBTProjectContainer ]) ], DocumentationTreeview), 
   exports.DocumentationTreeview = DocumentationTreeview;
   let IconActionsTreeview = IconActionsTreeview_1 = class extends IconActionsTreeviewProvider {};
   IconActionsTreeview = IconActionsTreeview_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(IconActionsTreeview_1) ], IconActionsTreeview), 
   exports.IconActionsTreeview = IconActionsTreeview;
  },
  86185: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.getStringSizeInMb = exports.getFormattedDateTime = exports.getColumnTestConfigFromYml = exports.isAcceptedValues = exports.isRelationship = exports.getExternalProjectNamesFromDbtLoomConfig = exports.isQuotedIdentifier = exports.isColumnNameEqual = exports.getColumnNameByCase = exports.deepEqual = exports.processStreamResponse = exports.getProjectRelativePath = exports.getFirstWorkspacePath = exports.stripANSI = exports.extendErrorWithSupportLinks = exports.provideSingleton = exports.setupWatcherHandler = exports.debounce = exports.arrayEquals = exports.notEmpty = exports.isEnclosedWithinCodeBlock = void 0;
   const inversify_binding_decorators_1 = __webpack_require__(25567), path = __webpack_require__(16928), vscode_1 = __webpack_require__(54980), fs_1 = __webpack_require__(79896), yaml_1 = __webpack_require__(91198);
   exports.isEnclosedWithinCodeBlock = (document, rangeOrPosition) => {
    const isWithinCodeBlock = (startPosition, direction, lookupChar, stopChar) => {
     const increment = "desc" === direction ? -1 : 1;
     let characterPosition = startPosition.character, lineNumber = startPosition.line;
     for (;lineNumber >= 0 && lineNumber < document.lineCount; ) {
      const line = document.lineAt(lineNumber).text;
      for (void 0 === characterPosition && (characterPosition = "desc" === direction ? line.length - 1 : 0); "desc" === direction ? characterPosition >= 0 : characterPosition <= line.length - 1; ) {
       if ([ "#", "%", stopChar ].includes(line[characterPosition]) && characterPosition + increment >= 0 && line[characterPosition + increment] === stopChar) return !1;
       if ([ "#", "%", lookupChar ].includes(line[characterPosition]) && characterPosition + increment >= 0 && line[characterPosition + increment] === lookupChar) return !0;
       characterPosition += increment;
      }
      lineNumber += increment, characterPosition = void 0;
     }
     return !1;
    }, {start, end} = rangeOrPosition instanceof vscode_1.Position ? {
     start: rangeOrPosition,
     end: rangeOrPosition
    } : rangeOrPosition;
    return isWithinCodeBlock(start, "desc", "{", "}") && isWithinCodeBlock(end, "asc", "}", "{");
   };
   exports.notEmpty = value => null != value;
   exports.arrayEquals = (a, b) => a.sort().toString() === b.sort().toString();
   exports.debounce = (fn, wait) => {
    let timeout;
    return () => {
     clearTimeout(timeout), timeout = setTimeout(fn, wait);
    };
   };
   exports.setupWatcherHandler = (watcher, handler) => [ watcher.onDidChange((() => handler())), watcher.onDidCreate((() => handler())), watcher.onDidDelete((() => handler())) ];
   exports.provideSingleton = identifier => (0, inversify_binding_decorators_1.fluentProvide)(identifier).inSingletonScope().done(), 
   exports.extendErrorWithSupportLinks = function(error) {
    return (" " === error[-1] ? error : error + " ") + "If the issue persists, please [contact us](https://www.altimate.ai/support) via chat or Slack";
   }, exports.stripANSI = function(src) {
    return src.replace(/[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-ORZcf-nqry=><]/g, "");
   }, exports.getFirstWorkspacePath = function() {
    const folders = vscode_1.workspace.workspaceFolders;
    return folders ? folders[0].uri.fsPath : vscode_1.Uri.file("./").fsPath;
   };
   exports.getProjectRelativePath = projectRoot => {
    const ws = vscode_1.workspace.getWorkspaceFolder(projectRoot);
    return path.relative((null == ws ? void 0 : ws.uri.fsPath) || "", projectRoot.fsPath);
   };
   exports.processStreamResponse = (stream, cb) => {
    const chunks = [];
    return new Promise(((resolve, reject) => {
     stream.on("data", (chunk => {
      cb((new TextDecoder).decode(chunk)), chunks.push(Buffer.from(chunk));
     })), stream.on("error", (err => reject(err))), stream.on("end", (() => resolve(Buffer.concat(chunks).toString("utf8"))));
    }));
   };
   exports.deepEqual = (obj1, obj2) => {
    if (obj1 === obj2) return !0;
    if ("object" != typeof obj1 || "object" != typeof obj2 || null === obj1 || null === obj2) return !1;
    const keys1 = Object.keys(obj1), keys2 = Object.keys(obj2);
    if (keys1.length !== keys2.length) return !1;
    for (const key of keys1) if (!keys2.includes(key) || !(0, exports.deepEqual)(obj1[key], obj2[key])) return !1;
    return !0;
   };
   exports.getColumnNameByCase = (columnName, adapter) => {
    if ((0, exports.isQuotedIdentifier)(columnName, adapter)) return columnName;
    return vscode_1.workspace.getConfiguration("dbt").get("showColumnNamesInLowercase", !0) ? columnName.toLowerCase() : columnName;
   };
   exports.isColumnNameEqual = (columnNameFromYml, incomingColumnName) => {
    if (!columnNameFromYml || !incomingColumnName) return !1;
    if (columnNameFromYml === incomingColumnName) return !0;
    return !!vscode_1.workspace.getConfiguration("dbt").get("showColumnNamesInLowercase", !0) && columnNameFromYml.toLowerCase() === incomingColumnName.toLowerCase();
   };
   exports.isQuotedIdentifier = (columnName, adapter) => {
    const regexFromConfig = vscode_1.workspace.getConfiguration("dbt").get("unquotedCaseInsensitiveIdentifierRegex", "");
    if (regexFromConfig) return console.log("[isQuotedIdentifier] using user provider regex for", regexFromConfig), 
    !new RegExp(regexFromConfig).test(columnName);
    return [ "trino", "athena", "postgres", "duckdb" ].includes(adapter) ? !/^([_a-z]+[_a-z0-9$]*)$/.test(columnName) : !/^([_A-Z]+[_A-Z0-9$]*)$/.test(columnName);
   };
   exports.getExternalProjectNamesFromDbtLoomConfig = projectRoot => {
    var _a;
    const dbtLoomConfigPath = process.env.DBT_LOOM_CONFIG_PATH || path.join(projectRoot, "dbt_loom.config.yml");
    try {
     const fileContents = (0, fs_1.readFileSync)(dbtLoomConfigPath, "utf8");
     if (fileContents) {
      return null === (_a = ((0, yaml_1.parse)(fileContents, {
       strict: !1,
       uniqueKeys: !1,
       maxAliasCount: -1
      }) || {}).manifests) || void 0 === _a ? void 0 : _a.map((manifest => manifest.name));
     }
    } catch (error) {
     console.debug("NodeParser", `Error reading dbt_loom.config.yml at ${dbtLoomConfigPath}`, error);
    }
    return null;
   };
   exports.isRelationship = metadata => void 0 !== metadata.field;
   exports.isAcceptedValues = metadata => void 0 !== metadata.values;
   exports.getColumnTestConfigFromYml = (allTests, kwargs, testName) => {
    const testsByTestName = null == allTests ? void 0 : allTests.filter((t => {
     if ("string" == typeof t) return t === testName;
     const [key] = Object.keys(t);
     return key === testName;
    })), testWithRightConfigValues = null == testsByTestName ? void 0 : testsByTestName.find((t => {
     var _a;
     return "string" == typeof t ? t === testName : (0, exports.isRelationship)(kwargs) ? kwargs.field === t.relationships.field && kwargs.to === t.relationships.to : !(0, 
     exports.isAcceptedValues)(kwargs) || (null === (_a = kwargs.values) || void 0 === _a ? void 0 : _a.sort().toString()) === t.accepted_values.values.sort().toString();
    }));
    return (0, exports.isRelationship)(kwargs) ? null == testWithRightConfigValues ? void 0 : testWithRightConfigValues.relationships : (0, 
    exports.isAcceptedValues)(kwargs) ? null == testWithRightConfigValues ? void 0 : testWithRightConfigValues.accepted_values : (null == testWithRightConfigValues ? void 0 : testWithRightConfigValues[testName]) ? {
     [testName]: null == testWithRightConfigValues ? void 0 : testWithRightConfigValues[testName]
    } : void 0;
   }, exports.getFormattedDateTime = function() {
    const now = new Date;
    return `${now.toLocaleDateString("en-GB").replace(/\//g, "-")}-${now.toLocaleTimeString("en-GB", {
     hour12: !1
    }).replace(/:/g, "-")}`;
   };
   exports.getStringSizeInMb = str => {
    let sizeInBytes = 0;
    for (let i = 0; i < str.length; i++) {
     const charCode = str.charCodeAt(i);
     sizeInBytes += charCode <= 127 ? 1 : charCode <= 2047 ? 2 : charCode <= 65535 ? 3 : 4;
    }
    return sizeInBytes / 1048576;
   };
  },
  79262: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var ValidationProvider_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.ValidationProvider = void 0;
   const tslib_1 = __webpack_require__(31635), vscode_1 = __webpack_require__(54980), utils_1 = __webpack_require__(86185), altimate_1 = __webpack_require__(91741), validTenantRegex = new RegExp(/^[a-z_][a-z0-9_]*$/);
   let ValidationProvider = ValidationProvider_1 = class {
    constructor(altimate) {
     this.altimate = altimate, this.disposables = [], this._isAuthenticated = !1, this.disposables.push(vscode_1.workspace.onDidChangeConfiguration((e => {
      e.affectsConfiguration("dbt") && (this.validateCredentials(), this.setDBTContext());
     }))), this.setDBTContext();
    }
    setDBTContext() {
     let dbtIntegration = vscode_1.workspace.getConfiguration("dbt").get("dbtIntegration", "core");
     [ "core", "cloud" ].includes(dbtIntegration) || (dbtIntegration = "core"), vscode_1.commands.executeCommand("setContext", "dbtPowerUser.dbtIntegration", dbtIntegration);
    }
    validateCredentials() {
     this._validateCredentials(!1);
    }
    validateCredentialsSilently() {
     this._validateCredentials(!0);
    }
    _validateCredentials(silent) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const key = this.altimate.getAIKey(), instance = this.altimate.getInstanceName();
      if (!key || !instance) return void (this._isAuthenticated = !1);
      let message = "";
      if (validTenantRegex.exec(instance) ? 32 !== key.length && (message = "API key is not valid") : message = "Instance name must not be URL.", 
      message) return this._isAuthenticated = !1, void (silent || vscode_1.window.showErrorMessage(message));
      const connectivity = yield this.altimate.checkApiConnectivity();
      if ("ok" !== (null == connectivity ? void 0 : connectivity.status)) return this._isAuthenticated = !1, 
      void (silent || vscode_1.window.showErrorMessage("Unable to connect to Altimate Service. Please check your Firewall/VPN settings or check service [status](https://altimateai.instatus.com/)."));
      const validation = yield this.altimate.validateCredentials(instance, key);
      if (!(null == validation ? void 0 : validation.ok)) return this._isAuthenticated = !1, 
      void (silent || vscode_1.window.showErrorMessage(`Credentials are invalid. ${null == validation ? void 0 : validation.detail}`));
      this._isAuthenticated = !0;
     }));
    }
    isAuthenticated() {
     return this._isAuthenticated;
    }
    throwIfNotAuthenticated() {
     if (!this.isAuthenticated()) {
      const message = this.altimate.getCredentialsMessage();
      throw message ? new altimate_1.NoCredentialsError(message) : new altimate_1.ForbiddenError;
     }
    }
    dispose() {
     for (;this.disposables.length; ) {
      const x = this.disposables.pop();
      x && x.dispose();
     }
    }
   };
   ValidationProvider = ValidationProvider_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(ValidationProvider_1), tslib_1.__metadata("design:paramtypes", [ altimate_1.AltimateRequest ]) ], ValidationProvider), 
   exports.ValidationProvider = ValidationProvider;
  },
  67164: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var DbtDocsView_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.DbtDocsView = void 0;
   const tslib_1 = __webpack_require__(31635), vscode_1 = __webpack_require__(54980), altimate_1 = __webpack_require__(91741), dbtTerminal_1 = __webpack_require__(83683), dbtProjectContainer_1 = __webpack_require__(82018), queryManifestService_1 = __webpack_require__(59269), sharedStateService_1 = __webpack_require__(37712), telemetry_1 = __webpack_require__(22644), utils_1 = __webpack_require__(86185), altimateWebviewProvider_1 = __webpack_require__(56183), usersService_1 = __webpack_require__(8502);
   let DbtDocsView = DbtDocsView_1 = class extends altimateWebviewProvider_1.AltimateWebviewProvider {
    constructor(dbtProjectContainer, altimateRequest, telemetry, emitterService, dbtTerminal, queryManifestService, usersService) {
     super(dbtProjectContainer, altimateRequest, telemetry, emitterService, dbtTerminal, queryManifestService, usersService), 
     this.dbtProjectContainer = dbtProjectContainer, this.altimateRequest = altimateRequest, 
     this.telemetry = telemetry, this.emitterService = emitterService, this.dbtTerminal = dbtTerminal, 
     this.queryManifestService = queryManifestService, this.usersService = usersService, 
     this.viewPath = "/dbt-docs", this.panelDescription = "Dbt docs view";
     const t = this;
     this._disposables.push(emitterService.eventEmitter.event((d => t.onEvent(d))));
    }
    onWebviewReady() {
     var _a;
     super.onWebviewReady(), this._webview && this.sendResponseToWebview({
      command: "dbtDocsShareDetails",
      args: {
       shareId: this._shareId,
       conversationGroupId: this._conversationGroupId,
       userId: null === (_a = this.usersService.user) || void 0 === _a ? void 0 : _a.id
      }
     });
    }
    onEvent({command, payload}) {
     const _super = Object.create(null, {
      onEvent: {
       get: () => super.onEvent
      }
     });
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      if ("dbtdocsview:render" === command) {
       this.dbtTerminal.debug("dbtdocsview:render", "rendering dbt docs view", payload), 
       this._shareId = payload.shareId, this._conversationGroupId = payload.conversationGroupId, 
       this._panel && this._panel.dispose();
       const webviewPanel = vscode_1.window.createWebviewPanel(DbtDocsView_1.viewType, "Dbt docs", {
        viewColumn: vscode_1.ViewColumn.Active
       }, {
        enableScripts: !0,
        retainContextWhenHidden: !0
       });
       this._panel = webviewPanel, this.renderWebview(webviewPanel);
      } else _super.onEvent.call(this, {
       command,
       payload
      });
     }));
    }
    renderWebviewView() {
     this._webview && (this._webview.onDidReceiveMessage(this.handleCommand, this, []), 
     this._webview.html = this.getHtml(this._webview, this.dbtProjectContainer.extensionUri));
    }
    renderWebview(webview) {
     this._webview = webview.webview, this.renderWebviewView();
    }
   };
   DbtDocsView.viewType = "dbtPowerUser.DbtDocs", DbtDocsView = DbtDocsView_1 = tslib_1.__decorate([ (0, 
   utils_1.provideSingleton)(DbtDocsView_1), tslib_1.__metadata("design:paramtypes", [ dbtProjectContainer_1.DBTProjectContainer, altimate_1.AltimateRequest, telemetry_1.TelemetryService, sharedStateService_1.SharedStateService, dbtTerminal_1.DBTTerminal, queryManifestService_1.QueryManifestService, usersService_1.UsersService ]) ], DbtDocsView), 
   exports.DbtDocsView = DbtDocsView;
  },
  56183: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var AltimateWebviewProvider_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.AltimateWebviewProvider = void 0;
   const tslib_1 = __webpack_require__(31635), vscode_1 = __webpack_require__(54980), utils_1 = __webpack_require__(86185), dbtProjectContainer_1 = __webpack_require__(82018), telemetry_1 = __webpack_require__(22644), path = __webpack_require__(16928), altimate_1 = __webpack_require__(91741), sharedStateService_1 = __webpack_require__(37712), dbtTerminal_1 = __webpack_require__(83683), queryManifestService_1 = __webpack_require__(59269), python_bridge_1 = __webpack_require__(63283), usersService_1 = __webpack_require__(8502);
   let AltimateWebviewProvider = AltimateWebviewProvider_1 = class {
    constructor(dbtProjectContainer, altimateRequest, telemetry, emitterService, dbtTerminal, queryManifestService, usersService) {
     this.dbtProjectContainer = dbtProjectContainer, this.altimateRequest = altimateRequest, 
     this.telemetry = telemetry, this.emitterService = emitterService, this.dbtTerminal = dbtTerminal, 
     this.queryManifestService = queryManifestService, this.usersService = usersService, 
     this.viewType = "dbtPowerUser.Default", this.viewPath = "/", this.panelDescription = "Altimate default webview", 
     this._panel = void 0, this._webview = void 0, this._disposables = [], this.eventMap = new Map, 
     this.isWebviewReady = !1, this._disposables.push(dbtProjectContainer.onManifestChanged((event => this.onManifestCacheChanged(event))));
     const t = this;
     this._disposables.push(emitterService.eventEmitter.event((d => t.onEvent(d))));
    }
    isWebviewView(panel) {
     return void 0 !== panel.show;
    }
    sendResponseToWebview(_a) {
     var _b, _c, {command, data, error, syncRequestId} = _a, rest = tslib_1.__rest(_a, [ "command", "data", "error", "syncRequestId" ]);
     null === (_c = null === (_b = this._panel) || void 0 === _b ? void 0 : _b.webview) || void 0 === _c || _c.postMessage(Object.assign({
      command,
      args: {
       syncRequestId,
       body: data,
       status: !error,
       error
      }
     }, rest));
    }
    handleSyncRequestFromWebview(syncRequestId, callback, command, showErrorNotification) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      try {
       const response = yield callback();
       this.sendResponseToWebview({
        command: "response",
        syncRequestId,
        data: response
       });
      } catch (error) {
       const message = error instanceof python_bridge_1.PythonException ? error.exception.message : error.message;
       error instanceof altimate_1.UserInputError ? this.dbtTerminal.debug(command, message, error) : this.dbtTerminal.error(command, message, error), 
       showErrorNotification && vscode_1.window.showErrorMessage((0, utils_1.extendErrorWithSupportLinks)(message)), 
       this.sendResponseToWebview({
        command: "response",
        syncRequestId,
        error: message
       });
      }
     }));
    }
    onManifestCacheChanged(event) {
     var _a, _b;
     null === (_a = event.added) || void 0 === _a || _a.forEach((added => {
      this.eventMap.set(added.project.projectRoot.fsPath, added);
     })), null === (_b = event.removed) || void 0 === _b || _b.forEach((removed => {
      this.eventMap.delete(removed.projectRoot.fsPath);
     }));
    }
    onEvent({command, payload}) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      if ("stream:chunk" === command) this.sendResponseToWebview({
       command: "response",
       syncRequestId: payload.syncRequestId,
       data: payload.body
      });
     }));
    }
    renderWebviewView(webview) {
     this._webview = webview, this._panel.webview.onDidReceiveMessage(this.handleCommand, this, []), 
     webview.html = this.getHtml(webview, this.dbtProjectContainer.extensionUri);
    }
    isUpdateConfigProps(data) {
     return void 0 !== data.key;
    }
    onWebviewReady() {
     this.isWebviewReady = !0;
    }
    handleWarningMessage(params, syncRequestId) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const {infoMessage, items} = params, result = yield vscode_1.window.showWarningMessage(infoMessage, ...items);
      syncRequestId && this.sendResponseToWebview({
       command: "response",
       data: result,
       syncRequestId
      });
     }));
    }
    handleCommand(message) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const {command, syncRequestId} = message, params = tslib_1.__rest(message, [ "command", "syncRequestId" ]);
      try {
       switch (command) {
       case "configEnabled":
        this.handleSyncRequestFromWebview(syncRequestId, (() => vscode_1.workspace.getConfiguration(params.section).get(params.config)), command, !0);
        break;

       case "deleteNotebook":
        this.handleSyncRequestFromWebview(syncRequestId, (() => this.altimateRequest.deleteNotebook(params.notebookId)), command, !0);
        break;

       case "updateNotebook":
        this.handleSyncRequestFromWebview(syncRequestId, (() => tslib_1.__awaiter(this, void 0, void 0, (function*() {
         const {notebookId, name, data} = params;
         return yield this.altimateRequest.updateNotebook(notebookId, {
          name,
          data
         });
        }))), command, !0);
        break;

       case "openNewNotebook":
        vscode_1.commands.executeCommand("dbtPowerUser.createDatapilotNotebook", params);
        break;

       case "setToWorkspaceState":
        this.dbtProjectContainer.setToWorkspaceState(params.key, params.value);
        break;

       case "openProblemsTab":
        vscode_1.commands.executeCommand("workbench.action.problems.focus");
        break;

       case "dbtdocsview:render":
        this.emitterService.fire({
         command: "dbtdocsview:render",
         payload: params
        });
        break;

       case "getUsers":
        this.handleSyncRequestFromWebview(syncRequestId, (() => this.usersService.users), command, !0);
        break;

       case "getCurrentUser":
        this.handleSyncRequestFromWebview(syncRequestId, (() => this.usersService.user), command, !0);
        break;

       case "fetch":
        this.handleSyncRequestFromWebview(syncRequestId, (() => this.altimateRequest.fetch(params.endpoint, params.fetchArgs)), command, "auth/tenant-info" !== params.endpoint);
        break;

       case "getProjectAdapterType":
        this.handleSyncRequestFromWebview(syncRequestId, (() => {
         var _a;
         return null === (_a = this.queryManifestService.getProject()) || void 0 === _a ? void 0 : _a.getAdapterType();
        }), command);
        break;

       case "openFile":
        vscode_1.workspace.openTextDocument(params.path).then((doc => {
         vscode_1.window.showTextDocument(doc);
        }));
        break;

       case "webview:ready":
        this.onWebviewReady();
        break;

       case "openURL":
        if (!params.url) return;
        vscode_1.env.openExternal(vscode_1.Uri.parse(params.url));
        break;

       case "datapilot:toggle":
        params.open && this.emitterService.eventEmitter.fire({
         command: "datapilot:toggle",
         payload: params
        });
        break;

       case "datapilot:message":
        this.emitterService.eventEmitter.fire({
         command: "datapilot:message",
         payload: message
        });
        break;

       case "validateCredentials":
        const isValid = yield this.altimateRequest.handlePreviewFeatures();
        this.sendResponseToWebview({
         command: "response",
         syncRequestId,
         data: {
          isValid
         }
        });
        break;

       case "sendTelemetryEvent":
        this.telemetry.sendTelemetryEvent(params.eventName, params.properties, params.measurements);
        break;

       case "sendTelemetryError":
        this.telemetry.sendTelemetryError(params.eventName, params.error, params.properties);
        break;

       case "setContext":
        this.dbtProjectContainer.setToGlobalState(params.key, params.value);
        break;

       case "getFromContext":
        this.sendResponseToWebview({
         command: "response",
         data: this.dbtProjectContainer.getFromGlobalState(params.key),
         syncRequestId
        });
        break;

       case "updateConfig":
        if (!this.isUpdateConfigProps(params)) return;
        this.dbtTerminal.debug("altimateWebviewProvider:handleCommand", "Updating config", params);
        const shouldUpdate = !params.isPreviewFeature || this.altimateRequest.handlePreviewFeatures();
        shouldUpdate && (yield vscode_1.workspace.getConfiguration("dbt").update(params.key, params.value)), 
        syncRequestId && this.sendResponseToWebview({
         command: "response",
         syncRequestId,
         data: {
          updated: shouldUpdate
         }
        });
        break;

       case "showInformationMessage":
        const {infoMessage, items} = params, result = yield vscode_1.window.showInformationMessage(infoMessage, ...items);
        syncRequestId && this.sendResponseToWebview({
         command: "response",
         data: result,
         syncRequestId
        });
        break;

       case "showErrorMessage":
        const args = params;
        vscode_1.window.showErrorMessage(args.infoMessage, ...args.items || []);
        break;

       case "showWarningMessage":
        this.handleWarningMessage(params, syncRequestId);
        break;

       case "findPackageVersion":
        this.handleSyncRequestFromWebview(syncRequestId, (() => {
         var _a;
         try {
          return null === (_a = this.queryManifestService.getProject()) || void 0 === _a ? void 0 : _a.findPackageVersion(params.packageName);
         } catch (err) {
          this.dbtTerminal.debug("findPackageVersion", err.message);
         }
        }), command, !1);
        break;

       case "queryResultTab:render":
        this.emitterService.fire({
         command: "queryResultTab:render",
         payload: params
        });
       }
      } catch (err) {
       this.dbtTerminal.error("altimateWebviewProvider:handleCommand", "error while handling command", err);
      }
     }));
    }
    checkIfWebviewReady() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      return new Promise((resolve => {
       const interval = setInterval((() => {
        this.isWebviewReady && (clearInterval(interval), resolve());
       }), 500);
      }));
     }));
    }
    resolveWebviewView(panel, context, _token) {
     this._panel = panel, this.setupWebviewOptions(context), this.renderWebviewView(this._panel.webview);
    }
    setupWebviewOptions(context) {
     this._panel && "description" in this._panel && (this._panel.description = this.panelDescription), 
     this._panel.webview.options = {
      enableScripts: !0,
      localResourceRoots: [ vscode_1.Uri.file(path.join(this.dbtProjectContainer.extensionUri.fsPath, "webview_panels", "dist", "assets")) ]
     };
    }
    getHtml(webview, extensionUri) {
     const indexJs = webview.asWebviewUri(vscode_1.Uri.file(path.join(extensionUri.fsPath, "webview_panels", "dist", "assets", "main.js"))), indexCss = webview.asWebviewUri(vscode_1.Uri.file(path.join(extensionUri.fsPath, "webview_panels", "dist", "assets", "main.css"))), SpinnerUrl = webview.asWebviewUri(vscode_1.Uri.file(path.join(extensionUri.fsPath, "webview_panels", "dist", "assets", "spinner.gif"))), LineageGif = webview.asWebviewUri(vscode_1.Uri.file(path.join(extensionUri.fsPath, "webview_panels", "dist", "assets", "lineage.gif"))), codiconsUri = webview.asWebviewUri(vscode_1.Uri.joinPath(extensionUri, "webview_panels", "dist", "assets", "codicons", "codicon.css")), nonce = function() {
      let text = "";
      const possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
      for (let i = 0; i < 32; i++) text += possible.charAt(Math.floor(Math.random() * possible.length));
      return text;
     }();
     return `\n        <!DOCTYPE html>\n          <html lang="en">\n          <head>\n            <meta charset="UTF-8">\n            <meta name="viewport" content="width=device-width, initial-scale=1.0">\n            \x3c!--\n              Use a content security policy to only allow loading images from https or from our extension directory,\n              and only allow scripts that have a specific nonce.\n              Added unsafe-inline for css due to csp issue: https://github.com/JedWatson/react-select/issues/4631\n              --\x3e\n            <meta http-equiv="Content-Security-Policy" content="default-src 'none'; worker-src blob:; font-src ${webview.cspSource}; style-src 'unsafe-inline' ${webview.cspSource}; img-src ${webview.cspSource} https: data:; script-src 'unsafe-eval' 'nonce-${nonce}' https://*.vscode-resource.vscode-cdn.net; connect-src https://*.s3.amazonaws.com">\n            <title>VSCode DBT Power user extension</title>\n            <link rel="stylesheet" type="text/css" href="${indexCss}">\n            <link rel="stylesheet" type="text/css" href="${codiconsUri}">\n          </head>\n      \n          <body class="${this.viewPath.replace(/\//g, "")}">\n            <div id="root"></div>\n            <div id="sidebar"></div>\n            <div id="modal"></div>\n            <script nonce="${nonce}" >\n              window.viewPath = "${this.viewPath}";\n              var spinnerUrl = "${SpinnerUrl}"\n              var lineageGif = "${LineageGif}"\n            <\/script>\n            \n            <script nonce="${nonce}" type="module" src="${indexJs}"><\/script>\n          </body>\n        </html>\n      `;
    }
    dispose() {
     for (;this._disposables.length; ) {
      const x = this._disposables.pop();
      x && x.dispose();
     }
    }
   };
   AltimateWebviewProvider = AltimateWebviewProvider_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(AltimateWebviewProvider_1), tslib_1.__metadata("design:paramtypes", [ dbtProjectContainer_1.DBTProjectContainer, altimate_1.AltimateRequest, telemetry_1.TelemetryService, sharedStateService_1.SharedStateService, dbtTerminal_1.DBTTerminal, queryManifestService_1.QueryManifestService, usersService_1.UsersService ]) ], AltimateWebviewProvider), 
   exports.AltimateWebviewProvider = AltimateWebviewProvider;
  },
  32262: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var DataPilotPanel_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.DataPilotPanel = void 0;
   const tslib_1 = __webpack_require__(31635), vscode_1 = __webpack_require__(54980), utils_1 = __webpack_require__(86185), dbtProjectContainer_1 = __webpack_require__(82018), telemetry_1 = __webpack_require__(22644), altimateWebviewProvider_1 = __webpack_require__(56183), docGenService_1 = __webpack_require__(88642), altimate_1 = __webpack_require__(91741), sharedStateService_1 = __webpack_require__(37712), queryAnalysisService_1 = __webpack_require__(27312), queryManifestService_1 = __webpack_require__(59269), dbtTerminal_1 = __webpack_require__(83683), dbtTestService_1 = __webpack_require__(2188), fileService_1 = __webpack_require__(69968), usersService_1 = __webpack_require__(8502);
   let DataPilotPanel = DataPilotPanel_1 = class extends altimateWebviewProvider_1.AltimateWebviewProvider {
    constructor(dbtProjectContainer, telemetry, altimateRequest, docGenService, emitterService, queryAnalysisService, queryManifestService, dbtTerminal, dbtTestService, fileService, usersService) {
     super(dbtProjectContainer, altimateRequest, telemetry, emitterService, dbtTerminal, queryManifestService, usersService), 
     this.altimateRequest = altimateRequest, this.docGenService = docGenService, this.emitterService = emitterService, 
     this.queryAnalysisService = queryAnalysisService, this.queryManifestService = queryManifestService, 
     this.dbtTerminal = dbtTerminal, this.dbtTestService = dbtTestService, this.fileService = fileService, 
     this.usersService = usersService, this.viewPath = "/datapilot", this.panelDescription = "Datapilot view", 
     this.incomingMessages = [], vscode_1.commands.registerCommand("dbtPowerUser.resetDatapilot", (() => this.sendResponseToWebview({
      command: "datapilot:reset"
     })));
    }
    handleCommand(message) {
     const _super = Object.create(null, {
      handleCommand: {
       get: () => super.handleCommand
      }
     });
     var _a;
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const {command, syncRequestId} = message, params = tslib_1.__rest(message, [ "command", "syncRequestId" ]), queryText = null === (_a = vscode_1.window.activeTextEditor) || void 0 === _a ? void 0 : _a.document.getText();
      switch (command) {
      case "sendFeedback":
       if (!queryText) return;
       this.docGenService.sendFeedback({
        queryText,
        message,
        panel: this._panel,
        syncRequestId
       });
       break;

      case "generateDocsForModel":
       if (!queryText) return;
       this.docGenService.generateDocsForModel({
        queryText,
        documentation: (yield this.docGenService.getDocumentationForCurrentActiveFile()).documentation,
        message,
        panel: this._panel,
        project: this.queryManifestService.getProject(),
        columnIndexCount: void 0,
        isBulkGen: !1
       });
       break;

      case "generateDocsForColumn":
       yield this.docGenService.generateDocsForColumns({
        documentation: (yield this.docGenService.getDocumentationForCurrentActiveFile()).documentation,
        panel: this._panel,
        message,
        project: this.queryManifestService.getProject(),
        isBulkGen: !1
       });
       break;

      case "docgen:insert":
      case "testgen:insert":
       this.emitterService.eventEmitter.fire({
        command,
        payload: params
       });
       break;

      case "querytranslate":
       this.handleSyncRequestFromWebview(syncRequestId, (() => tslib_1.__awaiter(this, void 0, void 0, (function*() {
        return {
         response: yield this.queryAnalysisService.executeQueryTranslate(params)
        };
       }))), command, !0);
       break;

      case "querytranslate:explanation":
       this.handleSyncRequestFromWebview(syncRequestId, (() => tslib_1.__awaiter(this, void 0, void 0, (function*() {
        return {
         response: yield this.queryAnalysisService.executeQueryTranslateExplanation(params, syncRequestId)
        };
       }))), command, !0);
       break;

      case "queryAnalysis:explain":
       this.handleSyncRequestFromWebview(syncRequestId, (() => tslib_1.__awaiter(this, void 0, void 0, (function*() {
        return {
         response: yield this.queryAnalysisService.executeQueryAnalysis(params, altimate_1.QueryAnalysisType.EXPLAIN, syncRequestId)
        };
       }))), command, !0);
       break;

      case "queryAnalysis:modify":
       this.handleSyncRequestFromWebview(syncRequestId, (() => tslib_1.__awaiter(this, void 0, void 0, (function*() {
        return {
         response: yield this.queryAnalysisService.executeQueryAnalysis(params, altimate_1.QueryAnalysisType.MODIFY, syncRequestId)
        };
       }))), command, !0);
       break;

      case "dbttest:create":
       this.handleSyncRequestFromWebview(syncRequestId, (() => tslib_1.__awaiter(this, void 0, void 0, (function*() {
        return {
         response: yield this.dbtTestService.createTest(params, syncRequestId)
        };
       }))), command, !0);
       break;

      case "file:replace-contents":
       if (!params.sql || !params.filePath) return;
       this.dbtTerminal.debug("datapilotpanel:replace_file_contents", "replacing translated sql", params);
       const editor = yield this.fileService.openFileByPath(params.filePath);
       editor.edit((edit => {
        const file = editor.document;
        edit.replace(new vscode_1.Range(file.lineAt(0).range.start, file.lineAt(file.lineCount - 1).range.end), params.sql);
       }));
       break;

      case "queryanalysis:followup":
       this.handleSyncRequestFromWebview(syncRequestId, (() => tslib_1.__awaiter(this, void 0, void 0, (function*() {
        return yield this.queryAnalysisService.getFollowupQuestions(params);
       }))), command, !0);
       break;

      default:
       _super.handleCommand.call(this, message);
      }
     }));
    }
    onEvent({command, payload}) {
     const _super = Object.create(null, {
      onEvent: {
       get: () => super.onEvent
      }
     });
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      switch (command) {
      case "datapilot:toggle":
       yield vscode_1.commands.executeCommand("dbtPowerUser.datapilot-webview.focus");
       break;

      case "datapilot:message":
       if (yield vscode_1.commands.executeCommand("dbtPowerUser.datapilot-webview.focus"), 
       !this.isWebviewReady) return void this.incomingMessages.push(payload);
       this.postToWebview(payload);
       break;

      case "dbtPowerUser.summarizeQuery":
       this.handleDatapilotEvent(altimate_1.QueryAnalysisType.EXPLAIN, payload);
       break;

      case "dbtPowerUser.changeQuery":
       this.handleDatapilotEvent(altimate_1.QueryAnalysisType.MODIFY, payload);
       break;

      case "dbtPowerUser.translateQuery":
       this.handleDatapilotEvent(altimate_1.QueryAnalysisType.TRANSLATE, payload);
       break;

      case "dbtPowerUser.openDatapilotWithQuery":
       this.handleDatapilotEvent(null, payload);
       break;

      case "dbtPowerUser.openHelpInDatapilot":
       this.sendResponseToWebview({
        command: "datapilot:showHelp"
       });
       break;

      default:
       _super.onEvent.call(this, {
        command,
        payload
       });
      }
     }));
    }
    onWebviewReady() {
     if (super.onWebviewReady(), this._panel) for (;this.incomingMessages.length; ) this.postToWebview(this.incomingMessages.pop());
    }
    postToWebview(message) {
     var _a;
     if (this._panel && message) {
      const command = "command" in message ? message.command : "datapilot:message";
      this.sendResponseToWebview({
       command,
       args: Object.assign({
        filePath: null === (_a = vscode_1.window.activeTextEditor) || void 0 === _a ? void 0 : _a.document.uri.fsPath
       }, message)
      });
     }
    }
    handleDatapilotEvent(analysisType, data) {
     this.sendResponseToWebview({
      command: "datapilot:reset",
      args: {}
     });
     const queryData = this.queryAnalysisService.getSelectedQuery();
     queryData && this.emitterService.fire({
      command: "datapilot:message",
      payload: {
       command: "datapilot:message",
       query: (null == data ? void 0 : data.query) || queryData.query,
       fileName: queryData.fileName,
       requestType: "QUERY_ANALYSIS",
       state: "UNINITIALIZED",
       analysisType,
       meta: null == data ? void 0 : data.meta
      }
     });
    }
   };
   DataPilotPanel.viewType = "dbtPowerUser.datapilot-webview", DataPilotPanel = DataPilotPanel_1 = tslib_1.__decorate([ (0, 
   utils_1.provideSingleton)(DataPilotPanel_1), tslib_1.__metadata("design:paramtypes", [ dbtProjectContainer_1.DBTProjectContainer, telemetry_1.TelemetryService, altimate_1.AltimateRequest, docGenService_1.DocGenService, sharedStateService_1.SharedStateService, queryAnalysisService_1.QueryAnalysisService, queryManifestService_1.QueryManifestService, dbtTerminal_1.DBTTerminal, dbtTestService_1.DbtTestService, fileService_1.FileService, usersService_1.UsersService ]) ], DataPilotPanel), 
   exports.DataPilotPanel = DataPilotPanel;
  },
  17215: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var DocsEditViewPanel_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.DocsEditViewPanel = exports.Source = void 0;
   const tslib_1 = __webpack_require__(31635), fs_1 = __webpack_require__(79896), vscode_1 = __webpack_require__(54980), dbtProjectContainer_1 = __webpack_require__(82018), utils_1 = __webpack_require__(86185), path = __webpack_require__(16928), python_bridge_1 = __webpack_require__(63283), telemetry_1 = __webpack_require__(22644), altimate_1 = __webpack_require__(91741), yaml_1 = __webpack_require__(91198), newDocsGenPanel_1 = __webpack_require__(21970), docGenService_1 = __webpack_require__(88642), dbtTerminal_1 = __webpack_require__(83683), dbtTestService_1 = __webpack_require__(2188), semver_1 = __webpack_require__(99589), events_1 = __webpack_require__(91723), dbtLineageService_1 = __webpack_require__(45451);
   !function(Source) {
    Source.YAML = "YAML", Source.DATABASE = "DATABASE";
   }(exports.Source || (exports.Source = {}));
   let DocsEditViewPanel = DocsEditViewPanel_1 = class {
    constructor(dbtProjectContainer, altimateRequest, telemetry, newDocsPanel, docGenService, dbtTestService, terminal, dbtLineageService) {
     this.dbtProjectContainer = dbtProjectContainer, this.altimateRequest = altimateRequest, 
     this.telemetry = telemetry, this.newDocsPanel = newDocsPanel, this.docGenService = docGenService, 
     this.dbtTestService = dbtTestService, this.terminal = terminal, this.dbtLineageService = dbtLineageService, 
     this._panel = void 0, this.loadedFromManifest = !1, this.eventMap = new Map, this._disposables = [], 
     this.init = () => tslib_1.__awaiter(this, void 0, void 0, (function*() {
      yield this.resolveWebviewView(this.panel, this.context, this.token);
     })), this.modifyColumnNames = (columns, existingColumnNames) => columns.map((c => {
      const existingColumn = existingColumnNames.find((name => name.toLowerCase() === c.name.toLowerCase()));
      return existingColumn ? Object.assign(Object.assign({}, c), {
       name: existingColumn
      }) : Object.assign(Object.assign({}, c), {
       name: c.name
      });
     })), dbtProjectContainer.onManifestChanged((event => this.onManifestCacheChanged(event))), 
     vscode_1.window.onDidChangeActiveColorTheme((e => tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this._panel && this.updateGraphStyle();
     }))), null, this._disposables), vscode_1.window.onDidChangeActiveTextEditor((event => tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.documentation = void 0, void 0 !== event && this._panel && (this.transmitData(), 
      this.updateGraphStyle());
     }))));
    }
    getProject() {
     if (!vscode_1.window.activeTextEditor) return;
     const currentFilePath = vscode_1.window.activeTextEditor.document.uri;
     return this.dbtProjectContainer.findDBTProject(currentFilePath);
    }
    transmitError() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this._panel && (yield this._panel.webview.postMessage({
       command: "renderError"
      }));
     }));
    }
    transmitData() {
     var _a;
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const {documentation, message} = yield this.docGenService.getDocumentationForCurrentActiveFile();
      this.documentation = documentation, this._panel && (yield this._panel.webview.postMessage({
       command: "renderDocumentation",
       docs: this.documentation,
       missingDocumentationMessage: message,
       tests: yield this.dbtTestService.getTestsForCurrentModel(),
       project: null === (_a = this.getProject()) || void 0 === _a ? void 0 : _a.getProjectName(),
       collaborationEnabled: vscode_1.workspace.getConfiguration("dbt").get("enableCollaboration", !1)
      }));
     }));
    }
    transmitColumns(columns) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this._panel && (yield this._panel.webview.postMessage({
       command: "renderColumnsFromMetadataFetch",
       columns
      }));
     }));
    }
    transmitConfig() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this._panel && (yield this._panel.webview.postMessage({
       command: "updateConfig",
       config: {
        aiEnabled: this.altimateRequest.enabled()
       }
      }));
     }));
    }
    updateGraphStyle() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const theme = [ vscode_1.ColorThemeKind.Light, vscode_1.ColorThemeKind.HighContrastLight ].includes(vscode_1.window.activeColorTheme.kind) ? "light" : "dark";
      this._panel && (yield this._panel.webview.postMessage({
       command: "setStylesByTheme",
       theme
      }));
     }));
    }
    resolveWebviewView(panel, context, token) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.panel = panel, this.context = context, this.token = token, this._panel = panel, 
      this.newDocsPanel.resolveWebview(panel, context, token), this.setupWebviewHooks(context), 
      this.transmitConfig(), this.transmitData();
     }));
    }
    resolveWebview(panel, context, _token) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this._panel = panel, this.setupWebviewOptions(context), this.renderWebviewView(context), 
      this.updateGraphStyle();
     }));
    }
    renderWebviewView(context) {
     const webview = this._panel.webview;
     webview.html = function(webview, extensionUri) {
      const indexPath = getUri(webview, extensionUri, [ "docs_edit_panel", "index.html" ]), resourceDir = getUri(webview, extensionUri, [ "docs_edit_panel" ]), theme = [ vscode_1.ColorThemeKind.Light, vscode_1.ColorThemeKind.HighContrastLight ].includes(vscode_1.window.activeColorTheme.kind) ? "light" : "dark";
      return (0, fs_1.readFileSync)(indexPath.fsPath).toString().replace(/__ROOT__/g, resourceDir.toString()).replace(/__THEME__/g, theme).replace(/__NONCE__/g, function() {
       let text = "";
       const possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
       for (let i = 0; i < 32; i++) text += possible.charAt(Math.floor(Math.random() * possible.length));
       return text;
      }()).replace(/__CSPSOURCE__/g, webview.cspSource);
     }(webview, this.dbtProjectContainer.extensionUri);
    }
    setupWebviewOptions(context) {
     this._panel.title = "", this._panel.description = "Edit model documentation", this._panel.webview.options = {
      enableScripts: !0
     };
    }
    getTestDataByModel(message, modelName) {
     const tests = message.updatedTests;
     if (!(null == tests ? void 0 : tests.length)) return void this.terminal.debug("docsEditViewPanel:getTestDataByModel", "No test data passed");
     const finalTests = tests.filter((test => {
      var _a, _b;
      const modelNameInTest = null === (_a = test.test_metadata) || void 0 === _a ? void 0 : _a.kwargs.model;
      return !(test.column_name || !modelNameInTest) && (modelNameInTest === modelName || (null === (_b = modelNameInTest.match(/'([^']+)'/)) || void 0 === _b ? void 0 : _b[1]) === modelName);
     })).map((test => {
      if (!(null == test ? void 0 : test.test_metadata)) return null;
      const {name, namespace, kwargs} = test.test_metadata, fullName = namespace ? `${namespace}.${name}` : name;
      return this.getTestMetadataKwArgs(kwargs, fullName) || fullName;
     })).filter((t => Boolean(t)));
     return finalTests.length ? finalTests : void 0;
    }
    getTestMetadataKwArgs(kwargs, fullName) {
     var _a;
     if (kwargs) {
      const rest = Object.entries(kwargs).reduce(((acc, [key, value]) => ("column_name" === key || "model" === key || (acc[key] = value), 
      acc)), {});
      if (null === (_a = Object.keys(rest)) || void 0 === _a ? void 0 : _a.length) return {
       [fullName]: rest
      };
     }
    }
    getTestDataByColumn(message, columnNameFromWebview, project, existingColumn) {
     const tests = message.updatedTests;
     if (!(null == tests ? void 0 : tests.length)) return void this.terminal.debug("docsEditViewPanel:getTestDataByColumn", "No test data passed");
     const columnTests = tests.filter((test => (0, utils_1.isColumnNameEqual)(test.column_name, columnNameFromWebview)));
     if (!columnTests.length) return;
     const data = columnTests.map((test => {
      if (!test.test_metadata) return null;
      const {name, namespace, kwargs} = test.test_metadata, testFullName = namespace ? `${namespace}.${name}` : name, columnTestConfigFromYml = (0, 
      utils_1.getColumnTestConfigFromYml)(null == existingColumn ? void 0 : existingColumn.tests, kwargs, testFullName);
      if ((0, utils_1.isRelationship)(kwargs)) {
       const {to, field} = kwargs;
       return {
        relationships: Object.assign(Object.assign({}, columnTestConfigFromYml), {
         field,
         to
        })
       };
      }
      if ((0, utils_1.isAcceptedValues)(kwargs)) return {
       accepted_values: Object.assign(Object.assign({}, columnTestConfigFromYml), {
        values: kwargs.values
       })
      };
      if (columnTestConfigFromYml) return columnTestConfigFromYml;
      return this.getTestMetadataKwArgs(kwargs, testFullName) || testFullName;
     }));
     if (this.terminal.debug("docsEditViewPanel:getTestDataByColumn", "test data", !1, data, columnNameFromWebview), 
     !data.length) return;
     const dbtVersion = project.getDBTVersion();
     return dbtVersion && (0, semver_1.gte)(dbtVersion.join("."), "1.8.0") && (null == existingColumn ? void 0 : existingColumn.name) === columnNameFromWebview && void 0 === (null == existingColumn ? void 0 : existingColumn.tests) ? {
      data_tests: data
     } : {
      tests: data
     };
    }
    convertColumnNamesByCaseConfig(columns, modelName, project) {
     var _a, _b, _c;
     if (!columns.length) return [];
     const patchPath = null === (_a = this.documentation) || void 0 === _a ? void 0 : _a.patchPath;
     if (!patchPath) return columns;
     const docFile = (0, fs_1.readFileSync)(path.join(project.projectRoot.fsPath, patchPath.split("://")[1])).toString("utf8"), model = null === (_b = ((0, 
     yaml_1.parse)(docFile, {
      strict: !1,
      uniqueKeys: !1,
      maxAliasCount: -1
     }) || {}).models) || void 0 === _b ? void 0 : _b.find((model => model.name === modelName));
     if (!model) return columns;
     const existingColumnNames = (null === (_c = model.columns) || void 0 === _c ? void 0 : _c.map((c => c.name))) || [];
     return this.modifyColumnNames(columns, existingColumnNames);
    }
    setOrDeleteInParsedDocument(doc, key, value) {
     value ? doc.set(key, value) : doc.delete(key);
    }
    findEntityInParsedDoc(models, predicate) {
     return models && models.items && models.items.find((item => {
      if (item instanceof yaml_1.YAMLMap) {
       const name = item.get("name");
       return name && predicate(name);
      }
      return !1;
     })) || null;
    }
    setupWebviewHooks(context) {
     this.onMessageDisposable && (this.onMessageDisposable.dispose(), this.onMessageDisposable = void 0), 
     this.onMessageDisposable = this._panel.webview.onDidReceiveMessage((message => tslib_1.__awaiter(this, void 0, void 0, (function*() {
      if (this.terminal.debug("docsEditPanel:setupWebviewHooks", "onDidReceiveMessage", message), 
      void 0 === vscode_1.window.activeTextEditor || void 0 === this.eventMap) return;
      const queryText = vscode_1.window.activeTextEditor.document.getText(), currentFilePath = vscode_1.window.activeTextEditor.document.uri, project = this.getProject();
      if (void 0 === project) return;
      const {command, syncRequestId} = message, params = tslib_1.__rest(message, [ "command", "syncRequestId" ]);
      switch (command) {
      case "fetchMetadataFromDatabase":
       this.telemetry.startTelemetryEvent(events_1.TelemetryEvents["DocumentationEditor/SyncWithDBClick"]), 
       vscode_1.window.withProgress({
        title: "Syncing columns with metadata from database",
        location: vscode_1.ProgressLocation.Notification,
        cancellable: !1
       }, (() => tslib_1.__awaiter(this, void 0, void 0, (function*() {
        const modelName = path.basename(currentFilePath.fsPath, ".sql");
        try {
         const columnsInRelation = yield project.getColumnsOfModel(modelName), columns = this.convertColumnNamesByCaseConfig(columnsInRelation.map((column => ({
          name: column.column,
          type: column.dtype.toLowerCase()
         }))), modelName, project);
         this.transmitColumns(columns), syncRequestId && this._panel.webview.postMessage({
          command: "response",
          args: {
           syncRequestId,
           body: {
            columns
           },
           status: !0
          }
         }), this.telemetry.endTelemetryEvent(events_1.TelemetryEvents["DocumentationEditor/SyncWithDBClick"]);
        } catch (exc) {
         if (this.transmitError(), this.telemetry.endTelemetryEvent(events_1.TelemetryEvents["DocumentationEditor/SyncWithDBClick"], exc), 
         exc instanceof python_bridge_1.PythonException) return vscode_1.window.showErrorMessage(`An error occured while fetching metadata for ${modelName} from the database: ` + exc.exception.message), 
         void this.terminal.error("docsEditPanelLoadPythonError", `An error occured while fetching metadata for ${modelName} from the database`, exc, !1);
         vscode_1.window.showErrorMessage(`An error occured while fetching metadata for ${modelName} from the database: ` + exc), 
         this.terminal.error("docsEditPanelLoadError", `An error occured while fetching metadata for ${modelName} from the database`, exc, !1), 
         syncRequestId && this._panel.webview.postMessage({
          command: "response",
          args: {
           syncRequestId,
           body: {},
           status: !1
          }
         });
        }
       }))));
       break;

      case "generateDocsForModel":
       this.docGenService.generateDocsForModel({
        queryText,
        documentation: this.documentation,
        message,
        panel: this._panel,
        project,
        columnIndexCount: void 0,
        isBulkGen: !1
       });
       break;

      case "generateDocsForColumn":
       yield this.docGenService.generateDocsForColumns({
        documentation: this.documentation,
        panel: this._panel,
        message,
        project,
        isBulkGen: message.isBulkGen
       });
       break;

      case "sendFeedback":
       this.docGenService.sendFeedback({
        queryText,
        message,
        panel: this._panel
       });
       break;

      case "columnLineageBase":
       this.dbtLineageService.handleColumnLineage(params, (() => {
        var _a;
        null === (_a = this._panel) || void 0 === _a || _a.webview.postMessage({
         command: "columnLineage",
         args: {
          event: dbtLineageService_1.CllEvents.CANCEL
         }
        });
       }));
       break;

      case "getDownstreamColumns":
       {
        const targets = params.targets, testsResult = yield Promise.all(targets.map((t => tslib_1.__awaiter(this, void 0, void 0, (function*() {
         if (!t[0].startsWith("model")) return;
         const splits = t[0].split("."), modelName = splits[splits.length - 1];
         return yield this.dbtTestService.getTestsForModel(modelName);
        }))))), tests = {};
        targets.forEach(((t, i) => {
         tests[t[0]] = testsResult[i];
        }));
        const _tables = targets.map((t => {
         var _a;
         return null === (_a = this.dbtLineageService.getUpstreamTables({
          table: t[0]
         })) || void 0 === _a ? void 0 : _a.tables;
        })).filter((t => Boolean(t))).flat(), tables = _tables.map((t => null == t ? void 0 : t.table));
        if (0 === tables.length) return void this.handleSyncRequestFromWebview(syncRequestId, (() => ({
         column_lineage: [],
         tables: [],
         tests
        })), command);
        const selectedColumn = {
         table: params.model,
         name: params.column
        }, currAnd1HopTables = [ ...tables, ...targets.map((t => t[0])) ], columns = yield this.dbtLineageService.getConnectedColumns({
         targets,
         currAnd1HopTables,
         selectedColumn,
         upstreamExpansion: !0,
         showIndirectEdges: !1,
         eventType: "documentation_propagation"
        });
        this.handleSyncRequestFromWebview(syncRequestId, (() => Object.assign(Object.assign({}, columns), {
         tables: _tables,
         tests
        })), command);
        break;
       }

      case "saveDocumentation":
       this.telemetry.sendTelemetryEvent(events_1.TelemetryEvents["DocumentationEditor/SaveClick"]), 
       vscode_1.window.withProgress({
        title: "Saving documentation",
        location: vscode_1.ProgressLocation.Notification,
        cancellable: !1
       }, (() => this.saveDocumentation(message, syncRequestId)));
       break;

      case "saveDocumentationBulk":
       this.telemetry.sendTelemetryEvent(events_1.TelemetryEvents["DocumentationEditor/SaveClick"]), 
       vscode_1.window.withProgress({
        title: "Saving documentation",
        location: vscode_1.ProgressLocation.Notification,
        cancellable: !1
       }, (() => tslib_1.__awaiter(this, void 0, void 0, (function*() {
        for (const item of message.models) yield this.saveDocumentation(item, syncRequestId);
       }))));
      }
     }))), null, this._disposables);
    }
    saveDocumentation(message, syncRequestId) {
     var _a, _b;
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      let patchPath = message.patchPath;
      try {
       const projectByFilePath = this.dbtProjectContainer.findDBTProject(vscode_1.Uri.file(message.filePath));
       if (!projectByFilePath) throw new Error("Unable to find project for saving documentation");
       const project = this.getProject();
       if (void 0 === project) return;
       if (patchPath) patchPath = path.join(projectByFilePath.projectRoot.fsPath, patchPath.split("://")[1]); else switch (message.dialogType) {
       case "Existing file":
        const openDialog = yield vscode_1.window.showOpenDialog({
         filters: {
          Yaml: [ "yml" ]
         },
         canSelectMany: !1
        });
        if (void 0 === openDialog || 0 === openDialog.length) return;
        patchPath = openDialog[0].fsPath;
        break;

       case "New file":
        const saveDialog = yield vscode_1.window.showSaveDialog({
         filters: {
          Yaml: [ "yml" ]
         }
        });
        if (!saveDialog) return;
        this.telemetry.sendTelemetryEvent(events_1.TelemetryEvents["DocumentationEditor/SaveNewFilePathSelect"]), 
        patchPath = saveDialog.fsPath;
       }
       (0, fs_1.existsSync)(patchPath) || (0, fs_1.writeFileSync)(patchPath, "");
       const docFile = (0, fs_1.readFileSync)(patchPath).toString("utf8"), parsedDocFile = (0, 
       yaml_1.parseDocument)(docFile, {
        strict: !1,
        uniqueKeys: !1
       }), existingModels = parsedDocFile.get("models"), model = this.findEntityInParsedDoc(existingModels, (name => name === message.name));
       if (model) {
        this.setOrDeleteInParsedDocument(model, "description", null === (_b = message.description) || void 0 === _b ? void 0 : _b.trim());
        const modelTests = this.getTestDataByModel(message, model.get("name"));
        this.setOrDeleteInParsedDocument(model, "tests", modelTests), message.columns.forEach((column => {
         var _a, _b, _c, _d;
         const existingColumn = this.findEntityInParsedDoc(model.get("columns"), (name => (0, 
         utils_1.isColumnNameEqual)(name, column.name)));
         if (existingColumn) {
          const _e = existingColumn.toJSON(), {tests, data_tests} = _e, rest = tslib_1.__rest(_e, [ "tests", "data_tests" ]);
          this.setOrDeleteInParsedDocument(existingColumn, "description", null === (_a = column.description) || void 0 === _a ? void 0 : _a.trim()), 
          this.setOrDeleteInParsedDocument(existingColumn, "data_type", null === (_b = rest.data_type || column.type) || void 0 === _b ? void 0 : _b.toLowerCase());
          const allTests = this.getTestDataByColumn(message, column.name, project, existingColumn.toJSON());
          this.setOrDeleteInParsedDocument(existingColumn, "tests", null == allTests ? void 0 : allTests.tests), 
          this.setOrDeleteInParsedDocument(existingColumn, "data_tests", null == allTests ? void 0 : allTests.data_tests);
         } else {
          const name = (0, utils_1.getColumnNameByCase)(column.name, projectByFilePath.getAdapterType());
          model.addIn([ "columns" ], Object.assign(Object.assign({
           name,
           description: (null === (_c = column.description) || void 0 === _c ? void 0 : _c.trim()) || void 0,
           data_type: null === (_d = column.type) || void 0 === _d ? void 0 : _d.toLowerCase()
          }, this.getTestDataByColumn(message, column.name, project)), (0, utils_1.isQuotedIdentifier)(column.name, projectByFilePath.getAdapterType()) ? {
           quote: !0
          } : void 0));
         }
        }));
       } else {
        const newModelData = {
         name: message.name,
         description: (null === (_a = message.description) || void 0 === _a ? void 0 : _a.trim()) || void 0,
         columns: message.columns.length ? message.columns.map((column => {
          var _a, _b;
          const name = (0, utils_1.getColumnNameByCase)(column.name, projectByFilePath.getAdapterType());
          return Object.assign(Object.assign({
           name,
           description: (null === (_a = column.description) || void 0 === _a ? void 0 : _a.trim()) || void 0,
           data_type: null === (_b = column.type) || void 0 === _b ? void 0 : _b.toLowerCase()
          }, this.getTestDataByColumn(message, column.name, project, {
           name: column.name
          })), (0, utils_1.isQuotedIdentifier)(column.name, projectByFilePath.getAdapterType()) ? {
           quote: !0
          } : void 0);
         })) : void 0
        };
        (null == existingModels ? void 0 : existingModels.items.length) ? parsedDocFile.addIn([ "models" ], newModelData) : parsedDocFile.set("models", [ newModelData ]);
       }
       this.loadedFromManifest = !1, (0, fs_1.writeFileSync)(patchPath, (0, yaml_1.stringify)(parsedDocFile, {
        lineWidth: 0
       })), this.documentation = (yield this.docGenService.getDocumentationForCurrentActiveFile()).documentation;
       const tests = yield this.dbtTestService.getTestsForCurrentModel();
       syncRequestId && this._panel.webview.postMessage({
        command: "response",
        args: {
         syncRequestId,
         body: {
          saved: !0,
          tests
         },
         status: !0
        }
       });
      } catch (error) {
       this.transmitError(), this.telemetry.sendTelemetryError(events_1.TelemetryEvents["DocumentationEditor/SaveError"], error), 
       vscode_1.window.showErrorMessage(`Could not save documentation to ${patchPath}: ${error}`), 
       this.terminal.error("saveDocumentationError", `Could not save documentation to ${patchPath}`, error, !1), 
       syncRequestId && this._panel.webview.postMessage({
        command: "response",
        args: {
         syncRequestId,
         body: {
          saved: !1
         },
         status: !0
        }
       });
      }
     }));
    }
    handleSyncRequestFromWebview(syncRequestId, callback, command, showErrorNotification) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      try {
       const response = yield callback();
       this.sendResponseToWebview({
        command: "response",
        syncRequestId,
        data: response
       });
      } catch (error) {
       const message = error instanceof python_bridge_1.PythonException ? error.exception.message : error.message;
       error instanceof altimate_1.UserInputError ? this.terminal.debug(command, message, error) : this.terminal.error(command, message, error), 
       showErrorNotification && vscode_1.window.showErrorMessage((0, utils_1.extendErrorWithSupportLinks)(message)), 
       this.sendResponseToWebview({
        command: "response",
        syncRequestId,
        error: message
       });
      }
     }));
    }
    sendResponseToWebview(_a) {
     var _b, _c, {command, data, error, syncRequestId} = _a, rest = tslib_1.__rest(_a, [ "command", "data", "error", "syncRequestId" ]);
     null === (_c = null === (_b = this._panel) || void 0 === _b ? void 0 : _b.webview) || void 0 === _c || _c.postMessage(Object.assign({
      command,
      args: {
       syncRequestId,
       body: data,
       status: !error,
       error
      }
     }, rest));
    }
    onManifestCacheChanged(event) {
     var _a, _b;
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      null === (_a = event.added) || void 0 === _a || _a.forEach((added => {
       this.eventMap.set(added.project.projectRoot.fsPath, added);
      })), null === (_b = event.removed) || void 0 === _b || _b.forEach((removed => {
       this.eventMap.delete(removed.projectRoot.fsPath);
      })), void 0 !== this.documentation && this.loadedFromManifest || (this.loadedFromManifest = !0, 
      this._panel && (this.transmitData(), this.updateGraphStyle()));
     }));
    }
   };
   function getUri(webview, extensionUri, pathList) {
    return webview.asWebviewUri(vscode_1.Uri.joinPath(extensionUri, ...pathList));
   }
   DocsEditViewPanel.viewType = "dbtPowerUser.DocsEdit", DocsEditViewPanel = DocsEditViewPanel_1 = tslib_1.__decorate([ (0, 
   utils_1.provideSingleton)(DocsEditViewPanel_1), tslib_1.__metadata("design:paramtypes", [ dbtProjectContainer_1.DBTProjectContainer, altimate_1.AltimateRequest, telemetry_1.TelemetryService, newDocsGenPanel_1.NewDocsGenPanel, docGenService_1.DocGenService, dbtTestService_1.DbtTestService, dbtTerminal_1.DBTTerminal, dbtLineageService_1.DbtLineageService ]) ], DocsEditViewPanel), 
   exports.DocsEditViewPanel = DocsEditViewPanel;
  },
  84208: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var WebviewViewProviders_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.WebviewViewProviders = void 0;
   const tslib_1 = __webpack_require__(31635), vscode_1 = __webpack_require__(54980), utils_1 = __webpack_require__(86185), queryResultPanel_1 = __webpack_require__(87639), docsEditPanel_1 = __webpack_require__(17215), lineagePanel_1 = __webpack_require__(32943), datapilotPanel_1 = __webpack_require__(32262), insightsPanel_1 = __webpack_require__(51421);
   let WebviewViewProviders = WebviewViewProviders_1 = class {
    constructor(queryResultPanel, docsEditPanel, lineagePanel, dataPilotPanel, insightsPanel) {
     this.queryResultPanel = queryResultPanel, this.docsEditPanel = docsEditPanel, this.lineagePanel = lineagePanel, 
     this.dataPilotPanel = dataPilotPanel, this.insightsPanel = insightsPanel, this.disposables = [], 
     this.disposables.push(vscode_1.window.registerWebviewViewProvider(queryResultPanel_1.QueryResultPanel.viewType, this.queryResultPanel, {
      webviewOptions: {
       retainContextWhenHidden: !0
      }
     }), vscode_1.window.registerWebviewViewProvider(docsEditPanel_1.DocsEditViewPanel.viewType, this.docsEditPanel, {
      webviewOptions: {
       retainContextWhenHidden: !0
      }
     }), vscode_1.window.registerWebviewViewProvider(lineagePanel_1.LineagePanel.viewType, this.lineagePanel, {
      webviewOptions: {
       retainContextWhenHidden: !0
      }
     }), vscode_1.window.registerWebviewViewProvider(datapilotPanel_1.DataPilotPanel.viewType, this.dataPilotPanel, {
      webviewOptions: {
       retainContextWhenHidden: !0
      }
     }), vscode_1.window.registerWebviewViewProvider(insightsPanel_1.InsightsPanel.viewType, this.insightsPanel, {
      webviewOptions: {
       retainContextWhenHidden: !0
      }
     }));
    }
    dispose() {
     for (;this.disposables.length; ) {
      const x = this.disposables.pop();
      x && x.dispose();
     }
    }
   };
   WebviewViewProviders = WebviewViewProviders_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(WebviewViewProviders_1), tslib_1.__metadata("design:paramtypes", [ queryResultPanel_1.QueryResultPanel, docsEditPanel_1.DocsEditViewPanel, lineagePanel_1.LineagePanel, datapilotPanel_1.DataPilotPanel, insightsPanel_1.InsightsPanel ]) ], WebviewViewProviders), 
   exports.WebviewViewProviders = WebviewViewProviders;
  },
  51421: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var InsightsPanel_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.InsightsPanel = void 0;
   const tslib_1 = __webpack_require__(31635), vscode_1 = __webpack_require__(54980), utils_1 = __webpack_require__(86185), dbtProjectContainer_1 = __webpack_require__(82018), telemetry_1 = __webpack_require__(22644), altimateWebviewProvider_1 = __webpack_require__(56183), altimate_1 = __webpack_require__(91741), sharedStateService_1 = __webpack_require__(37712), dbtTerminal_1 = __webpack_require__(83683), deferToProdService_1 = __webpack_require__(2826), queryManifestService_1 = __webpack_require__(59269), validation_provider_1 = __webpack_require__(79262), usersService_1 = __webpack_require__(8502), _lib_1 = __webpack_require__(17176);
   var PromptAnswer;
   !function(PromptAnswer) {
    PromptAnswer.YES = "Install altimate datapilot cli";
   }(PromptAnswer || (PromptAnswer = {}));
   let InsightsPanel = InsightsPanel_1 = class extends altimateWebviewProvider_1.AltimateWebviewProvider {
    constructor(dbtProjectContainer, altimateRequest, telemetry, emitterService, dbtTerminal, queryManifestService, deferToProdService, validationProvider, usersService, notebookFileSystemProvider) {
     super(dbtProjectContainer, altimateRequest, telemetry, emitterService, dbtTerminal, queryManifestService, usersService), 
     this.dbtProjectContainer = dbtProjectContainer, this.altimateRequest = altimateRequest, 
     this.telemetry = telemetry, this.emitterService = emitterService, this.dbtTerminal = dbtTerminal, 
     this.queryManifestService = queryManifestService, this.deferToProdService = deferToProdService, 
     this.validationProvider = validationProvider, this.usersService = usersService, 
     this.notebookFileSystemProvider = notebookFileSystemProvider, this.viewPath = "/insights", 
     this.panelDescription = "Toggle Defer to prod and other features", this._disposables.push(vscode_1.window.onDidChangeActiveTextEditor((event => tslib_1.__awaiter(this, void 0, void 0, (function*() {
      if (void 0 !== event && this._panel) {
       const currentProject = yield this.getCurrentProject(), dbtIntegrationMode = vscode_1.workspace.getConfiguration("dbt").get("dbtIntegration", "core"), projectPath = this.getCurrentProject();
       if (!projectPath) return void this.dbtTerminal.warn("InsightsPanel", "No project selected");
       this.sendResponseToWebview({
        command: "renderDeferConfig",
        data: {
         config: this.deferToProdService.getDeferConfigByProjectRoot(projectPath.projectRoot.fsPath),
         projectPath: null == currentProject ? void 0 : currentProject.projectRoot.fsPath,
         dbtIntegrationMode
        }
       });
      }
     }))))), this._disposables.push(this.notebookFileSystemProvider.onDidChangeFile((e => {
      e.find((event => event.type === vscode_1.FileChangeType.Created)) && this.sendResponseToWebview({
       command: "refetchNotebooks",
       data: {}
      });
     })));
    }
    getCurrentProject() {
     var _a;
     const currentFilePath = null === (_a = vscode_1.window.activeTextEditor) || void 0 === _a ? void 0 : _a.document.uri;
     if (!currentFilePath) return void this.dbtTerminal.debug("InsightsPanel", "No file selected in the editor");
     return this.dbtProjectContainer.findDBTProject(currentFilePath);
    }
    updateDeferConfig(syncRequestId, params) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      try {
       if (this.dbtTerminal.debug("InsightsPanel", "Updating defer config", params), !params.projectRoot) return void vscode_1.window.showErrorMessage("Please select a project");
       const updateConfigs = params.config, target = vscode_1.workspace.workspaceFolders ? vscode_1.ConfigurationTarget.WorkspaceFolder : vscode_1.ConfigurationTarget.Global;
       this.dbtTerminal.debug("InsightsPanel", "config target: ${window.activeTextEditor?.document.uri}");
       const currentConfig = this.deferToProdService.getDeferConfigByWorkspace(), root = (0, 
       utils_1.getProjectRelativePath)(vscode_1.Uri.file(params.projectRoot));
       this.dbtTerminal.info("Defer config", "updating defer config", !0, root, updateConfigs);
       const newConfig = Object.assign(Object.assign({}, currentConfig), {
        [root]: Object.assign(Object.assign({}, currentConfig[root]), updateConfigs.reduce(((acc, param) => (acc[param.key] = param.value, 
        acc)), {}))
       }), workspaceFolder = vscode_1.workspace.getWorkspaceFolder(vscode_1.Uri.file(params.projectRoot));
       yield vscode_1.workspace.getConfiguration("dbt", workspaceFolder).update("deferConfigPerProject", newConfig, target), 
       syncRequestId && this.sendResponseToWebview({
        command: "response",
        syncRequestId,
        data: {
         updated: !0
        }
       }), currentConfig[root].deferToProduction === newConfig[root].deferToProduction && currentConfig[root].manifestPathForDeferral === newConfig[root].manifestPathForDeferral && currentConfig[root].favorState === newConfig[root].favorState || vscode_1.window.withProgress({
        location: vscode_1.ProgressLocation.Notification,
        title: "Applying defer config...",
        cancellable: !1
       }, (() => tslib_1.__awaiter(this, void 0, void 0, (function*() {
        var _a;
        yield null === (_a = this.dbtProjectContainer.findDBTProject(vscode_1.Uri.file(params.projectRoot))) || void 0 === _a ? void 0 : _a.applyDeferConfig();
       }))));
      } catch (err) {
       this.dbtTerminal.error("InsightsPanel", "error while updating defer config", err), 
       this.sendResponseToWebview({
        command: "response",
        syncRequestId,
        data: {
         updated: !1
        },
        error: err.message
       });
      }
     }));
    }
    fetchProjectIntegrations(syncRequestId, params) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      try {
       if (params.clearCache && (this.projectIntegrations = void 0), this.projectIntegrations) return void (syncRequestId && this.sendResponseToWebview({
        command: "response",
        syncRequestId,
        data: this.projectIntegrations
       }));
       if (!this.altimateRequest.handlePreviewFeatures()) return this.projectIntegrations = [], 
       void (syncRequestId && this.sendResponseToWebview({
        command: "response",
        syncRequestId,
        data: this.projectIntegrations
       }));
       this.dbtTerminal.debug("InsightsPanel", "Fetching project integrations");
       const response = yield this.altimateRequest.fetchProjectIntegrations();
       (null == response ? void 0 : response.length) || (this.dbtTerminal.debug("InsightsPanel", "Missing project integrations"), 
       vscode_1.window.showInformationMessage("You need to set up integration in SaaS. Please check the documentation", "View", "Cancel").then((selection => {
        "View" === selection && vscode_1.env.openExternal(vscode_1.Uri.parse("https://docs.myaltimate.com/test/defertoprod"));
       }))), this.projectIntegrations = response, syncRequestId && this.sendResponseToWebview({
        command: "response",
        syncRequestId,
        data: response
       });
      } catch (err) {
       this.dbtTerminal.error("InsightsPanel", "could not fetch project integrations", err), 
       this.sendResponseToWebview({
        command: "response",
        syncRequestId,
        data: {
         response: []
        },
        error: err.message
       });
      }
     }));
    }
    testRemoteManifest(syncRequestId, dbtCoreIntegrationId) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      try {
       this.dbtTerminal.debug("InsightsPanel", "Fetching manifest signed url");
       const response = yield this.altimateRequest.fetchArtifactUrl("manifest", dbtCoreIntegrationId);
       syncRequestId && this.sendResponseToWebview({
        command: "response",
        syncRequestId,
        body: response
       });
      } catch (err) {
       const errorMessage = err instanceof altimate_1.NotFoundError ? "No remote manifest file present for selected dbt core integration" : err.message;
       vscode_1.window.showErrorMessage(`Could not download remote manifest: ${errorMessage}`), 
       this.dbtTerminal.error("InsightsPanel", "could not download remote manifest", err), 
       this.sendResponseToWebview({
        command: "response",
        syncRequestId,
        data: {
         response: []
        },
        error: err.message
       });
      }
     }));
    }
    getProjects(syncRequestId) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      try {
       this.dbtTerminal.debug("InsightsPanel", "Fetching projects");
       const projects = this.dbtProjectContainer.getProjects(), dbtProjects = [];
       projects.forEach((i => {
        const projectName = i.getProjectName(), projectRoot = i.projectRoot;
        dbtProjects.push({
         projectName,
         projectRoot: projectRoot.fsPath
        });
       })), syncRequestId && this.sendResponseToWebview({
        command: "response",
        syncRequestId,
        data: dbtProjects
       });
      } catch (err) {
       this.dbtTerminal.error("InsightsPanel", "could not fetch project integrations", err), 
       this.sendResponseToWebview({
        command: "response",
        syncRequestId,
        data: {
         response: []
        },
        error: err.message
       });
      }
     }));
    }
    selectDirectoryForManifest(syncRequestId) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const openDialog = yield vscode_1.window.showOpenDialog({
       filters: {},
       canSelectFolders: !0,
       openLabel: "Select",
       canSelectFiles: !1,
       canSelectMany: !1
      });
      if (void 0 === openDialog || 0 === openDialog.length) return this.dbtTerminal.debug("InsightsPanel", "opendialog cancelled"), 
      void this.sendResponseToWebview({
       command: "response",
       syncRequestId,
       data: {
        error: "Folder not selected"
       },
       error: "Folder not selected"
      });
      this.sendResponseToWebview({
       command: "response",
       syncRequestId,
       data: {
        path: openDialog[0].fsPath
       }
      });
     }));
    }
    selectFiles(syncRequestId, {filters = {}, canSelectMany = !1}) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const openDialog = yield vscode_1.window.showOpenDialog({
       filters,
       canSelectFolders: !1,
       openLabel: "Select",
       canSelectFiles: !0,
       canSelectMany
      });
      if (void 0 === openDialog || 0 === openDialog.length) return this.dbtTerminal.debug("InsightsPanel", "opendialog cancelled"), 
      void this._panel.webview.postMessage({
       command: "response",
       args: {
        syncRequestId,
        body: {
         error: "File not selected"
        },
        status: !1
       }
      });
      this._panel.webview.postMessage({
       command: "response",
       args: {
        syncRequestId,
        body: {
         path: openDialog.map((i => i.fsPath))
        },
        status: !0
       }
      });
     }));
    }
    emitError(syncRequestId, errorMsg) {
     vscode_1.window.showErrorMessage(errorMsg), this._panel.webview.postMessage({
      command: "response",
      args: {
       syncRequestId,
       status: !1,
       error: errorMsg
      }
     });
    }
    altimateScan(syncRequestId, args) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      try {
       this.validationProvider.throwIfNotAuthenticated(), yield this.altimateRequest.logDBTHealthcheckStartScan();
      } catch (e) {
       return void this.emitError(syncRequestId, e.message);
      }
      let isInstalled = !1;
      try {
       isInstalled = yield this.dbtProjectContainer.checkIfAltimateDatapilotInstalled();
      } catch (e) {
       return this.emitError(syncRequestId, `Error while checking altimate datapilot cli installation: ${e.message}`), 
       void this.dbtTerminal.error("atimateDatapilotInstallationCheck", "Error while checking altimate datapilot cli installation", e);
      }
      if (!isInstalled) {
       if ((yield vscode_1.window.showInformationMessage("Altimate datapilot cli is not detected. Install it?", PromptAnswer.YES)) !== PromptAnswer.YES) return void this.emitError(syncRequestId, "Altimate datapilot cli is not installed.");
       try {
        yield vscode_1.window.withProgress({
         title: "Installing altimate-datapilot-cli...",
         location: vscode_1.ProgressLocation.Notification,
         cancellable: !1
        }, (() => tslib_1.__awaiter(this, void 0, void 0, (function*() {
         yield this.dbtProjectContainer.installAltimateDatapilot(), vscode_1.window.showInformationMessage("Successfully installed altimate-datapilot-cli");
        }))));
       } catch (e) {
        return this.emitError(syncRequestId, `Error while installing altimate datapilot cli: ${e.message}`), 
        void this.dbtTerminal.error("atimateDatapilotInstallation", "Error while installing altimate datapilot", e);
       }
      }
      this.telemetry.sendTelemetryEvent("performDatapilotHealthcheck", {
       args: JSON.stringify(args)
      });
      try {
       yield vscode_1.window.withProgress({
        title: "Performing healthcheck...",
        location: vscode_1.ProgressLocation.Notification,
        cancellable: !1
       }, (() => tslib_1.__awaiter(this, void 0, void 0, (function*() {
        const projectHealthcheck = yield this.dbtProjectContainer.executeAltimateDatapilotHealthcheck(args);
        this._panel.webview.postMessage({
         command: "response",
         args: {
          syncRequestId,
          body: {
           projectHealthcheck
          },
          status: !0
         }
        });
       }))));
      } catch (e) {
       this.emitError(syncRequestId, `Error while performing project governance checks:${e.message}`), 
       this.dbtTerminal.error("atimateDatapilotGovernance", "Error while performing project governance checks", e);
      }
     }));
    }
    handleCommand(message) {
     const _super = Object.create(null, {
      handleCommand: {
       get: () => super.handleCommand
      }
     });
     var _a;
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const {command, syncRequestId} = message, params = tslib_1.__rest(message, [ "command", "syncRequestId" ]);
      switch (command) {
      case "getNotebooks":
       this.sendResponseToWebview({
        command: "response",
        syncRequestId: message.syncRequestId,
        data: yield this.altimateRequest.getNotebooks("", [], params.privacy)
       });
       break;

      case "getPreConfiguredNotebooks":
       this.sendResponseToWebview({
        command: "response",
        syncRequestId: message.syncRequestId,
        data: yield this.altimateRequest.getPreConfiguredNotebooks()
       });
       break;

      case "updateNotebookPrivacy":
       this.sendResponseToWebview({
        command: "response",
        syncRequestId: message.syncRequestId,
        data: yield this.altimateRequest.updateNotebookPrivacy(params.notebookId, params.privacy)
       });
       break;

      case "selectDirectoryForManifest":
       this.selectDirectoryForManifest(syncRequestId);
       break;

      case "selectFiles":
       this.selectFiles(syncRequestId, params);
       break;

      case "updateDeferConfig":
       yield this.updateDeferConfig(syncRequestId, params);
       break;

      case "bigqueryCostEstimate":
       this.dbtTerminal.debug("InsightsPanel", "insights_panel:handleCommand -> bigqueryCostEstimate");
       const result = yield vscode_1.commands.executeCommand("dbtPowerUser.bigqueryCostEstimate", {
        returnResult: !0
       });
       this.sendResponseToWebview({
        command: "response",
        syncRequestId,
        data: result
       });
       break;

      case "altimateScan":
       this.altimateScan(syncRequestId, params);
       break;

      case "clearAltimateScanResults":
       vscode_1.commands.executeCommand("dbtPowerUser.clearAltimateScanResults", {});
       break;

      case "getDeferToProductionConfig":
       const {projectRoot} = params, projectPath = projectRoot || (null === (_a = yield this.getCurrentProject()) || void 0 === _a ? void 0 : _a.projectRoot.fsPath);
       if (!projectPath) return void this.sendResponseToWebview({
        command: "response",
        syncRequestId,
        data: {
         error: "No project selected"
        },
        error: "No project selected"
       });
       const config = this.deferToProdService.getDeferConfigByProjectRoot(projectPath);
       this.dbtTerminal.debug("InsightsPanel", `getting defer config for ${projectPath}`, projectRoot);
       const dbtIntegrationMode = vscode_1.workspace.getConfiguration("dbt").get("dbtIntegration", "core");
       this.sendResponseToWebview({
        command: "response",
        syncRequestId,
        data: {
         config,
         projectPath,
         dbtIntegrationMode
        }
       });
       break;

      case "fetchProjectIntegrations":
       yield this.fetchProjectIntegrations(syncRequestId, params);
       break;

      case "testRemoteManifest":
       const {dbtCoreIntegrationId} = params;
       yield this.testRemoteManifest(syncRequestId, dbtCoreIntegrationId);
       break;

      case "getProjects":
       yield this.getProjects(syncRequestId);
       break;

      case "logDBTHealthcheckConfig":
       yield this.altimateRequest.logDBTHealthcheckConfig(params.configId);
       break;

      case "getInsightConfigs":
       yield this.handleSyncRequestFromWebview(syncRequestId, (() => tslib_1.__awaiter(this, void 0, void 0, (function*() {
        return yield this.altimateRequest.getHealthcheckConfigs();
       }))), command, !0);
       break;

      default:
       _super.handleCommand.call(this, message);
      }
     }));
    }
   };
   InsightsPanel.viewType = "dbtPowerUser.Insights", InsightsPanel = InsightsPanel_1 = tslib_1.__decorate([ (0, 
   utils_1.provideSingleton)(InsightsPanel_1), tslib_1.__metadata("design:paramtypes", [ dbtProjectContainer_1.DBTProjectContainer, altimate_1.AltimateRequest, telemetry_1.TelemetryService, sharedStateService_1.SharedStateService, dbtTerminal_1.DBTTerminal, queryManifestService_1.QueryManifestService, deferToProdService_1.DeferToProdService, validation_provider_1.ValidationProvider, usersService_1.UsersService, _lib_1.NotebookFileSystemProvider ]) ], InsightsPanel), 
   exports.InsightsPanel = InsightsPanel;
  },
  32943: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var LineagePanel_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.LineagePanel = void 0;
   const tslib_1 = __webpack_require__(31635), vscode_1 = __webpack_require__(54980), utils_1 = __webpack_require__(86185), telemetry_1 = __webpack_require__(22644), dbtProjectContainer_1 = __webpack_require__(82018), modelGraphViewPanel_1 = __webpack_require__(19316), newLineagePanel_1 = __webpack_require__(49823), dbtTerminal_1 = __webpack_require__(83683);
   let LineagePanel = LineagePanel_1 = class {
    constructor(lineagePanel, legacyLineagePanel, dbtProjectContainer, telemetry, dbtTerminal) {
     this.lineagePanel = lineagePanel, this.legacyLineagePanel = legacyLineagePanel, 
     this.telemetry = telemetry, this.dbtTerminal = dbtTerminal, this.eventMap = new Map, 
     this.disposables = [], this.init = () => tslib_1.__awaiter(this, void 0, void 0, (function*() {
      yield this.getPanel().resolveWebviewView(this.panel, this.context, this.token), 
      this.getPanel().eventMapChanged(this.eventMap);
     })), this.handleWebviewMessage = message => tslib_1.__awaiter(this, void 0, void 0, (function*() {
      var _a, _b;
      this.dbtTerminal.debug("lineagePanel:handleWebviewMessage", "message", message);
      const {command, args} = message;
      if ("openFile" !== command) {
       if ("setNewLineageView" === command) return yield vscode_1.workspace.getConfiguration("dbt").update("enableNewLineagePanel", !0), 
       this.init(), void this.telemetry.sendTelemetryEvent("NewLineagePanelSelected");
       if ("setLegacyLineageView" === command) return yield vscode_1.workspace.getConfiguration("dbt").update("enableNewLineagePanel", !1), 
       this.init(), void this.telemetry.sendTelemetryEvent("LegacyLineagePanelSelected");
       if ("init" !== command) {
        if ("reactError" === command) {
         const typeMapper = {
          generic: "Generic"
         }, {type} = args;
         this.telemetry.sendTelemetryEvent("ReactError:" + typeMapper[type] || 0);
        }
        this.getPanel().handleCommand(message);
       } else null === (_b = this.getPanel()) || void 0 === _b || _b.init();
      } else {
       const url = null === (_a = args.params) || void 0 === _a ? void 0 : _a.url;
       if (!url) return;
       yield vscode_1.commands.executeCommand("vscode.open", vscode_1.Uri.file(url), {
        preview: !1,
        preserveFocus: !0
       });
      }
     })), this.disposables.push(dbtProjectContainer.onManifestChanged((event => this.onManifestCacheChanged(event)))), 
     vscode_1.window.onDidChangeActiveColorTheme((e => tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.getPanel().changedActiveColorTheme();
     }))), null, this.disposables), vscode_1.window.onDidChangeActiveTextEditor((event => {
      this.getPanel().changedActiveTextEditor(event);
     }));
    }
    getPanel() {
     return vscode_1.workspace.getConfiguration("dbt").get("enableNewLineagePanel", !1) ? this.lineagePanel : this.legacyLineagePanel;
    }
    onManifestCacheChanged(event) {
     var _a, _b;
     null === (_a = event.added) || void 0 === _a || _a.forEach((added => {
      this.eventMap.set(added.project.projectRoot.fsPath, added);
     })), null === (_b = event.removed) || void 0 === _b || _b.forEach((removed => {
      this.eventMap.delete(removed.projectRoot.fsPath);
     })), this.getPanel().eventMapChanged(this.eventMap);
    }
    dispose() {
     for (;this.disposables.length; ) {
      const x = this.disposables.pop();
      x && x.dispose();
     }
    }
    resolveWebviewView(panel, context, token) {
     this.panel = panel, this.context = context, this.token = token;
     const panelType = vscode_1.workspace.getConfiguration("dbt").get("enableNewLineagePanel", !1);
     this.init(), panel.webview.onDidReceiveMessage(this.handleWebviewMessage, null, []);
     const sendLineageViewEvent = () => {
      this.panel.visible && this.telemetry.sendTelemetryEvent(panelType ? "NewLineagePanelActive" : "LineagePanelActive");
     };
     sendLineageViewEvent(), panel.onDidChangeVisibility(sendLineageViewEvent);
    }
   };
   LineagePanel.viewType = "dbtPowerUser.Lineage", LineagePanel = LineagePanel_1 = tslib_1.__decorate([ (0, 
   utils_1.provideSingleton)(LineagePanel_1), tslib_1.__metadata("design:paramtypes", [ newLineagePanel_1.NewLineagePanel, modelGraphViewPanel_1.ModelGraphViewPanel, dbtProjectContainer_1.DBTProjectContainer, telemetry_1.TelemetryService, dbtTerminal_1.DBTTerminal ]) ], LineagePanel), 
   exports.LineagePanel = LineagePanel;
  },
  19316: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var ModelGraphViewPanel_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.ModelGraphViewPanel = void 0;
   const tslib_1 = __webpack_require__(31635), fs_1 = __webpack_require__(79896), path = __webpack_require__(16928), vscode_1 = __webpack_require__(54980), dbtProjectContainer_1 = __webpack_require__(82018), utils_1 = __webpack_require__(86185), dbtTerminal_1 = __webpack_require__(83683), colors_black = "#000", colors_purple = "#88447D", colors_white = "#FFFFFF", nodeConfigurations = {
    children: {
     style: {
      lineWidth: 2,
      fill: "#EFB27B",
      stroke: colors_black,
      radius: 6
     }
    },
    parents: {
     style: {
      lineWidth: 2,
      fill: "#8DAAE8",
      stroke: colors_black,
      radius: 6
     }
    },
    tests: {
     style: {
      lineWidth: 2,
      fill: "#8DE88E",
      stroke: colors_black,
      radius: 6
     }
    }
   };
   let ModelGraphViewPanel = ModelGraphViewPanel_1 = class {
    constructor(dbtProjectContainer, dbtTerminal) {
     this.dbtProjectContainer = dbtProjectContainer, this.dbtTerminal = dbtTerminal, 
     this._panel = void 0, this.eventMap = new Map, this.parseGraphData = () => {
      if (void 0 === vscode_1.window.activeTextEditor || void 0 === this.eventMap) return;
      const currentFilePath = vscode_1.window.activeTextEditor.document.uri, projectRootpath = this.dbtProjectContainer.getProjectRootpath(currentFilePath);
      if (void 0 === projectRootpath) return;
      const event = this.eventMap.get(projectRootpath.fsPath);
      if (void 0 === event) return;
      const {graphMetaMap} = event, fileName = path.basename(vscode_1.window.activeTextEditor.document.fileName, ".sql");
      return this.mapParentsAndChildren(graphMetaMap, fileName);
     }, this.mapParentsAndChildren = (graphMetaMap, fileName) => {
      let nodes = [];
      const edges = [];
      return Object.keys(nodeConfigurations).forEach((type => {
       const dependencyNodes = graphMetaMap[type];
       Array.from(dependencyNodes.keys()).forEach((key => {
        if (key.endsWith(`.${fileName}`) && key.startsWith("model.")) {
         const currentNode = dependencyNodes.get(key);
         nodes = this.addCurrentNode(key, nodes), void 0 !== currentNode && currentNode.nodes.map((childrenNode => {
          let edge = {
           target: childrenNode.key,
           source: key
          };
          "parents" === type && (edge = {
           target: key,
           source: childrenNode.key
          }), edges.push(edge), nodes.push({
           id: childrenNode.key,
           label: fitLabelToNodeWidth(childrenNode.label, 280, 14),
           style: nodeConfigurations[type].style,
           url: childrenNode.url
          });
         }));
        }
       }));
      })), {
       nodes,
       edges
      };
     };
    }
    eventMapChanged(eventMap) {
     this.eventMap = eventMap, this.init();
    }
    changedActiveColorTheme() {
     this.updateGraphStyle();
    }
    changedActiveTextEditor(event) {
     void 0 !== event && this.init();
    }
    transmitData(graphInfo) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this._panel && (yield this._panel.webview.postMessage({
       command: "renderGraph",
       graph: graphInfo
      }));
     }));
    }
    updateGraphStyle() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      if (!this._panel) return;
      const theme = [ vscode_1.ColorThemeKind.Light, vscode_1.ColorThemeKind.HighContrastLight ].includes(vscode_1.window.activeColorTheme.kind) ? "light" : "dark";
      yield this._panel.webview.postMessage({
       command: "setStylesByTheme",
       theme
      });
     }));
    }
    resolveWebviewView(panel, context, _token) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this._panel = panel, this.setupWebviewOptions(context), this.renderWebviewView(context);
     }));
    }
    renderWebviewView(context) {
     const webview = this._panel.webview;
     webview.html = function(webview, extensionUri) {
      const indexPath = getUri(webview, extensionUri, [ "lineage_panel", "index.html" ]), resourceDir = getUri(webview, extensionUri, [ "lineage_panel" ]), theme = [ vscode_1.ColorThemeKind.Light, vscode_1.ColorThemeKind.HighContrastLight ].includes(vscode_1.window.activeColorTheme.kind) ? "light" : "dark";
      return (0, fs_1.readFileSync)(indexPath.fsPath).toString().replace(/__ROOT__/g, resourceDir.toString()).replace(/__THEME__/g, theme).replace(/__NONCE__/g, function() {
       let text = "";
       const possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
       for (let i = 0; i < 32; i++) text += possible.charAt(Math.floor(Math.random() * possible.length));
       return text;
      }()).replace(/__CSPSOURCE__/g, webview.cspSource);
     }(webview, this.dbtProjectContainer.extensionUri);
    }
    setupWebviewOptions(context) {
     this._panel.title = "", this._panel.description = "View dbt graph", this._panel.webview.options = {
      enableScripts: !0
     };
    }
    init() {
     this.g6Data = this.parseGraphData(), this.transmitData(this.g6Data), this.updateGraphStyle();
    }
    handleCommand(message) {
     this.dbtTerminal.debug("modelGraphViewPanel:handleCommand", "Unsupported mssage", message);
    }
    addCurrentNode(nodeKey, nodes) {
     const nodeLabel = nodeKey.split(".").pop() || "";
     return [ ...nodes, {
      id: nodeKey,
      label: fitLabelToNodeWidth(nodeLabel, 280, 14),
      labelCfg: {
       style: {
        fill: colors_white
       }
      },
      style: {
       fill: colors_purple,
       stroke: "black",
       radius: 6,
       lineWidth: 2
      }
     } ];
    }
   };
   ModelGraphViewPanel.viewType = "dbtPowerUser.ModelViewGraph", ModelGraphViewPanel = ModelGraphViewPanel_1 = tslib_1.__decorate([ (0, 
   utils_1.provideSingleton)(ModelGraphViewPanel_1), tslib_1.__metadata("design:paramtypes", [ dbtProjectContainer_1.DBTProjectContainer, dbtTerminal_1.DBTTerminal ]) ], ModelGraphViewPanel), 
   exports.ModelGraphViewPanel = ModelGraphViewPanel;
   const fitLabelToNodeWidth = (label, maxWidth, fontSize) => {
    const fontWidth = 1.3 * fontSize;
    maxWidth *= 2;
    const width = (label => {
     let len = 0;
     for (let i = 0; i < label.length; i++) label.charCodeAt(i) > 0 && label.charCodeAt(i) < 128 ? len++ : len += 2;
     return len;
    })(label) * fontWidth;
    if (width > maxWidth) {
     const actualLen = Math.floor((maxWidth - 10) / fontWidth);
     return label.substring(0, actualLen) + "…";
    }
    return label;
   };
   function getUri(webview, extensionUri, pathList) {
    return webview.asWebviewUri(vscode_1.Uri.joinPath(extensionUri, ...pathList));
   }
  },
  21970: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var NewDocsGenPanel_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.NewDocsGenPanel = void 0;
   const tslib_1 = __webpack_require__(31635), fs_1 = __webpack_require__(79896), vscode_1 = __webpack_require__(54980), altimate_1 = __webpack_require__(91741), dbtTerminal_1 = __webpack_require__(83683), dbtProjectContainer_1 = __webpack_require__(82018), queryManifestService_1 = __webpack_require__(59269), docGenService_1 = __webpack_require__(88642), sharedStateService_1 = __webpack_require__(37712), telemetry_1 = __webpack_require__(22644), utils_1 = __webpack_require__(86185), altimateWebviewProvider_1 = __webpack_require__(56183), dbtTestService_1 = __webpack_require__(2188), usersService_1 = __webpack_require__(8502), conversationProvider_1 = __webpack_require__(10998), DbtDocsView_1 = __webpack_require__(67164), conversationService_1 = __webpack_require__(99311);
   let NewDocsGenPanel = NewDocsGenPanel_1 = class extends altimateWebviewProvider_1.AltimateWebviewProvider {
    constructor(dbtProjectContainer, altimateRequest, telemetry, docGenService, emitterService, queryManifestService, dbtTerminal, dbtTestService, userService, dbtDocsView, conversationProvider, conversationService) {
     super(dbtProjectContainer, altimateRequest, telemetry, emitterService, dbtTerminal, queryManifestService, userService), 
     this.altimateRequest = altimateRequest, this.docGenService = docGenService, this.emitterService = emitterService, 
     this.queryManifestService = queryManifestService, this.dbtTerminal = dbtTerminal, 
     this.dbtTestService = dbtTestService, this.userService = userService, this.dbtDocsView = dbtDocsView, 
     this.conversationProvider = conversationProvider, this.conversationService = conversationService, 
     this.viewPath = "/docs-generator", this.panelDescription = "Generate documentation for your models";
    }
    onManifestCacheChanged(event) {
     super.onManifestCacheChanged(event);
    }
    onWebviewReady() {
     super.onWebviewReady(), this.transmitConversationsData();
    }
    transmitConversationsData() {
     const conversations = this.conversationService.getConversations();
     conversations && Object.entries(conversations).forEach((([shareId, conversationGroups]) => {
      this.sendResponseToWebview({
       command: "conversations:updates",
       shareId,
       conversationGroups
      });
     }));
    }
    resolveWebview(panel, context, token) {
     super.resolveWebviewView(panel, context, token);
    }
    getDbtTestCode(test, modelName) {
     const {path: testPath, column_name} = test;
     return this.dbtTerminal.debug("getDbtTestCode", "getting sql and config", testPath, column_name, modelName), 
     {
      sql: (null == testPath ? void 0 : testPath.endsWith(".sql")) ? (0, fs_1.readFileSync)(testPath, {
       encoding: "utf-8"
      }) : void 0,
      config: this.dbtTestService.getConfigByTest(test, modelName, column_name)
     };
    }
    createConversation(_a) {
     var _b, {comment} = _a, params = tslib_1.__rest(_a, [ "comment" ]);
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      if (!(null === (_b = vscode_1.window.activeTextEditor) || void 0 === _b ? void 0 : _b.document.uri)) throw new Error("Invalid file");
      if (!comment) throw new Error("Invalid comment");
      const result = yield this.conversationProvider.saveConversation(comment, vscode_1.window.activeTextEditor.document.uri, params.meta, new vscode_1.Range(0, 0, 0, 0), "documentation-editor");
      if (null == result ? void 0 : result.shareId) return {
       [result.shareId]: yield this.conversationService.loadConversationsByShareId(result.shareId)
      };
     }));
    }
    handleCommand(message) {
     const _super = Object.create(null, {
      handleCommand: {
       get: () => super.handleCommand
      }
     });
     var _a;
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const {command, syncRequestId} = message, args = tslib_1.__rest(message, [ "command", "syncRequestId" ]);
      switch (command) {
      case "refetchConversations":
       this.emitterService.fire({
        command,
        payload: args
       });
       break;

      case "createConversation":
       this.handleSyncRequestFromWebview(syncRequestId, (() => tslib_1.__awaiter(this, void 0, void 0, (function*() {
        return this.createConversation(args);
       }))), command);
       break;

      case "getTestCode":
       this.handleSyncRequestFromWebview(syncRequestId, (() => tslib_1.__awaiter(this, void 0, void 0, (function*() {
        return this.getDbtTestCode(args.test, args.model);
       }))), command);
       break;

      case "getDistinctColumnValues":
       this.handleSyncRequestFromWebview(syncRequestId, (() => tslib_1.__awaiter(this, void 0, void 0, (function*() {
        var _b;
        return yield null === (_b = this.queryManifestService.getProject()) || void 0 === _b ? void 0 : _b.getColumnValues(args.model, args.column);
       }))), command, !0);
       break;

      case "getCurrentModelDocumentation":
       if (!this._panel) return;
       const {documentation, message: missingDocumentationMessage} = yield this.docGenService.getDocumentationForCurrentActiveFile();
       this.sendResponseToWebview({
        command: "renderDocumentation",
        docs: documentation,
        missingDocumentationMessage,
        tests: yield this.dbtTestService.getTestsForCurrentModel(),
        project: null === (_a = this.queryManifestService.getProject()) || void 0 === _a ? void 0 : _a.getProjectName(),
        collaborationEnabled: vscode_1.workspace.getConfiguration("dbt").get("enableCollaboration", !1)
       });
       break;

      case "getColumnsOfSources":
       this.handleSyncRequestFromWebview(syncRequestId, (() => tslib_1.__awaiter(this, void 0, void 0, (function*() {
        var _c;
        const columnsFromSources = yield null === (_c = this.queryManifestService.getProject()) || void 0 === _c ? void 0 : _c.getColumnsOfSource(args.source, args.table);
        return {
         columns: columnsFromSources ? columnsFromSources.map((c => c.column)) : []
        };
       }))), command, !0);
       break;

      case "getColumnsOfModel":
       this.handleSyncRequestFromWebview(syncRequestId, (() => tslib_1.__awaiter(this, void 0, void 0, (function*() {
        var _d;
        const columns = yield null === (_d = this.queryManifestService.getProject()) || void 0 === _d ? void 0 : _d.getColumnsOfModel(args.model);
        return {
         columns: columns ? columns.map((c => c.column)) : []
        };
       }))), command, !0);
       break;

      case "getSourcesInProject":
       this.handleSyncRequestFromWebview(syncRequestId, (() => tslib_1.__awaiter(this, void 0, void 0, (function*() {
        var _e;
        return {
         sources: this.queryManifestService.getSourcesInProject(null === (_e = vscode_1.window.activeTextEditor) || void 0 === _e ? void 0 : _e.document.uri)
        };
       }))), command, !0);
       break;

      case "getModelsInProject":
       this.handleSyncRequestFromWebview(syncRequestId, (() => tslib_1.__awaiter(this, void 0, void 0, (function*() {
        var _f;
        return {
         models: this.queryManifestService.getModelsInProject(null === (_f = vscode_1.window.activeTextEditor) || void 0 === _f ? void 0 : _f.document.uri)
        };
       }))), command);
       break;

      default:
       _super.handleCommand.call(this, message);
      }
     }));
    }
    onEvent({command, payload}) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      switch (command) {
      case "viewConversation":
      case "conversations:updates":
      case "docgen:insert":
      case "testgen:insert":
       this.sendResponseToWebview(Object.assign({
        command
       }, payload));
      }
     }));
    }
   };
   NewDocsGenPanel.viewType = "dbtPowerUser.DocsEdit", NewDocsGenPanel = NewDocsGenPanel_1 = tslib_1.__decorate([ (0, 
   utils_1.provideSingleton)(NewDocsGenPanel_1), tslib_1.__metadata("design:paramtypes", [ dbtProjectContainer_1.DBTProjectContainer, altimate_1.AltimateRequest, telemetry_1.TelemetryService, docGenService_1.DocGenService, sharedStateService_1.SharedStateService, queryManifestService_1.QueryManifestService, dbtTerminal_1.DBTTerminal, dbtTestService_1.DbtTestService, usersService_1.UsersService, DbtDocsView_1.DbtDocsView, conversationProvider_1.ConversationProvider, conversationService_1.ConversationService ]) ], NewDocsGenPanel), 
   exports.NewDocsGenPanel = NewDocsGenPanel;
  },
  49823: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var NewLineagePanel_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.NewLineagePanel = void 0;
   const tslib_1 = __webpack_require__(31635), path = __webpack_require__(16928), vscode_1 = __webpack_require__(54980), altimate_1 = __webpack_require__(91741), dbtProjectContainer_1 = __webpack_require__(82018), utils_1 = __webpack_require__(86185), dbtProject_1 = __webpack_require__(38821), telemetry_1 = __webpack_require__(22644), dbtTerminal_1 = __webpack_require__(83683), altimateWebviewProvider_1 = __webpack_require__(56183), queryManifestService_1 = __webpack_require__(59269), sharedStateService_1 = __webpack_require__(37712), usersService_1 = __webpack_require__(8502), dbtLineageService_1 = __webpack_require__(45451);
   let NewLineagePanel = NewLineagePanel_1 = class extends altimateWebviewProvider_1.AltimateWebviewProvider {
    constructor(dbtProjectContainer, altimate, telemetry, terminal, dbtLineageService, eventEmitterService, queryManifestService, usersService) {
     super(dbtProjectContainer, altimate, telemetry, eventEmitterService, terminal, queryManifestService, usersService), 
     this.dbtProjectContainer = dbtProjectContainer, this.altimate = altimate, this.telemetry = telemetry, 
     this.terminal = terminal, this.dbtLineageService = dbtLineageService, this.queryManifestService = queryManifestService, 
     this.usersService = usersService, this.viewPath = "/lineage", this.panelDescription = "Lineage panel";
    }
    changedActiveTextEditor(event) {
     void 0 !== event && this._panel && this.renderStartingNode();
    }
    eventMapChanged(eventMap) {
     this.eventMap = eventMap;
    }
    changedActiveColorTheme() {
     if (!this._panel) return;
     const theme = [ vscode_1.ColorThemeKind.Light, vscode_1.ColorThemeKind.HighContrastLight ].includes(vscode_1.window.activeColorTheme.kind) ? "light" : "dark";
     this._panel.webview.postMessage({
      command: "setTheme",
      args: {
       theme
      }
     });
    }
    init() {
     this.terminal.debug("newLineagePanel:init", "init", this._panel), this.changedActiveColorTheme(), 
     this.renderStartingNode();
    }
    renderStartingNode() {
     this._panel && this._panel.webview.postMessage({
      command: "render",
      args: this.getStartingNode()
     });
    }
    handleCommand(message) {
     const _super = Object.create(null, {
      handleCommand: {
       get: () => super.handleCommand
      }
     });
     var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const {command, args = {}, syncRequestId} = message, {id = syncRequestId, params} = args;
      if ("openProblemsTab" !== command) if ("upstreamTables" !== command) if ("downstreamTables" !== command) if ("getColumns" !== command) if ("getExposureDetails" !== command) if ("getConnectedColumns" !== command) if ("sendFeedback" !== command) if ("columnLineage" !== command) if ("telemetryEvents" !== command) if ("previewFeature" !== command) if ("showInfoNotification" !== command) if ("getLineageSettings" !== command) if ("persistLineageSettings" !== command) this.terminal.debug("newLineagePanel:handleCommand", "Unsupported command", message), 
      _super.handleCommand.call(this, message); else {
       const config = vscode_1.workspace.getConfiguration("dbt.lineage");
       for (const k in params) yield config.update(k, params[k]);
       null === (_k = this._panel) || void 0 === _k || _k.webview.postMessage({
        command: "response",
        args: {
         id,
         syncRequestId,
         status: !0,
         body: {
          ok: !0
         }
        }
       });
      } else {
       const config = vscode_1.workspace.getConfiguration("dbt.lineage");
       null === (_j = this._panel) || void 0 === _j || _j.webview.postMessage({
        command: "response",
        args: {
         id,
         syncRequestId,
         status: !0,
         body: {
          showSelectEdges: config.get("showSelectEdges", !0),
          showNonSelectEdges: config.get("showNonSelectEdges", !1),
          defaultExpansion: config.get("defaultExpansion", 1)
         }
        }
       });
      } else vscode_1.window.showInformationMessage(params.message); else this.altimate.handlePreviewFeatures(); else this.telemetry.sendTelemetryEvent(id, params); else this.dbtLineageService.handleColumnLineage(args, (() => {
       var _a;
       null === (_a = this._panel) || void 0 === _a || _a.webview.postMessage({
        command: "columnLineage",
        args: {
         event: dbtLineageService_1.CllEvents.CANCEL
        }
       });
      })); else try {
       yield this.altimate.sendFeedback({
        feedback_src: "dbtpu-extension",
        feedback_text: params.feedback_text,
        feedback_value: params.feedback_value,
        data: {}
       }), null === (_g = this._panel) || void 0 === _g || _g.webview.postMessage({
        command: "response",
        args: {
         id,
         syncRequestId,
         status: !0
        }
       });
      } catch (error) {
       null === (_h = this._panel) || void 0 === _h || _h.webview.postMessage({
        command: "response",
        args: {
         id,
         syncRequestId,
         status: !1
        }
       }), vscode_1.window.showErrorMessage((0, utils_1.extendErrorWithSupportLinks)("Could not send feedback: " + error.message)), 
       this.telemetry.sendTelemetryError("altimateLineageSendFeedbackError", error);
      } else try {
       const body = yield this.dbtLineageService.getConnectedColumns(Object.assign(Object.assign({}, params), {
        eventType: "column_lineage"
       }));
       null === (_e = this._panel) || void 0 === _e || _e.webview.postMessage({
        command: "response",
        args: {
         id,
         syncRequestId,
         body,
         status: !!body
        }
       });
      } catch (error) {
       vscode_1.window.showErrorMessage((0, utils_1.extendErrorWithSupportLinks)("Unable to generate lineage: " + error.message)), 
       null === (_f = this._panel) || void 0 === _f || _f.webview.postMessage({
        command: "response",
        args: {
         id,
         error,
         status: !1
        }
       }), this.telemetry.sendTelemetryError("columnLineageUnknownError", {
        params
       });
      } else {
       const body = yield this.getExposureDetails(params);
       null === (_d = this._panel) || void 0 === _d || _d.webview.postMessage({
        command: "response",
        args: {
         id,
         syncRequestId,
         body,
         status: !0
        }
       });
      } else {
       const body = yield this.getColumns(params);
       null === (_c = this._panel) || void 0 === _c || _c.webview.postMessage({
        command: "response",
        args: {
         id,
         syncRequestId,
         body,
         status: !0
        }
       });
      } else {
       const body = this.dbtLineageService.getDownstreamTables(params);
       null === (_b = this._panel) || void 0 === _b || _b.webview.postMessage({
        command: "response",
        args: {
         id,
         syncRequestId,
         body,
         status: !0
        }
       });
      } else {
       const body = this.dbtLineageService.getUpstreamTables(params);
       null === (_a = this._panel) || void 0 === _a || _a.webview.postMessage({
        command: "response",
        args: {
         id,
         syncRequestId,
         body,
         status: !0
        }
       });
      } else vscode_1.commands.executeCommand("workbench.action.problems.focus");
     }));
    }
    addModelColumnsFromDB(project, node) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const columnsFromDB = yield project.getColumnsOfModel(node.name);
      return console.log("addColumnsFromDB: ", node.name, " -> ", columnsFromDB), project.mergeColumnsFromDB(node, columnsFromDB);
     }));
    }
    addSourceColumnsFromDB(project, nodeName, table) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const columnsFromDB = yield project.getColumnsOfSource(nodeName, table.name);
      return console.log("addColumnsFromDB: ", nodeName, " -> ", columnsFromDB), project.mergeColumnsFromDB(table, columnsFromDB);
     }));
    }
    getExposureDetails({name}) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const event = this.queryManifestService.getEventByCurrentProject();
      if (!(null == event ? void 0 : event.event)) return;
      if (!this.queryManifestService.getProject()) return;
      const {exposureMetaMap} = event.event;
      return exposureMetaMap.get(name);
     }));
    }
    getColumns({table, refresh}) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const event = this.queryManifestService.getEventByCurrentProject();
      if (!(null == event ? void 0 : event.event)) return;
      const project = this.queryManifestService.getProject();
      if (!project) return;
      const splits = table.split(".");
      if (splits[0] === dbtProject_1.DBTProject.RESOURCE_TYPE_SOURCE) {
       const {sourceMetaMap} = event.event, sourceName = splits[2], tableName = splits[3], node = sourceMetaMap.get(sourceName);
       if (!node) return;
       const _table = node.tables.find((t => t.name === tableName));
       if (!_table) return;
       if (refresh) {
        if (!(yield vscode_1.window.withProgress({
         title: "Fetching metadata",
         location: vscode_1.ProgressLocation.Notification,
         cancellable: !1
        }, (() => tslib_1.__awaiter(this, void 0, void 0, (function*() {
         return yield this.addSourceColumnsFromDB(project, node.name, _table);
        })))))) return void vscode_1.window.showErrorMessage((0, utils_1.extendErrorWithSupportLinks)("Unable to get columns from DB for model: " + node.name + " table: " + _table.name + "."));
       }
       return {
        id: table,
        purpose: _table.description,
        columns: Object.values(_table.columns).map((c => {
         var _a;
         return {
          table,
          name: c.name,
          datatype: (null === (_a = c.data_type) || void 0 === _a ? void 0 : _a.toLowerCase()) || "",
          can_lineage_expand: !1,
          description: c.description
         };
        })).sort(((a, b) => a.name.localeCompare(b.name)))
       };
      }
      const {nodeMetaMap} = event.event, node = nodeMetaMap.lookupByUniqueId(table);
      if (node) {
       if (refresh) {
        if ("ephemeral" === node.config.materialized) return void vscode_1.window.showInformationMessage("Cannot fetch columns for ephemeral models.");
        if (!(yield vscode_1.window.withProgress({
         title: "Fetching metadata",
         location: vscode_1.ProgressLocation.Notification,
         cancellable: !1
        }, (() => tslib_1.__awaiter(this, void 0, void 0, (function*() {
         return yield this.addModelColumnsFromDB(project, node);
        })))))) return void vscode_1.window.showErrorMessage((0, utils_1.extendErrorWithSupportLinks)("Unable to get columns from DB for model: " + node.name + " table: " + table + "."));
       }
       return {
        id: table,
        purpose: node.description,
        columns: Object.values(node.columns).map((c => {
         var _a;
         return {
          table,
          name: c.name,
          datatype: (null === (_a = c.data_type) || void 0 === _a ? void 0 : _a.toLowerCase()) || "",
          can_lineage_expand: !1,
          description: c.description
         };
        })).sort(((a, b) => a.name.localeCompare(b.name)))
       };
      }
     }));
    }
    getFilename() {
     return path.basename(vscode_1.window.activeTextEditor.document.fileName, ".sql");
    }
    getMissingLineageMessage() {
     var _a;
     try {
      null === (_a = this.queryManifestService.getProject()) || void 0 === _a || _a.throwDiagnosticsErrorIfAvailable();
     } catch (err) {
      return this.dbtTerminal.error("Lineage:getMissingLineageMessage", err.message, err), 
      {
       message: err.message,
       type: "error"
      };
     }
     return {
      message: "A valid dbt file (model, seed etc.) needs to be open and active in the editor area above to view lineage",
      type: "warning"
     };
    }
    getStartingNode() {
     const aiEnabled = this.altimate.enabled(), event = this.queryManifestService.getEventByCurrentProject();
     if (!(null == event ? void 0 : event.event)) return this.dbtTerminal.info("Lineage:getStartingNode", "No event found"), 
     {
      aiEnabled,
      missingLineageMessage: this.getMissingLineageMessage()
     };
     const {nodeMetaMap} = event.event, tableName = this.getFilename(), _node = nodeMetaMap.lookupByBaseName(tableName);
     if (!_node) return this.dbtTerminal.info("Lineage:getStartingNode", `No node found for ${tableName}`), 
     {
      aiEnabled,
      missingLineageMessage: this.getMissingLineageMessage()
     };
     const key = _node.uniqueId, url = vscode_1.window.activeTextEditor.document.uri.path;
     return {
      node: this.dbtLineageService.createTable(event.event, url, key),
      aiEnabled
     };
    }
    renderWebviewView(webview) {
     this._panel.webview.html = super.getHtml(webview, this.dbtProjectContainer.extensionUri);
    }
   };
   NewLineagePanel = NewLineagePanel_1 = tslib_1.__decorate([ (0, utils_1.provideSingleton)(NewLineagePanel_1), tslib_1.__metadata("design:paramtypes", [ dbtProjectContainer_1.DBTProjectContainer, altimate_1.AltimateRequest, telemetry_1.TelemetryService, dbtTerminal_1.DBTTerminal, dbtLineageService_1.DbtLineageService, sharedStateService_1.SharedStateService, queryManifestService_1.QueryManifestService, usersService_1.UsersService ]) ], NewLineagePanel), 
   exports.NewLineagePanel = NewLineagePanel;
  },
  87639: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var QueryResultPanel_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.QueryResultPanel = void 0;
   const tslib_1 = __webpack_require__(31635), vscode_1 = __webpack_require__(54980), python_bridge_1 = __webpack_require__(63283), dbtProjectContainer_1 = __webpack_require__(82018), utils_1 = __webpack_require__(86185), telemetry_1 = __webpack_require__(22644), altimate_1 = __webpack_require__(91741), dbtIntegration_1 = __webpack_require__(22373), sharedStateService_1 = __webpack_require__(37712), altimateWebviewProvider_1 = __webpack_require__(56183), dbtTerminal_1 = __webpack_require__(83683), queryManifestService_1 = __webpack_require__(59269), usersService_1 = __webpack_require__(8502), events_1 = __webpack_require__(91723);
   var QueryPanelViewType, OutboundCommand, InboundCommand;
   !function(QueryPanelViewType) {
    QueryPanelViewType[QueryPanelViewType.DEFAULT = 0] = "DEFAULT", QueryPanelViewType[QueryPanelViewType.OPEN_RESULTS_IN_TAB = 1] = "OPEN_RESULTS_IN_TAB", 
    QueryPanelViewType[QueryPanelViewType.OPEN_RESULTS_FROM_HISTORY_BOOKMARKS = 2] = "OPEN_RESULTS_FROM_HISTORY_BOOKMARKS";
   }(QueryPanelViewType || (QueryPanelViewType = {})), function(OutboundCommand) {
    OutboundCommand.RenderQuery = "renderQuery", OutboundCommand.RenderLoading = "renderLoading", 
    OutboundCommand.RenderError = "renderError", OutboundCommand.InjectConfig = "injectConfig", 
    OutboundCommand.ResetState = "resetState", OutboundCommand.GetContext = "getContext";
   }(OutboundCommand || (OutboundCommand = {})), function(InboundCommand) {
    InboundCommand.CollectQueryResultsDebugInfo = "collectQueryResultsDebugInfo", InboundCommand.Info = "info", 
    InboundCommand.Error = "error", InboundCommand.UpdateConfig = "updateConfig", InboundCommand.OpenUrl = "openUrl", 
    InboundCommand.GetSummary = "getSummary", InboundCommand.CancelQuery = "cancelQuery", 
    InboundCommand.SetContext = "setContext", InboundCommand.GetQueryPanelContext = "getQueryPanelContext", 
    InboundCommand.GetQueryHistory = "getQueryHistory", InboundCommand.ExecuteQuery = "executeQuery", 
    InboundCommand.GetQueryTabData = "getQueryTabData", InboundCommand.RunAdhocQuery = "runAdhocQuery", 
    InboundCommand.ViewResultSet = "viewResultSet", InboundCommand.OpenCodeInEditor = "openCodeInEditor", 
    InboundCommand.ClearQueryHistory = "clearQueryHistory";
   }(InboundCommand || (InboundCommand = {}));
   let QueryResultPanel = QueryResultPanel_1 = class extends altimateWebviewProvider_1.AltimateWebviewProvider {
    constructor(dbtProjectContainer, telemetry, altimate, eventEmitterService, dbtTerminal, queryManifestService, usersService) {
     super(dbtProjectContainer, altimate, telemetry, eventEmitterService, dbtTerminal, queryManifestService, usersService), 
     this.dbtProjectContainer = dbtProjectContainer, this.telemetry = telemetry, this.altimate = altimate, 
     this.eventEmitterService = eventEmitterService, this.dbtTerminal = dbtTerminal, 
     this.queryManifestService = queryManifestService, this.usersService = usersService, 
     this.viewPath = "/query-panel", this.panelDescription = "Query results panel", this.incomingMessages = [], 
     this._queryHistory = [], this.sendQueryTabViewEvent = () => {
      this.telemetry.sendTelemetryEvent("QueryTabActive");
     }, this._disposables.push(vscode_1.workspace.onDidChangeConfiguration((e => {
      if (e.affectsConfiguration("dbt.disableQueryHistory") && this._panel && this.renderWebviewView(this._panel.webview), 
      e.affectsConfiguration("dbt.enableNotebooks")) {
       this.updateEnableNotebooksInContext();
       const event = vscode_1.workspace.getConfiguration("dbt").get("enableNotebooks", !1) ? "NotebooksEnabled" : "NotebooksDisabled";
       this.telemetry.sendTelemetryEvent(event);
      }
     }), this, this._disposables)), this.updateEnableNotebooksInContext(), this._disposables.push(vscode_1.commands.registerCommand("dbtPowerUser.collectQueryResultsDebugInfo", (() => this.collectQueryResultsDebugInfo())), this);
    }
    collectQueryResultsDebugInfo() {
     var _a, _b;
     console.log("Collecting query results debug info"), null === (_b = null === (_a = this._panel) || void 0 === _a ? void 0 : _a.webview) || void 0 === _b || _b.postMessage({
      command: "collectQueryResultsDebugInfo"
     });
    }
    updateEnableNotebooksInContext() {
     vscode_1.commands.executeCommand("setContext", "dbt.enableNotebooks", vscode_1.workspace.getConfiguration("dbt").get("enableNotebooks", !1));
    }
    createQueryResultsPanelVirtualDocument(editorName) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.isWebviewReady = !1;
      const webviewPanel = vscode_1.window.createWebviewPanel(QueryResultPanel_1.viewType, editorName + "_" + (0, 
      utils_1.getFormattedDateTime)(), {
       viewColumn: vscode_1.ViewColumn.Active
      }, {
       enableScripts: !0,
       retainContextWhenHidden: !0
      });
      this._panel = webviewPanel, this._webview = webviewPanel.webview, this.renderWebviewView(webviewPanel.webview), 
      this.setupWebviewHooks(), yield this.checkIfWebviewReady();
     }));
    }
    updateViewTypeToWebview(viewType) {
     this.sendResponseToWebview({
      command: "updateViewType",
      data: {
       type: viewType
      }
     });
    }
    onEvent({command, payload}) {
     const _super = Object.create(null, {
      onEvent: {
       get: () => super.onEvent
      }
     });
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      switch (command) {
      case "executeQuery":
       this.executeQuery(payload.query, payload.fn, payload.projectName);
       break;

      case "queryResultTab:render":
       this.dbtTerminal.debug("queryResultTab:render", "rendering query result tab", payload), 
       this._queryTabData = payload.queryTabData, this.createQueryResultsPanelVirtualDocument("Query results"), 
       this.updateViewTypeToWebview(QueryPanelViewType.OPEN_RESULTS_IN_TAB), this.sendQueryTabViewEvent();
       break;

      default:
       _super.onEvent.call(this, {
        command,
        payload
       });
      }
     }));
    }
    resolveWebviewView(panel, context, _token) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.updateViewTypeToWebview(QueryPanelViewType.DEFAULT), this._panel = panel, this._bottomPanel = panel, 
      this._webview = panel.webview, this.bindWebviewOptions(context), this.renderWebviewView(panel.webview), 
      this.setupWebviewHooks(), this.transmitConfig(), _token.onCancellationRequested((() => tslib_1.__awaiter(this, void 0, void 0, (function*() {
       yield this.transmitReset();
      })))), this.sendQueryPanelViewEvent(), this._panel.onDidChangeVisibility(this.sendQueryPanelViewEvent);
     }));
    }
    bindWebviewOptions(context) {
     this._panel && (this._panel.title = "Query Results", this.isWebviewView(this._panel) && (this._panel.description = "Preview dbt SQL Results"), 
     this._panel.webview.options = {
      enableScripts: !0
     });
    }
    getProject(projectName) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      if (!projectName) return this.queryManifestService.getOrPickProjectFromWorkspace();
      const project = this.queryManifestService.getProjectByName(projectName);
      if (!project) throw new Error("Unable to find project to execute query");
      return project;
     }));
    }
    executeIncomingQuery(message) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      try {
       const isHistoryTab = Boolean(message.projectName), project = yield this.getProject(message.projectName);
       if (!project) throw new Error("Unable to find project to execute query");
       return yield this.createQueryResultsPanelVirtualDocument(message.editorName || "Custom query"), 
       this.updateViewTypeToWebview(QueryPanelViewType.OPEN_RESULTS_FROM_HISTORY_BOOKMARKS), 
       this.telemetry.sendTelemetryEvent(isHistoryTab ? "QueryHistoryExecuteSql" : "QueryBookmarkExecuteSql"), 
       void (yield project.executeSQL(message.query, ""));
      } catch (error) {
       vscode_1.window.showErrorMessage((0, utils_1.extendErrorWithSupportLinks)(error.message)), 
       this.dbtTerminal.error("ExecuteSqlError", "Unable to execute query", error);
      }
     }));
    }
    handleOpenCodeInEditor(message) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      vscode_1.commands.executeCommand("dbtPowerUser.createSqlFile", {
       code: null == message ? void 0 : message.code,
       name: null == message ? void 0 : message.name
      });
     }));
    }
    setupWebviewHooks() {
     const _super = Object.create(null, {
      handleCommand: {
       get: () => super.handleCommand
      }
     });
     this._panel.webview.onDidReceiveMessage((message => tslib_1.__awaiter(this, void 0, void 0, (function*() {
      switch (message.command) {
      case InboundCommand.ClearQueryHistory:
       this.telemetry.sendTelemetryError(events_1.TelemetryEvents["QueryHistory/Cleared"], message.error), 
       this._queryHistory = [], this.sendResponseToWebview({
        command: "response",
        data: {},
        syncRequestId: message.syncRequestId
       });
       break;

      case InboundCommand.OpenCodeInEditor:
       this.handleOpenCodeInEditor(message);
       break;

      case InboundCommand.ViewResultSet:
       const queryHistoryData = message.queryHistory;
       this._queryTabData = {
        queryResults: {
         data: queryHistoryData.data,
         columnNames: queryHistoryData.columnNames,
         columnTypes: queryHistoryData.columnTypes
        },
        compiledCodeMarkup: queryHistoryData.compiledSql,
        rawSql: queryHistoryData.rawSql,
        elapsedTime: {
         queryExecutionInfo: {
          elapsedTime: queryHistoryData.duration
         }
        }
       }, this.createQueryResultsPanelVirtualDocument(message.editorName || "Custom query"), 
       this.updateViewTypeToWebview(QueryPanelViewType.OPEN_RESULTS_IN_TAB);
       break;

      case InboundCommand.RunAdhocQuery:
       vscode_1.commands.executeCommand("dbtPowerUser.createSqlFile", {
        fileName: "Custom Query"
       });
       break;

      case InboundCommand.ExecuteQuery:
       yield this.executeIncomingQuery(message);
       break;

      case InboundCommand.GetQueryHistory:
       this.sendResponseToWebview({
        command: "queryHistory",
        data: this._queryHistory
       });
       break;

      case InboundCommand.GetQueryTabData:
       this.sendResponseToWebview({
        command: "response",
        data: this._queryTabData,
        syncRequestId: message.syncRequestId
       }), this._queryTabData && (this._panel = this._bottomPanel, this._queryTabData = void 0);
       break;

      case InboundCommand.GetQueryPanelContext:
       {
        const perspectiveTheme = vscode_1.workspace.getConfiguration("dbt").get("perspectiveTheme", "Vintage"), queryHistoryDisabled = vscode_1.workspace.getConfiguration("dbt").get("disableQueryHistory", !1), limit = vscode_1.workspace.getConfiguration("dbt").get("queryLimit");
        yield this._panel.webview.postMessage({
         command: OutboundCommand.GetContext,
         limit,
         perspectiveTheme,
         queryHistoryDisabled
        });
       }
       break;

      case InboundCommand.CancelQuery:
       this.queryExecution && this.queryExecution.cancel(), yield this.transmitReset();
       break;

      case InboundCommand.Error:
       const error = message;
       vscode_1.window.showErrorMessage(error.text);
       break;

      case InboundCommand.Info:
       const info = message;
       vscode_1.window.withProgress({
        title: info.text,
        location: vscode_1.ProgressLocation.Notification,
        cancellable: !1
       }, (() => tslib_1.__awaiter(this, void 0, void 0, (function*() {
        yield new Promise((timer => setTimeout(timer, 3e3)));
       }))));
       break;

      case InboundCommand.UpdateConfig:
       const configMessage = message;
       void 0 !== configMessage.limit && vscode_1.workspace.getConfiguration("dbt").update("queryLimit", configMessage.limit), 
       configMessage.scale && vscode_1.workspace.getConfiguration("dbt").update("queryScale", configMessage.scale), 
       "perspectiveTheme" in configMessage && vscode_1.workspace.getConfiguration("dbt").update("perspectiveTheme", configMessage.perspectiveTheme);
       break;

      case InboundCommand.OpenUrl:
       const config = message;
       vscode_1.env.openExternal(vscode_1.Uri.parse(config.url));
       break;

      case InboundCommand.GetSummary:
       const summary = message;
       this.eventEmitterService.fire({
        command: "dbtPowerUser.summarizeQuery",
        payload: {
         query: summary.compiledSql
        }
       });
       break;

      case InboundCommand.SetContext:
       this.dbtProjectContainer.setToGlobalState(message.key, message.value);
       break;

      case InboundCommand.CollectQueryResultsDebugInfo:
       const data = Object.assign(Object.assign({}, message), {
        historyItems: this._queryHistory.length,
        historySize: JSON.stringify(this._queryHistory).length
       });
       this.dbtTerminal.debug("CollectQueryResultsDebugInfo", "collecting query results debug info", data), 
       this.telemetry.sendTelemetryEvent("CollectQueryResultsDebugInfo", data);
       break;

      default:
       _super.handleCommand.call(this, message);
      }
     }))), this, this._disposables);
    }
    sendQueryPanelViewEvent() {
     var _a;
     (null === (_a = this._panel) || void 0 === _a ? void 0 : _a.visible) && this.telemetry.sendTelemetryEvent("QueryPanelActive");
    }
    renderWebviewView(webview) {
     this._panel.webview.html = super.getHtml(webview, this.dbtProjectContainer.extensionUri);
    }
    transmitData(columnNames, columnTypes, rows, raw_sql, compiled_sql) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const result = {
       columnNames,
       columnTypes,
       rows,
       raw_sql,
       compiled_sql
      };
      return this._panel && (yield this._panel.webview.postMessage(Object.assign({
       command: OutboundCommand.RenderQuery
      }, result))), result;
     }));
    }
    transmitError(error, raw_sql, compiled_sql) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this._panel && (yield this._panel.webview.postMessage(Object.assign({
       command: OutboundCommand.RenderError
      }, Object.assign(Object.assign({}, error), {
       raw_sql,
       compiled_sql
      }))));
     }));
    }
    transmitConfig() {
     const limit = vscode_1.workspace.getConfiguration("dbt").get("queryLimit");
     this._panel && this._panel.webview.postMessage(Object.assign({
      command: OutboundCommand.InjectConfig
     }, {
      limit,
      darkMode: ![ vscode_1.ColorThemeKind.Light, vscode_1.ColorThemeKind.HighContrastLight ].includes(vscode_1.window.activeColorTheme.kind),
      aiEnabled: this.altimate.enabled()
     }));
    }
    transmitLoading() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this._panel && this.isWebviewReady ? yield this._panel.webview.postMessage({
       command: OutboundCommand.RenderLoading
      }) : this.incomingMessages.push({
       command: OutboundCommand.RenderLoading
      });
     }));
    }
    transmitReset() {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this._panel && (yield this._panel.webview.postMessage({
       command: OutboundCommand.ResetState
      }));
     }));
    }
    transmitDataWrapper(result, query) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const rows = [];
      for (let i = 0; i < result.table.rows.length; i++) result.table.rows[i].forEach(((value, j) => {
       rows[i] = Object.assign(Object.assign({}, rows[i]), {
        [result.table.column_names[j]]: value
       });
      }));
      return yield this.transmitData(result.table.column_names, result.table.column_types, rows, query, result.compiled_sql);
     }));
    }
    updateQueryHistory(result, projectName, query, duration, modelName) {
     if (vscode_1.workspace.getConfiguration("dbt").get("disableQueryHistory", !1)) return;
     const project = projectName ? this.queryManifestService.getProjectByName(projectName) : this.queryManifestService.getProject();
     if (!project) return void this.dbtTerminal.debug("updateQueryHistory", "skipping query history update, no project found, may be executed from query history");
     (0, utils_1.getStringSizeInMb)(JSON.stringify(this._queryHistory)) > 3 && (this._queryHistory.pop(), 
     this.dbtTerminal.info("updateQueryHistory", "Query history size exceeded 3MB, cleared oldest entry")), 
     this._queryHistory.unshift({
      rawSql: query,
      compiledSql: result.compiled_sql,
      timestamp: Date.now(),
      duration,
      adapter: project.getAdapterType(),
      projectName: project.getProjectName(),
      data: result.rows,
      columnNames: result.columnNames,
      columnTypes: result.columnTypes,
      modelName
     }), this._queryHistory = this._queryHistory.splice(0, 10);
    }
    executeQuery(query, queryExecutionPromise, projectName) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const start = Date.now();
      yield vscode_1.commands.executeCommand("dbtPowerUser.PreviewResults.focus"), this._panel && this.isWebviewView(this._panel) && (this._panel.show(), 
      this._panel.webview.postMessage({
       command: "focus"
      })), this.transmitLoading();
      try {
       const queryExecution = this.queryExecution = yield queryExecutionPromise, output = yield queryExecution.executeQuery(), result = yield this.transmitDataWrapper(output, query);
       return this.updateQueryHistory(result, projectName, query, Date.now() - start, output.modelName), 
       result;
      } catch (exc) {
       if (exc instanceof python_bridge_1.PythonException) return "KeyboardInterrupt" === exc.exception.type.name ? void this.transmitReset() : (vscode_1.window.showErrorMessage("An error occured while trying to execute your query: " + exc.exception.message), 
       void (yield this.transmitError({
        error: {
         code: -1,
         message: exc.exception.message,
         data: JSON.stringify(exc.stack, null, 2)
        }
       }, query, query)));
       if (exc instanceof dbtIntegration_1.ExecuteSQLError) return vscode_1.window.showErrorMessage("An error occured while trying to execute your query: " + exc.message), 
       void (yield this.transmitError({
        error: {
         code: -1,
         message: exc.message,
         data: JSON.stringify(exc.stack, null, 2)
        }
       }, query, exc.compiled_sql));
       yield this.transmitError({
        error: {
         code: -1,
         message: `${exc}`,
         data: {}
        }
       }, query, query);
      } finally {
       this.queryExecution = void 0, this._panel = this._bottomPanel;
      }
     }));
    }
    onWebviewReady() {
     if (super.onWebviewReady(), this._panel) for (;this.incomingMessages.length; ) {
      const message = this.incomingMessages.pop();
      message && this.sendResponseToWebview(message);
     }
    }
   };
   QueryResultPanel.viewType = "dbtPowerUser.PreviewResults", QueryResultPanel = QueryResultPanel_1 = tslib_1.__decorate([ (0, 
   utils_1.provideSingleton)(QueryResultPanel_1), tslib_1.__metadata("design:paramtypes", [ dbtProjectContainer_1.DBTProjectContainer, telemetry_1.TelemetryService, altimate_1.AltimateRequest, sharedStateService_1.SharedStateService, dbtTerminal_1.DBTTerminal, queryManifestService_1.QueryManifestService, usersService_1.UsersService ]) ], QueryResultPanel), 
   exports.QueryResultPanel = QueryResultPanel;
  },
  58261: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var SQLLineagePanel_1;
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.SQLLineagePanel = void 0;
   const tslib_1 = __webpack_require__(31635), path = __webpack_require__(16928), vscode_1 = __webpack_require__(54980), altimate_1 = __webpack_require__(91741), dbtProjectContainer_1 = __webpack_require__(82018), utils_1 = __webpack_require__(86185), telemetry_1 = __webpack_require__(22644), dbtTerminal_1 = __webpack_require__(83683), crypto = __webpack_require__(76982), dbtProject_1 = __webpack_require__(38821), queryManifestService_1 = __webpack_require__(59269), altimateWebviewProvider_1 = __webpack_require__(56183), sharedStateService_1 = __webpack_require__(37712), usersService_1 = __webpack_require__(8502);
   let SQLLineagePanel = SQLLineagePanel_1 = class extends altimateWebviewProvider_1.AltimateWebviewProvider {
    constructor(dbtProjectContainer, altimate, telemetry, terminal, queryManifestService, eventEmitterService, usersService) {
     super(dbtProjectContainer, altimate, telemetry, eventEmitterService, terminal, queryManifestService, usersService), 
     this.dbtProjectContainer = dbtProjectContainer, this.altimate = altimate, this.telemetry = telemetry, 
     this.terminal = terminal, this.queryManifestService = queryManifestService, this.eventEmitterService = eventEmitterService, 
     this.usersService = usersService, this.viewPath = "/lineage", this.disposables = [], 
     vscode_1.window.onDidChangeActiveColorTheme((() => tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.changedActiveColorTheme();
     }))), null, this.disposables), this.activeTextEditor = vscode_1.window.activeTextEditor, 
     vscode_1.window.onDidChangeActiveTextEditor((event => {
      event && (this.activeTextEditor = event);
     }));
    }
    dispose() {
     for (;this.disposables.length; ) {
      const x = this.disposables.pop();
      x && x.dispose();
     }
    }
    changedActiveColorTheme() {
     if (!this._panel) return;
     const theme = [ vscode_1.ColorThemeKind.Light, vscode_1.ColorThemeKind.HighContrastLight ].includes(vscode_1.window.activeColorTheme.kind) ? "light" : "dark";
     this._panel.webview.postMessage({
      command: "setTheme",
      args: {
       theme
      }
     });
    }
    getEvent() {
     var _a;
     const currentFilePath = null === (_a = this.activeTextEditor) || void 0 === _a ? void 0 : _a.document.uri;
     if (currentFilePath) return this.queryManifestService.getEventByDocument(currentFilePath);
    }
    getActiveEditorFilename() {
     return path.basename(this.activeTextEditor.document.fileName, ".sql");
    }
    getProject() {
     var _a;
     const currentFilePath = null === (_a = this.activeTextEditor) || void 0 === _a ? void 0 : _a.document.uri;
     if (currentFilePath) return this.queryManifestService.getProjectByUri(currentFilePath);
    }
    getMissingLineageMessage() {
     var _a;
     try {
      null === (_a = this.getProject()) || void 0 === _a || _a.throwDiagnosticsErrorIfAvailable();
     } catch (err) {
      return err.message;
     }
     return "A valid dbt file (model, seed etc.) needs to be open and active in the editor area above to view lineage";
    }
    getSQLLineage(token) {
     var _a;
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const event = this.getEvent();
      if (!event) throw new Error(this.getMissingLineageMessage());
      const {nodeMetaMap, sourceMetaMap} = event, project = this.getProject();
      if (!project) throw new Error("Unable to find the project");
      const modelName = this.getActiveEditorFilename(), currentFile = null === (_a = this.activeTextEditor) || void 0 === _a ? void 0 : _a.document.uri;
      if (!currentFile) throw new Error("Unable to get current file");
      const fileContentBytes = yield vscode_1.workspace.fs.readFile(currentFile), compiledSQL = yield project.unsafeCompileQuery(fileContentBytes.toString(), modelName);
      if (!compiledSQL) throw new Error(`Unable to compile sql for model ${modelName}`);
      const currNode = nodeMetaMap.lookupByBaseName(modelName);
      if (!currNode) throw new Error(`Unable to find model for model ${modelName}`);
      let model_info = [];
      const config = vscode_1.workspace.getConfiguration("dbt.lineage"), modelId = currNode.uniqueId, modelsToFetch = dbtProject_1.DBTProject.getNonEphemeralParents(event, [ modelId ]);
      let shouldFetchSchema = !1;
      if (currNode.path) {
       const sql = (yield vscode_1.workspace.fs.readFile(vscode_1.Uri.file(currNode.path))).toString();
       shouldFetchSchema = !(yield project.validateWhetherSqlHasColumns(sql));
      }
      if (config.get("useSchemaForQueryVisualizer", !1) || shouldFetchSchema) {
       const {mappedNode} = yield project.getNodesWithDBColumns(event, modelsToFetch, token);
       model_info = modelsToFetch.map((n => ({
        model_node: mappedNode[n]
       })));
      }
      const hash = crypto.createHash("md5").update(compiledSQL).digest("hex"), sessionId = `${vscode_1.env.sessionId}-${hash}`, response = yield this.altimate.sqlLineage({
       compiled_sql: compiledSQL,
       model_info,
       model_dialect: project.getAdapterType(),
       session_id: sessionId
      }), {details, nodePositions} = response, nodeMapping = {};
      for (const modelId of modelsToFetch) {
       const splits = modelId.split(".");
       if ("source" === splits[0]) {
        const _source = sourceMetaMap.get(splits[splits.length - 2]), _table = splits[splits.length - 1].toLowerCase();
        if (_source) {
         for (const key in details) if ("table" === details[key].type && key.toLowerCase() === _table) {
          nodeMapping[key] = {
           nodeId: modelId,
           type: "source"
          };
          break;
         }
         continue;
        }
       }
       const _node = nodeMetaMap.lookupByUniqueId(modelId);
       if (_node) {
        for (const key in details) if ("table" === details[key].type && key.toLowerCase() === _node.alias.toLowerCase()) {
         nodeMapping[key] = {
          nodeId: modelId,
          type: _node.resource_type
         };
         break;
        }
       } else ;
      }
      nodeMapping[modelName] = {
       nodeId: currNode.uniqueId,
       type: currNode.resource_type
      };
      const tableEdges = response.tableEdges.map((edge => edge.map((item => "__final_select__" === item ? modelName : item))));
      details[modelName] = details.__final_select__, delete details.__final_select__;
      for (const k in details) details[k] = Object.assign(Object.assign({}, details[k]), nodeMapping[k]), 
      k === modelName && (details[k].name = modelName);
      return nodePositions && (nodePositions[modelName] = nodePositions.__final_select__, 
      delete nodePositions.__final_select__), {
       tableEdges,
       details,
       nodePositions
      };
     }));
    }
    renderSqlVisualizer(panel, lineage) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.terminal.debug("sqlLineagePanel:resolveWebviewView", "onResolveWebviewView"), 
      this._panel = panel, this.renderWebviewView(panel.webview), yield this.checkIfWebviewReady(), 
      panel.webview.postMessage({
       command: "render",
       args: lineage
      });
     }));
    }
    handleCommand(message) {
     const _super = Object.create(null, {
      handleCommand: {
       get: () => super.handleCommand
      }
     });
     var _a, _b;
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      this.terminal.debug("sqlLineagePanel:handleWebviewMessage", "message", message);
      const {command, args = {}, syncRequestId} = message, {id, params} = args;
      switch (command) {
      case "openFile":
       const {url} = args;
       if (!url) return;
       yield vscode_1.commands.executeCommand("vscode.open", vscode_1.Uri.file(url), {
        preview: !1,
        preserveFocus: !0
       });
       break;

      case "getColumns":
       const body = yield this.getColumns(params);
       null === (_a = this._panel) || void 0 === _a || _a.webview.postMessage({
        command: "response",
        args: {
         id,
         syncRequestId,
         body,
         status: !0
        }
       });
       break;

      case "getLineageSettings":
       const config = vscode_1.workspace.getConfiguration("dbt.lineage");
       null === (_b = this._panel) || void 0 === _b || _b.webview.postMessage({
        command: "response",
        args: {
         id,
         syncRequestId,
         status: !0,
         body: {
          showSelectEdges: config.get("showSelectEdges", !0),
          showNonSelectEdges: config.get("showNonSelectEdges", !0),
          defaultExpansion: config.get("defaultExpansion", 1),
          useSchemaForQueryVisualizer: config.get("useSchemaForQueryVisualizer", !1)
         }
        }
       });
       break;

      default:
       _super.handleCommand.call(this, message);
      }
     }));
    }
    addModelColumnsFromDB(project, node) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const columnsFromDB = yield project.getColumnsOfModel(node.name);
      return console.log("addColumnsFromDB: ", node.name, " -> ", columnsFromDB), project.mergeColumnsFromDB(node, columnsFromDB);
     }));
    }
    addSourceColumnsFromDB(project, nodeName, table) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const columnsFromDB = yield project.getColumnsOfSource(nodeName, table.name);
      return console.log("addColumnsFromDB: ", nodeName, " -> ", columnsFromDB), project.mergeColumnsFromDB(table, columnsFromDB);
     }));
    }
    getColumns({table, refresh}) {
     return tslib_1.__awaiter(this, void 0, void 0, (function*() {
      const event = this.getEvent();
      if (!event) return;
      const project = this.getProject();
      if (!project) return;
      const splits = table.split(".");
      if (splits[0] === dbtProject_1.DBTProject.RESOURCE_TYPE_SOURCE) {
       const {sourceMetaMap} = event, sourceName = splits[2], tableName = splits[3], node = sourceMetaMap.get(sourceName);
       if (!node) return;
       const _table = node.tables.find((t => t.name === tableName));
       if (!_table) return;
       if (refresh) {
        if (!(yield vscode_1.window.withProgress({
         title: "Fetching metadata",
         location: vscode_1.ProgressLocation.Notification,
         cancellable: !1
        }, (() => tslib_1.__awaiter(this, void 0, void 0, (function*() {
         return yield this.addSourceColumnsFromDB(project, node.name, _table);
        })))))) return void vscode_1.window.showErrorMessage((0, utils_1.extendErrorWithSupportLinks)("Unable to get columns from DB for model: " + node.name + " table: " + _table.name + "."));
       }
       return {
        id: table,
        purpose: _table.description,
        columns: Object.values(_table.columns).map((c => {
         var _a;
         return {
          table,
          name: c.name,
          datatype: (null === (_a = c.data_type) || void 0 === _a ? void 0 : _a.toLowerCase()) || "",
          can_lineage_expand: !1,
          description: c.description
         };
        })).sort(((a, b) => a.name.localeCompare(b.name)))
       };
      }
      const {nodeMetaMap} = event, node = nodeMetaMap.lookupByUniqueId(table);
      if (node) {
       if (refresh) {
        if ("ephemeral" === node.config.materialized) return void vscode_1.window.showInformationMessage("Cannot fetch columns for ephemeral models.");
        if (!(yield vscode_1.window.withProgress({
         title: "Fetching metadata",
         location: vscode_1.ProgressLocation.Notification,
         cancellable: !1
        }, (() => tslib_1.__awaiter(this, void 0, void 0, (function*() {
         return yield this.addModelColumnsFromDB(project, node);
        })))))) return void vscode_1.window.showErrorMessage((0, utils_1.extendErrorWithSupportLinks)("Unable to get columns from DB for model: " + node.name + " table: " + table + "."));
       }
       return {
        id: table,
        purpose: node.description,
        columns: Object.values(node.columns).map((c => {
         var _a;
         return {
          table,
          name: c.name,
          datatype: (null === (_a = c.data_type) || void 0 === _a ? void 0 : _a.toLowerCase()) || "",
          can_lineage_expand: !1,
          description: c.description
         };
        })).sort(((a, b) => a.name.localeCompare(b.name)))
       };
      }
     }));
    }
   };
   SQLLineagePanel.viewType = "dbtPowerUser.sqlLineage", SQLLineagePanel = SQLLineagePanel_1 = tslib_1.__decorate([ (0, 
   utils_1.provideSingleton)(SQLLineagePanel_1), tslib_1.__metadata("design:paramtypes", [ dbtProjectContainer_1.DBTProjectContainer, altimate_1.AltimateRequest, telemetry_1.TelemetryService, dbtTerminal_1.DBTTerminal, queryManifestService_1.QueryManifestService, sharedStateService_1.SharedStateService, usersService_1.UsersService ]) ], SQLLineagePanel), 
   exports.SQLLineagePanel = SQLLineagePanel;
  },
  61160: (module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   var required = __webpack_require__(92063), qs = __webpack_require__(73992), controlOrWhitespace = /^[\x00-\x20\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]+/, CRHTLF = /[\n\r\t]/g, slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//, port = /:\d+$/, protocolre = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\\/]+)?([\S\s]*)/i, windowsDriveLetter = /^[a-zA-Z]:/;
   function trimLeft(str) {
    return (str || "").toString().replace(controlOrWhitespace, "");
   }
   var rules = [ [ "#", "hash" ], [ "?", "query" ], function(address, url) {
    return isSpecial(url.protocol) ? address.replace(/\\/g, "/") : address;
   }, [ "/", "pathname" ], [ "@", "auth", 1 ], [ NaN, "host", void 0, 1, 1 ], [ /:(\d*)$/, "port", void 0, 1 ], [ NaN, "hostname", void 0, 1, 1 ] ], ignore = {
    hash: 1,
    query: 1
   };
   function lolcation(loc) {
    var key, location = ("undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {}).location || {}, finaldestination = {}, type = typeof (loc = loc || location);
    if ("blob:" === loc.protocol) finaldestination = new Url(unescape(loc.pathname), {}); else if ("string" === type) for (key in finaldestination = new Url(loc, {}), 
    ignore) delete finaldestination[key]; else if ("object" === type) {
     for (key in loc) key in ignore || (finaldestination[key] = loc[key]);
     void 0 === finaldestination.slashes && (finaldestination.slashes = slashes.test(loc.href));
    }
    return finaldestination;
   }
   function isSpecial(scheme) {
    return "file:" === scheme || "ftp:" === scheme || "http:" === scheme || "https:" === scheme || "ws:" === scheme || "wss:" === scheme;
   }
   function extractProtocol(address, location) {
    address = (address = trimLeft(address)).replace(CRHTLF, ""), location = location || {};
    var rest, match = protocolre.exec(address), protocol = match[1] ? match[1].toLowerCase() : "", forwardSlashes = !!match[2], otherSlashes = !!match[3], slashesCount = 0;
    return forwardSlashes ? otherSlashes ? (rest = match[2] + match[3] + match[4], slashesCount = match[2].length + match[3].length) : (rest = match[2] + match[4], 
    slashesCount = match[2].length) : otherSlashes ? (rest = match[3] + match[4], slashesCount = match[3].length) : rest = match[4], 
    "file:" === protocol ? slashesCount >= 2 && (rest = rest.slice(2)) : isSpecial(protocol) ? rest = match[4] : protocol ? forwardSlashes && (rest = rest.slice(2)) : slashesCount >= 2 && isSpecial(location.protocol) && (rest = match[4]), 
    {
     protocol,
     slashes: forwardSlashes || isSpecial(protocol),
     slashesCount,
     rest
    };
   }
   function Url(address, location, parser) {
    if (address = (address = trimLeft(address)).replace(CRHTLF, ""), !(this instanceof Url)) return new Url(address, location, parser);
    var relative, extracted, parse, instruction, index, key, instructions = rules.slice(), type = typeof location, url = this, i = 0;
    for ("object" !== type && "string" !== type && (parser = location, location = null), 
    parser && "function" != typeof parser && (parser = qs.parse), relative = !(extracted = extractProtocol(address || "", location = lolcation(location))).protocol && !extracted.slashes, 
    url.slashes = extracted.slashes || relative && location.slashes, url.protocol = extracted.protocol || location.protocol || "", 
    address = extracted.rest, ("file:" === extracted.protocol && (2 !== extracted.slashesCount || windowsDriveLetter.test(address)) || !extracted.slashes && (extracted.protocol || extracted.slashesCount < 2 || !isSpecial(url.protocol))) && (instructions[3] = [ /(.*)/, "pathname" ]); i < instructions.length; i++) "function" != typeof (instruction = instructions[i]) ? (parse = instruction[0], 
    key = instruction[1], parse != parse ? url[key] = address : "string" == typeof parse ? ~(index = "@" === parse ? address.lastIndexOf(parse) : address.indexOf(parse)) && ("number" == typeof instruction[2] ? (url[key] = address.slice(0, index), 
    address = address.slice(index + instruction[2])) : (url[key] = address.slice(index), 
    address = address.slice(0, index))) : (index = parse.exec(address)) && (url[key] = index[1], 
    address = address.slice(0, index.index)), url[key] = url[key] || relative && instruction[3] && location[key] || "", 
    instruction[4] && (url[key] = url[key].toLowerCase())) : address = instruction(address, url);
    parser && (url.query = parser(url.query)), relative && location.slashes && "/" !== url.pathname.charAt(0) && ("" !== url.pathname || "" !== location.pathname) && (url.pathname = function(relative, base) {
     if ("" === relative) return base;
     for (var path = (base || "/").split("/").slice(0, -1).concat(relative.split("/")), i = path.length, last = path[i - 1], unshift = !1, up = 0; i--; ) "." === path[i] ? path.splice(i, 1) : ".." === path[i] ? (path.splice(i, 1), 
     up++) : up && (0 === i && (unshift = !0), path.splice(i, 1), up--);
     return unshift && path.unshift(""), "." !== last && ".." !== last || path.push(""), 
     path.join("/");
    }(url.pathname, location.pathname)), "/" !== url.pathname.charAt(0) && isSpecial(url.protocol) && (url.pathname = "/" + url.pathname), 
    required(url.port, url.protocol) || (url.host = url.hostname, url.port = ""), url.username = url.password = "", 
    url.auth && (~(index = url.auth.indexOf(":")) ? (url.username = url.auth.slice(0, index), 
    url.username = encodeURIComponent(decodeURIComponent(url.username)), url.password = url.auth.slice(index + 1), 
    url.password = encodeURIComponent(decodeURIComponent(url.password))) : url.username = encodeURIComponent(decodeURIComponent(url.auth)), 
    url.auth = url.password ? url.username + ":" + url.password : url.username), url.origin = "file:" !== url.protocol && isSpecial(url.protocol) && url.host ? url.protocol + "//" + url.host : "null", 
    url.href = url.toString();
   }
   Url.prototype = {
    set: function(part, value, fn) {
     var url = this;
     switch (part) {
     case "query":
      "string" == typeof value && value.length && (value = (fn || qs.parse)(value)), url[part] = value;
      break;

     case "port":
      url[part] = value, required(value, url.protocol) ? value && (url.host = url.hostname + ":" + value) : (url.host = url.hostname, 
      url[part] = "");
      break;

     case "hostname":
      url[part] = value, url.port && (value += ":" + url.port), url.host = value;
      break;

     case "host":
      url[part] = value, port.test(value) ? (value = value.split(":"), url.port = value.pop(), 
      url.hostname = value.join(":")) : (url.hostname = value, url.port = "");
      break;

     case "protocol":
      url.protocol = value.toLowerCase(), url.slashes = !fn;
      break;

     case "pathname":
     case "hash":
      if (value) {
       var char = "pathname" === part ? "/" : "#";
       url[part] = value.charAt(0) !== char ? char + value : value;
      } else url[part] = value;
      break;

     case "username":
     case "password":
      url[part] = encodeURIComponent(value);
      break;

     case "auth":
      var index = value.indexOf(":");
      ~index ? (url.username = value.slice(0, index), url.username = encodeURIComponent(decodeURIComponent(url.username)), 
      url.password = value.slice(index + 1), url.password = encodeURIComponent(decodeURIComponent(url.password))) : url.username = encodeURIComponent(decodeURIComponent(value));
     }
     for (var i = 0; i < rules.length; i++) {
      var ins = rules[i];
      ins[4] && (url[ins[1]] = url[ins[1]].toLowerCase());
     }
     return url.auth = url.password ? url.username + ":" + url.password : url.username, 
     url.origin = "file:" !== url.protocol && isSpecial(url.protocol) && url.host ? url.protocol + "//" + url.host : "null", 
     url.href = url.toString(), url;
    },
    toString: function(stringify) {
     stringify && "function" == typeof stringify || (stringify = qs.stringify);
     var query, url = this, host = url.host, protocol = url.protocol;
     protocol && ":" !== protocol.charAt(protocol.length - 1) && (protocol += ":");
     var result = protocol + (url.protocol && url.slashes || isSpecial(url.protocol) ? "//" : "");
     return url.username ? (result += url.username, url.password && (result += ":" + url.password), 
     result += "@") : url.password ? (result += ":" + url.password, result += "@") : "file:" !== url.protocol && isSpecial(url.protocol) && !host && "/" !== url.pathname && (result += "@"), 
     (":" === host[host.length - 1] || port.test(url.hostname) && !url.port) && (host += ":"), 
     result += host + url.pathname, (query = "object" == typeof url.query ? stringify(url.query) : url.query) && (result += "?" !== query.charAt(0) ? "?" + query : query), 
     url.hash && (result += url.hash), result;
    }
   }, Url.extractProtocol = extractProtocol, Url.location = lolcation, Url.trimLeft = trimLeft, 
   Url.qs = qs, module.exports = Url;
  },
  45010: function(__unused_webpack_module, exports) {
   var factory;
   factory = function(exports) {
    "use strict";
    function noop() {}
    function typeIsObject(x) {
     return "object" == typeof x && null !== x || "function" == typeof x;
    }
    const rethrowAssertionErrorRejection = noop;
    function setFunctionName(fn, name) {
     try {
      Object.defineProperty(fn, "name", {
       value: name,
       configurable: !0
      });
     } catch (_a) {}
    }
    const originalPromise = Promise, originalPromiseThen = Promise.prototype.then, originalPromiseReject = Promise.reject.bind(originalPromise);
    function newPromise(executor) {
     return new originalPromise(executor);
    }
    function promiseResolvedWith(value) {
     return newPromise((resolve => resolve(value)));
    }
    function promiseRejectedWith(reason) {
     return originalPromiseReject(reason);
    }
    function PerformPromiseThen(promise, onFulfilled, onRejected) {
     return originalPromiseThen.call(promise, onFulfilled, onRejected);
    }
    function uponPromise(promise, onFulfilled, onRejected) {
     PerformPromiseThen(PerformPromiseThen(promise, onFulfilled, onRejected), void 0, rethrowAssertionErrorRejection);
    }
    function uponFulfillment(promise, onFulfilled) {
     uponPromise(promise, onFulfilled);
    }
    function uponRejection(promise, onRejected) {
     uponPromise(promise, void 0, onRejected);
    }
    function transformPromiseWith(promise, fulfillmentHandler, rejectionHandler) {
     return PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler);
    }
    function setPromiseIsHandledToTrue(promise) {
     PerformPromiseThen(promise, void 0, rethrowAssertionErrorRejection);
    }
    let _queueMicrotask = callback => {
     if ("function" == typeof queueMicrotask) _queueMicrotask = queueMicrotask; else {
      const resolvedPromise = promiseResolvedWith(void 0);
      _queueMicrotask = cb => PerformPromiseThen(resolvedPromise, cb);
     }
     return _queueMicrotask(callback);
    };
    function reflectCall(F, V, args) {
     if ("function" != typeof F) throw new TypeError("Argument is not a function");
     return Function.prototype.apply.call(F, V, args);
    }
    function promiseCall(F, V, args) {
     try {
      return promiseResolvedWith(reflectCall(F, V, args));
     } catch (value) {
      return promiseRejectedWith(value);
     }
    }
    class SimpleQueue {
     constructor() {
      this._cursor = 0, this._size = 0, this._front = {
       _elements: [],
       _next: void 0
      }, this._back = this._front, this._cursor = 0, this._size = 0;
     }
     get length() {
      return this._size;
     }
     push(element) {
      const oldBack = this._back;
      let newBack = oldBack;
      16383 === oldBack._elements.length && (newBack = {
       _elements: [],
       _next: void 0
      }), oldBack._elements.push(element), newBack !== oldBack && (this._back = newBack, 
      oldBack._next = newBack), ++this._size;
     }
     shift() {
      const oldFront = this._front;
      let newFront = oldFront;
      const oldCursor = this._cursor;
      let newCursor = oldCursor + 1;
      const elements = oldFront._elements, element = elements[oldCursor];
      return 16384 === newCursor && (newFront = oldFront._next, newCursor = 0), --this._size, 
      this._cursor = newCursor, oldFront !== newFront && (this._front = newFront), elements[oldCursor] = void 0, 
      element;
     }
     forEach(callback) {
      let i = this._cursor, node = this._front, elements = node._elements;
      for (;!(i === elements.length && void 0 === node._next || i === elements.length && (node = node._next, 
      elements = node._elements, i = 0, 0 === elements.length)); ) callback(elements[i]), 
      ++i;
     }
     peek() {
      const front = this._front, cursor = this._cursor;
      return front._elements[cursor];
     }
    }
    const AbortSteps = Symbol("[[AbortSteps]]"), ErrorSteps = Symbol("[[ErrorSteps]]"), CancelSteps = Symbol("[[CancelSteps]]"), PullSteps = Symbol("[[PullSteps]]"), ReleaseSteps = Symbol("[[ReleaseSteps]]");
    function ReadableStreamReaderGenericInitialize(reader, stream) {
     reader._ownerReadableStream = stream, stream._reader = reader, "readable" === stream._state ? defaultReaderClosedPromiseInitialize(reader) : "closed" === stream._state ? function(reader) {
      defaultReaderClosedPromiseInitialize(reader), defaultReaderClosedPromiseResolve(reader);
     }(reader) : defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);
    }
    function ReadableStreamReaderGenericCancel(reader, reason) {
     return ReadableStreamCancel(reader._ownerReadableStream, reason);
    }
    function ReadableStreamReaderGenericRelease(reader) {
     const stream = reader._ownerReadableStream;
     "readable" === stream._state ? defaultReaderClosedPromiseReject(reader, new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")) : function(reader, reason) {
      defaultReaderClosedPromiseInitializeAsRejected(reader, reason);
     }(reader, new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")), 
     stream._readableStreamController[ReleaseSteps](), stream._reader = void 0, reader._ownerReadableStream = void 0;
    }
    function readerLockException(name) {
     return new TypeError("Cannot " + name + " a stream using a released reader");
    }
    function defaultReaderClosedPromiseInitialize(reader) {
     reader._closedPromise = newPromise(((resolve, reject) => {
      reader._closedPromise_resolve = resolve, reader._closedPromise_reject = reject;
     }));
    }
    function defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {
     defaultReaderClosedPromiseInitialize(reader), defaultReaderClosedPromiseReject(reader, reason);
    }
    function defaultReaderClosedPromiseReject(reader, reason) {
     void 0 !== reader._closedPromise_reject && (setPromiseIsHandledToTrue(reader._closedPromise), 
     reader._closedPromise_reject(reason), reader._closedPromise_resolve = void 0, reader._closedPromise_reject = void 0);
    }
    function defaultReaderClosedPromiseResolve(reader) {
     void 0 !== reader._closedPromise_resolve && (reader._closedPromise_resolve(void 0), 
     reader._closedPromise_resolve = void 0, reader._closedPromise_reject = void 0);
    }
    const NumberIsFinite = Number.isFinite || function(x) {
     return "number" == typeof x && isFinite(x);
    }, MathTrunc = Math.trunc || function(v) {
     return v < 0 ? Math.ceil(v) : Math.floor(v);
    };
    function assertDictionary(obj, context) {
     if (void 0 !== obj && "object" != typeof (x = obj) && "function" != typeof x) throw new TypeError(`${context} is not an object.`);
     var x;
    }
    function assertFunction(x, context) {
     if ("function" != typeof x) throw new TypeError(`${context} is not a function.`);
    }
    function assertObject(x, context) {
     if (!function(x) {
      return "object" == typeof x && null !== x || "function" == typeof x;
     }(x)) throw new TypeError(`${context} is not an object.`);
    }
    function assertRequiredArgument(x, position, context) {
     if (void 0 === x) throw new TypeError(`Parameter ${position} is required in '${context}'.`);
    }
    function assertRequiredField(x, field, context) {
     if (void 0 === x) throw new TypeError(`${field} is required in '${context}'.`);
    }
    function convertUnrestrictedDouble(value) {
     return Number(value);
    }
    function censorNegativeZero(x) {
     return 0 === x ? 0 : x;
    }
    function convertUnsignedLongLongWithEnforceRange(value, context) {
     const upperBound = Number.MAX_SAFE_INTEGER;
     let x = Number(value);
     if (x = censorNegativeZero(x), !NumberIsFinite(x)) throw new TypeError(`${context} is not a finite number`);
     if (x = function(x) {
      return censorNegativeZero(MathTrunc(x));
     }(x), x < 0 || x > upperBound) throw new TypeError(`${context} is outside the accepted range of 0 to ${upperBound}, inclusive`);
     return NumberIsFinite(x) && 0 !== x ? x : 0;
    }
    function assertReadableStream(x, context) {
     if (!IsReadableStream(x)) throw new TypeError(`${context} is not a ReadableStream.`);
    }
    function AcquireReadableStreamDefaultReader(stream) {
     return new ReadableStreamDefaultReader(stream);
    }
    function ReadableStreamAddReadRequest(stream, readRequest) {
     stream._reader._readRequests.push(readRequest);
    }
    function ReadableStreamFulfillReadRequest(stream, chunk, done) {
     const readRequest = stream._reader._readRequests.shift();
     done ? readRequest._closeSteps() : readRequest._chunkSteps(chunk);
    }
    function ReadableStreamGetNumReadRequests(stream) {
     return stream._reader._readRequests.length;
    }
    function ReadableStreamHasDefaultReader(stream) {
     const reader = stream._reader;
     return void 0 !== reader && !!IsReadableStreamDefaultReader(reader);
    }
    class ReadableStreamDefaultReader {
     constructor(stream) {
      if (assertRequiredArgument(stream, 1, "ReadableStreamDefaultReader"), assertReadableStream(stream, "First parameter"), 
      IsReadableStreamLocked(stream)) throw new TypeError("This stream has already been locked for exclusive reading by another reader");
      ReadableStreamReaderGenericInitialize(this, stream), this._readRequests = new SimpleQueue;
     }
     get closed() {
      return IsReadableStreamDefaultReader(this) ? this._closedPromise : promiseRejectedWith(defaultReaderBrandCheckException("closed"));
     }
     cancel(reason = void 0) {
      return IsReadableStreamDefaultReader(this) ? void 0 === this._ownerReadableStream ? promiseRejectedWith(readerLockException("cancel")) : ReadableStreamReaderGenericCancel(this, reason) : promiseRejectedWith(defaultReaderBrandCheckException("cancel"));
     }
     read() {
      if (!IsReadableStreamDefaultReader(this)) return promiseRejectedWith(defaultReaderBrandCheckException("read"));
      if (void 0 === this._ownerReadableStream) return promiseRejectedWith(readerLockException("read from"));
      let resolvePromise, rejectPromise;
      const promise = newPromise(((resolve, reject) => {
       resolvePromise = resolve, rejectPromise = reject;
      }));
      return ReadableStreamDefaultReaderRead(this, {
       _chunkSteps: chunk => resolvePromise({
        value: chunk,
        done: !1
       }),
       _closeSteps: () => resolvePromise({
        value: void 0,
        done: !0
       }),
       _errorSteps: e => rejectPromise(e)
      }), promise;
     }
     releaseLock() {
      if (!IsReadableStreamDefaultReader(this)) throw defaultReaderBrandCheckException("releaseLock");
      void 0 !== this._ownerReadableStream && function(reader) {
       ReadableStreamReaderGenericRelease(reader);
       const e = new TypeError("Reader was released");
       ReadableStreamDefaultReaderErrorReadRequests(reader, e);
      }(this);
     }
    }
    function IsReadableStreamDefaultReader(x) {
     return !!typeIsObject(x) && !!Object.prototype.hasOwnProperty.call(x, "_readRequests") && x instanceof ReadableStreamDefaultReader;
    }
    function ReadableStreamDefaultReaderRead(reader, readRequest) {
     const stream = reader._ownerReadableStream;
     stream._disturbed = !0, "closed" === stream._state ? readRequest._closeSteps() : "errored" === stream._state ? readRequest._errorSteps(stream._storedError) : stream._readableStreamController[PullSteps](readRequest);
    }
    function ReadableStreamDefaultReaderErrorReadRequests(reader, e) {
     const readRequests = reader._readRequests;
     reader._readRequests = new SimpleQueue, readRequests.forEach((readRequest => {
      readRequest._errorSteps(e);
     }));
    }
    function defaultReaderBrandCheckException(name) {
     return new TypeError(`ReadableStreamDefaultReader.prototype.${name} can only be used on a ReadableStreamDefaultReader`);
    }
    Object.defineProperties(ReadableStreamDefaultReader.prototype, {
     cancel: {
      enumerable: !0
     },
     read: {
      enumerable: !0
     },
     releaseLock: {
      enumerable: !0
     },
     closed: {
      enumerable: !0
     }
    }), setFunctionName(ReadableStreamDefaultReader.prototype.cancel, "cancel"), setFunctionName(ReadableStreamDefaultReader.prototype.read, "read"), 
    setFunctionName(ReadableStreamDefaultReader.prototype.releaseLock, "releaseLock"), 
    "symbol" == typeof Symbol.toStringTag && Object.defineProperty(ReadableStreamDefaultReader.prototype, Symbol.toStringTag, {
     value: "ReadableStreamDefaultReader",
     configurable: !0
    });
    const AsyncIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf((async function*() {})).prototype);
    class ReadableStreamAsyncIteratorImpl {
     constructor(reader, preventCancel) {
      this._ongoingPromise = void 0, this._isFinished = !1, this._reader = reader, this._preventCancel = preventCancel;
     }
     next() {
      const nextSteps = () => this._nextSteps();
      return this._ongoingPromise = this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, nextSteps, nextSteps) : nextSteps(), 
      this._ongoingPromise;
     }
     return(value) {
      const returnSteps = () => this._returnSteps(value);
      return this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, returnSteps, returnSteps) : returnSteps();
     }
     _nextSteps() {
      if (this._isFinished) return Promise.resolve({
       value: void 0,
       done: !0
      });
      const reader = this._reader;
      let resolvePromise, rejectPromise;
      const promise = newPromise(((resolve, reject) => {
       resolvePromise = resolve, rejectPromise = reject;
      }));
      return ReadableStreamDefaultReaderRead(reader, {
       _chunkSteps: chunk => {
        this._ongoingPromise = void 0, _queueMicrotask((() => resolvePromise({
         value: chunk,
         done: !1
        })));
       },
       _closeSteps: () => {
        this._ongoingPromise = void 0, this._isFinished = !0, ReadableStreamReaderGenericRelease(reader), 
        resolvePromise({
         value: void 0,
         done: !0
        });
       },
       _errorSteps: reason => {
        this._ongoingPromise = void 0, this._isFinished = !0, ReadableStreamReaderGenericRelease(reader), 
        rejectPromise(reason);
       }
      }), promise;
     }
     _returnSteps(value) {
      if (this._isFinished) return Promise.resolve({
       value,
       done: !0
      });
      this._isFinished = !0;
      const reader = this._reader;
      if (!this._preventCancel) {
       const result = ReadableStreamReaderGenericCancel(reader, value);
       return ReadableStreamReaderGenericRelease(reader), transformPromiseWith(result, (() => ({
        value,
        done: !0
       })));
      }
      return ReadableStreamReaderGenericRelease(reader), promiseResolvedWith({
       value,
       done: !0
      });
     }
    }
    const ReadableStreamAsyncIteratorPrototype = {
     next() {
      return IsReadableStreamAsyncIterator(this) ? this._asyncIteratorImpl.next() : promiseRejectedWith(streamAsyncIteratorBrandCheckException("next"));
     },
     return(value) {
      return IsReadableStreamAsyncIterator(this) ? this._asyncIteratorImpl.return(value) : promiseRejectedWith(streamAsyncIteratorBrandCheckException("return"));
     }
    };
    function IsReadableStreamAsyncIterator(x) {
     if (!typeIsObject(x)) return !1;
     if (!Object.prototype.hasOwnProperty.call(x, "_asyncIteratorImpl")) return !1;
     try {
      return x._asyncIteratorImpl instanceof ReadableStreamAsyncIteratorImpl;
     } catch (_a) {
      return !1;
     }
    }
    function streamAsyncIteratorBrandCheckException(name) {
     return new TypeError(`ReadableStreamAsyncIterator.${name} can only be used on a ReadableSteamAsyncIterator`);
    }
    Object.setPrototypeOf(ReadableStreamAsyncIteratorPrototype, AsyncIteratorPrototype);
    const NumberIsNaN = Number.isNaN || function(x) {
     return x != x;
    };
    var _a, _b, _c;
    function CreateArrayFromList(elements) {
     return elements.slice();
    }
    function CopyDataBlockBytes(dest, destOffset, src, srcOffset, n) {
     new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);
    }
    let TransferArrayBuffer = O => (TransferArrayBuffer = "function" == typeof O.transfer ? buffer => buffer.transfer() : "function" == typeof structuredClone ? buffer => structuredClone(buffer, {
     transfer: [ buffer ]
    }) : buffer => buffer, TransferArrayBuffer(O)), IsDetachedBuffer = O => (IsDetachedBuffer = "boolean" == typeof O.detached ? buffer => buffer.detached : buffer => 0 === buffer.byteLength, 
    IsDetachedBuffer(O));
    function ArrayBufferSlice(buffer, begin, end) {
     if (buffer.slice) return buffer.slice(begin, end);
     const length = end - begin, slice = new ArrayBuffer(length);
     return CopyDataBlockBytes(slice, 0, buffer, begin, length), slice;
    }
    function GetMethod(receiver, prop) {
     const func = receiver[prop];
     if (null != func) {
      if ("function" != typeof func) throw new TypeError(`${String(prop)} is not a function`);
      return func;
     }
    }
    const SymbolAsyncIterator = null !== (_c = null !== (_a = Symbol.asyncIterator) && void 0 !== _a ? _a : null === (_b = Symbol.for) || void 0 === _b ? void 0 : _b.call(Symbol, "Symbol.asyncIterator")) && void 0 !== _c ? _c : "@@asyncIterator";
    function GetIterator(obj, hint = "sync", method) {
     if (void 0 === method) if ("async" === hint) {
      if (void 0 === (method = GetMethod(obj, SymbolAsyncIterator))) return function(syncIteratorRecord) {
       const syncIterable = {
        [Symbol.iterator]: () => syncIteratorRecord.iterator
       }, asyncIterator = async function*() {
        return yield* syncIterable;
       }();
       return {
        iterator: asyncIterator,
        nextMethod: asyncIterator.next,
        done: !1
       };
      }(GetIterator(obj, "sync", GetMethod(obj, Symbol.iterator)));
     } else method = GetMethod(obj, Symbol.iterator);
     if (void 0 === method) throw new TypeError("The object is not iterable");
     const iterator = reflectCall(method, obj, []);
     if (!typeIsObject(iterator)) throw new TypeError("The iterator method must return an object");
     return {
      iterator,
      nextMethod: iterator.next,
      done: !1
     };
    }
    function CloneAsUint8Array(O) {
     const buffer = ArrayBufferSlice(O.buffer, O.byteOffset, O.byteOffset + O.byteLength);
     return new Uint8Array(buffer);
    }
    function DequeueValue(container) {
     const pair = container._queue.shift();
     return container._queueTotalSize -= pair.size, container._queueTotalSize < 0 && (container._queueTotalSize = 0), 
     pair.value;
    }
    function EnqueueValueWithSize(container, value, size) {
     if ("number" != typeof (v = size) || NumberIsNaN(v) || v < 0 || size === 1 / 0) throw new RangeError("Size must be a finite, non-NaN, non-negative number.");
     var v;
     container._queue.push({
      value,
      size
     }), container._queueTotalSize += size;
    }
    function ResetQueue(container) {
     container._queue = new SimpleQueue, container._queueTotalSize = 0;
    }
    function isDataViewConstructor(ctor) {
     return ctor === DataView;
    }
    class ReadableStreamBYOBRequest {
     constructor() {
      throw new TypeError("Illegal constructor");
     }
     get view() {
      if (!IsReadableStreamBYOBRequest(this)) throw byobRequestBrandCheckException("view");
      return this._view;
     }
     respond(bytesWritten) {
      if (!IsReadableStreamBYOBRequest(this)) throw byobRequestBrandCheckException("respond");
      if (assertRequiredArgument(bytesWritten, 1, "respond"), bytesWritten = convertUnsignedLongLongWithEnforceRange(bytesWritten, "First parameter"), 
      void 0 === this._associatedReadableByteStreamController) throw new TypeError("This BYOB request has been invalidated");
      if (IsDetachedBuffer(this._view.buffer)) throw new TypeError("The BYOB request's buffer has been detached and so cannot be used as a response");
      ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);
     }
     respondWithNewView(view) {
      if (!IsReadableStreamBYOBRequest(this)) throw byobRequestBrandCheckException("respondWithNewView");
      if (assertRequiredArgument(view, 1, "respondWithNewView"), !ArrayBuffer.isView(view)) throw new TypeError("You can only respond with array buffer views");
      if (void 0 === this._associatedReadableByteStreamController) throw new TypeError("This BYOB request has been invalidated");
      if (IsDetachedBuffer(view.buffer)) throw new TypeError("The given view's buffer has been detached and so cannot be used as a response");
      ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);
     }
    }
    Object.defineProperties(ReadableStreamBYOBRequest.prototype, {
     respond: {
      enumerable: !0
     },
     respondWithNewView: {
      enumerable: !0
     },
     view: {
      enumerable: !0
     }
    }), setFunctionName(ReadableStreamBYOBRequest.prototype.respond, "respond"), setFunctionName(ReadableStreamBYOBRequest.prototype.respondWithNewView, "respondWithNewView"), 
    "symbol" == typeof Symbol.toStringTag && Object.defineProperty(ReadableStreamBYOBRequest.prototype, Symbol.toStringTag, {
     value: "ReadableStreamBYOBRequest",
     configurable: !0
    });
    class ReadableByteStreamController {
     constructor() {
      throw new TypeError("Illegal constructor");
     }
     get byobRequest() {
      if (!IsReadableByteStreamController(this)) throw byteStreamControllerBrandCheckException("byobRequest");
      return ReadableByteStreamControllerGetBYOBRequest(this);
     }
     get desiredSize() {
      if (!IsReadableByteStreamController(this)) throw byteStreamControllerBrandCheckException("desiredSize");
      return ReadableByteStreamControllerGetDesiredSize(this);
     }
     close() {
      if (!IsReadableByteStreamController(this)) throw byteStreamControllerBrandCheckException("close");
      if (this._closeRequested) throw new TypeError("The stream has already been closed; do not close it again!");
      const state = this._controlledReadableByteStream._state;
      if ("readable" !== state) throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be closed`);
      ReadableByteStreamControllerClose(this);
     }
     enqueue(chunk) {
      if (!IsReadableByteStreamController(this)) throw byteStreamControllerBrandCheckException("enqueue");
      if (assertRequiredArgument(chunk, 1, "enqueue"), !ArrayBuffer.isView(chunk)) throw new TypeError("chunk must be an array buffer view");
      if (0 === chunk.byteLength) throw new TypeError("chunk must have non-zero byteLength");
      if (0 === chunk.buffer.byteLength) throw new TypeError("chunk's buffer must have non-zero byteLength");
      if (this._closeRequested) throw new TypeError("stream is closed or draining");
      const state = this._controlledReadableByteStream._state;
      if ("readable" !== state) throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be enqueued to`);
      ReadableByteStreamControllerEnqueue(this, chunk);
     }
     error(e = void 0) {
      if (!IsReadableByteStreamController(this)) throw byteStreamControllerBrandCheckException("error");
      ReadableByteStreamControllerError(this, e);
     }
     [CancelSteps](reason) {
      ReadableByteStreamControllerClearPendingPullIntos(this), ResetQueue(this);
      const result = this._cancelAlgorithm(reason);
      return ReadableByteStreamControllerClearAlgorithms(this), result;
     }
     [PullSteps](readRequest) {
      const stream = this._controlledReadableByteStream;
      if (this._queueTotalSize > 0) return void ReadableByteStreamControllerFillReadRequestFromQueue(this, readRequest);
      const autoAllocateChunkSize = this._autoAllocateChunkSize;
      if (void 0 !== autoAllocateChunkSize) {
       let buffer;
       try {
        buffer = new ArrayBuffer(autoAllocateChunkSize);
       } catch (bufferE) {
        return void readRequest._errorSteps(bufferE);
       }
       const pullIntoDescriptor = {
        buffer,
        bufferByteLength: autoAllocateChunkSize,
        byteOffset: 0,
        byteLength: autoAllocateChunkSize,
        bytesFilled: 0,
        minimumFill: 1,
        elementSize: 1,
        viewConstructor: Uint8Array,
        readerType: "default"
       };
       this._pendingPullIntos.push(pullIntoDescriptor);
      }
      ReadableStreamAddReadRequest(stream, readRequest), ReadableByteStreamControllerCallPullIfNeeded(this);
     }
     [ReleaseSteps]() {
      if (this._pendingPullIntos.length > 0) {
       const firstPullInto = this._pendingPullIntos.peek();
       firstPullInto.readerType = "none", this._pendingPullIntos = new SimpleQueue, this._pendingPullIntos.push(firstPullInto);
      }
     }
    }
    function IsReadableByteStreamController(x) {
     return !!typeIsObject(x) && !!Object.prototype.hasOwnProperty.call(x, "_controlledReadableByteStream") && x instanceof ReadableByteStreamController;
    }
    function IsReadableStreamBYOBRequest(x) {
     return !!typeIsObject(x) && !!Object.prototype.hasOwnProperty.call(x, "_associatedReadableByteStreamController") && x instanceof ReadableStreamBYOBRequest;
    }
    function ReadableByteStreamControllerCallPullIfNeeded(controller) {
     const shouldPull = function(controller) {
      const stream = controller._controlledReadableByteStream;
      if ("readable" !== stream._state) return !1;
      if (controller._closeRequested) return !1;
      if (!controller._started) return !1;
      if (ReadableStreamHasDefaultReader(stream) && ReadableStreamGetNumReadRequests(stream) > 0) return !0;
      if (ReadableStreamHasBYOBReader(stream) && ReadableStreamGetNumReadIntoRequests(stream) > 0) return !0;
      const desiredSize = ReadableByteStreamControllerGetDesiredSize(controller);
      return desiredSize > 0;
     }(controller);
     shouldPull && (controller._pulling ? controller._pullAgain = !0 : (controller._pulling = !0, 
     uponPromise(controller._pullAlgorithm(), (() => (controller._pulling = !1, controller._pullAgain && (controller._pullAgain = !1, 
     ReadableByteStreamControllerCallPullIfNeeded(controller)), null)), (e => (ReadableByteStreamControllerError(controller, e), 
     null)))));
    }
    function ReadableByteStreamControllerClearPendingPullIntos(controller) {
     ReadableByteStreamControllerInvalidateBYOBRequest(controller), controller._pendingPullIntos = new SimpleQueue;
    }
    function ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {
     let done = !1;
     "closed" === stream._state && (done = !0);
     const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
     "default" === pullIntoDescriptor.readerType ? ReadableStreamFulfillReadRequest(stream, filledView, done) : function(stream, chunk, done) {
      const reader = stream._reader, readIntoRequest = reader._readIntoRequests.shift();
      done ? readIntoRequest._closeSteps(chunk) : readIntoRequest._chunkSteps(chunk);
     }(stream, filledView, done);
    }
    function ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {
     const bytesFilled = pullIntoDescriptor.bytesFilled, elementSize = pullIntoDescriptor.elementSize;
     return new pullIntoDescriptor.viewConstructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);
    }
    function ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {
     controller._queue.push({
      buffer,
      byteOffset,
      byteLength
     }), controller._queueTotalSize += byteLength;
    }
    function ReadableByteStreamControllerEnqueueClonedChunkToQueue(controller, buffer, byteOffset, byteLength) {
     let clonedChunk;
     try {
      clonedChunk = ArrayBufferSlice(buffer, byteOffset, byteOffset + byteLength);
     } catch (cloneE) {
      throw ReadableByteStreamControllerError(controller, cloneE), cloneE;
     }
     ReadableByteStreamControllerEnqueueChunkToQueue(controller, clonedChunk, 0, byteLength);
    }
    function ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue(controller, firstDescriptor) {
     firstDescriptor.bytesFilled > 0 && ReadableByteStreamControllerEnqueueClonedChunkToQueue(controller, firstDescriptor.buffer, firstDescriptor.byteOffset, firstDescriptor.bytesFilled), 
     ReadableByteStreamControllerShiftPendingPullInto(controller);
    }
    function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {
     const maxBytesToCopy = Math.min(controller._queueTotalSize, pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled), maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;
     let totalBytesToCopyRemaining = maxBytesToCopy, ready = !1;
     const maxAlignedBytes = maxBytesFilled - maxBytesFilled % pullIntoDescriptor.elementSize;
     maxAlignedBytes >= pullIntoDescriptor.minimumFill && (totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled, 
     ready = !0);
     const queue = controller._queue;
     for (;totalBytesToCopyRemaining > 0; ) {
      const headOfQueue = queue.peek(), bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength), destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
      CopyDataBlockBytes(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy), 
      headOfQueue.byteLength === bytesToCopy ? queue.shift() : (headOfQueue.byteOffset += bytesToCopy, 
      headOfQueue.byteLength -= bytesToCopy), controller._queueTotalSize -= bytesToCopy, 
      ReadableByteStreamControllerFillHeadPullIntoDescriptor(0, bytesToCopy, pullIntoDescriptor), 
      totalBytesToCopyRemaining -= bytesToCopy;
     }
     return ready;
    }
    function ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {
     pullIntoDescriptor.bytesFilled += size;
    }
    function ReadableByteStreamControllerHandleQueueDrain(controller) {
     0 === controller._queueTotalSize && controller._closeRequested ? (ReadableByteStreamControllerClearAlgorithms(controller), 
     ReadableStreamClose(controller._controlledReadableByteStream)) : ReadableByteStreamControllerCallPullIfNeeded(controller);
    }
    function ReadableByteStreamControllerInvalidateBYOBRequest(controller) {
     null !== controller._byobRequest && (controller._byobRequest._associatedReadableByteStreamController = void 0, 
     controller._byobRequest._view = null, controller._byobRequest = null);
    }
    function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {
     for (;controller._pendingPullIntos.length > 0; ) {
      if (0 === controller._queueTotalSize) return;
      const pullIntoDescriptor = controller._pendingPullIntos.peek();
      ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) && (ReadableByteStreamControllerShiftPendingPullInto(controller), 
      ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor));
     }
    }
    function ReadableByteStreamControllerPullInto(controller, view, min, readIntoRequest) {
     const stream = controller._controlledReadableByteStream, ctor = view.constructor, elementSize = function(ctor) {
      return isDataViewConstructor(ctor) ? 1 : ctor.BYTES_PER_ELEMENT;
     }(ctor), {byteOffset, byteLength} = view, minimumFill = min * elementSize;
     let buffer;
     try {
      buffer = TransferArrayBuffer(view.buffer);
     } catch (e) {
      return void readIntoRequest._errorSteps(e);
     }
     const pullIntoDescriptor = {
      buffer,
      bufferByteLength: buffer.byteLength,
      byteOffset,
      byteLength,
      bytesFilled: 0,
      minimumFill,
      elementSize,
      viewConstructor: ctor,
      readerType: "byob"
     };
     if (controller._pendingPullIntos.length > 0) return controller._pendingPullIntos.push(pullIntoDescriptor), 
     void ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
     if ("closed" !== stream._state) {
      if (controller._queueTotalSize > 0) {
       if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
        const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
        return ReadableByteStreamControllerHandleQueueDrain(controller), void readIntoRequest._chunkSteps(filledView);
       }
       if (controller._closeRequested) {
        const e = new TypeError("Insufficient bytes to fill elements in the given buffer");
        return ReadableByteStreamControllerError(controller, e), void readIntoRequest._errorSteps(e);
       }
      }
      controller._pendingPullIntos.push(pullIntoDescriptor), ReadableStreamAddReadIntoRequest(stream, readIntoRequest), 
      ReadableByteStreamControllerCallPullIfNeeded(controller);
     } else {
      const emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);
      readIntoRequest._closeSteps(emptyView);
     }
    }
    function ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {
     const firstDescriptor = controller._pendingPullIntos.peek();
     ReadableByteStreamControllerInvalidateBYOBRequest(controller), "closed" === controller._controlledReadableByteStream._state ? function(controller, firstDescriptor) {
      "none" === firstDescriptor.readerType && ReadableByteStreamControllerShiftPendingPullInto(controller);
      const stream = controller._controlledReadableByteStream;
      if (ReadableStreamHasBYOBReader(stream)) for (;ReadableStreamGetNumReadIntoRequests(stream) > 0; ) ReadableByteStreamControllerCommitPullIntoDescriptor(stream, ReadableByteStreamControllerShiftPendingPullInto(controller));
     }(controller, firstDescriptor) : function(controller, bytesWritten, pullIntoDescriptor) {
      if (ReadableByteStreamControllerFillHeadPullIntoDescriptor(0, bytesWritten, pullIntoDescriptor), 
      "none" === pullIntoDescriptor.readerType) return ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue(controller, pullIntoDescriptor), 
      void ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
      if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.minimumFill) return;
      ReadableByteStreamControllerShiftPendingPullInto(controller);
      const remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;
      if (remainderSize > 0) {
       const end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
       ReadableByteStreamControllerEnqueueClonedChunkToQueue(controller, pullIntoDescriptor.buffer, end - remainderSize, remainderSize);
      }
      pullIntoDescriptor.bytesFilled -= remainderSize, ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor), 
      ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
     }(controller, bytesWritten, firstDescriptor), ReadableByteStreamControllerCallPullIfNeeded(controller);
    }
    function ReadableByteStreamControllerShiftPendingPullInto(controller) {
     return controller._pendingPullIntos.shift();
    }
    function ReadableByteStreamControllerClearAlgorithms(controller) {
     controller._pullAlgorithm = void 0, controller._cancelAlgorithm = void 0;
    }
    function ReadableByteStreamControllerClose(controller) {
     const stream = controller._controlledReadableByteStream;
     if (!controller._closeRequested && "readable" === stream._state) if (controller._queueTotalSize > 0) controller._closeRequested = !0; else {
      if (controller._pendingPullIntos.length > 0) {
       const firstPendingPullInto = controller._pendingPullIntos.peek();
       if (firstPendingPullInto.bytesFilled % firstPendingPullInto.elementSize != 0) {
        const e = new TypeError("Insufficient bytes to fill elements in the given buffer");
        throw ReadableByteStreamControllerError(controller, e), e;
       }
      }
      ReadableByteStreamControllerClearAlgorithms(controller), ReadableStreamClose(stream);
     }
    }
    function ReadableByteStreamControllerEnqueue(controller, chunk) {
     const stream = controller._controlledReadableByteStream;
     if (controller._closeRequested || "readable" !== stream._state) return;
     const {buffer, byteOffset, byteLength} = chunk;
     if (IsDetachedBuffer(buffer)) throw new TypeError("chunk's buffer is detached and so cannot be enqueued");
     const transferredBuffer = TransferArrayBuffer(buffer);
     if (controller._pendingPullIntos.length > 0) {
      const firstPendingPullInto = controller._pendingPullIntos.peek();
      if (IsDetachedBuffer(firstPendingPullInto.buffer)) throw new TypeError("The BYOB request's buffer has been detached and so cannot be filled with an enqueued chunk");
      ReadableByteStreamControllerInvalidateBYOBRequest(controller), firstPendingPullInto.buffer = TransferArrayBuffer(firstPendingPullInto.buffer), 
      "none" === firstPendingPullInto.readerType && ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue(controller, firstPendingPullInto);
     }
     ReadableStreamHasDefaultReader(stream) ? (function(controller) {
      const reader = controller._controlledReadableByteStream._reader;
      for (;reader._readRequests.length > 0; ) {
       if (0 === controller._queueTotalSize) return;
       ReadableByteStreamControllerFillReadRequestFromQueue(controller, reader._readRequests.shift());
      }
     }(controller), 0 === ReadableStreamGetNumReadRequests(stream) ? ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength) : (controller._pendingPullIntos.length > 0 && ReadableByteStreamControllerShiftPendingPullInto(controller), 
     ReadableStreamFulfillReadRequest(stream, new Uint8Array(transferredBuffer, byteOffset, byteLength), !1))) : ReadableStreamHasBYOBReader(stream) ? (ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength), 
     ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller)) : ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength), 
     ReadableByteStreamControllerCallPullIfNeeded(controller);
    }
    function ReadableByteStreamControllerError(controller, e) {
     const stream = controller._controlledReadableByteStream;
     "readable" === stream._state && (ReadableByteStreamControllerClearPendingPullIntos(controller), 
     ResetQueue(controller), ReadableByteStreamControllerClearAlgorithms(controller), 
     ReadableStreamError(stream, e));
    }
    function ReadableByteStreamControllerFillReadRequestFromQueue(controller, readRequest) {
     const entry = controller._queue.shift();
     controller._queueTotalSize -= entry.byteLength, ReadableByteStreamControllerHandleQueueDrain(controller);
     const view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);
     readRequest._chunkSteps(view);
    }
    function ReadableByteStreamControllerGetBYOBRequest(controller) {
     if (null === controller._byobRequest && controller._pendingPullIntos.length > 0) {
      const firstDescriptor = controller._pendingPullIntos.peek(), view = new Uint8Array(firstDescriptor.buffer, firstDescriptor.byteOffset + firstDescriptor.bytesFilled, firstDescriptor.byteLength - firstDescriptor.bytesFilled), byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);
      !function(request, controller, view) {
       request._associatedReadableByteStreamController = controller, request._view = view;
      }(byobRequest, controller, view), controller._byobRequest = byobRequest;
     }
     return controller._byobRequest;
    }
    function ReadableByteStreamControllerGetDesiredSize(controller) {
     const state = controller._controlledReadableByteStream._state;
     return "errored" === state ? null : "closed" === state ? 0 : controller._strategyHWM - controller._queueTotalSize;
    }
    function ReadableByteStreamControllerRespond(controller, bytesWritten) {
     const firstDescriptor = controller._pendingPullIntos.peek();
     if ("closed" === controller._controlledReadableByteStream._state) {
      if (0 !== bytesWritten) throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream");
     } else {
      if (0 === bytesWritten) throw new TypeError("bytesWritten must be greater than 0 when calling respond() on a readable stream");
      if (firstDescriptor.bytesFilled + bytesWritten > firstDescriptor.byteLength) throw new RangeError("bytesWritten out of range");
     }
     firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer), ReadableByteStreamControllerRespondInternal(controller, bytesWritten);
    }
    function ReadableByteStreamControllerRespondWithNewView(controller, view) {
     const firstDescriptor = controller._pendingPullIntos.peek();
     if ("closed" === controller._controlledReadableByteStream._state) {
      if (0 !== view.byteLength) throw new TypeError("The view's length must be 0 when calling respondWithNewView() on a closed stream");
     } else if (0 === view.byteLength) throw new TypeError("The view's length must be greater than 0 when calling respondWithNewView() on a readable stream");
     if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) throw new RangeError("The region specified by view does not match byobRequest");
     if (firstDescriptor.bufferByteLength !== view.buffer.byteLength) throw new RangeError("The buffer of view has different capacity than byobRequest");
     if (firstDescriptor.bytesFilled + view.byteLength > firstDescriptor.byteLength) throw new RangeError("The region specified by view is larger than byobRequest");
     const viewByteLength = view.byteLength;
     firstDescriptor.buffer = TransferArrayBuffer(view.buffer), ReadableByteStreamControllerRespondInternal(controller, viewByteLength);
    }
    function SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize) {
     controller._controlledReadableByteStream = stream, controller._pullAgain = !1, controller._pulling = !1, 
     controller._byobRequest = null, controller._queue = controller._queueTotalSize = void 0, 
     ResetQueue(controller), controller._closeRequested = !1, controller._started = !1, 
     controller._strategyHWM = highWaterMark, controller._pullAlgorithm = pullAlgorithm, 
     controller._cancelAlgorithm = cancelAlgorithm, controller._autoAllocateChunkSize = autoAllocateChunkSize, 
     controller._pendingPullIntos = new SimpleQueue, stream._readableStreamController = controller, 
     uponPromise(promiseResolvedWith(startAlgorithm()), (() => (controller._started = !0, 
     ReadableByteStreamControllerCallPullIfNeeded(controller), null)), (r => (ReadableByteStreamControllerError(controller, r), 
     null)));
    }
    function byobRequestBrandCheckException(name) {
     return new TypeError(`ReadableStreamBYOBRequest.prototype.${name} can only be used on a ReadableStreamBYOBRequest`);
    }
    function byteStreamControllerBrandCheckException(name) {
     return new TypeError(`ReadableByteStreamController.prototype.${name} can only be used on a ReadableByteStreamController`);
    }
    function convertReadableStreamReaderMode(mode, context) {
     if ("byob" != (mode = `${mode}`)) throw new TypeError(`${context} '${mode}' is not a valid enumeration value for ReadableStreamReaderMode`);
     return mode;
    }
    function AcquireReadableStreamBYOBReader(stream) {
     return new ReadableStreamBYOBReader(stream);
    }
    function ReadableStreamAddReadIntoRequest(stream, readIntoRequest) {
     stream._reader._readIntoRequests.push(readIntoRequest);
    }
    function ReadableStreamGetNumReadIntoRequests(stream) {
     return stream._reader._readIntoRequests.length;
    }
    function ReadableStreamHasBYOBReader(stream) {
     const reader = stream._reader;
     return void 0 !== reader && !!IsReadableStreamBYOBReader(reader);
    }
    Object.defineProperties(ReadableByteStreamController.prototype, {
     close: {
      enumerable: !0
     },
     enqueue: {
      enumerable: !0
     },
     error: {
      enumerable: !0
     },
     byobRequest: {
      enumerable: !0
     },
     desiredSize: {
      enumerable: !0
     }
    }), setFunctionName(ReadableByteStreamController.prototype.close, "close"), setFunctionName(ReadableByteStreamController.prototype.enqueue, "enqueue"), 
    setFunctionName(ReadableByteStreamController.prototype.error, "error"), "symbol" == typeof Symbol.toStringTag && Object.defineProperty(ReadableByteStreamController.prototype, Symbol.toStringTag, {
     value: "ReadableByteStreamController",
     configurable: !0
    });
    class ReadableStreamBYOBReader {
     constructor(stream) {
      if (assertRequiredArgument(stream, 1, "ReadableStreamBYOBReader"), assertReadableStream(stream, "First parameter"), 
      IsReadableStreamLocked(stream)) throw new TypeError("This stream has already been locked for exclusive reading by another reader");
      if (!IsReadableByteStreamController(stream._readableStreamController)) throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source");
      ReadableStreamReaderGenericInitialize(this, stream), this._readIntoRequests = new SimpleQueue;
     }
     get closed() {
      return IsReadableStreamBYOBReader(this) ? this._closedPromise : promiseRejectedWith(byobReaderBrandCheckException("closed"));
     }
     cancel(reason = void 0) {
      return IsReadableStreamBYOBReader(this) ? void 0 === this._ownerReadableStream ? promiseRejectedWith(readerLockException("cancel")) : ReadableStreamReaderGenericCancel(this, reason) : promiseRejectedWith(byobReaderBrandCheckException("cancel"));
     }
     read(view, rawOptions = {}) {
      if (!IsReadableStreamBYOBReader(this)) return promiseRejectedWith(byobReaderBrandCheckException("read"));
      if (!ArrayBuffer.isView(view)) return promiseRejectedWith(new TypeError("view must be an array buffer view"));
      if (0 === view.byteLength) return promiseRejectedWith(new TypeError("view must have non-zero byteLength"));
      if (0 === view.buffer.byteLength) return promiseRejectedWith(new TypeError("view's buffer must have non-zero byteLength"));
      if (IsDetachedBuffer(view.buffer)) return promiseRejectedWith(new TypeError("view's buffer has been detached"));
      let options;
      try {
       options = function(options, context) {
        var _a;
        return assertDictionary(options, context), {
         min: convertUnsignedLongLongWithEnforceRange(null !== (_a = null == options ? void 0 : options.min) && void 0 !== _a ? _a : 1, `${context} has member 'min' that`)
        };
       }(rawOptions, "options");
      } catch (e) {
       return promiseRejectedWith(e);
      }
      const min = options.min;
      if (0 === min) return promiseRejectedWith(new TypeError("options.min must be greater than 0"));
      if (function(view) {
       return isDataViewConstructor(view.constructor);
      }(view)) {
       if (min > view.byteLength) return promiseRejectedWith(new RangeError("options.min must be less than or equal to view's byteLength"));
      } else if (min > view.length) return promiseRejectedWith(new RangeError("options.min must be less than or equal to view's length"));
      if (void 0 === this._ownerReadableStream) return promiseRejectedWith(readerLockException("read from"));
      let resolvePromise, rejectPromise;
      const promise = newPromise(((resolve, reject) => {
       resolvePromise = resolve, rejectPromise = reject;
      }));
      return ReadableStreamBYOBReaderRead(this, view, min, {
       _chunkSteps: chunk => resolvePromise({
        value: chunk,
        done: !1
       }),
       _closeSteps: chunk => resolvePromise({
        value: chunk,
        done: !0
       }),
       _errorSteps: e => rejectPromise(e)
      }), promise;
     }
     releaseLock() {
      if (!IsReadableStreamBYOBReader(this)) throw byobReaderBrandCheckException("releaseLock");
      void 0 !== this._ownerReadableStream && function(reader) {
       ReadableStreamReaderGenericRelease(reader);
       const e = new TypeError("Reader was released");
       ReadableStreamBYOBReaderErrorReadIntoRequests(reader, e);
      }(this);
     }
    }
    function IsReadableStreamBYOBReader(x) {
     return !!typeIsObject(x) && !!Object.prototype.hasOwnProperty.call(x, "_readIntoRequests") && x instanceof ReadableStreamBYOBReader;
    }
    function ReadableStreamBYOBReaderRead(reader, view, min, readIntoRequest) {
     const stream = reader._ownerReadableStream;
     stream._disturbed = !0, "errored" === stream._state ? readIntoRequest._errorSteps(stream._storedError) : ReadableByteStreamControllerPullInto(stream._readableStreamController, view, min, readIntoRequest);
    }
    function ReadableStreamBYOBReaderErrorReadIntoRequests(reader, e) {
     const readIntoRequests = reader._readIntoRequests;
     reader._readIntoRequests = new SimpleQueue, readIntoRequests.forEach((readIntoRequest => {
      readIntoRequest._errorSteps(e);
     }));
    }
    function byobReaderBrandCheckException(name) {
     return new TypeError(`ReadableStreamBYOBReader.prototype.${name} can only be used on a ReadableStreamBYOBReader`);
    }
    function ExtractHighWaterMark(strategy, defaultHWM) {
     const {highWaterMark} = strategy;
     if (void 0 === highWaterMark) return defaultHWM;
     if (NumberIsNaN(highWaterMark) || highWaterMark < 0) throw new RangeError("Invalid highWaterMark");
     return highWaterMark;
    }
    function ExtractSizeAlgorithm(strategy) {
     const {size} = strategy;
     return size || (() => 1);
    }
    function convertQueuingStrategy(init, context) {
     assertDictionary(init, context);
     const highWaterMark = null == init ? void 0 : init.highWaterMark, size = null == init ? void 0 : init.size;
     return {
      highWaterMark: void 0 === highWaterMark ? void 0 : convertUnrestrictedDouble(highWaterMark),
      size: void 0 === size ? void 0 : convertQueuingStrategySize(size, `${context} has member 'size' that`)
     };
    }
    function convertQueuingStrategySize(fn, context) {
     return assertFunction(fn, context), chunk => convertUnrestrictedDouble(fn(chunk));
    }
    function convertUnderlyingSinkAbortCallback(fn, original, context) {
     return assertFunction(fn, context), reason => promiseCall(fn, original, [ reason ]);
    }
    function convertUnderlyingSinkCloseCallback(fn, original, context) {
     return assertFunction(fn, context), () => promiseCall(fn, original, []);
    }
    function convertUnderlyingSinkStartCallback(fn, original, context) {
     return assertFunction(fn, context), controller => reflectCall(fn, original, [ controller ]);
    }
    function convertUnderlyingSinkWriteCallback(fn, original, context) {
     return assertFunction(fn, context), (chunk, controller) => promiseCall(fn, original, [ chunk, controller ]);
    }
    function assertWritableStream(x, context) {
     if (!IsWritableStream(x)) throw new TypeError(`${context} is not a WritableStream.`);
    }
    Object.defineProperties(ReadableStreamBYOBReader.prototype, {
     cancel: {
      enumerable: !0
     },
     read: {
      enumerable: !0
     },
     releaseLock: {
      enumerable: !0
     },
     closed: {
      enumerable: !0
     }
    }), setFunctionName(ReadableStreamBYOBReader.prototype.cancel, "cancel"), setFunctionName(ReadableStreamBYOBReader.prototype.read, "read"), 
    setFunctionName(ReadableStreamBYOBReader.prototype.releaseLock, "releaseLock"), 
    "symbol" == typeof Symbol.toStringTag && Object.defineProperty(ReadableStreamBYOBReader.prototype, Symbol.toStringTag, {
     value: "ReadableStreamBYOBReader",
     configurable: !0
    });
    const supportsAbortController = "function" == typeof AbortController;
    class WritableStream {
     constructor(rawUnderlyingSink = {}, rawStrategy = {}) {
      void 0 === rawUnderlyingSink ? rawUnderlyingSink = null : assertObject(rawUnderlyingSink, "First parameter");
      const strategy = convertQueuingStrategy(rawStrategy, "Second parameter"), underlyingSink = function(original, context) {
       assertDictionary(original, context);
       const abort = null == original ? void 0 : original.abort, close = null == original ? void 0 : original.close, start = null == original ? void 0 : original.start, type = null == original ? void 0 : original.type, write = null == original ? void 0 : original.write;
       return {
        abort: void 0 === abort ? void 0 : convertUnderlyingSinkAbortCallback(abort, original, `${context} has member 'abort' that`),
        close: void 0 === close ? void 0 : convertUnderlyingSinkCloseCallback(close, original, `${context} has member 'close' that`),
        start: void 0 === start ? void 0 : convertUnderlyingSinkStartCallback(start, original, `${context} has member 'start' that`),
        write: void 0 === write ? void 0 : convertUnderlyingSinkWriteCallback(write, original, `${context} has member 'write' that`),
        type
       };
      }(rawUnderlyingSink, "First parameter");
      if (InitializeWritableStream(this), void 0 !== underlyingSink.type) throw new RangeError("Invalid type is specified");
      const sizeAlgorithm = ExtractSizeAlgorithm(strategy);
      !function(stream, underlyingSink, highWaterMark, sizeAlgorithm) {
       const controller = Object.create(WritableStreamDefaultController.prototype);
       let startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm;
       startAlgorithm = void 0 !== underlyingSink.start ? () => underlyingSink.start(controller) : () => {}, 
       writeAlgorithm = void 0 !== underlyingSink.write ? chunk => underlyingSink.write(chunk, controller) : () => promiseResolvedWith(void 0), 
       closeAlgorithm = void 0 !== underlyingSink.close ? () => underlyingSink.close() : () => promiseResolvedWith(void 0), 
       abortAlgorithm = void 0 !== underlyingSink.abort ? reason => underlyingSink.abort(reason) : () => promiseResolvedWith(void 0), 
       SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
      }(this, underlyingSink, ExtractHighWaterMark(strategy, 1), sizeAlgorithm);
     }
     get locked() {
      if (!IsWritableStream(this)) throw streamBrandCheckException$2("locked");
      return IsWritableStreamLocked(this);
     }
     abort(reason = void 0) {
      return IsWritableStream(this) ? IsWritableStreamLocked(this) ? promiseRejectedWith(new TypeError("Cannot abort a stream that already has a writer")) : WritableStreamAbort(this, reason) : promiseRejectedWith(streamBrandCheckException$2("abort"));
     }
     close() {
      return IsWritableStream(this) ? IsWritableStreamLocked(this) ? promiseRejectedWith(new TypeError("Cannot close a stream that already has a writer")) : WritableStreamCloseQueuedOrInFlight(this) ? promiseRejectedWith(new TypeError("Cannot close an already-closing stream")) : WritableStreamClose(this) : promiseRejectedWith(streamBrandCheckException$2("close"));
     }
     getWriter() {
      if (!IsWritableStream(this)) throw streamBrandCheckException$2("getWriter");
      return AcquireWritableStreamDefaultWriter(this);
     }
    }
    function AcquireWritableStreamDefaultWriter(stream) {
     return new WritableStreamDefaultWriter(stream);
    }
    function InitializeWritableStream(stream) {
     stream._state = "writable", stream._storedError = void 0, stream._writer = void 0, 
     stream._writableStreamController = void 0, stream._writeRequests = new SimpleQueue, 
     stream._inFlightWriteRequest = void 0, stream._closeRequest = void 0, stream._inFlightCloseRequest = void 0, 
     stream._pendingAbortRequest = void 0, stream._backpressure = !1;
    }
    function IsWritableStream(x) {
     return !!typeIsObject(x) && !!Object.prototype.hasOwnProperty.call(x, "_writableStreamController") && x instanceof WritableStream;
    }
    function IsWritableStreamLocked(stream) {
     return void 0 !== stream._writer;
    }
    function WritableStreamAbort(stream, reason) {
     var _a;
     if ("closed" === stream._state || "errored" === stream._state) return promiseResolvedWith(void 0);
     stream._writableStreamController._abortReason = reason, null === (_a = stream._writableStreamController._abortController) || void 0 === _a || _a.abort(reason);
     const state = stream._state;
     if ("closed" === state || "errored" === state) return promiseResolvedWith(void 0);
     if (void 0 !== stream._pendingAbortRequest) return stream._pendingAbortRequest._promise;
     let wasAlreadyErroring = !1;
     "erroring" === state && (wasAlreadyErroring = !0, reason = void 0);
     const promise = newPromise(((resolve, reject) => {
      stream._pendingAbortRequest = {
       _promise: void 0,
       _resolve: resolve,
       _reject: reject,
       _reason: reason,
       _wasAlreadyErroring: wasAlreadyErroring
      };
     }));
     return stream._pendingAbortRequest._promise = promise, wasAlreadyErroring || WritableStreamStartErroring(stream, reason), 
     promise;
    }
    function WritableStreamClose(stream) {
     const state = stream._state;
     if ("closed" === state || "errored" === state) return promiseRejectedWith(new TypeError(`The stream (in ${state} state) is not in the writable state and cannot be closed`));
     const promise = newPromise(((resolve, reject) => {
      const closeRequest = {
       _resolve: resolve,
       _reject: reject
      };
      stream._closeRequest = closeRequest;
     })), writer = stream._writer;
     var controller;
     return void 0 !== writer && stream._backpressure && "writable" === state && defaultWriterReadyPromiseResolve(writer), 
     EnqueueValueWithSize(controller = stream._writableStreamController, closeSentinel, 0), 
     WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller), promise;
    }
    function WritableStreamDealWithRejection(stream, error) {
     "writable" !== stream._state ? WritableStreamFinishErroring(stream) : WritableStreamStartErroring(stream, error);
    }
    function WritableStreamStartErroring(stream, reason) {
     const controller = stream._writableStreamController;
     stream._state = "erroring", stream._storedError = reason;
     const writer = stream._writer;
     void 0 !== writer && WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason), 
     !function(stream) {
      return void 0 !== stream._inFlightWriteRequest || void 0 !== stream._inFlightCloseRequest;
     }(stream) && controller._started && WritableStreamFinishErroring(stream);
    }
    function WritableStreamFinishErroring(stream) {
     stream._state = "errored", stream._writableStreamController[ErrorSteps]();
     const storedError = stream._storedError;
     if (stream._writeRequests.forEach((writeRequest => {
      writeRequest._reject(storedError);
     })), stream._writeRequests = new SimpleQueue, void 0 === stream._pendingAbortRequest) return void WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
     const abortRequest = stream._pendingAbortRequest;
     if (stream._pendingAbortRequest = void 0, abortRequest._wasAlreadyErroring) return abortRequest._reject(storedError), 
     void WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
     uponPromise(stream._writableStreamController[AbortSteps](abortRequest._reason), (() => (abortRequest._resolve(), 
     WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream), null)), (reason => (abortRequest._reject(reason), 
     WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream), null)));
    }
    function WritableStreamCloseQueuedOrInFlight(stream) {
     return void 0 !== stream._closeRequest || void 0 !== stream._inFlightCloseRequest;
    }
    function WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {
     void 0 !== stream._closeRequest && (stream._closeRequest._reject(stream._storedError), 
     stream._closeRequest = void 0);
     const writer = stream._writer;
     void 0 !== writer && defaultWriterClosedPromiseReject(writer, stream._storedError);
    }
    function WritableStreamUpdateBackpressure(stream, backpressure) {
     const writer = stream._writer;
     void 0 !== writer && backpressure !== stream._backpressure && (backpressure ? function(writer) {
      defaultWriterReadyPromiseInitialize(writer);
     }(writer) : defaultWriterReadyPromiseResolve(writer)), stream._backpressure = backpressure;
    }
    Object.defineProperties(WritableStream.prototype, {
     abort: {
      enumerable: !0
     },
     close: {
      enumerable: !0
     },
     getWriter: {
      enumerable: !0
     },
     locked: {
      enumerable: !0
     }
    }), setFunctionName(WritableStream.prototype.abort, "abort"), setFunctionName(WritableStream.prototype.close, "close"), 
    setFunctionName(WritableStream.prototype.getWriter, "getWriter"), "symbol" == typeof Symbol.toStringTag && Object.defineProperty(WritableStream.prototype, Symbol.toStringTag, {
     value: "WritableStream",
     configurable: !0
    });
    class WritableStreamDefaultWriter {
     constructor(stream) {
      if (assertRequiredArgument(stream, 1, "WritableStreamDefaultWriter"), assertWritableStream(stream, "First parameter"), 
      IsWritableStreamLocked(stream)) throw new TypeError("This stream has already been locked for exclusive writing by another writer");
      this._ownerWritableStream = stream, stream._writer = this;
      const state = stream._state;
      if ("writable" === state) !WritableStreamCloseQueuedOrInFlight(stream) && stream._backpressure ? defaultWriterReadyPromiseInitialize(this) : defaultWriterReadyPromiseInitializeAsResolved(this), 
      defaultWriterClosedPromiseInitialize(this); else if ("erroring" === state) defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError), 
      defaultWriterClosedPromiseInitialize(this); else if ("closed" === state) defaultWriterReadyPromiseInitializeAsResolved(this), 
      defaultWriterClosedPromiseInitialize(writer = this), defaultWriterClosedPromiseResolve(writer); else {
       const storedError = stream._storedError;
       defaultWriterReadyPromiseInitializeAsRejected(this, storedError), defaultWriterClosedPromiseInitializeAsRejected(this, storedError);
      }
      var writer;
     }
     get closed() {
      return IsWritableStreamDefaultWriter(this) ? this._closedPromise : promiseRejectedWith(defaultWriterBrandCheckException("closed"));
     }
     get desiredSize() {
      if (!IsWritableStreamDefaultWriter(this)) throw defaultWriterBrandCheckException("desiredSize");
      if (void 0 === this._ownerWritableStream) throw defaultWriterLockException("desiredSize");
      return function(writer) {
       const stream = writer._ownerWritableStream, state = stream._state;
       return "errored" === state || "erroring" === state ? null : "closed" === state ? 0 : WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);
      }(this);
     }
     get ready() {
      return IsWritableStreamDefaultWriter(this) ? this._readyPromise : promiseRejectedWith(defaultWriterBrandCheckException("ready"));
     }
     abort(reason = void 0) {
      return IsWritableStreamDefaultWriter(this) ? void 0 === this._ownerWritableStream ? promiseRejectedWith(defaultWriterLockException("abort")) : function(writer, reason) {
       return WritableStreamAbort(writer._ownerWritableStream, reason);
      }(this, reason) : promiseRejectedWith(defaultWriterBrandCheckException("abort"));
     }
     close() {
      if (!IsWritableStreamDefaultWriter(this)) return promiseRejectedWith(defaultWriterBrandCheckException("close"));
      const stream = this._ownerWritableStream;
      return void 0 === stream ? promiseRejectedWith(defaultWriterLockException("close")) : WritableStreamCloseQueuedOrInFlight(stream) ? promiseRejectedWith(new TypeError("Cannot close an already-closing stream")) : WritableStreamDefaultWriterClose(this);
     }
     releaseLock() {
      if (!IsWritableStreamDefaultWriter(this)) throw defaultWriterBrandCheckException("releaseLock");
      void 0 !== this._ownerWritableStream && WritableStreamDefaultWriterRelease(this);
     }
     write(chunk = void 0) {
      return IsWritableStreamDefaultWriter(this) ? void 0 === this._ownerWritableStream ? promiseRejectedWith(defaultWriterLockException("write to")) : WritableStreamDefaultWriterWrite(this, chunk) : promiseRejectedWith(defaultWriterBrandCheckException("write"));
     }
    }
    function IsWritableStreamDefaultWriter(x) {
     return !!typeIsObject(x) && !!Object.prototype.hasOwnProperty.call(x, "_ownerWritableStream") && x instanceof WritableStreamDefaultWriter;
    }
    function WritableStreamDefaultWriterClose(writer) {
     return WritableStreamClose(writer._ownerWritableStream);
    }
    function WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error) {
     "pending" === writer._closedPromiseState ? defaultWriterClosedPromiseReject(writer, error) : function(writer, reason) {
      defaultWriterClosedPromiseInitializeAsRejected(writer, reason);
     }(writer, error);
    }
    function WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) {
     "pending" === writer._readyPromiseState ? defaultWriterReadyPromiseReject(writer, error) : function(writer, reason) {
      defaultWriterReadyPromiseInitializeAsRejected(writer, reason);
     }(writer, error);
    }
    function WritableStreamDefaultWriterRelease(writer) {
     const stream = writer._ownerWritableStream, releasedError = new TypeError("Writer was released and can no longer be used to monitor the stream's closedness");
     WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError), WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError), 
     stream._writer = void 0, writer._ownerWritableStream = void 0;
    }
    function WritableStreamDefaultWriterWrite(writer, chunk) {
     const stream = writer._ownerWritableStream, controller = stream._writableStreamController, chunkSize = function(controller, chunk) {
      try {
       return controller._strategySizeAlgorithm(chunk);
      } catch (chunkSizeE) {
       return WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE), 1;
      }
     }(controller, chunk);
     if (stream !== writer._ownerWritableStream) return promiseRejectedWith(defaultWriterLockException("write to"));
     const state = stream._state;
     if ("errored" === state) return promiseRejectedWith(stream._storedError);
     if (WritableStreamCloseQueuedOrInFlight(stream) || "closed" === state) return promiseRejectedWith(new TypeError("The stream is closing or closed and cannot be written to"));
     if ("erroring" === state) return promiseRejectedWith(stream._storedError);
     const promise = function(stream) {
      return newPromise(((resolve, reject) => {
       const writeRequest = {
        _resolve: resolve,
        _reject: reject
       };
       stream._writeRequests.push(writeRequest);
      }));
     }(stream);
     return function(controller, chunk, chunkSize) {
      try {
       EnqueueValueWithSize(controller, chunk, chunkSize);
      } catch (enqueueE) {
       return void WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);
      }
      const stream = controller._controlledWritableStream;
      WritableStreamCloseQueuedOrInFlight(stream) || "writable" !== stream._state || WritableStreamUpdateBackpressure(stream, WritableStreamDefaultControllerGetBackpressure(controller)), 
      WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
     }(controller, chunk, chunkSize), promise;
    }
    Object.defineProperties(WritableStreamDefaultWriter.prototype, {
     abort: {
      enumerable: !0
     },
     close: {
      enumerable: !0
     },
     releaseLock: {
      enumerable: !0
     },
     write: {
      enumerable: !0
     },
     closed: {
      enumerable: !0
     },
     desiredSize: {
      enumerable: !0
     },
     ready: {
      enumerable: !0
     }
    }), setFunctionName(WritableStreamDefaultWriter.prototype.abort, "abort"), setFunctionName(WritableStreamDefaultWriter.prototype.close, "close"), 
    setFunctionName(WritableStreamDefaultWriter.prototype.releaseLock, "releaseLock"), 
    setFunctionName(WritableStreamDefaultWriter.prototype.write, "write"), "symbol" == typeof Symbol.toStringTag && Object.defineProperty(WritableStreamDefaultWriter.prototype, Symbol.toStringTag, {
     value: "WritableStreamDefaultWriter",
     configurable: !0
    });
    const closeSentinel = {};
    class WritableStreamDefaultController {
     constructor() {
      throw new TypeError("Illegal constructor");
     }
     get abortReason() {
      if (!IsWritableStreamDefaultController(this)) throw defaultControllerBrandCheckException$2("abortReason");
      return this._abortReason;
     }
     get signal() {
      if (!IsWritableStreamDefaultController(this)) throw defaultControllerBrandCheckException$2("signal");
      if (void 0 === this._abortController) throw new TypeError("WritableStreamDefaultController.prototype.signal is not supported");
      return this._abortController.signal;
     }
     error(e = void 0) {
      if (!IsWritableStreamDefaultController(this)) throw defaultControllerBrandCheckException$2("error");
      "writable" === this._controlledWritableStream._state && WritableStreamDefaultControllerError(this, e);
     }
     [AbortSteps](reason) {
      const result = this._abortAlgorithm(reason);
      return WritableStreamDefaultControllerClearAlgorithms(this), result;
     }
     [ErrorSteps]() {
      ResetQueue(this);
     }
    }
    function IsWritableStreamDefaultController(x) {
     return !!typeIsObject(x) && !!Object.prototype.hasOwnProperty.call(x, "_controlledWritableStream") && x instanceof WritableStreamDefaultController;
    }
    function SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {
     controller._controlledWritableStream = stream, stream._writableStreamController = controller, 
     controller._queue = void 0, controller._queueTotalSize = void 0, ResetQueue(controller), 
     controller._abortReason = void 0, controller._abortController = function() {
      if (supportsAbortController) return new AbortController;
     }(), controller._started = !1, controller._strategySizeAlgorithm = sizeAlgorithm, 
     controller._strategyHWM = highWaterMark, controller._writeAlgorithm = writeAlgorithm, 
     controller._closeAlgorithm = closeAlgorithm, controller._abortAlgorithm = abortAlgorithm;
     const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
     WritableStreamUpdateBackpressure(stream, backpressure), uponPromise(promiseResolvedWith(startAlgorithm()), (() => (controller._started = !0, 
     WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller), null)), (r => (controller._started = !0, 
     WritableStreamDealWithRejection(stream, r), null)));
    }
    function WritableStreamDefaultControllerClearAlgorithms(controller) {
     controller._writeAlgorithm = void 0, controller._closeAlgorithm = void 0, controller._abortAlgorithm = void 0, 
     controller._strategySizeAlgorithm = void 0;
    }
    function WritableStreamDefaultControllerGetDesiredSize(controller) {
     return controller._strategyHWM - controller._queueTotalSize;
    }
    function WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {
     const stream = controller._controlledWritableStream;
     if (!controller._started) return;
     if (void 0 !== stream._inFlightWriteRequest) return;
     if ("erroring" === stream._state) return void WritableStreamFinishErroring(stream);
     if (0 === controller._queue.length) return;
     const value = controller._queue.peek().value;
     value === closeSentinel ? function(controller) {
      const stream = controller._controlledWritableStream;
      (function(stream) {
       stream._inFlightCloseRequest = stream._closeRequest, stream._closeRequest = void 0;
      })(stream), DequeueValue(controller);
      const sinkClosePromise = controller._closeAlgorithm();
      WritableStreamDefaultControllerClearAlgorithms(controller), uponPromise(sinkClosePromise, (() => (function(stream) {
       stream._inFlightCloseRequest._resolve(void 0), stream._inFlightCloseRequest = void 0, 
       "erroring" === stream._state && (stream._storedError = void 0, void 0 !== stream._pendingAbortRequest && (stream._pendingAbortRequest._resolve(), 
       stream._pendingAbortRequest = void 0)), stream._state = "closed";
       const writer = stream._writer;
       void 0 !== writer && defaultWriterClosedPromiseResolve(writer);
      }(stream), null)), (reason => (function(stream, error) {
       stream._inFlightCloseRequest._reject(error), stream._inFlightCloseRequest = void 0, 
       void 0 !== stream._pendingAbortRequest && (stream._pendingAbortRequest._reject(error), 
       stream._pendingAbortRequest = void 0), WritableStreamDealWithRejection(stream, error);
      }(stream, reason), null)));
     }(controller) : function(controller, chunk) {
      const stream = controller._controlledWritableStream;
      !function(stream) {
       stream._inFlightWriteRequest = stream._writeRequests.shift();
      }(stream);
      const sinkWritePromise = controller._writeAlgorithm(chunk);
      uponPromise(sinkWritePromise, (() => {
       !function(stream) {
        stream._inFlightWriteRequest._resolve(void 0), stream._inFlightWriteRequest = void 0;
       }(stream);
       const state = stream._state;
       if (DequeueValue(controller), !WritableStreamCloseQueuedOrInFlight(stream) && "writable" === state) {
        const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
        WritableStreamUpdateBackpressure(stream, backpressure);
       }
       return WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller), null;
      }), (reason => ("writable" === stream._state && WritableStreamDefaultControllerClearAlgorithms(controller), 
      function(stream, error) {
       stream._inFlightWriteRequest._reject(error), stream._inFlightWriteRequest = void 0, 
       WritableStreamDealWithRejection(stream, error);
      }(stream, reason), null)));
     }(controller, value);
    }
    function WritableStreamDefaultControllerErrorIfNeeded(controller, error) {
     "writable" === controller._controlledWritableStream._state && WritableStreamDefaultControllerError(controller, error);
    }
    function WritableStreamDefaultControllerGetBackpressure(controller) {
     return WritableStreamDefaultControllerGetDesiredSize(controller) <= 0;
    }
    function WritableStreamDefaultControllerError(controller, error) {
     const stream = controller._controlledWritableStream;
     WritableStreamDefaultControllerClearAlgorithms(controller), WritableStreamStartErroring(stream, error);
    }
    function streamBrandCheckException$2(name) {
     return new TypeError(`WritableStream.prototype.${name} can only be used on a WritableStream`);
    }
    function defaultControllerBrandCheckException$2(name) {
     return new TypeError(`WritableStreamDefaultController.prototype.${name} can only be used on a WritableStreamDefaultController`);
    }
    function defaultWriterBrandCheckException(name) {
     return new TypeError(`WritableStreamDefaultWriter.prototype.${name} can only be used on a WritableStreamDefaultWriter`);
    }
    function defaultWriterLockException(name) {
     return new TypeError("Cannot " + name + " a stream using a released writer");
    }
    function defaultWriterClosedPromiseInitialize(writer) {
     writer._closedPromise = newPromise(((resolve, reject) => {
      writer._closedPromise_resolve = resolve, writer._closedPromise_reject = reject, 
      writer._closedPromiseState = "pending";
     }));
    }
    function defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {
     defaultWriterClosedPromiseInitialize(writer), defaultWriterClosedPromiseReject(writer, reason);
    }
    function defaultWriterClosedPromiseReject(writer, reason) {
     void 0 !== writer._closedPromise_reject && (setPromiseIsHandledToTrue(writer._closedPromise), 
     writer._closedPromise_reject(reason), writer._closedPromise_resolve = void 0, writer._closedPromise_reject = void 0, 
     writer._closedPromiseState = "rejected");
    }
    function defaultWriterClosedPromiseResolve(writer) {
     void 0 !== writer._closedPromise_resolve && (writer._closedPromise_resolve(void 0), 
     writer._closedPromise_resolve = void 0, writer._closedPromise_reject = void 0, writer._closedPromiseState = "resolved");
    }
    function defaultWriterReadyPromiseInitialize(writer) {
     writer._readyPromise = newPromise(((resolve, reject) => {
      writer._readyPromise_resolve = resolve, writer._readyPromise_reject = reject;
     })), writer._readyPromiseState = "pending";
    }
    function defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {
     defaultWriterReadyPromiseInitialize(writer), defaultWriterReadyPromiseReject(writer, reason);
    }
    function defaultWriterReadyPromiseInitializeAsResolved(writer) {
     defaultWriterReadyPromiseInitialize(writer), defaultWriterReadyPromiseResolve(writer);
    }
    function defaultWriterReadyPromiseReject(writer, reason) {
     void 0 !== writer._readyPromise_reject && (setPromiseIsHandledToTrue(writer._readyPromise), 
     writer._readyPromise_reject(reason), writer._readyPromise_resolve = void 0, writer._readyPromise_reject = void 0, 
     writer._readyPromiseState = "rejected");
    }
    function defaultWriterReadyPromiseResolve(writer) {
     void 0 !== writer._readyPromise_resolve && (writer._readyPromise_resolve(void 0), 
     writer._readyPromise_resolve = void 0, writer._readyPromise_reject = void 0, writer._readyPromiseState = "fulfilled");
    }
    Object.defineProperties(WritableStreamDefaultController.prototype, {
     abortReason: {
      enumerable: !0
     },
     signal: {
      enumerable: !0
     },
     error: {
      enumerable: !0
     }
    }), "symbol" == typeof Symbol.toStringTag && Object.defineProperty(WritableStreamDefaultController.prototype, Symbol.toStringTag, {
     value: "WritableStreamDefaultController",
     configurable: !0
    });
    const globals = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : "undefined" != typeof global ? global : void 0, DOMException = function() {
     const ctor = null == globals ? void 0 : globals.DOMException;
     return function(ctor) {
      if ("function" != typeof ctor && "object" != typeof ctor) return !1;
      if ("DOMException" !== ctor.name) return !1;
      try {
       return new ctor, !0;
      } catch (_a) {
       return !1;
      }
     }(ctor) ? ctor : void 0;
    }() || function() {
     const ctor = function(message, name) {
      this.message = message || "", this.name = name || "Error", Error.captureStackTrace && Error.captureStackTrace(this, this.constructor);
     };
     return setFunctionName(ctor, "DOMException"), ctor.prototype = Object.create(Error.prototype), 
     Object.defineProperty(ctor.prototype, "constructor", {
      value: ctor,
      writable: !0,
      configurable: !0
     }), ctor;
    }();
    function ReadableStreamPipeTo(source, dest, preventClose, preventAbort, preventCancel, signal) {
     const reader = AcquireReadableStreamDefaultReader(source), writer = AcquireWritableStreamDefaultWriter(dest);
     source._disturbed = !0;
     let shuttingDown = !1, currentWrite = promiseResolvedWith(void 0);
     return newPromise(((resolve, reject) => {
      let abortAlgorithm;
      if (void 0 !== signal) {
       if (abortAlgorithm = () => {
        const error = void 0 !== signal.reason ? signal.reason : new DOMException("Aborted", "AbortError"), actions = [];
        preventAbort || actions.push((() => "writable" === dest._state ? WritableStreamAbort(dest, error) : promiseResolvedWith(void 0))), 
        preventCancel || actions.push((() => "readable" === source._state ? ReadableStreamCancel(source, error) : promiseResolvedWith(void 0))), 
        shutdownWithAction((() => Promise.all(actions.map((action => action())))), !0, error);
       }, signal.aborted) return void abortAlgorithm();
       signal.addEventListener("abort", abortAlgorithm);
      }
      var stream, promise, action;
      if (isOrBecomesErrored(source, reader._closedPromise, (storedError => (preventAbort ? shutdown(!0, storedError) : shutdownWithAction((() => WritableStreamAbort(dest, storedError)), !0, storedError), 
      null))), isOrBecomesErrored(dest, writer._closedPromise, (storedError => (preventCancel ? shutdown(!0, storedError) : shutdownWithAction((() => ReadableStreamCancel(source, storedError)), !0, storedError), 
      null))), stream = source, promise = reader._closedPromise, action = () => (preventClose ? shutdown() : shutdownWithAction((() => function(writer) {
       const stream = writer._ownerWritableStream, state = stream._state;
       return WritableStreamCloseQueuedOrInFlight(stream) || "closed" === state ? promiseResolvedWith(void 0) : "errored" === state ? promiseRejectedWith(stream._storedError) : WritableStreamDefaultWriterClose(writer);
      }(writer))), null), "closed" === stream._state ? action() : uponFulfillment(promise, action), 
      WritableStreamCloseQueuedOrInFlight(dest) || "closed" === dest._state) {
       const destClosed = new TypeError("the destination writable stream closed before all data could be piped to it");
       preventCancel ? shutdown(!0, destClosed) : shutdownWithAction((() => ReadableStreamCancel(source, destClosed)), !0, destClosed);
      }
      function waitForWritesToFinish() {
       const oldCurrentWrite = currentWrite;
       return PerformPromiseThen(currentWrite, (() => oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : void 0));
      }
      function isOrBecomesErrored(stream, promise, action) {
       "errored" === stream._state ? action(stream._storedError) : uponRejection(promise, action);
      }
      function shutdownWithAction(action, originalIsError, originalError) {
       function doTheRest() {
        return uponPromise(action(), (() => finalize(originalIsError, originalError)), (newError => finalize(!0, newError))), 
        null;
       }
       shuttingDown || (shuttingDown = !0, "writable" !== dest._state || WritableStreamCloseQueuedOrInFlight(dest) ? doTheRest() : uponFulfillment(waitForWritesToFinish(), doTheRest));
      }
      function shutdown(isError, error) {
       shuttingDown || (shuttingDown = !0, "writable" !== dest._state || WritableStreamCloseQueuedOrInFlight(dest) ? finalize(isError, error) : uponFulfillment(waitForWritesToFinish(), (() => finalize(isError, error))));
      }
      function finalize(isError, error) {
       return WritableStreamDefaultWriterRelease(writer), ReadableStreamReaderGenericRelease(reader), 
       void 0 !== signal && signal.removeEventListener("abort", abortAlgorithm), isError ? reject(error) : resolve(void 0), 
       null;
      }
      setPromiseIsHandledToTrue(newPromise(((resolveLoop, rejectLoop) => {
       !function next(done) {
        done ? resolveLoop() : PerformPromiseThen(shuttingDown ? promiseResolvedWith(!0) : PerformPromiseThen(writer._readyPromise, (() => newPromise(((resolveRead, rejectRead) => {
         ReadableStreamDefaultReaderRead(reader, {
          _chunkSteps: chunk => {
           currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, chunk), void 0, noop), 
           resolveRead(!1);
          },
          _closeSteps: () => resolveRead(!0),
          _errorSteps: rejectRead
         });
        })))), next, rejectLoop);
       }(!1);
      })));
     }));
    }
    class ReadableStreamDefaultController {
     constructor() {
      throw new TypeError("Illegal constructor");
     }
     get desiredSize() {
      if (!IsReadableStreamDefaultController(this)) throw defaultControllerBrandCheckException$1("desiredSize");
      return ReadableStreamDefaultControllerGetDesiredSize(this);
     }
     close() {
      if (!IsReadableStreamDefaultController(this)) throw defaultControllerBrandCheckException$1("close");
      if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) throw new TypeError("The stream is not in a state that permits close");
      ReadableStreamDefaultControllerClose(this);
     }
     enqueue(chunk = void 0) {
      if (!IsReadableStreamDefaultController(this)) throw defaultControllerBrandCheckException$1("enqueue");
      if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) throw new TypeError("The stream is not in a state that permits enqueue");
      return ReadableStreamDefaultControllerEnqueue(this, chunk);
     }
     error(e = void 0) {
      if (!IsReadableStreamDefaultController(this)) throw defaultControllerBrandCheckException$1("error");
      ReadableStreamDefaultControllerError(this, e);
     }
     [CancelSteps](reason) {
      ResetQueue(this);
      const result = this._cancelAlgorithm(reason);
      return ReadableStreamDefaultControllerClearAlgorithms(this), result;
     }
     [PullSteps](readRequest) {
      const stream = this._controlledReadableStream;
      if (this._queue.length > 0) {
       const chunk = DequeueValue(this);
       this._closeRequested && 0 === this._queue.length ? (ReadableStreamDefaultControllerClearAlgorithms(this), 
       ReadableStreamClose(stream)) : ReadableStreamDefaultControllerCallPullIfNeeded(this), 
       readRequest._chunkSteps(chunk);
      } else ReadableStreamAddReadRequest(stream, readRequest), ReadableStreamDefaultControllerCallPullIfNeeded(this);
     }
     [ReleaseSteps]() {}
    }
    function IsReadableStreamDefaultController(x) {
     return !!typeIsObject(x) && !!Object.prototype.hasOwnProperty.call(x, "_controlledReadableStream") && x instanceof ReadableStreamDefaultController;
    }
    function ReadableStreamDefaultControllerCallPullIfNeeded(controller) {
     ReadableStreamDefaultControllerShouldCallPull(controller) && (controller._pulling ? controller._pullAgain = !0 : (controller._pulling = !0, 
     uponPromise(controller._pullAlgorithm(), (() => (controller._pulling = !1, controller._pullAgain && (controller._pullAgain = !1, 
     ReadableStreamDefaultControllerCallPullIfNeeded(controller)), null)), (e => (ReadableStreamDefaultControllerError(controller, e), 
     null)))));
    }
    function ReadableStreamDefaultControllerShouldCallPull(controller) {
     const stream = controller._controlledReadableStream;
     return !!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) && (!!controller._started && (!!(IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) || ReadableStreamDefaultControllerGetDesiredSize(controller) > 0));
    }
    function ReadableStreamDefaultControllerClearAlgorithms(controller) {
     controller._pullAlgorithm = void 0, controller._cancelAlgorithm = void 0, controller._strategySizeAlgorithm = void 0;
    }
    function ReadableStreamDefaultControllerClose(controller) {
     if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) return;
     const stream = controller._controlledReadableStream;
     controller._closeRequested = !0, 0 === controller._queue.length && (ReadableStreamDefaultControllerClearAlgorithms(controller), 
     ReadableStreamClose(stream));
    }
    function ReadableStreamDefaultControllerEnqueue(controller, chunk) {
     if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) return;
     const stream = controller._controlledReadableStream;
     if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) ReadableStreamFulfillReadRequest(stream, chunk, !1); else {
      let chunkSize;
      try {
       chunkSize = controller._strategySizeAlgorithm(chunk);
      } catch (chunkSizeE) {
       throw ReadableStreamDefaultControllerError(controller, chunkSizeE), chunkSizeE;
      }
      try {
       EnqueueValueWithSize(controller, chunk, chunkSize);
      } catch (enqueueE) {
       throw ReadableStreamDefaultControllerError(controller, enqueueE), enqueueE;
      }
     }
     ReadableStreamDefaultControllerCallPullIfNeeded(controller);
    }
    function ReadableStreamDefaultControllerError(controller, e) {
     const stream = controller._controlledReadableStream;
     "readable" === stream._state && (ResetQueue(controller), ReadableStreamDefaultControllerClearAlgorithms(controller), 
     ReadableStreamError(stream, e));
    }
    function ReadableStreamDefaultControllerGetDesiredSize(controller) {
     const state = controller._controlledReadableStream._state;
     return "errored" === state ? null : "closed" === state ? 0 : controller._strategyHWM - controller._queueTotalSize;
    }
    function ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {
     const state = controller._controlledReadableStream._state;
     return !controller._closeRequested && "readable" === state;
    }
    function SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {
     controller._controlledReadableStream = stream, controller._queue = void 0, controller._queueTotalSize = void 0, 
     ResetQueue(controller), controller._started = !1, controller._closeRequested = !1, 
     controller._pullAgain = !1, controller._pulling = !1, controller._strategySizeAlgorithm = sizeAlgorithm, 
     controller._strategyHWM = highWaterMark, controller._pullAlgorithm = pullAlgorithm, 
     controller._cancelAlgorithm = cancelAlgorithm, stream._readableStreamController = controller, 
     uponPromise(promiseResolvedWith(startAlgorithm()), (() => (controller._started = !0, 
     ReadableStreamDefaultControllerCallPullIfNeeded(controller), null)), (r => (ReadableStreamDefaultControllerError(controller, r), 
     null)));
    }
    function defaultControllerBrandCheckException$1(name) {
     return new TypeError(`ReadableStreamDefaultController.prototype.${name} can only be used on a ReadableStreamDefaultController`);
    }
    function ReadableStreamTee(stream, cloneForBranch2) {
     return IsReadableByteStreamController(stream._readableStreamController) ? function(stream) {
      let reason1, reason2, branch1, branch2, resolveCancelPromise, reader = AcquireReadableStreamDefaultReader(stream), reading = !1, readAgainForBranch1 = !1, readAgainForBranch2 = !1, canceled1 = !1, canceled2 = !1;
      const cancelPromise = newPromise((resolve => {
       resolveCancelPromise = resolve;
      }));
      function forwardReaderError(thisReader) {
       uponRejection(thisReader._closedPromise, (r => (thisReader !== reader || (ReadableByteStreamControllerError(branch1._readableStreamController, r), 
       ReadableByteStreamControllerError(branch2._readableStreamController, r), canceled1 && canceled2 || resolveCancelPromise(void 0)), 
       null)));
      }
      function pullWithDefaultReader() {
       IsReadableStreamBYOBReader(reader) && (ReadableStreamReaderGenericRelease(reader), 
       reader = AcquireReadableStreamDefaultReader(stream), forwardReaderError(reader)), 
       ReadableStreamDefaultReaderRead(reader, {
        _chunkSteps: chunk => {
         _queueMicrotask((() => {
          readAgainForBranch1 = !1, readAgainForBranch2 = !1;
          const chunk1 = chunk;
          let chunk2 = chunk;
          if (!canceled1 && !canceled2) try {
           chunk2 = CloneAsUint8Array(chunk);
          } catch (cloneE) {
           return ReadableByteStreamControllerError(branch1._readableStreamController, cloneE), 
           ReadableByteStreamControllerError(branch2._readableStreamController, cloneE), void resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
          }
          canceled1 || ReadableByteStreamControllerEnqueue(branch1._readableStreamController, chunk1), 
          canceled2 || ReadableByteStreamControllerEnqueue(branch2._readableStreamController, chunk2), 
          reading = !1, readAgainForBranch1 ? pull1Algorithm() : readAgainForBranch2 && pull2Algorithm();
         }));
        },
        _closeSteps: () => {
         reading = !1, canceled1 || ReadableByteStreamControllerClose(branch1._readableStreamController), 
         canceled2 || ReadableByteStreamControllerClose(branch2._readableStreamController), 
         branch1._readableStreamController._pendingPullIntos.length > 0 && ReadableByteStreamControllerRespond(branch1._readableStreamController, 0), 
         branch2._readableStreamController._pendingPullIntos.length > 0 && ReadableByteStreamControllerRespond(branch2._readableStreamController, 0), 
         canceled1 && canceled2 || resolveCancelPromise(void 0);
        },
        _errorSteps: () => {
         reading = !1;
        }
       });
      }
      function pullWithBYOBReader(view, forBranch2) {
       IsReadableStreamDefaultReader(reader) && (ReadableStreamReaderGenericRelease(reader), 
       reader = AcquireReadableStreamBYOBReader(stream), forwardReaderError(reader));
       const byobBranch = forBranch2 ? branch2 : branch1, otherBranch = forBranch2 ? branch1 : branch2;
       ReadableStreamBYOBReaderRead(reader, view, 1, {
        _chunkSteps: chunk => {
         _queueMicrotask((() => {
          readAgainForBranch1 = !1, readAgainForBranch2 = !1;
          const byobCanceled = forBranch2 ? canceled2 : canceled1;
          if (forBranch2 ? canceled1 : canceled2) byobCanceled || ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk); else {
           let clonedChunk;
           try {
            clonedChunk = CloneAsUint8Array(chunk);
           } catch (cloneE) {
            return ReadableByteStreamControllerError(byobBranch._readableStreamController, cloneE), 
            ReadableByteStreamControllerError(otherBranch._readableStreamController, cloneE), 
            void resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
           }
           byobCanceled || ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk), 
           ReadableByteStreamControllerEnqueue(otherBranch._readableStreamController, clonedChunk);
          }
          reading = !1, readAgainForBranch1 ? pull1Algorithm() : readAgainForBranch2 && pull2Algorithm();
         }));
        },
        _closeSteps: chunk => {
         reading = !1;
         const byobCanceled = forBranch2 ? canceled2 : canceled1, otherCanceled = forBranch2 ? canceled1 : canceled2;
         byobCanceled || ReadableByteStreamControllerClose(byobBranch._readableStreamController), 
         otherCanceled || ReadableByteStreamControllerClose(otherBranch._readableStreamController), 
         void 0 !== chunk && (byobCanceled || ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk), 
         !otherCanceled && otherBranch._readableStreamController._pendingPullIntos.length > 0 && ReadableByteStreamControllerRespond(otherBranch._readableStreamController, 0)), 
         byobCanceled && otherCanceled || resolveCancelPromise(void 0);
        },
        _errorSteps: () => {
         reading = !1;
        }
       });
      }
      function pull1Algorithm() {
       if (reading) return readAgainForBranch1 = !0, promiseResolvedWith(void 0);
       reading = !0;
       const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch1._readableStreamController);
       return null === byobRequest ? pullWithDefaultReader() : pullWithBYOBReader(byobRequest._view, !1), 
       promiseResolvedWith(void 0);
      }
      function pull2Algorithm() {
       if (reading) return readAgainForBranch2 = !0, promiseResolvedWith(void 0);
       reading = !0;
       const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch2._readableStreamController);
       return null === byobRequest ? pullWithDefaultReader() : pullWithBYOBReader(byobRequest._view, !0), 
       promiseResolvedWith(void 0);
      }
      function cancel1Algorithm(reason) {
       if (canceled1 = !0, reason1 = reason, canceled2) {
        const compositeReason = CreateArrayFromList([ reason1, reason2 ]), cancelResult = ReadableStreamCancel(stream, compositeReason);
        resolveCancelPromise(cancelResult);
       }
       return cancelPromise;
      }
      function cancel2Algorithm(reason) {
       if (canceled2 = !0, reason2 = reason, canceled1) {
        const compositeReason = CreateArrayFromList([ reason1, reason2 ]), cancelResult = ReadableStreamCancel(stream, compositeReason);
        resolveCancelPromise(cancelResult);
       }
       return cancelPromise;
      }
      function startAlgorithm() {}
      return branch1 = CreateReadableByteStream(startAlgorithm, pull1Algorithm, cancel1Algorithm), 
      branch2 = CreateReadableByteStream(startAlgorithm, pull2Algorithm, cancel2Algorithm), 
      forwardReaderError(reader), [ branch1, branch2 ];
     }(stream) : function(stream) {
      const reader = AcquireReadableStreamDefaultReader(stream);
      let reason1, reason2, branch1, branch2, resolveCancelPromise, reading = !1, readAgain = !1, canceled1 = !1, canceled2 = !1;
      const cancelPromise = newPromise((resolve => {
       resolveCancelPromise = resolve;
      }));
      function pullAlgorithm() {
       return reading ? (readAgain = !0, promiseResolvedWith(void 0)) : (reading = !0, 
       ReadableStreamDefaultReaderRead(reader, {
        _chunkSteps: chunk => {
         _queueMicrotask((() => {
          readAgain = !1;
          const chunk1 = chunk, chunk2 = chunk;
          canceled1 || ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, chunk1), 
          canceled2 || ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, chunk2), 
          reading = !1, readAgain && pullAlgorithm();
         }));
        },
        _closeSteps: () => {
         reading = !1, canceled1 || ReadableStreamDefaultControllerClose(branch1._readableStreamController), 
         canceled2 || ReadableStreamDefaultControllerClose(branch2._readableStreamController), 
         canceled1 && canceled2 || resolveCancelPromise(void 0);
        },
        _errorSteps: () => {
         reading = !1;
        }
       }), promiseResolvedWith(void 0));
      }
      function cancel1Algorithm(reason) {
       if (canceled1 = !0, reason1 = reason, canceled2) {
        const compositeReason = CreateArrayFromList([ reason1, reason2 ]), cancelResult = ReadableStreamCancel(stream, compositeReason);
        resolveCancelPromise(cancelResult);
       }
       return cancelPromise;
      }
      function cancel2Algorithm(reason) {
       if (canceled2 = !0, reason2 = reason, canceled1) {
        const compositeReason = CreateArrayFromList([ reason1, reason2 ]), cancelResult = ReadableStreamCancel(stream, compositeReason);
        resolveCancelPromise(cancelResult);
       }
       return cancelPromise;
      }
      function startAlgorithm() {}
      return branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm), 
      branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm), 
      uponRejection(reader._closedPromise, (r => (ReadableStreamDefaultControllerError(branch1._readableStreamController, r), 
      ReadableStreamDefaultControllerError(branch2._readableStreamController, r), canceled1 && canceled2 || resolveCancelPromise(void 0), 
      null))), [ branch1, branch2 ];
     }(stream);
    }
    function ReadableStreamFrom(source) {
     return typeIsObject(stream = source) && void 0 !== stream.getReader ? function(reader) {
      let stream;
      function pullAlgorithm() {
       let readPromise;
       try {
        readPromise = reader.read();
       } catch (e) {
        return promiseRejectedWith(e);
       }
       return transformPromiseWith(readPromise, (readResult => {
        if (!typeIsObject(readResult)) throw new TypeError("The promise returned by the reader.read() method must fulfill with an object");
        if (readResult.done) ReadableStreamDefaultControllerClose(stream._readableStreamController); else {
         const value = readResult.value;
         ReadableStreamDefaultControllerEnqueue(stream._readableStreamController, value);
        }
       }));
      }
      function cancelAlgorithm(reason) {
       try {
        return promiseResolvedWith(reader.cancel(reason));
       } catch (e) {
        return promiseRejectedWith(e);
       }
      }
      return stream = CreateReadableStream(noop, pullAlgorithm, cancelAlgorithm, 0), stream;
     }(source.getReader()) : function(asyncIterable) {
      let stream;
      const iteratorRecord = GetIterator(asyncIterable, "async");
      function pullAlgorithm() {
       let nextResult;
       try {
        nextResult = function(iteratorRecord) {
         const result = reflectCall(iteratorRecord.nextMethod, iteratorRecord.iterator, []);
         if (!typeIsObject(result)) throw new TypeError("The iterator.next() method must return an object");
         return result;
        }(iteratorRecord);
       } catch (e) {
        return promiseRejectedWith(e);
       }
       return transformPromiseWith(promiseResolvedWith(nextResult), (iterResult => {
        if (!typeIsObject(iterResult)) throw new TypeError("The promise returned by the iterator.next() method must fulfill with an object");
        const done = function(iterResult) {
         return Boolean(iterResult.done);
        }(iterResult);
        if (done) ReadableStreamDefaultControllerClose(stream._readableStreamController); else {
         const value = function(iterResult) {
          return iterResult.value;
         }(iterResult);
         ReadableStreamDefaultControllerEnqueue(stream._readableStreamController, value);
        }
       }));
      }
      function cancelAlgorithm(reason) {
       const iterator = iteratorRecord.iterator;
       let returnMethod, returnResult;
       try {
        returnMethod = GetMethod(iterator, "return");
       } catch (e) {
        return promiseRejectedWith(e);
       }
       if (void 0 === returnMethod) return promiseResolvedWith(void 0);
       try {
        returnResult = reflectCall(returnMethod, iterator, [ reason ]);
       } catch (e) {
        return promiseRejectedWith(e);
       }
       return transformPromiseWith(promiseResolvedWith(returnResult), (iterResult => {
        if (!typeIsObject(iterResult)) throw new TypeError("The promise returned by the iterator.return() method must fulfill with an object");
       }));
      }
      return stream = CreateReadableStream(noop, pullAlgorithm, cancelAlgorithm, 0), stream;
     }(source);
     var stream;
    }
    function convertUnderlyingSourceCancelCallback(fn, original, context) {
     return assertFunction(fn, context), reason => promiseCall(fn, original, [ reason ]);
    }
    function convertUnderlyingSourcePullCallback(fn, original, context) {
     return assertFunction(fn, context), controller => promiseCall(fn, original, [ controller ]);
    }
    function convertUnderlyingSourceStartCallback(fn, original, context) {
     return assertFunction(fn, context), controller => reflectCall(fn, original, [ controller ]);
    }
    function convertReadableStreamType(type, context) {
     if ("bytes" != (type = `${type}`)) throw new TypeError(`${context} '${type}' is not a valid enumeration value for ReadableStreamType`);
     return type;
    }
    function convertPipeOptions(options, context) {
     assertDictionary(options, context);
     const preventAbort = null == options ? void 0 : options.preventAbort, preventCancel = null == options ? void 0 : options.preventCancel, preventClose = null == options ? void 0 : options.preventClose, signal = null == options ? void 0 : options.signal;
     return void 0 !== signal && function assertAbortSignal(signal, context) {
      if (!function isAbortSignal(value) {
       if ("object" != typeof value || null === value) return !1;
       try {
        return "boolean" == typeof value.aborted;
       } catch (_a) {
        return !1;
       }
      }(signal)) throw new TypeError(`${context} is not an AbortSignal.`);
     }(signal, `${context} has member 'signal' that`), {
      preventAbort: Boolean(preventAbort),
      preventCancel: Boolean(preventCancel),
      preventClose: Boolean(preventClose),
      signal
     };
    }
    Object.defineProperties(ReadableStreamDefaultController.prototype, {
     close: {
      enumerable: !0
     },
     enqueue: {
      enumerable: !0
     },
     error: {
      enumerable: !0
     },
     desiredSize: {
      enumerable: !0
     }
    }), setFunctionName(ReadableStreamDefaultController.prototype.close, "close"), setFunctionName(ReadableStreamDefaultController.prototype.enqueue, "enqueue"), 
    setFunctionName(ReadableStreamDefaultController.prototype.error, "error"), "symbol" == typeof Symbol.toStringTag && Object.defineProperty(ReadableStreamDefaultController.prototype, Symbol.toStringTag, {
     value: "ReadableStreamDefaultController",
     configurable: !0
    });
    class ReadableStream {
     constructor(rawUnderlyingSource = {}, rawStrategy = {}) {
      void 0 === rawUnderlyingSource ? rawUnderlyingSource = null : assertObject(rawUnderlyingSource, "First parameter");
      const strategy = convertQueuingStrategy(rawStrategy, "Second parameter"), underlyingSource = function(source, context) {
       assertDictionary(source, context);
       const original = source, autoAllocateChunkSize = null == original ? void 0 : original.autoAllocateChunkSize, cancel = null == original ? void 0 : original.cancel, pull = null == original ? void 0 : original.pull, start = null == original ? void 0 : original.start, type = null == original ? void 0 : original.type;
       return {
        autoAllocateChunkSize: void 0 === autoAllocateChunkSize ? void 0 : convertUnsignedLongLongWithEnforceRange(autoAllocateChunkSize, `${context} has member 'autoAllocateChunkSize' that`),
        cancel: void 0 === cancel ? void 0 : convertUnderlyingSourceCancelCallback(cancel, original, `${context} has member 'cancel' that`),
        pull: void 0 === pull ? void 0 : convertUnderlyingSourcePullCallback(pull, original, `${context} has member 'pull' that`),
        start: void 0 === start ? void 0 : convertUnderlyingSourceStartCallback(start, original, `${context} has member 'start' that`),
        type: void 0 === type ? void 0 : convertReadableStreamType(type, `${context} has member 'type' that`)
       };
      }(rawUnderlyingSource, "First parameter");
      if (InitializeReadableStream(this), "bytes" === underlyingSource.type) {
       if (void 0 !== strategy.size) throw new RangeError("The strategy for a byte stream cannot have a size function");
       !function(stream, underlyingByteSource, highWaterMark) {
        const controller = Object.create(ReadableByteStreamController.prototype);
        let startAlgorithm, pullAlgorithm, cancelAlgorithm;
        startAlgorithm = void 0 !== underlyingByteSource.start ? () => underlyingByteSource.start(controller) : () => {}, 
        pullAlgorithm = void 0 !== underlyingByteSource.pull ? () => underlyingByteSource.pull(controller) : () => promiseResolvedWith(void 0), 
        cancelAlgorithm = void 0 !== underlyingByteSource.cancel ? reason => underlyingByteSource.cancel(reason) : () => promiseResolvedWith(void 0);
        const autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;
        if (0 === autoAllocateChunkSize) throw new TypeError("autoAllocateChunkSize must be greater than 0");
        SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize);
       }(this, underlyingSource, ExtractHighWaterMark(strategy, 0));
      } else {
       const sizeAlgorithm = ExtractSizeAlgorithm(strategy);
       !function(stream, underlyingSource, highWaterMark, sizeAlgorithm) {
        const controller = Object.create(ReadableStreamDefaultController.prototype);
        let startAlgorithm, pullAlgorithm, cancelAlgorithm;
        startAlgorithm = void 0 !== underlyingSource.start ? () => underlyingSource.start(controller) : () => {}, 
        pullAlgorithm = void 0 !== underlyingSource.pull ? () => underlyingSource.pull(controller) : () => promiseResolvedWith(void 0), 
        cancelAlgorithm = void 0 !== underlyingSource.cancel ? reason => underlyingSource.cancel(reason) : () => promiseResolvedWith(void 0), 
        SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
       }(this, underlyingSource, ExtractHighWaterMark(strategy, 1), sizeAlgorithm);
      }
     }
     get locked() {
      if (!IsReadableStream(this)) throw streamBrandCheckException$1("locked");
      return IsReadableStreamLocked(this);
     }
     cancel(reason = void 0) {
      return IsReadableStream(this) ? IsReadableStreamLocked(this) ? promiseRejectedWith(new TypeError("Cannot cancel a stream that already has a reader")) : ReadableStreamCancel(this, reason) : promiseRejectedWith(streamBrandCheckException$1("cancel"));
     }
     getReader(rawOptions = void 0) {
      if (!IsReadableStream(this)) throw streamBrandCheckException$1("getReader");
      return void 0 === function(options, context) {
       assertDictionary(options, context);
       const mode = null == options ? void 0 : options.mode;
       return {
        mode: void 0 === mode ? void 0 : convertReadableStreamReaderMode(mode, `${context} has member 'mode' that`)
       };
      }(rawOptions, "First parameter").mode ? AcquireReadableStreamDefaultReader(this) : AcquireReadableStreamBYOBReader(this);
     }
     pipeThrough(rawTransform, rawOptions = {}) {
      if (!IsReadableStream(this)) throw streamBrandCheckException$1("pipeThrough");
      assertRequiredArgument(rawTransform, 1, "pipeThrough");
      const transform = function(pair, context) {
       assertDictionary(pair, context);
       const readable = null == pair ? void 0 : pair.readable;
       assertRequiredField(readable, "readable", "ReadableWritablePair"), assertReadableStream(readable, `${context} has member 'readable' that`);
       const writable = null == pair ? void 0 : pair.writable;
       return assertRequiredField(writable, "writable", "ReadableWritablePair"), assertWritableStream(writable, `${context} has member 'writable' that`), 
       {
        readable,
        writable
       };
      }(rawTransform, "First parameter"), options = convertPipeOptions(rawOptions, "Second parameter");
      if (IsReadableStreamLocked(this)) throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream");
      if (IsWritableStreamLocked(transform.writable)) throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream");
      return setPromiseIsHandledToTrue(ReadableStreamPipeTo(this, transform.writable, options.preventClose, options.preventAbort, options.preventCancel, options.signal)), 
      transform.readable;
     }
     pipeTo(destination, rawOptions = {}) {
      if (!IsReadableStream(this)) return promiseRejectedWith(streamBrandCheckException$1("pipeTo"));
      if (void 0 === destination) return promiseRejectedWith("Parameter 1 is required in 'pipeTo'.");
      if (!IsWritableStream(destination)) return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo's first argument must be a WritableStream"));
      let options;
      try {
       options = convertPipeOptions(rawOptions, "Second parameter");
      } catch (e) {
       return promiseRejectedWith(e);
      }
      return IsReadableStreamLocked(this) ? promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream")) : IsWritableStreamLocked(destination) ? promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream")) : ReadableStreamPipeTo(this, destination, options.preventClose, options.preventAbort, options.preventCancel, options.signal);
     }
     tee() {
      if (!IsReadableStream(this)) throw streamBrandCheckException$1("tee");
      return CreateArrayFromList(ReadableStreamTee(this));
     }
     values(rawOptions = void 0) {
      if (!IsReadableStream(this)) throw streamBrandCheckException$1("values");
      return function(stream, preventCancel) {
       const reader = AcquireReadableStreamDefaultReader(stream), impl = new ReadableStreamAsyncIteratorImpl(reader, preventCancel), iterator = Object.create(ReadableStreamAsyncIteratorPrototype);
       return iterator._asyncIteratorImpl = impl, iterator;
      }(this, function(options, context) {
       assertDictionary(options, context);
       const preventCancel = null == options ? void 0 : options.preventCancel;
       return {
        preventCancel: Boolean(preventCancel)
       };
      }(rawOptions, "First parameter").preventCancel);
     }
     [SymbolAsyncIterator](options) {
      return this.values(options);
     }
     static from(asyncIterable) {
      return ReadableStreamFrom(asyncIterable);
     }
    }
    function CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {
     const stream = Object.create(ReadableStream.prototype);
     return InitializeReadableStream(stream), SetUpReadableStreamDefaultController(stream, Object.create(ReadableStreamDefaultController.prototype), startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm), 
     stream;
    }
    function CreateReadableByteStream(startAlgorithm, pullAlgorithm, cancelAlgorithm) {
     const stream = Object.create(ReadableStream.prototype);
     return InitializeReadableStream(stream), SetUpReadableByteStreamController(stream, Object.create(ReadableByteStreamController.prototype), startAlgorithm, pullAlgorithm, cancelAlgorithm, 0, void 0), 
     stream;
    }
    function InitializeReadableStream(stream) {
     stream._state = "readable", stream._reader = void 0, stream._storedError = void 0, 
     stream._disturbed = !1;
    }
    function IsReadableStream(x) {
     return !!typeIsObject(x) && !!Object.prototype.hasOwnProperty.call(x, "_readableStreamController") && x instanceof ReadableStream;
    }
    function IsReadableStreamLocked(stream) {
     return void 0 !== stream._reader;
    }
    function ReadableStreamCancel(stream, reason) {
     if (stream._disturbed = !0, "closed" === stream._state) return promiseResolvedWith(void 0);
     if ("errored" === stream._state) return promiseRejectedWith(stream._storedError);
     ReadableStreamClose(stream);
     const reader = stream._reader;
     if (void 0 !== reader && IsReadableStreamBYOBReader(reader)) {
      const readIntoRequests = reader._readIntoRequests;
      reader._readIntoRequests = new SimpleQueue, readIntoRequests.forEach((readIntoRequest => {
       readIntoRequest._closeSteps(void 0);
      }));
     }
     return transformPromiseWith(stream._readableStreamController[CancelSteps](reason), noop);
    }
    function ReadableStreamClose(stream) {
     stream._state = "closed";
     const reader = stream._reader;
     if (void 0 !== reader && (defaultReaderClosedPromiseResolve(reader), IsReadableStreamDefaultReader(reader))) {
      const readRequests = reader._readRequests;
      reader._readRequests = new SimpleQueue, readRequests.forEach((readRequest => {
       readRequest._closeSteps();
      }));
     }
    }
    function ReadableStreamError(stream, e) {
     stream._state = "errored", stream._storedError = e;
     const reader = stream._reader;
     void 0 !== reader && (defaultReaderClosedPromiseReject(reader, e), IsReadableStreamDefaultReader(reader) ? ReadableStreamDefaultReaderErrorReadRequests(reader, e) : ReadableStreamBYOBReaderErrorReadIntoRequests(reader, e));
    }
    function streamBrandCheckException$1(name) {
     return new TypeError(`ReadableStream.prototype.${name} can only be used on a ReadableStream`);
    }
    function convertQueuingStrategyInit(init, context) {
     assertDictionary(init, context);
     const highWaterMark = null == init ? void 0 : init.highWaterMark;
     return assertRequiredField(highWaterMark, "highWaterMark", "QueuingStrategyInit"), 
     {
      highWaterMark: convertUnrestrictedDouble(highWaterMark)
     };
    }
    Object.defineProperties(ReadableStream, {
     from: {
      enumerable: !0
     }
    }), Object.defineProperties(ReadableStream.prototype, {
     cancel: {
      enumerable: !0
     },
     getReader: {
      enumerable: !0
     },
     pipeThrough: {
      enumerable: !0
     },
     pipeTo: {
      enumerable: !0
     },
     tee: {
      enumerable: !0
     },
     values: {
      enumerable: !0
     },
     locked: {
      enumerable: !0
     }
    }), setFunctionName(ReadableStream.from, "from"), setFunctionName(ReadableStream.prototype.cancel, "cancel"), 
    setFunctionName(ReadableStream.prototype.getReader, "getReader"), setFunctionName(ReadableStream.prototype.pipeThrough, "pipeThrough"), 
    setFunctionName(ReadableStream.prototype.pipeTo, "pipeTo"), setFunctionName(ReadableStream.prototype.tee, "tee"), 
    setFunctionName(ReadableStream.prototype.values, "values"), "symbol" == typeof Symbol.toStringTag && Object.defineProperty(ReadableStream.prototype, Symbol.toStringTag, {
     value: "ReadableStream",
     configurable: !0
    }), Object.defineProperty(ReadableStream.prototype, SymbolAsyncIterator, {
     value: ReadableStream.prototype.values,
     writable: !0,
     configurable: !0
    });
    const byteLengthSizeFunction = chunk => chunk.byteLength;
    setFunctionName(byteLengthSizeFunction, "size");
    class ByteLengthQueuingStrategy {
     constructor(options) {
      assertRequiredArgument(options, 1, "ByteLengthQueuingStrategy"), options = convertQueuingStrategyInit(options, "First parameter"), 
      this._byteLengthQueuingStrategyHighWaterMark = options.highWaterMark;
     }
     get highWaterMark() {
      if (!IsByteLengthQueuingStrategy(this)) throw byteLengthBrandCheckException("highWaterMark");
      return this._byteLengthQueuingStrategyHighWaterMark;
     }
     get size() {
      if (!IsByteLengthQueuingStrategy(this)) throw byteLengthBrandCheckException("size");
      return byteLengthSizeFunction;
     }
    }
    function byteLengthBrandCheckException(name) {
     return new TypeError(`ByteLengthQueuingStrategy.prototype.${name} can only be used on a ByteLengthQueuingStrategy`);
    }
    function IsByteLengthQueuingStrategy(x) {
     return !!typeIsObject(x) && !!Object.prototype.hasOwnProperty.call(x, "_byteLengthQueuingStrategyHighWaterMark") && x instanceof ByteLengthQueuingStrategy;
    }
    Object.defineProperties(ByteLengthQueuingStrategy.prototype, {
     highWaterMark: {
      enumerable: !0
     },
     size: {
      enumerable: !0
     }
    }), "symbol" == typeof Symbol.toStringTag && Object.defineProperty(ByteLengthQueuingStrategy.prototype, Symbol.toStringTag, {
     value: "ByteLengthQueuingStrategy",
     configurable: !0
    });
    const countSizeFunction = () => 1;
    setFunctionName(countSizeFunction, "size");
    class CountQueuingStrategy {
     constructor(options) {
      assertRequiredArgument(options, 1, "CountQueuingStrategy"), options = convertQueuingStrategyInit(options, "First parameter"), 
      this._countQueuingStrategyHighWaterMark = options.highWaterMark;
     }
     get highWaterMark() {
      if (!IsCountQueuingStrategy(this)) throw countBrandCheckException("highWaterMark");
      return this._countQueuingStrategyHighWaterMark;
     }
     get size() {
      if (!IsCountQueuingStrategy(this)) throw countBrandCheckException("size");
      return countSizeFunction;
     }
    }
    function countBrandCheckException(name) {
     return new TypeError(`CountQueuingStrategy.prototype.${name} can only be used on a CountQueuingStrategy`);
    }
    function IsCountQueuingStrategy(x) {
     return !!typeIsObject(x) && !!Object.prototype.hasOwnProperty.call(x, "_countQueuingStrategyHighWaterMark") && x instanceof CountQueuingStrategy;
    }
    function convertTransformerFlushCallback(fn, original, context) {
     return assertFunction(fn, context), controller => promiseCall(fn, original, [ controller ]);
    }
    function convertTransformerStartCallback(fn, original, context) {
     return assertFunction(fn, context), controller => reflectCall(fn, original, [ controller ]);
    }
    function convertTransformerTransformCallback(fn, original, context) {
     return assertFunction(fn, context), (chunk, controller) => promiseCall(fn, original, [ chunk, controller ]);
    }
    function convertTransformerCancelCallback(fn, original, context) {
     return assertFunction(fn, context), reason => promiseCall(fn, original, [ reason ]);
    }
    Object.defineProperties(CountQueuingStrategy.prototype, {
     highWaterMark: {
      enumerable: !0
     },
     size: {
      enumerable: !0
     }
    }), "symbol" == typeof Symbol.toStringTag && Object.defineProperty(CountQueuingStrategy.prototype, Symbol.toStringTag, {
     value: "CountQueuingStrategy",
     configurable: !0
    });
    class TransformStream {
     constructor(rawTransformer = {}, rawWritableStrategy = {}, rawReadableStrategy = {}) {
      void 0 === rawTransformer && (rawTransformer = null);
      const writableStrategy = convertQueuingStrategy(rawWritableStrategy, "Second parameter"), readableStrategy = convertQueuingStrategy(rawReadableStrategy, "Third parameter"), transformer = function(original, context) {
       assertDictionary(original, context);
       const cancel = null == original ? void 0 : original.cancel, flush = null == original ? void 0 : original.flush, readableType = null == original ? void 0 : original.readableType, start = null == original ? void 0 : original.start, transform = null == original ? void 0 : original.transform, writableType = null == original ? void 0 : original.writableType;
       return {
        cancel: void 0 === cancel ? void 0 : convertTransformerCancelCallback(cancel, original, `${context} has member 'cancel' that`),
        flush: void 0 === flush ? void 0 : convertTransformerFlushCallback(flush, original, `${context} has member 'flush' that`),
        readableType,
        start: void 0 === start ? void 0 : convertTransformerStartCallback(start, original, `${context} has member 'start' that`),
        transform: void 0 === transform ? void 0 : convertTransformerTransformCallback(transform, original, `${context} has member 'transform' that`),
        writableType
       };
      }(rawTransformer, "First parameter");
      if (void 0 !== transformer.readableType) throw new RangeError("Invalid readableType specified");
      if (void 0 !== transformer.writableType) throw new RangeError("Invalid writableType specified");
      const readableHighWaterMark = ExtractHighWaterMark(readableStrategy, 0), readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy), writableHighWaterMark = ExtractHighWaterMark(writableStrategy, 1), writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy);
      let startPromise_resolve;
      !function(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) {
       function startAlgorithm() {
        return startPromise;
       }
       function writeAlgorithm(chunk) {
        return function(stream, chunk) {
         const controller = stream._transformStreamController;
         return stream._backpressure ? transformPromiseWith(stream._backpressureChangePromise, (() => {
          const writable = stream._writable;
          if ("erroring" === writable._state) throw writable._storedError;
          return TransformStreamDefaultControllerPerformTransform(controller, chunk);
         })) : TransformStreamDefaultControllerPerformTransform(controller, chunk);
        }(stream, chunk);
       }
       function abortAlgorithm(reason) {
        return function(stream, reason) {
         const controller = stream._transformStreamController;
         if (void 0 !== controller._finishPromise) return controller._finishPromise;
         const readable = stream._readable;
         controller._finishPromise = newPromise(((resolve, reject) => {
          controller._finishPromise_resolve = resolve, controller._finishPromise_reject = reject;
         }));
         const cancelPromise = controller._cancelAlgorithm(reason);
         return TransformStreamDefaultControllerClearAlgorithms(controller), uponPromise(cancelPromise, (() => ("errored" === readable._state ? defaultControllerFinishPromiseReject(controller, readable._storedError) : (ReadableStreamDefaultControllerError(readable._readableStreamController, reason), 
         defaultControllerFinishPromiseResolve(controller)), null)), (r => (ReadableStreamDefaultControllerError(readable._readableStreamController, r), 
         defaultControllerFinishPromiseReject(controller, r), null))), controller._finishPromise;
        }(stream, reason);
       }
       function closeAlgorithm() {
        return function(stream) {
         const controller = stream._transformStreamController;
         if (void 0 !== controller._finishPromise) return controller._finishPromise;
         const readable = stream._readable;
         controller._finishPromise = newPromise(((resolve, reject) => {
          controller._finishPromise_resolve = resolve, controller._finishPromise_reject = reject;
         }));
         const flushPromise = controller._flushAlgorithm();
         return TransformStreamDefaultControllerClearAlgorithms(controller), uponPromise(flushPromise, (() => ("errored" === readable._state ? defaultControllerFinishPromiseReject(controller, readable._storedError) : (ReadableStreamDefaultControllerClose(readable._readableStreamController), 
         defaultControllerFinishPromiseResolve(controller)), null)), (r => (ReadableStreamDefaultControllerError(readable._readableStreamController, r), 
         defaultControllerFinishPromiseReject(controller, r), null))), controller._finishPromise;
        }(stream);
       }
       function pullAlgorithm() {
        return function(stream) {
         return TransformStreamSetBackpressure(stream, !1), stream._backpressureChangePromise;
        }(stream);
       }
       function cancelAlgorithm(reason) {
        return function(stream, reason) {
         const controller = stream._transformStreamController;
         if (void 0 !== controller._finishPromise) return controller._finishPromise;
         const writable = stream._writable;
         controller._finishPromise = newPromise(((resolve, reject) => {
          controller._finishPromise_resolve = resolve, controller._finishPromise_reject = reject;
         }));
         const cancelPromise = controller._cancelAlgorithm(reason);
         return TransformStreamDefaultControllerClearAlgorithms(controller), uponPromise(cancelPromise, (() => ("errored" === writable._state ? defaultControllerFinishPromiseReject(controller, writable._storedError) : (WritableStreamDefaultControllerErrorIfNeeded(writable._writableStreamController, reason), 
         TransformStreamUnblockWrite(stream), defaultControllerFinishPromiseResolve(controller)), 
         null)), (r => (WritableStreamDefaultControllerErrorIfNeeded(writable._writableStreamController, r), 
         TransformStreamUnblockWrite(stream), defaultControllerFinishPromiseReject(controller, r), 
         null))), controller._finishPromise;
        }(stream, reason);
       }
       stream._writable = function(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {
        const stream = Object.create(WritableStream.prototype);
        return InitializeWritableStream(stream), SetUpWritableStreamDefaultController(stream, Object.create(WritableStreamDefaultController.prototype), startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm), 
        stream;
       }(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm), 
       stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark, readableSizeAlgorithm), 
       stream._backpressure = void 0, stream._backpressureChangePromise = void 0, stream._backpressureChangePromise_resolve = void 0, 
       TransformStreamSetBackpressure(stream, !0), stream._transformStreamController = void 0;
      }(this, newPromise((resolve => {
       startPromise_resolve = resolve;
      })), writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm), 
      function(stream, transformer) {
       const controller = Object.create(TransformStreamDefaultController.prototype);
       let transformAlgorithm, flushAlgorithm, cancelAlgorithm;
       transformAlgorithm = void 0 !== transformer.transform ? chunk => transformer.transform(chunk, controller) : chunk => {
        try {
         return TransformStreamDefaultControllerEnqueue(controller, chunk), promiseResolvedWith(void 0);
        } catch (transformResultE) {
         return promiseRejectedWith(transformResultE);
        }
       }, flushAlgorithm = void 0 !== transformer.flush ? () => transformer.flush(controller) : () => promiseResolvedWith(void 0), 
       cancelAlgorithm = void 0 !== transformer.cancel ? reason => transformer.cancel(reason) : () => promiseResolvedWith(void 0), 
       function(stream, controller, transformAlgorithm, flushAlgorithm, cancelAlgorithm) {
        controller._controlledTransformStream = stream, stream._transformStreamController = controller, 
        controller._transformAlgorithm = transformAlgorithm, controller._flushAlgorithm = flushAlgorithm, 
        controller._cancelAlgorithm = cancelAlgorithm, controller._finishPromise = void 0, 
        controller._finishPromise_resolve = void 0, controller._finishPromise_reject = void 0;
       }(stream, controller, transformAlgorithm, flushAlgorithm, cancelAlgorithm);
      }(this, transformer), void 0 !== transformer.start ? startPromise_resolve(transformer.start(this._transformStreamController)) : startPromise_resolve(void 0);
     }
     get readable() {
      if (!IsTransformStream(this)) throw streamBrandCheckException("readable");
      return this._readable;
     }
     get writable() {
      if (!IsTransformStream(this)) throw streamBrandCheckException("writable");
      return this._writable;
     }
    }
    function IsTransformStream(x) {
     return !!typeIsObject(x) && !!Object.prototype.hasOwnProperty.call(x, "_transformStreamController") && x instanceof TransformStream;
    }
    function TransformStreamError(stream, e) {
     ReadableStreamDefaultControllerError(stream._readable._readableStreamController, e), 
     TransformStreamErrorWritableAndUnblockWrite(stream, e);
    }
    function TransformStreamErrorWritableAndUnblockWrite(stream, e) {
     TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController), 
     WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e), 
     TransformStreamUnblockWrite(stream);
    }
    function TransformStreamUnblockWrite(stream) {
     stream._backpressure && TransformStreamSetBackpressure(stream, !1);
    }
    function TransformStreamSetBackpressure(stream, backpressure) {
     void 0 !== stream._backpressureChangePromise && stream._backpressureChangePromise_resolve(), 
     stream._backpressureChangePromise = newPromise((resolve => {
      stream._backpressureChangePromise_resolve = resolve;
     })), stream._backpressure = backpressure;
    }
    Object.defineProperties(TransformStream.prototype, {
     readable: {
      enumerable: !0
     },
     writable: {
      enumerable: !0
     }
    }), "symbol" == typeof Symbol.toStringTag && Object.defineProperty(TransformStream.prototype, Symbol.toStringTag, {
     value: "TransformStream",
     configurable: !0
    });
    class TransformStreamDefaultController {
     constructor() {
      throw new TypeError("Illegal constructor");
     }
     get desiredSize() {
      if (!IsTransformStreamDefaultController(this)) throw defaultControllerBrandCheckException("desiredSize");
      return ReadableStreamDefaultControllerGetDesiredSize(this._controlledTransformStream._readable._readableStreamController);
     }
     enqueue(chunk = void 0) {
      if (!IsTransformStreamDefaultController(this)) throw defaultControllerBrandCheckException("enqueue");
      TransformStreamDefaultControllerEnqueue(this, chunk);
     }
     error(reason = void 0) {
      if (!IsTransformStreamDefaultController(this)) throw defaultControllerBrandCheckException("error");
      var e;
      e = reason, TransformStreamError(this._controlledTransformStream, e);
     }
     terminate() {
      if (!IsTransformStreamDefaultController(this)) throw defaultControllerBrandCheckException("terminate");
      !function(controller) {
       const stream = controller._controlledTransformStream;
       ReadableStreamDefaultControllerClose(stream._readable._readableStreamController);
       const error = new TypeError("TransformStream terminated");
       TransformStreamErrorWritableAndUnblockWrite(stream, error);
      }(this);
     }
    }
    function IsTransformStreamDefaultController(x) {
     return !!typeIsObject(x) && !!Object.prototype.hasOwnProperty.call(x, "_controlledTransformStream") && x instanceof TransformStreamDefaultController;
    }
    function TransformStreamDefaultControllerClearAlgorithms(controller) {
     controller._transformAlgorithm = void 0, controller._flushAlgorithm = void 0, controller._cancelAlgorithm = void 0;
    }
    function TransformStreamDefaultControllerEnqueue(controller, chunk) {
     const stream = controller._controlledTransformStream, readableController = stream._readable._readableStreamController;
     if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController)) throw new TypeError("Readable side is not in a state that permits enqueue");
     try {
      ReadableStreamDefaultControllerEnqueue(readableController, chunk);
     } catch (e) {
      throw TransformStreamErrorWritableAndUnblockWrite(stream, e), stream._readable._storedError;
     }
     const backpressure = function(controller) {
      return !ReadableStreamDefaultControllerShouldCallPull(controller);
     }(readableController);
     backpressure !== stream._backpressure && TransformStreamSetBackpressure(stream, !0);
    }
    function TransformStreamDefaultControllerPerformTransform(controller, chunk) {
     return transformPromiseWith(controller._transformAlgorithm(chunk), void 0, (r => {
      throw TransformStreamError(controller._controlledTransformStream, r), r;
     }));
    }
    function defaultControllerBrandCheckException(name) {
     return new TypeError(`TransformStreamDefaultController.prototype.${name} can only be used on a TransformStreamDefaultController`);
    }
    function defaultControllerFinishPromiseResolve(controller) {
     void 0 !== controller._finishPromise_resolve && (controller._finishPromise_resolve(), 
     controller._finishPromise_resolve = void 0, controller._finishPromise_reject = void 0);
    }
    function defaultControllerFinishPromiseReject(controller, reason) {
     void 0 !== controller._finishPromise_reject && (setPromiseIsHandledToTrue(controller._finishPromise), 
     controller._finishPromise_reject(reason), controller._finishPromise_resolve = void 0, 
     controller._finishPromise_reject = void 0);
    }
    function streamBrandCheckException(name) {
     return new TypeError(`TransformStream.prototype.${name} can only be used on a TransformStream`);
    }
    Object.defineProperties(TransformStreamDefaultController.prototype, {
     enqueue: {
      enumerable: !0
     },
     error: {
      enumerable: !0
     },
     terminate: {
      enumerable: !0
     },
     desiredSize: {
      enumerable: !0
     }
    }), setFunctionName(TransformStreamDefaultController.prototype.enqueue, "enqueue"), 
    setFunctionName(TransformStreamDefaultController.prototype.error, "error"), setFunctionName(TransformStreamDefaultController.prototype.terminate, "terminate"), 
    "symbol" == typeof Symbol.toStringTag && Object.defineProperty(TransformStreamDefaultController.prototype, Symbol.toStringTag, {
     value: "TransformStreamDefaultController",
     configurable: !0
    }), exports.ByteLengthQueuingStrategy = ByteLengthQueuingStrategy, exports.CountQueuingStrategy = CountQueuingStrategy, 
    exports.ReadableByteStreamController = ReadableByteStreamController, exports.ReadableStream = ReadableStream, 
    exports.ReadableStreamBYOBReader = ReadableStreamBYOBReader, exports.ReadableStreamBYOBRequest = ReadableStreamBYOBRequest, 
    exports.ReadableStreamDefaultController = ReadableStreamDefaultController, exports.ReadableStreamDefaultReader = ReadableStreamDefaultReader, 
    exports.TransformStream = TransformStream, exports.TransformStreamDefaultController = TransformStreamDefaultController, 
    exports.WritableStream = WritableStream, exports.WritableStreamDefaultController = WritableStreamDefaultController, 
    exports.WritableStreamDefaultWriter = WritableStreamDefaultWriter;
   }, factory(exports);
  },
  85616: module => {
   "use strict";
   var conversions = {};
   function sign(x) {
    return x < 0 ? -1 : 1;
   }
   function createNumberConversion(bitLength, typeOpts) {
    typeOpts.unsigned || --bitLength;
    const lowerBound = typeOpts.unsigned ? 0 : -Math.pow(2, bitLength), upperBound = Math.pow(2, bitLength) - 1, moduloVal = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength) : Math.pow(2, bitLength), moduloBound = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength - 1) : Math.pow(2, bitLength - 1);
    return function(V, opts) {
     opts || (opts = {});
     let x = +V;
     if (opts.enforceRange) {
      if (!Number.isFinite(x)) throw new TypeError("Argument is not a finite number");
      if (x = sign(x) * Math.floor(Math.abs(x)), x < lowerBound || x > upperBound) throw new TypeError("Argument is not in byte range");
      return x;
     }
     if (!isNaN(x) && opts.clamp) return x = function(x) {
      return x % 1 != .5 || 1 & x ? Math.round(x) : Math.floor(x);
     }(x), x < lowerBound && (x = lowerBound), x > upperBound && (x = upperBound), x;
     if (!Number.isFinite(x) || 0 === x) return 0;
     if (x = sign(x) * Math.floor(Math.abs(x)), x %= moduloVal, !typeOpts.unsigned && x >= moduloBound) return x - moduloVal;
     if (typeOpts.unsigned) if (x < 0) x += moduloVal; else if (-0 === x) return 0;
     return x;
    };
   }
   module.exports = conversions, conversions.void = function() {}, conversions.boolean = function(val) {
    return !!val;
   }, conversions.byte = createNumberConversion(8, {
    unsigned: !1
   }), conversions.octet = createNumberConversion(8, {
    unsigned: !0
   }), conversions.short = createNumberConversion(16, {
    unsigned: !1
   }), conversions["unsigned short"] = createNumberConversion(16, {
    unsigned: !0
   }), conversions.long = createNumberConversion(32, {
    unsigned: !1
   }), conversions["unsigned long"] = createNumberConversion(32, {
    unsigned: !0
   }), conversions["long long"] = createNumberConversion(32, {
    unsigned: !1,
    moduloBitLength: 64
   }), conversions["unsigned long long"] = createNumberConversion(32, {
    unsigned: !0,
    moduloBitLength: 64
   }), conversions.double = function(V) {
    const x = +V;
    if (!Number.isFinite(x)) throw new TypeError("Argument is not a finite floating-point value");
    return x;
   }, conversions["unrestricted double"] = function(V) {
    const x = +V;
    if (isNaN(x)) throw new TypeError("Argument is NaN");
    return x;
   }, conversions.float = conversions.double, conversions["unrestricted float"] = conversions["unrestricted double"], 
   conversions.DOMString = function(V, opts) {
    return opts || (opts = {}), opts.treatNullAsEmptyString && null === V ? "" : String(V);
   }, conversions.ByteString = function(V, opts) {
    const x = String(V);
    let c;
    for (let i = 0; void 0 !== (c = x.codePointAt(i)); ++i) if (c > 255) throw new TypeError("Argument is not a valid bytestring");
    return x;
   }, conversions.USVString = function(V) {
    const S = String(V), n = S.length, U = [];
    for (let i = 0; i < n; ++i) {
     const c = S.charCodeAt(i);
     if (c < 55296 || c > 57343) U.push(String.fromCodePoint(c)); else if (56320 <= c && c <= 57343) U.push(String.fromCodePoint(65533)); else if (i === n - 1) U.push(String.fromCodePoint(65533)); else {
      const d = S.charCodeAt(i + 1);
      if (56320 <= d && d <= 57343) {
       const a = 1023 & c, b = 1023 & d;
       U.push(String.fromCodePoint(65536 + 1024 * a + b)), ++i;
      } else U.push(String.fromCodePoint(65533));
     }
    }
    return U.join("");
   }, conversions.Date = function(V, opts) {
    if (!(V instanceof Date)) throw new TypeError("Argument is not a Date object");
    if (!isNaN(V)) return V;
   }, conversions.RegExp = function(V, opts) {
    return V instanceof RegExp || (V = new RegExp(V)), V;
   };
  },
  67079: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   const usm = __webpack_require__(95484);
   exports.implementation = class {
    constructor(constructorArgs) {
     const url = constructorArgs[0], base = constructorArgs[1];
     let parsedBase = null;
     if (void 0 !== base && (parsedBase = usm.basicURLParse(base), "failure" === parsedBase)) throw new TypeError("Invalid base URL");
     const parsedURL = usm.basicURLParse(url, {
      baseURL: parsedBase
     });
     if ("failure" === parsedURL) throw new TypeError("Invalid URL");
     this._url = parsedURL;
    }
    get href() {
     return usm.serializeURL(this._url);
    }
    set href(v) {
     const parsedURL = usm.basicURLParse(v);
     if ("failure" === parsedURL) throw new TypeError("Invalid URL");
     this._url = parsedURL;
    }
    get origin() {
     return usm.serializeURLOrigin(this._url);
    }
    get protocol() {
     return this._url.scheme + ":";
    }
    set protocol(v) {
     usm.basicURLParse(v + ":", {
      url: this._url,
      stateOverride: "scheme start"
     });
    }
    get username() {
     return this._url.username;
    }
    set username(v) {
     usm.cannotHaveAUsernamePasswordPort(this._url) || usm.setTheUsername(this._url, v);
    }
    get password() {
     return this._url.password;
    }
    set password(v) {
     usm.cannotHaveAUsernamePasswordPort(this._url) || usm.setThePassword(this._url, v);
    }
    get host() {
     const url = this._url;
     return null === url.host ? "" : null === url.port ? usm.serializeHost(url.host) : usm.serializeHost(url.host) + ":" + usm.serializeInteger(url.port);
    }
    set host(v) {
     this._url.cannotBeABaseURL || usm.basicURLParse(v, {
      url: this._url,
      stateOverride: "host"
     });
    }
    get hostname() {
     return null === this._url.host ? "" : usm.serializeHost(this._url.host);
    }
    set hostname(v) {
     this._url.cannotBeABaseURL || usm.basicURLParse(v, {
      url: this._url,
      stateOverride: "hostname"
     });
    }
    get port() {
     return null === this._url.port ? "" : usm.serializeInteger(this._url.port);
    }
    set port(v) {
     usm.cannotHaveAUsernamePasswordPort(this._url) || ("" === v ? this._url.port = null : usm.basicURLParse(v, {
      url: this._url,
      stateOverride: "port"
     }));
    }
    get pathname() {
     return this._url.cannotBeABaseURL ? this._url.path[0] : 0 === this._url.path.length ? "" : "/" + this._url.path.join("/");
    }
    set pathname(v) {
     this._url.cannotBeABaseURL || (this._url.path = [], usm.basicURLParse(v, {
      url: this._url,
      stateOverride: "path start"
     }));
    }
    get search() {
     return null === this._url.query || "" === this._url.query ? "" : "?" + this._url.query;
    }
    set search(v) {
     const url = this._url;
     if ("" === v) return void (url.query = null);
     const input = "?" === v[0] ? v.substring(1) : v;
     url.query = "", usm.basicURLParse(input, {
      url,
      stateOverride: "query"
     });
    }
    get hash() {
     return null === this._url.fragment || "" === this._url.fragment ? "" : "#" + this._url.fragment;
    }
    set hash(v) {
     if ("" === v) return void (this._url.fragment = null);
     const input = "#" === v[0] ? v.substring(1) : v;
     this._url.fragment = "", usm.basicURLParse(input, {
      url: this._url,
      stateOverride: "fragment"
     });
    }
    toJSON() {
     return this.href;
    }
   };
  },
  76648: (module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   const conversions = __webpack_require__(85616), utils = __webpack_require__(46892), Impl = __webpack_require__(67079), impl = utils.implSymbol;
   function URL(url) {
    if (!this || this[impl] || !(this instanceof URL)) throw new TypeError("Failed to construct 'URL': Please use the 'new' operator, this DOM object constructor cannot be called as a function.");
    if (arguments.length < 1) throw new TypeError("Failed to construct 'URL': 1 argument required, but only " + arguments.length + " present.");
    const args = [];
    for (let i = 0; i < arguments.length && i < 2; ++i) args[i] = arguments[i];
    args[0] = conversions.USVString(args[0]), void 0 !== args[1] && (args[1] = conversions.USVString(args[1])), 
    module.exports.setup(this, args);
   }
   URL.prototype.toJSON = function() {
    if (!this || !module.exports.is(this)) throw new TypeError("Illegal invocation");
    const args = [];
    for (let i = 0; i < arguments.length && i < 0; ++i) args[i] = arguments[i];
    return this[impl].toJSON.apply(this[impl], args);
   }, Object.defineProperty(URL.prototype, "href", {
    get() {
     return this[impl].href;
    },
    set(V) {
     V = conversions.USVString(V), this[impl].href = V;
    },
    enumerable: !0,
    configurable: !0
   }), URL.prototype.toString = function() {
    if (!this || !module.exports.is(this)) throw new TypeError("Illegal invocation");
    return this.href;
   }, Object.defineProperty(URL.prototype, "origin", {
    get() {
     return this[impl].origin;
    },
    enumerable: !0,
    configurable: !0
   }), Object.defineProperty(URL.prototype, "protocol", {
    get() {
     return this[impl].protocol;
    },
    set(V) {
     V = conversions.USVString(V), this[impl].protocol = V;
    },
    enumerable: !0,
    configurable: !0
   }), Object.defineProperty(URL.prototype, "username", {
    get() {
     return this[impl].username;
    },
    set(V) {
     V = conversions.USVString(V), this[impl].username = V;
    },
    enumerable: !0,
    configurable: !0
   }), Object.defineProperty(URL.prototype, "password", {
    get() {
     return this[impl].password;
    },
    set(V) {
     V = conversions.USVString(V), this[impl].password = V;
    },
    enumerable: !0,
    configurable: !0
   }), Object.defineProperty(URL.prototype, "host", {
    get() {
     return this[impl].host;
    },
    set(V) {
     V = conversions.USVString(V), this[impl].host = V;
    },
    enumerable: !0,
    configurable: !0
   }), Object.defineProperty(URL.prototype, "hostname", {
    get() {
     return this[impl].hostname;
    },
    set(V) {
     V = conversions.USVString(V), this[impl].hostname = V;
    },
    enumerable: !0,
    configurable: !0
   }), Object.defineProperty(URL.prototype, "port", {
    get() {
     return this[impl].port;
    },
    set(V) {
     V = conversions.USVString(V), this[impl].port = V;
    },
    enumerable: !0,
    configurable: !0
   }), Object.defineProperty(URL.prototype, "pathname", {
    get() {
     return this[impl].pathname;
    },
    set(V) {
     V = conversions.USVString(V), this[impl].pathname = V;
    },
    enumerable: !0,
    configurable: !0
   }), Object.defineProperty(URL.prototype, "search", {
    get() {
     return this[impl].search;
    },
    set(V) {
     V = conversions.USVString(V), this[impl].search = V;
    },
    enumerable: !0,
    configurable: !0
   }), Object.defineProperty(URL.prototype, "hash", {
    get() {
     return this[impl].hash;
    },
    set(V) {
     V = conversions.USVString(V), this[impl].hash = V;
    },
    enumerable: !0,
    configurable: !0
   }), module.exports = {
    is: obj => !!obj && obj[impl] instanceof Impl.implementation,
    create(constructorArgs, privateData) {
     let obj = Object.create(URL.prototype);
     return this.setup(obj, constructorArgs, privateData), obj;
    },
    setup(obj, constructorArgs, privateData) {
     privateData || (privateData = {}), privateData.wrapper = obj, obj[impl] = new Impl.implementation(constructorArgs, privateData), 
     obj[impl][utils.wrapperSymbol] = obj;
    },
    interface: URL,
    expose: {
     Window: {
      URL
     },
     Worker: {
      URL
     }
    }
   };
  },
  53417: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   exports.URL = __webpack_require__(76648).interface, __webpack_require__(95484).serializeURL, 
   __webpack_require__(95484).serializeURLOrigin, __webpack_require__(95484).basicURLParse, 
   __webpack_require__(95484).setTheUsername, __webpack_require__(95484).setThePassword, 
   __webpack_require__(95484).serializeHost, __webpack_require__(95484).serializeInteger, 
   __webpack_require__(95484).parseURL;
  },
  95484: (module, __unused_webpack_exports, __webpack_require__) => {
   "use strict";
   const punycode = __webpack_require__(24876), tr46 = __webpack_require__(36673), specialSchemes = {
    ftp: 21,
    file: null,
    gopher: 70,
    http: 80,
    https: 443,
    ws: 80,
    wss: 443
   }, failure = Symbol("failure");
   function countSymbols(str) {
    return punycode.ucs2.decode(str).length;
   }
   function at(input, idx) {
    const c = input[idx];
    return isNaN(c) ? void 0 : String.fromCodePoint(c);
   }
   function isASCIIDigit(c) {
    return c >= 48 && c <= 57;
   }
   function isASCIIAlpha(c) {
    return c >= 65 && c <= 90 || c >= 97 && c <= 122;
   }
   function isASCIIHex(c) {
    return isASCIIDigit(c) || c >= 65 && c <= 70 || c >= 97 && c <= 102;
   }
   function isSingleDot(buffer) {
    return "." === buffer || "%2e" === buffer.toLowerCase();
   }
   function isWindowsDriveLetterString(string) {
    return 2 === string.length && isASCIIAlpha(string.codePointAt(0)) && (":" === string[1] || "|" === string[1]);
   }
   function isSpecialScheme(scheme) {
    return void 0 !== specialSchemes[scheme];
   }
   function isSpecial(url) {
    return isSpecialScheme(url.scheme);
   }
   function percentEncode(c) {
    let hex = c.toString(16).toUpperCase();
    return 1 === hex.length && (hex = "0" + hex), "%" + hex;
   }
   function isC0ControlPercentEncode(c) {
    return c <= 31 || c > 126;
   }
   const extraPathPercentEncodeSet = new Set([ 32, 34, 35, 60, 62, 63, 96, 123, 125 ]);
   function isPathPercentEncode(c) {
    return isC0ControlPercentEncode(c) || extraPathPercentEncodeSet.has(c);
   }
   const extraUserinfoPercentEncodeSet = new Set([ 47, 58, 59, 61, 64, 91, 92, 93, 94, 124 ]);
   function isUserinfoPercentEncode(c) {
    return isPathPercentEncode(c) || extraUserinfoPercentEncodeSet.has(c);
   }
   function percentEncodeChar(c, encodeSetPredicate) {
    const cStr = String.fromCodePoint(c);
    return encodeSetPredicate(c) ? function(c) {
     const buf = new Buffer(c);
     let str = "";
     for (let i = 0; i < buf.length; ++i) str += percentEncode(buf[i]);
     return str;
    }(cStr) : cStr;
   }
   function parseIPv4Number(input) {
    let R = 10;
    if (input.length >= 2 && "0" === input.charAt(0) && "x" === input.charAt(1).toLowerCase() ? (input = input.substring(2), 
    R = 16) : input.length >= 2 && "0" === input.charAt(0) && (input = input.substring(1), 
    R = 8), "" === input) return 0;
    return (10 === R ? /[^0-9]/ : 16 === R ? /[^0-9A-Fa-f]/ : /[^0-7]/).test(input) ? failure : parseInt(input, R);
   }
   function parseHost(input, isSpecialArg) {
    if ("[" === input[0]) return "]" !== input[input.length - 1] ? failure : function(input) {
     const address = [ 0, 0, 0, 0, 0, 0, 0, 0 ];
     let pieceIndex = 0, compress = null, pointer = 0;
     if (58 === (input = punycode.ucs2.decode(input))[pointer]) {
      if (58 !== input[pointer + 1]) return failure;
      pointer += 2, ++pieceIndex, compress = pieceIndex;
     }
     for (;pointer < input.length; ) {
      if (8 === pieceIndex) return failure;
      if (58 === input[pointer]) {
       if (null !== compress) return failure;
       ++pointer, ++pieceIndex, compress = pieceIndex;
       continue;
      }
      let value = 0, length = 0;
      for (;length < 4 && isASCIIHex(input[pointer]); ) value = 16 * value + parseInt(at(input, pointer), 16), 
      ++pointer, ++length;
      if (46 === input[pointer]) {
       if (0 === length) return failure;
       if (pointer -= length, pieceIndex > 6) return failure;
       let numbersSeen = 0;
       for (;void 0 !== input[pointer]; ) {
        let ipv4Piece = null;
        if (numbersSeen > 0) {
         if (!(46 === input[pointer] && numbersSeen < 4)) return failure;
         ++pointer;
        }
        if (!isASCIIDigit(input[pointer])) return failure;
        for (;isASCIIDigit(input[pointer]); ) {
         const number = parseInt(at(input, pointer));
         if (null === ipv4Piece) ipv4Piece = number; else {
          if (0 === ipv4Piece) return failure;
          ipv4Piece = 10 * ipv4Piece + number;
         }
         if (ipv4Piece > 255) return failure;
         ++pointer;
        }
        address[pieceIndex] = 256 * address[pieceIndex] + ipv4Piece, ++numbersSeen, 2 !== numbersSeen && 4 !== numbersSeen || ++pieceIndex;
       }
       if (4 !== numbersSeen) return failure;
       break;
      }
      if (58 === input[pointer]) {
       if (++pointer, void 0 === input[pointer]) return failure;
      } else if (void 0 !== input[pointer]) return failure;
      address[pieceIndex] = value, ++pieceIndex;
     }
     if (null !== compress) {
      let swaps = pieceIndex - compress;
      for (pieceIndex = 7; 0 !== pieceIndex && swaps > 0; ) {
       const temp = address[compress + swaps - 1];
       address[compress + swaps - 1] = address[pieceIndex], address[pieceIndex] = temp, 
       --pieceIndex, --swaps;
      }
     } else if (null === compress && 8 !== pieceIndex) return failure;
     return address;
    }(input.substring(1, input.length - 1));
    if (!isSpecialArg) return function(input) {
     if (string = input, -1 !== string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|\/|:|\?|@|\[|\\|\]/)) return failure;
     var string;
     let output = "";
     const decoded = punycode.ucs2.decode(input);
     for (let i = 0; i < decoded.length; ++i) output += percentEncodeChar(decoded[i], isC0ControlPercentEncode);
     return output;
    }(input);
    const domain = function(str) {
     const input = new Buffer(str), output = [];
     for (let i = 0; i < input.length; ++i) 37 !== input[i] ? output.push(input[i]) : 37 === input[i] && isASCIIHex(input[i + 1]) && isASCIIHex(input[i + 2]) ? (output.push(parseInt(input.slice(i + 1, i + 3).toString(), 16)), 
     i += 2) : output.push(input[i]);
     return new Buffer(output).toString();
    }(input), asciiDomain = tr46.toASCII(domain, !1, tr46.PROCESSING_OPTIONS.NONTRANSITIONAL, !1);
    if (null === asciiDomain) return failure;
    if (-1 !== asciiDomain.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|%|\/|:|\?|@|\[|\\|\]/)) return failure;
    const ipv4Host = function(input) {
     const parts = input.split(".");
     if ("" === parts[parts.length - 1] && parts.length > 1 && parts.pop(), parts.length > 4) return input;
     const numbers = [];
     for (const part of parts) {
      if ("" === part) return input;
      const n = parseIPv4Number(part);
      if (n === failure) return input;
      numbers.push(n);
     }
     for (let i = 0; i < numbers.length - 1; ++i) if (numbers[i] > 255) return failure;
     if (numbers[numbers.length - 1] >= Math.pow(256, 5 - numbers.length)) return failure;
     let ipv4 = numbers.pop(), counter = 0;
     for (const n of numbers) ipv4 += n * Math.pow(256, 3 - counter), ++counter;
     return ipv4;
    }(asciiDomain);
    return "number" == typeof ipv4Host || ipv4Host === failure ? ipv4Host : asciiDomain;
   }
   function serializeHost(host) {
    return "number" == typeof host ? function(address) {
     let output = "", n = address;
     for (let i = 1; i <= 4; ++i) output = String(n % 256) + output, 4 !== i && (output = "." + output), 
     n = Math.floor(n / 256);
     return output;
    }(host) : host instanceof Array ? "[" + function(address) {
     let output = "";
     const compress = function(arr) {
      let maxIdx = null, maxLen = 1, currStart = null, currLen = 0;
      for (let i = 0; i < arr.length; ++i) 0 !== arr[i] ? (currLen > maxLen && (maxIdx = currStart, 
      maxLen = currLen), currStart = null, currLen = 0) : (null === currStart && (currStart = i), 
      ++currLen);
      return currLen > maxLen && (maxIdx = currStart, maxLen = currLen), {
       idx: maxIdx,
       len: maxLen
      };
     }(address).idx;
     let ignore0 = !1;
     for (let pieceIndex = 0; pieceIndex <= 7; ++pieceIndex) ignore0 && 0 === address[pieceIndex] || (ignore0 && (ignore0 = !1), 
     compress !== pieceIndex ? (output += address[pieceIndex].toString(16), 7 !== pieceIndex && (output += ":")) : (output += 0 === pieceIndex ? "::" : ":", 
     ignore0 = !0));
     return output;
    }(host) + "]" : host;
   }
   function shortenPath(url) {
    const path = url.path;
    var string;
    0 !== path.length && ("file" === url.scheme && 1 === path.length && (string = path[0], 
    /^[A-Za-z]:$/.test(string)) || path.pop());
   }
   function includesCredentials(url) {
    return "" !== url.username || "" !== url.password;
   }
   function URLStateMachine(input, base, encodingOverride, url, stateOverride) {
    if (this.pointer = 0, this.input = input, this.base = base || null, this.encodingOverride = encodingOverride || "utf-8", 
    this.stateOverride = stateOverride, this.url = url, this.failure = !1, this.parseError = !1, 
    !this.url) {
     this.url = {
      scheme: "",
      username: "",
      password: "",
      host: null,
      port: null,
      path: [],
      query: null,
      fragment: null,
      cannotBeABaseURL: !1
     };
     const res = function(url) {
      return url.replace(/^[\u0000-\u001F\u0020]+|[\u0000-\u001F\u0020]+$/g, "");
     }(this.input);
     res !== this.input && (this.parseError = !0), this.input = res;
    }
    const res = function(url) {
     return url.replace(/\u0009|\u000A|\u000D/g, "");
    }(this.input);
    for (res !== this.input && (this.parseError = !0), this.input = res, this.state = stateOverride || "scheme start", 
    this.buffer = "", this.atFlag = !1, this.arrFlag = !1, this.passwordTokenSeenFlag = !1, 
    this.input = punycode.ucs2.decode(this.input); this.pointer <= this.input.length; ++this.pointer) {
     const c = this.input[this.pointer], cStr = isNaN(c) ? void 0 : String.fromCodePoint(c), ret = this["parse " + this.state](c, cStr);
     if (!ret) break;
     if (ret === failure) {
      this.failure = !0;
      break;
     }
    }
   }
   URLStateMachine.prototype["parse scheme start"] = function(c, cStr) {
    if (isASCIIAlpha(c)) this.buffer += cStr.toLowerCase(), this.state = "scheme"; else {
     if (this.stateOverride) return this.parseError = !0, failure;
     this.state = "no scheme", --this.pointer;
    }
    return !0;
   }, URLStateMachine.prototype["parse scheme"] = function(c, cStr) {
    if (function(c) {
     return isASCIIAlpha(c) || isASCIIDigit(c);
    }(c) || 43 === c || 45 === c || 46 === c) this.buffer += cStr.toLowerCase(); else if (58 === c) {
     if (this.stateOverride) {
      if (isSpecial(this.url) && !isSpecialScheme(this.buffer)) return !1;
      if (!isSpecial(this.url) && isSpecialScheme(this.buffer)) return !1;
      if ((includesCredentials(this.url) || null !== this.url.port) && "file" === this.buffer) return !1;
      if ("file" === this.url.scheme && ("" === this.url.host || null === this.url.host)) return !1;
     }
     if (this.url.scheme = this.buffer, this.buffer = "", this.stateOverride) return !1;
     "file" === this.url.scheme ? (47 === this.input[this.pointer + 1] && 47 === this.input[this.pointer + 2] || (this.parseError = !0), 
     this.state = "file") : isSpecial(this.url) && null !== this.base && this.base.scheme === this.url.scheme ? this.state = "special relative or authority" : isSpecial(this.url) ? this.state = "special authority slashes" : 47 === this.input[this.pointer + 1] ? (this.state = "path or authority", 
     ++this.pointer) : (this.url.cannotBeABaseURL = !0, this.url.path.push(""), this.state = "cannot-be-a-base-URL path");
    } else {
     if (this.stateOverride) return this.parseError = !0, failure;
     this.buffer = "", this.state = "no scheme", this.pointer = -1;
    }
    return !0;
   }, URLStateMachine.prototype["parse no scheme"] = function(c) {
    return null === this.base || this.base.cannotBeABaseURL && 35 !== c ? failure : (this.base.cannotBeABaseURL && 35 === c ? (this.url.scheme = this.base.scheme, 
    this.url.path = this.base.path.slice(), this.url.query = this.base.query, this.url.fragment = "", 
    this.url.cannotBeABaseURL = !0, this.state = "fragment") : "file" === this.base.scheme ? (this.state = "file", 
    --this.pointer) : (this.state = "relative", --this.pointer), !0);
   }, URLStateMachine.prototype["parse special relative or authority"] = function(c) {
    return 47 === c && 47 === this.input[this.pointer + 1] ? (this.state = "special authority ignore slashes", 
    ++this.pointer) : (this.parseError = !0, this.state = "relative", --this.pointer), 
    !0;
   }, URLStateMachine.prototype["parse path or authority"] = function(c) {
    return 47 === c ? this.state = "authority" : (this.state = "path", --this.pointer), 
    !0;
   }, URLStateMachine.prototype["parse relative"] = function(c) {
    return this.url.scheme = this.base.scheme, isNaN(c) ? (this.url.username = this.base.username, 
    this.url.password = this.base.password, this.url.host = this.base.host, this.url.port = this.base.port, 
    this.url.path = this.base.path.slice(), this.url.query = this.base.query) : 47 === c ? this.state = "relative slash" : 63 === c ? (this.url.username = this.base.username, 
    this.url.password = this.base.password, this.url.host = this.base.host, this.url.port = this.base.port, 
    this.url.path = this.base.path.slice(), this.url.query = "", this.state = "query") : 35 === c ? (this.url.username = this.base.username, 
    this.url.password = this.base.password, this.url.host = this.base.host, this.url.port = this.base.port, 
    this.url.path = this.base.path.slice(), this.url.query = this.base.query, this.url.fragment = "", 
    this.state = "fragment") : isSpecial(this.url) && 92 === c ? (this.parseError = !0, 
    this.state = "relative slash") : (this.url.username = this.base.username, this.url.password = this.base.password, 
    this.url.host = this.base.host, this.url.port = this.base.port, this.url.path = this.base.path.slice(0, this.base.path.length - 1), 
    this.state = "path", --this.pointer), !0;
   }, URLStateMachine.prototype["parse relative slash"] = function(c) {
    return !isSpecial(this.url) || 47 !== c && 92 !== c ? 47 === c ? this.state = "authority" : (this.url.username = this.base.username, 
    this.url.password = this.base.password, this.url.host = this.base.host, this.url.port = this.base.port, 
    this.state = "path", --this.pointer) : (92 === c && (this.parseError = !0), this.state = "special authority ignore slashes"), 
    !0;
   }, URLStateMachine.prototype["parse special authority slashes"] = function(c) {
    return 47 === c && 47 === this.input[this.pointer + 1] ? (this.state = "special authority ignore slashes", 
    ++this.pointer) : (this.parseError = !0, this.state = "special authority ignore slashes", 
    --this.pointer), !0;
   }, URLStateMachine.prototype["parse special authority ignore slashes"] = function(c) {
    return 47 !== c && 92 !== c ? (this.state = "authority", --this.pointer) : this.parseError = !0, 
    !0;
   }, URLStateMachine.prototype["parse authority"] = function(c, cStr) {
    if (64 === c) {
     this.parseError = !0, this.atFlag && (this.buffer = "%40" + this.buffer), this.atFlag = !0;
     const len = countSymbols(this.buffer);
     for (let pointer = 0; pointer < len; ++pointer) {
      const codePoint = this.buffer.codePointAt(pointer);
      if (58 === codePoint && !this.passwordTokenSeenFlag) {
       this.passwordTokenSeenFlag = !0;
       continue;
      }
      const encodedCodePoints = percentEncodeChar(codePoint, isUserinfoPercentEncode);
      this.passwordTokenSeenFlag ? this.url.password += encodedCodePoints : this.url.username += encodedCodePoints;
     }
     this.buffer = "";
    } else if (isNaN(c) || 47 === c || 63 === c || 35 === c || isSpecial(this.url) && 92 === c) {
     if (this.atFlag && "" === this.buffer) return this.parseError = !0, failure;
     this.pointer -= countSymbols(this.buffer) + 1, this.buffer = "", this.state = "host";
    } else this.buffer += cStr;
    return !0;
   }, URLStateMachine.prototype["parse hostname"] = URLStateMachine.prototype["parse host"] = function(c, cStr) {
    if (this.stateOverride && "file" === this.url.scheme) --this.pointer, this.state = "file host"; else if (58 !== c || this.arrFlag) if (isNaN(c) || 47 === c || 63 === c || 35 === c || isSpecial(this.url) && 92 === c) {
     if (--this.pointer, isSpecial(this.url) && "" === this.buffer) return this.parseError = !0, 
     failure;
     if (this.stateOverride && "" === this.buffer && (includesCredentials(this.url) || null !== this.url.port)) return this.parseError = !0, 
     !1;
     const host = parseHost(this.buffer, isSpecial(this.url));
     if (host === failure) return failure;
     if (this.url.host = host, this.buffer = "", this.state = "path start", this.stateOverride) return !1;
    } else 91 === c ? this.arrFlag = !0 : 93 === c && (this.arrFlag = !1), this.buffer += cStr; else {
     if ("" === this.buffer) return this.parseError = !0, failure;
     const host = parseHost(this.buffer, isSpecial(this.url));
     if (host === failure) return failure;
     if (this.url.host = host, this.buffer = "", this.state = "port", "hostname" === this.stateOverride) return !1;
    }
    return !0;
   }, URLStateMachine.prototype["parse port"] = function(c, cStr) {
    if (isASCIIDigit(c)) this.buffer += cStr; else {
     if (!(isNaN(c) || 47 === c || 63 === c || 35 === c || isSpecial(this.url) && 92 === c || this.stateOverride)) return this.parseError = !0, 
     failure;
     if ("" !== this.buffer) {
      const port = parseInt(this.buffer);
      if (port > Math.pow(2, 16) - 1) return this.parseError = !0, failure;
      this.url.port = port === (scheme = this.url.scheme, specialSchemes[scheme]) ? null : port, 
      this.buffer = "";
     }
     if (this.stateOverride) return !1;
     this.state = "path start", --this.pointer;
    }
    var scheme;
    return !0;
   };
   const fileOtherwiseCodePoints = new Set([ 47, 92, 63, 35 ]);
   URLStateMachine.prototype["parse file"] = function(c) {
    var cp1, cp2;
    return this.url.scheme = "file", 47 === c || 92 === c ? (92 === c && (this.parseError = !0), 
    this.state = "file slash") : null !== this.base && "file" === this.base.scheme ? isNaN(c) ? (this.url.host = this.base.host, 
    this.url.path = this.base.path.slice(), this.url.query = this.base.query) : 63 === c ? (this.url.host = this.base.host, 
    this.url.path = this.base.path.slice(), this.url.query = "", this.state = "query") : 35 === c ? (this.url.host = this.base.host, 
    this.url.path = this.base.path.slice(), this.url.query = this.base.query, this.url.fragment = "", 
    this.state = "fragment") : (this.input.length - this.pointer - 1 == 0 || (cp1 = c, 
    cp2 = this.input[this.pointer + 1], !isASCIIAlpha(cp1) || 58 !== cp2 && 124 !== cp2) || this.input.length - this.pointer - 1 >= 2 && !fileOtherwiseCodePoints.has(this.input[this.pointer + 2]) ? (this.url.host = this.base.host, 
    this.url.path = this.base.path.slice(), shortenPath(this.url)) : this.parseError = !0, 
    this.state = "path", --this.pointer) : (this.state = "path", --this.pointer), !0;
   }, URLStateMachine.prototype["parse file slash"] = function(c) {
    var string;
    return 47 === c || 92 === c ? (92 === c && (this.parseError = !0), this.state = "file host") : (null !== this.base && "file" === this.base.scheme && (2 === (string = this.base.path[0]).length && isASCIIAlpha(string.codePointAt(0)) && ":" === string[1] ? this.url.path.push(this.base.path[0]) : this.url.host = this.base.host), 
    this.state = "path", --this.pointer), !0;
   }, URLStateMachine.prototype["parse file host"] = function(c, cStr) {
    if (isNaN(c) || 47 === c || 92 === c || 63 === c || 35 === c) if (--this.pointer, 
    !this.stateOverride && isWindowsDriveLetterString(this.buffer)) this.parseError = !0, 
    this.state = "path"; else if ("" === this.buffer) {
     if (this.url.host = "", this.stateOverride) return !1;
     this.state = "path start";
    } else {
     let host = parseHost(this.buffer, isSpecial(this.url));
     if (host === failure) return failure;
     if ("localhost" === host && (host = ""), this.url.host = host, this.stateOverride) return !1;
     this.buffer = "", this.state = "path start";
    } else this.buffer += cStr;
    return !0;
   }, URLStateMachine.prototype["parse path start"] = function(c) {
    return isSpecial(this.url) ? (92 === c && (this.parseError = !0), this.state = "path", 
    47 !== c && 92 !== c && --this.pointer) : this.stateOverride || 63 !== c ? this.stateOverride || 35 !== c ? void 0 !== c && (this.state = "path", 
    47 !== c && --this.pointer) : (this.url.fragment = "", this.state = "fragment") : (this.url.query = "", 
    this.state = "query"), !0;
   }, URLStateMachine.prototype["parse path"] = function(c) {
    if (isNaN(c) || 47 === c || isSpecial(this.url) && 92 === c || !this.stateOverride && (63 === c || 35 === c)) {
     if (isSpecial(this.url) && 92 === c && (this.parseError = !0), ".." === (buffer = (buffer = this.buffer).toLowerCase()) || "%2e." === buffer || ".%2e" === buffer || "%2e%2e" === buffer ? (shortenPath(this.url), 
     47 === c || isSpecial(this.url) && 92 === c || this.url.path.push("")) : !isSingleDot(this.buffer) || 47 === c || isSpecial(this.url) && 92 === c ? isSingleDot(this.buffer) || ("file" === this.url.scheme && 0 === this.url.path.length && isWindowsDriveLetterString(this.buffer) && ("" !== this.url.host && null !== this.url.host && (this.parseError = !0, 
     this.url.host = ""), this.buffer = this.buffer[0] + ":"), this.url.path.push(this.buffer)) : this.url.path.push(""), 
     this.buffer = "", "file" === this.url.scheme && (void 0 === c || 63 === c || 35 === c)) for (;this.url.path.length > 1 && "" === this.url.path[0]; ) this.parseError = !0, 
     this.url.path.shift();
     63 === c && (this.url.query = "", this.state = "query"), 35 === c && (this.url.fragment = "", 
     this.state = "fragment");
    } else 37 !== c || isASCIIHex(this.input[this.pointer + 1]) && isASCIIHex(this.input[this.pointer + 2]) || (this.parseError = !0), 
    this.buffer += percentEncodeChar(c, isPathPercentEncode);
    var buffer;
    return !0;
   }, URLStateMachine.prototype["parse cannot-be-a-base-URL path"] = function(c) {
    return 63 === c ? (this.url.query = "", this.state = "query") : 35 === c ? (this.url.fragment = "", 
    this.state = "fragment") : (isNaN(c) || 37 === c || (this.parseError = !0), 37 !== c || isASCIIHex(this.input[this.pointer + 1]) && isASCIIHex(this.input[this.pointer + 2]) || (this.parseError = !0), 
    isNaN(c) || (this.url.path[0] = this.url.path[0] + percentEncodeChar(c, isC0ControlPercentEncode))), 
    !0;
   }, URLStateMachine.prototype["parse query"] = function(c, cStr) {
    if (isNaN(c) || !this.stateOverride && 35 === c) {
     isSpecial(this.url) && "ws" !== this.url.scheme && "wss" !== this.url.scheme || (this.encodingOverride = "utf-8");
     const buffer = new Buffer(this.buffer);
     for (let i = 0; i < buffer.length; ++i) buffer[i] < 33 || buffer[i] > 126 || 34 === buffer[i] || 35 === buffer[i] || 60 === buffer[i] || 62 === buffer[i] ? this.url.query += percentEncode(buffer[i]) : this.url.query += String.fromCodePoint(buffer[i]);
     this.buffer = "", 35 === c && (this.url.fragment = "", this.state = "fragment");
    } else 37 !== c || isASCIIHex(this.input[this.pointer + 1]) && isASCIIHex(this.input[this.pointer + 2]) || (this.parseError = !0), 
    this.buffer += cStr;
    return !0;
   }, URLStateMachine.prototype["parse fragment"] = function(c) {
    return isNaN(c) || (0 === c ? this.parseError = !0 : (37 !== c || isASCIIHex(this.input[this.pointer + 1]) && isASCIIHex(this.input[this.pointer + 2]) || (this.parseError = !0), 
    this.url.fragment += percentEncodeChar(c, isC0ControlPercentEncode))), !0;
   }, module.exports.serializeURL = function(url, excludeFragment) {
    let output = url.scheme + ":";
    if (null !== url.host ? (output += "//", "" === url.username && "" === url.password || (output += url.username, 
    "" !== url.password && (output += ":" + url.password), output += "@"), output += serializeHost(url.host), 
    null !== url.port && (output += ":" + url.port)) : null === url.host && "file" === url.scheme && (output += "//"), 
    url.cannotBeABaseURL) output += url.path[0]; else for (const string of url.path) output += "/" + string;
    return null !== url.query && (output += "?" + url.query), excludeFragment || null === url.fragment || (output += "#" + url.fragment), 
    output;
   }, module.exports.serializeURLOrigin = function(url) {
    switch (url.scheme) {
    case "blob":
     try {
      return module.exports.serializeURLOrigin(module.exports.parseURL(url.path[0]));
     } catch (e) {
      return "null";
     }

    case "ftp":
    case "gopher":
    case "http":
    case "https":
    case "ws":
    case "wss":
     return function(tuple) {
      let result = tuple.scheme + "://";
      return result += serializeHost(tuple.host), null !== tuple.port && (result += ":" + tuple.port), 
      result;
     }({
      scheme: url.scheme,
      host: url.host,
      port: url.port
     });

    case "file":
     return "file://";

    default:
     return "null";
    }
   }, module.exports.basicURLParse = function(input, options) {
    void 0 === options && (options = {});
    const usm = new URLStateMachine(input, options.baseURL, options.encodingOverride, options.url, options.stateOverride);
    return usm.failure ? "failure" : usm.url;
   }, module.exports.setTheUsername = function(url, username) {
    url.username = "";
    const decoded = punycode.ucs2.decode(username);
    for (let i = 0; i < decoded.length; ++i) url.username += percentEncodeChar(decoded[i], isUserinfoPercentEncode);
   }, module.exports.setThePassword = function(url, password) {
    url.password = "";
    const decoded = punycode.ucs2.decode(password);
    for (let i = 0; i < decoded.length; ++i) url.password += percentEncodeChar(decoded[i], isUserinfoPercentEncode);
   }, module.exports.serializeHost = serializeHost, module.exports.cannotHaveAUsernamePasswordPort = function(url) {
    return null === url.host || "" === url.host || url.cannotBeABaseURL || "file" === url.scheme;
   }, module.exports.serializeInteger = function(integer) {
    return String(integer);
   }, module.exports.parseURL = function(input, options) {
    return void 0 === options && (options = {}), module.exports.basicURLParse(input, {
     baseURL: options.baseURL,
     encodingOverride: options.encodingOverride
    });
   };
  },
  46892: module => {
   "use strict";
   module.exports.mixin = function(target, source) {
    const keys = Object.getOwnPropertyNames(source);
    for (let i = 0; i < keys.length; ++i) Object.defineProperty(target, keys[i], Object.getOwnPropertyDescriptor(source, keys[i]));
   }, module.exports.wrapperSymbol = Symbol("wrapper"), module.exports.implSymbol = Symbol("impl"), 
   module.exports.wrapperForImpl = function(impl) {
    return impl[module.exports.wrapperSymbol];
   }, module.exports.implForWrapper = function(wrapper) {
    return wrapper[module.exports.implSymbol];
   };
  },
  77242: (module, __unused_webpack_exports, __webpack_require__) => {
   const {isexe, sync: isexeSync} = __webpack_require__(16262), {join, delimiter, sep, posix} = __webpack_require__(16928), isWindows = "win32" === process.platform, rSlash = new RegExp(`[${posix.sep}${sep === posix.sep ? "" : sep}]`.replace(/(\\)/g, "\\$1")), rRel = new RegExp(`^\\.${rSlash.source}`), getNotFoundError = cmd => Object.assign(new Error(`not found: ${cmd}`), {
    code: "ENOENT"
   }), getPathInfo = (cmd, {path: optPath = process.env.PATH, pathExt: optPathExt = process.env.PATHEXT, delimiter: optDelimiter = delimiter}) => {
    const pathEnv = cmd.match(rSlash) ? [ "" ] : [ ...isWindows ? [ process.cwd() ] : [], ...(optPath || "").split(optDelimiter) ];
    if (isWindows) {
     const pathExtExe = optPathExt || [ ".EXE", ".CMD", ".BAT", ".COM" ].join(optDelimiter), pathExt = pathExtExe.split(optDelimiter).flatMap((item => [ item, item.toLowerCase() ]));
     return cmd.includes(".") && "" !== pathExt[0] && pathExt.unshift(""), {
      pathEnv,
      pathExt,
      pathExtExe
     };
    }
    return {
     pathEnv,
     pathExt: [ "" ]
    };
   }, getPathPart = (raw, cmd) => {
    const pathPart = /^".*"$/.test(raw) ? raw.slice(1, -1) : raw;
    return (!pathPart && rRel.test(cmd) ? cmd.slice(0, 2) : "") + join(pathPart, cmd);
   }, which = async (cmd, opt = {}) => {
    const {pathEnv, pathExt, pathExtExe} = getPathInfo(cmd, opt), found = [];
    for (const envPart of pathEnv) {
     const p = getPathPart(envPart, cmd);
     for (const ext of pathExt) {
      const withExt = p + ext;
      if (await isexe(withExt, {
       pathExt: pathExtExe,
       ignoreErrors: !0
      })) {
       if (!opt.all) return withExt;
       found.push(withExt);
      }
     }
    }
    if (opt.all && found.length) return found;
    if (opt.nothrow) return null;
    throw getNotFoundError(cmd);
   };
   module.exports = which, which.sync = (cmd, opt = {}) => {
    const {pathEnv, pathExt, pathExtExe} = getPathInfo(cmd, opt), found = [];
    for (const pathEnvPart of pathEnv) {
     const p = getPathPart(pathEnvPart, cmd);
     for (const ext of pathExt) {
      const withExt = p + ext;
      if (isexeSync(withExt, {
       pathExt: pathExtExe,
       ignoreErrors: !0
      })) {
       if (!opt.all) return withExt;
       found.push(withExt);
      }
     }
    }
    if (opt.all && found.length) return found;
    if (opt.nothrow) return null;
    throw getNotFoundError(cmd);
   };
  },
  17176: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   Object.defineProperty(exports, Symbol.toStringTag, {
    value: "Module"
   });
   const l = __webpack_require__(54980), u = __webpack_require__(80537), B = __webpack_require__(63283), H = __webpack_require__(79896);
   const $ = function(r) {
    const e = Object.create(null, {
     [Symbol.toStringTag]: {
      value: "Module"
     }
    });
    if (r) for (const t in r) if ("default" !== t) {
     const o = Object.getOwnPropertyDescriptor(r, t);
     Object.defineProperty(e, t, o.get ? o : {
      enumerable: !0,
      get: () => r[t]
     });
    }
    return e.default = r, Object.freeze(e);
   }(__webpack_require__(78697)), Q = r => r instanceof l.NotebookCellData ? r.value : r.document.getText(), X = r => r instanceof l.NotebookCellData ? r.languageId : r.document.languageId, A = (r, e, t) => {
    var n;
    const o = [];
    for (const i of (r => "getCells" in r ? r.getCells() : r.cells)(r)) o.push({
     cell_type: i.kind,
     source: Q(i).split(/\r?\n/g),
     languageId: X(i),
     metadata: i.metadata,
     outputs: t ? i.outputs : void 0
    });
    return {
     cells: o,
     metadata: {
      ...r.metadata,
      name: e,
      createdAt: (null == (n = r.metadata) ? void 0 : n.createdAt) || (new Date).toISOString(),
      updatedAt: (new Date).toISOString()
     }
    };
   }, _ = () => Math.random().toString(36).substr(2, 9);
   let E = class {
    dispose() {
     throw new Error("Method not implemented.");
    }
    async deserializeNotebook(e, t) {
     const o = (new TextDecoder).decode(e);
     let n;
     try {
      n = JSON.parse(o);
     } catch {
      n = {
       cells: []
      };
     }
     const i = n.cells.map((a => {
      var d;
      const c = new l.NotebookCellData(a.cell_type, null == (d = a.source) ? void 0 : d.join("\n"), a.languageId);
      return c.metadata = a.metadata, c.outputs = a.outputs, c;
     })), s = new l.NotebookData(i);
     return s.metadata = n.metadata, s;
    }
    async serializeNotebook(e, t) {
     const o = A(e);
     return (new TextEncoder).encode(JSON.stringify(o));
    }
   };
   var g, r;
   E = function(r, e, t, o) {
    var s, n = arguments.length, i = n < 3 ? e : null === o ? o = Object.getOwnPropertyDescriptor(e, t) : o;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) i = Reflect.decorate(r, e, t, o); else for (var a = r.length - 1; a >= 0; a--) (s = r[a]) && (i = (n < 3 ? s(i) : n > 3 ? s(e, t, i) : s(e, t)) || i);
    return n > 3 && i && Object.defineProperty(e, t, i), i;
   }([ u.provideSingleton(E) ], E), (r = g || (g = {})).error = "application/vnd.code.notebook.error", 
   r.stderr = "application/vnd.code.notebook.stderr", r.stdout = "application/vnd.code.notebook.stdout";
   const te = [ "text/plain", "text/markdown", g.stderr, g.stdout ], F = [ "application/vnd.*", "application/vdom.*", "application/geo+json", "application/x-nteract-model-debug+json", "text/html", "application/javascript", "image/gif", "text/latex", "text/markdown", "image/png", "image/svg+xml", "image/jpeg", "application/json", "text/plain" ], k = new Map;
   function S(r) {
    const e = k.get(r.output_type);
    let t;
    return e ? t = e(r) : (console.warn(`Unable to translate cell from ${r.output_type} to NotebookCellData for VS Code.`), 
    t = M(r)), t;
   }
   function W(r) {
    const e = {
     outputType: r.output_type
    };
    switch (r.transient && (e.transient = r.transient), r.output_type) {
    case "display_data":
    case "execute_result":
    case "update_display_data":
     e.executionCount = r.execution_count, e.metadata = r.metadata ? JSON.parse(JSON.stringify(r.metadata)) : {};
    }
    return e;
   }
   function M(r) {
    const e = W(r);
    ("image/svg+xml" in r.data || "image/png" in r.data) && (e.__displayOpenPlotIcon = !0);
    const t = [];
    if (r.data) for (const o in r.data) t.push(re(o, r.data[o]));
    return new l.NotebookCellOutput(function(r) {
     return r.sort(((e, t) => {
      const o = (s, a) => (s.endsWith(".*") && (s = s.substr(0, s.indexOf(".*"))), a.startsWith(s));
      let n = F.findIndex((s => o(s, e.mime))), i = F.findIndex((s => o(s, t.mime)));
      return q(e) && (n = -1), q(t) && (i = -1), n = -1 === n ? 100 : n, i = -1 === i ? 100 : i, 
      n - i;
     }));
    }(t), e);
   }
   function q(r) {
    if (r.mime.startsWith("application/vnd.")) try {
     return 0 === (new TextDecoder).decode(r.data).length;
    } catch {}
    return !1;
   }
   function re(r, e) {
    if (!e) return l.NotebookCellOutputItem.text("", r);
    try {
     if (!r.startsWith("text/") && !te.includes(r) || !Array.isArray(e) && "string" != typeof e) return r.startsWith("image/") && "string" == typeof e && "image/svg+xml" !== r ? new l.NotebookCellOutputItem(function(r) {
      return typeof Buffer < "u" && "function" == typeof Buffer.from ? Buffer.from(r, "base64") : Uint8Array.from(atob(r), (e => e.charCodeAt(0)));
     }(e), r) : "object" != typeof e || null === e || Array.isArray(e) ? (e = Array.isArray(e) ? D(e) : e, 
     l.NotebookCellOutputItem.text(e, r)) : l.NotebookCellOutputItem.text(JSON.stringify(e), r);
     {
      const t = Array.isArray(e) ? D(e) : e;
      return l.NotebookCellOutputItem.text(t, r);
     }
    } catch (t) {
     return console.error(`Failed to convert ${r} output to a buffer ${typeof e}, ${e}`, t), 
     l.NotebookCellOutputItem.text("");
    }
   }
   function D(r) {
    if (Array.isArray(r)) {
     let e = "";
     for (let t = 0; t < r.length; t += 1) {
      const o = r[t];
      e = t < r.length - 1 && !o.endsWith("\n") ? e.concat(`${o}\n`) : e.concat(o);
     }
     return e;
    }
    return r.toString();
   }
   function N(r) {
    if (r.parent_header && "msg_id" in r.parent_header) return r.parent_header.msg_id;
   }
   function le(r) {
    if (r.hasOwnProperty("text/html")) {
     const e = r["text/html"];
     "string" == typeof e && e.includes('<iframe id="tensorboard-frame-') && (r["text/html"] = e.replace(/new URL\((.*), window.location\)/, 'new URL("http://localhost")'));
    }
    return r;
   }
   k.set("display_data", M), k.set("error", (function(r) {
    return r = r || {
     output_type: "error",
     ename: "",
     evalue: "",
     traceback: []
    }, new l.NotebookCellOutput([ l.NotebookCellOutputItem.error({
     name: (null == r ? void 0 : r.ename) || "",
     message: (null == r ? void 0 : r.evalue) || "",
     stack: ((null == r ? void 0 : r.traceback) || []).join("\n")
    }) ], {
     ...W(r),
     originalError: r
    });
   })), k.set("execute_result", M), k.set("stream", (function(r) {
    const e = D(r.text), t = "stderr" === r.name ? l.NotebookCellOutputItem.stderr : l.NotebookCellOutputItem.stdout;
    return new l.NotebookCellOutput([ t(e) ], W(r));
   })), k.set("update_display_data", M);
   function j(r) {
    let e = "string" == typeof r ? r : "";
    return "string" != typeof r && "content" in r && "code" in r.content && "string" == typeof r.content.code && (e = r.content.code), 
    !e.includes("e976ee50-99ed-4aba-9b6b-9dcd5634d07d:IPyWidgets:");
   }
   var I;
   !function(r) {
    r.GeneratedThemeName = "ipython-theme", r.MatplotLibDefaultParams = "_VSCode_defaultMatplotlib_Params", 
    r.MatplotLibFigureFormats = "_VSCode_matplotLib_FigureFormats", r.DefaultCodeCellMarker = "# %%", 
    r.DefaultCommTarget = "jupyter.widget", r.ALL_VARIABLES = "ALL_VARIABLES", r.KERNEL_VARIABLES = "KERNEL_VARIABLES", 
    r.DEBUGGER_VARIABLES = "DEBUGGER_VARIABLES", r.PYTHON_VARIABLES_REQUESTER = "PYTHON_VARIABLES_REQUESTER", 
    r.MULTIPLEXING_DEBUGSERVICE = "MULTIPLEXING_DEBUGSERVICE", r.RUN_BY_LINE_DEBUGSERVICE = "RUN_BY_LINE_DEBUGSERVICE", 
    r.REMOTE_URI = "https://remote/", r.REMOTE_URI_ID_PARAM = "id", r.REMOTE_URI_HANDLE_PARAM = "uriHandle", 
    r.REMOTE_URI_EXTENSION_ID_PARAM = "extensionId";
   }(I || (I = {}));
   const O = "application/vnd.jupyter.widget-view+json";
   class pe {
    get value() {
     return this._value;
    }
    constructor(e = null) {
     Object.defineProperty(this, "scope", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: e
     }), Object.defineProperty(this, "_resolve", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
     }), Object.defineProperty(this, "_reject", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
     }), Object.defineProperty(this, "_resolved", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
     }), Object.defineProperty(this, "_rejected", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
     }), Object.defineProperty(this, "_promise", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
     }), Object.defineProperty(this, "_value", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
     }), this._promise = new Promise(((t, o) => {
      this._resolve = t, this._reject = o;
     }));
    }
    resolve(e) {
     this._value = e, this._resolve.apply(this.scope ? this.scope : this, arguments), 
     this._resolved = !0;
    }
    reject(e) {
     this._reject.apply(this.scope ? this.scope : this, arguments), this._rejected = !0;
    }
    get promise() {
     return this._promise;
    }
    get resolved() {
     return this._resolved;
    }
    get rejected() {
     return this._rejected;
    }
    get completed() {
     return this._rejected || this._resolved;
    }
   }
   var P = {};
   Object.defineProperty(P, "__esModule", {
    value: !0
   }), P.serialize = R = P.deserialize = void 0;
   var R = P.deserialize = function(r) {
    let e;
    return e = "string" == typeof r ? JSON.parse(r) : function(r) {
     const e = new DataView(r), t = e.getUint32(0), o = [];
     if (t < 2) throw new Error("Invalid incoming Kernel Message");
     for (let s = 1; s <= t; s++) o.push(e.getUint32(4 * s));
     const n = new Uint8Array(r.slice(o[0], o[1])), i = JSON.parse(new TextDecoder("utf8").decode(n));
     i.buffers = [];
     for (let s = 1; s < t; s++) {
      const a = o[s], c = o[s + 1] || r.byteLength;
      i.buffers.push(new DataView(r.slice(a, c)));
     }
     return i;
    }(r), e;
   };
   function ye(r) {
    if (!r || !Array.isArray(r) || 0 === r.length) return;
    const e = [];
    for (let t = 0; t < r.length; t += 1) {
     const o = r[t];
     if ("buffer" in o && "byteOffset" in o) {
      const n = [ ...new Uint8Array(o.buffer) ];
      e.push({
       ...o,
       byteLength: o.byteLength,
       byteOffset: o.byteOffset,
       buffer: n
      });
     } else e.push([ ...new Uint8Array(o) ]);
    }
    return e;
   }
   P.serialize = function(r) {
    var e;
    let t;
    return t = null !== (e = r.buffers) && void 0 !== e && e.length ? function(r) {
     const e = [], t = [], o = new TextEncoder;
     let n = [];
     void 0 !== r.buffers && (n = r.buffers, delete r.buffers);
     const i = o.encode(JSON.stringify(r));
     t.push(i.buffer);
     for (let d = 0; d < n.length; d++) {
      const h = n[d];
      t.push(ArrayBuffer.isView(h) ? h.buffer : h);
     }
     const s = t.length;
     e.push(4 * (s + 1));
     for (let d = 0; d + 1 < t.length; d++) e.push(e[e.length - 1] + t[d].byteLength);
     const a = new Uint8Array(e[e.length - 1] + t[t.length - 1].byteLength), c = new DataView(a.buffer);
     c.setUint32(0, s);
     for (let d = 0; d < e.length; d++) c.setUint32(4 * (d + 1), e[d]);
     for (let d = 0; d < t.length; d++) a.set(new Uint8Array(t[d]), e[d]);
     return a.buffer;
    }(r) : JSON.stringify(r), t;
   };
   function y() {}
   __webpack_require__(16928).join(__dirname, ".");
   const ve = [ "username", "version", "session", "msg_id", "msg_type" ], K = {
    stream: {
     name: "string",
     text: "string"
    },
    display_data: {
     data: "object",
     metadata: "object"
    },
    execute_input: {
     code: "string",
     execution_count: "number"
    },
    execute_result: {
     execution_count: "number",
     data: "object",
     metadata: "object"
    },
    error: {
     ename: "string",
     evalue: "string",
     traceback: "object"
    },
    status: {
     execution_state: [ "string", [ "starting", "idle", "busy", "restarting", "dead" ] ]
    },
    clear_output: {
     wait: "boolean"
    },
    comm_open: {
     comm_id: "string",
     target_name: "string",
     data: "object"
    },
    comm_msg: {
     comm_id: "string",
     data: "object"
    },
    comm_close: {
     comm_id: "string"
    },
    shutdown_reply: {
     restart: "boolean"
    }
   };
   function Te(r, e) {
    const t = r.header;
    ve.forEach((o => {
     "string" != typeof t[o] && (t[o] = "");
    })), "string" != typeof r.channel && (r.channel = e), r.content || (r.content = {}), 
    r.metadata || (r.metadata = {}), "iopub" === r.channel && function(r) {
     if ("iopub" !== r.channel) return;
     const e = r.header.msg_type;
     if (e in K) {
      const t = K[e];
      if (void 0 === t) return;
      const o = Object.keys(t), n = r.content;
      for (let i = 0; i < o.length; i++) {
       let s = t[o[i]];
       Array.isArray(s) || (s = [ s ]);
       const a = o[i];
       if (!(a in n) || typeof n[a] !== s[0]) switch (s[0]) {
       case "string":
        n[a] = "";
        break;

       case "boolean":
        n[a] = !1;
        break;

       case "object":
        n[a] = {};
        break;

       case "number":
        n[a] = 0;
       }
      }
     }
    }(r);
   }
   class Ne {
    constructor(e, t) {
     Object.defineProperty(this, "connection", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: e
     }), Object.defineProperty(this, "serialize", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: t
     }), Object.defineProperty(this, "onopen", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: y
     }), Object.defineProperty(this, "onerror", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: y
     }), Object.defineProperty(this, "onclose", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: y
     }), Object.defineProperty(this, "onmessage", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: y
     }), Object.defineProperty(this, "receiveHooks", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
     }), Object.defineProperty(this, "sendHooks", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
     }), Object.defineProperty(this, "msgChain", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: Promise.resolve()
     }), Object.defineProperty(this, "sendChain", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: Promise.resolve()
     }), Object.defineProperty(this, "channels", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
     }), Object.defineProperty(this, "closed", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
     }), this.channels = this.generateChannels(e);
    }
    dispose() {
     this.closed || this.close();
    }
    close() {
     this.closed = !0;
     const e = t => {
      try {
       t.close();
      } catch (o) {
       console.error("Error during socket shutdown", o);
      }
     };
     e(this.channels.control), e(this.channels.iopub), e(this.channels.shell), e(this.channels.stdin);
    }
    emit(e, ...t) {
     switch (e) {
     case "message":
      this.onmessage({
       data: t[0],
       type: "message",
       target: this
      });
      break;

     case "close":
      this.onclose({
       wasClean: !0,
       code: 0,
       reason: "",
       target: this
      });
      break;

     case "error":
      this.onerror({
       error: "",
       message: "to do",
       type: "error",
       target: this
      });
      break;

     case "open":
      this.onopen({
       target: this
      });
     }
     return !0;
    }
    send(e, t) {
     this.sendMessage(e, !1);
    }
    addReceiveHook(e) {
     this.receiveHooks.push(e);
    }
    removeReceiveHook(e) {
     this.receiveHooks = this.receiveHooks.filter((t => t !== e));
    }
    addSendHook(e) {
     this.sendHooks.push(e);
    }
    removeSendHook(e) {
     this.sendHooks = this.sendHooks.filter((t => t !== e));
    }
    generateChannel(e, t, o) {
     const n = o();
     return n.connect(function(r, e) {
      const t = "tcp" === r.transport ? ":" : "-", o = r[`${e}_port`];
      if (!o) throw new Error(`Port not found for channel "${e}"`);
      return `${r.transport}://${r.ip}${t}${o}`;
     }(e, t)), this.processSocketMessages(t, n).catch((i => console.error(`Failed to read messages from channel ${t}`, i))), 
     n;
    }
    async processSocketMessages(e, t) {
     for await (const o of t) {
      if (this.closed) break;
      this.onIncomingMessage(e, o);
     }
    }
    generateChannels(e) {
     const t = function() {
      console.log("Trying to load zmq");
      const r = __webpack_require__(11594);
      return r.context.blocky = !1, console.info("ZMQ loaded."), r;
     }(), o = _(), n = {
      iopub: this.generateChannel(e, "iopub", (() => new t.Subscriber({
       maxMessageSize: -1,
       receiveHighWaterMark: 0
      }))),
      shell: this.generateChannel(e, "shell", (() => new t.Dealer({
       routingId: o,
       sendHighWaterMark: 0,
       receiveHighWaterMark: 0,
       maxMessageSize: -1
      }))),
      control: this.generateChannel(e, "control", (() => new t.Dealer({
       routingId: o,
       sendHighWaterMark: 0,
       receiveHighWaterMark: 0,
       maxMessageSize: -1
      }))),
      stdin: this.generateChannel(e, "stdin", (() => new t.Dealer({
       routingId: o,
       sendHighWaterMark: 0,
       receiveHighWaterMark: 0,
       maxMessageSize: -1
      })))
     };
     return n.iopub.subscribe(), n;
    }
    onIncomingMessage(e, t) {
     const o = this.closed ? {} : $.decode(t, this.connection.key, this.connection.signature_scheme);
     o.channel = e, this.receiveHooks.length ? this.msgChain = this.msgChain.then((() => {
      const n = this.serialize(o);
      return Promise.all(this.receiveHooks.map((i => i(n))));
     })).then((() => this.fireOnMessage(o, e))) : this.msgChain = this.msgChain.then((() => this.fireOnMessage(o, e)));
    }
    fireOnMessage(e, t) {
     if (!this.closed) try {
      Te(e, t), this.onmessage({
       data: e,
       type: "message",
       target: this
      });
     } catch (o) {
      console.error(`Failed to handle message in Jupyter Kernel package ${JSON.stringify(e)}`, o);
     }
    }
    sendMessage(e, t) {
     const o = $.encode(e, this.connection.key, this.connection.signature_scheme);
     if (!t && this.sendHooks.length) {
      const n = this.serialize(e);
      this.sendChain = this.sendChain.then((() => Promise.all(this.sendHooks.map((i => i(n, y)))))).then((async () => {
       try {
        await this.postToSocket(e.channel, o);
       } catch (i) {
        console.error(`Failed to write data to the kernel channel ${e.channel}`, o, i);
       }
      }));
     } else this.sendChain = this.sendChain.then((() => {
      this.postToSocket(e.channel, o);
     }));
     this.sendChain.catch(y);
    }
    postToSocket(e, t) {
     const o = this.channels[e];
     o ? o.send(t).catch((n => {
      console.error("Error communicating with the kernel", n);
     })) : console.error(`Attempting to send message on invalid channel: ${e}`);
    }
   }
   let x;
   class Ee {
    get postMessage() {
     return this._postMessageEmitter.event;
    }
    constructor(e, t, o, n) {
     Object.defineProperty(this, "outputWidgetIds", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new Set
     }), Object.defineProperty(this, "waitingMessageIds", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new Map
     }), Object.defineProperty(this, "kernel", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
     }), Object.defineProperty(this, "_postMessageEmitter", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new l.EventEmitter
     }), this.kernel = this.initializeKernel(e, t, o, n);
    }
    get rawKernel() {
     return this.kernel;
    }
    initializeKernel(e, t, o, n) {
     const i = __webpack_require__(50608), s = __webpack_require__(93962);
     let a;
     const d = i.ServerConnection.makeSettings({
      WebSocket: class extends Ne {
       constructor() {
        super(e.connection, s.serialize), a = this;
       }
      },
      wsUrl: "RAW"
     });
     x || (x = __webpack_require__(92175));
     const h = new x.KernelConnection({
      serverSettings: d,
      clientId: t,
      handleComms: !1,
      username: o,
      model: n
     });
     return a && (a.emit("open"), a.addReceiveHook(this.onKernelSocketMessage.bind(this)), 
     a.addSendHook(this.mirrorSend.bind(this))), {
      realKernel: h,
      socket: a,
      kernelProcess: e
     };
    }
    async mirrorSend(e, t) {
     if ("string" == typeof e && e.includes("shell") && e.includes("execute_request")) {
      const o = R(e);
      if ("shell" === o.channel && "execute_request" === o.header.msg_type) {
       if (!j(o)) return;
       this.mirrorExecuteRequest(o);
      }
     }
    }
    raisePostMessage(e, t) {
     this._postMessageEmitter.fire({
      payload: t,
      type: e
     });
    }
    mirrorExecuteRequest(e) {
     this.raisePostMessage("IPyWidgets_mirror_execute", {
      id: e.header.msg_id,
      msg: e
     });
    }
    async onKernelSocketMessage(e) {
     var i, s, a, c, d, h, m, p, f;
     const t = _(), o = function(r = null) {
      return new pe(r);
     }();
     if (this.waitingMessageIds.set(t, {
      startTime: Date.now(),
      resultPromise: o
     }), "string" == typeof e ? j(e) && this.raisePostMessage("IPyWidgets_msg", {
      id: t,
      data: e
     }) : this.raisePostMessage("IPyWidgets_binary_msg", {
      id: t,
      data: ye([ e ])
     }), "string" != typeof e || e.includes(O) || e.includes(I.DefaultCommTarget) || e.includes("comm_open") || e.includes("comm_close") || e.includes("comm_msg")) {
      const b = R(e);
      if (!j(b)) return;
      const T = "comm_open" === (null == (i = b.header) ? void 0 : i.msg_type) && "@jupyter-widgets/output" === (null == (c = null == (a = null == (s = b.content) ? void 0 : s.data) ? void 0 : a.state) ? void 0 : c._model_module) && "OutputModel" === (null == (m = null == (h = null == (d = b.content) ? void 0 : d.data) ? void 0 : h.state) ? void 0 : m._model_name), V = "comm_close" === (null == (p = b.header) ? void 0 : p.msg_type) && this.outputWidgetIds.has(null == (f = b.content) ? void 0 : f.comm_id);
      T ? this.outputWidgetIds.add(b.content.comm_id) : V && this.outputWidgetIds.delete(b.content.comm_id);
     }
    }
    onKernelSocketResponse(e) {
     const t = this.waitingMessageIds.get(e.id);
     t && (this.waitingMessageIds.delete(e.id), t.resultPromise.resolve());
    }
   }
   const Oe = __webpack_require__(16928);
   class w {
    get postMessage() {
     return this._postMessageEmitter.event;
    }
    constructor(e, t, o, n) {
     Object.defineProperty(this, "executionInfrastructure", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: t
     }), Object.defineProperty(this, "notebookDependencies", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: o
     }), Object.defineProperty(this, "dbtTerminal", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: n
     }), Object.defineProperty(this, "_postMessageEmitter", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new l.EventEmitter
     }), Object.defineProperty(this, "disposables", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
     }), Object.defineProperty(this, "lastUsedStreamOutput", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
     }), Object.defineProperty(this, "python", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
     }), Object.defineProperty(this, "kernel", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
     }), Object.defineProperty(this, "isInitializing", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
     }), Object.defineProperty(this, "ownedCommIds", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new Set
     }), Object.defineProperty(this, "commIdsMappedToWidgetOutputModels", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new Set
     }), Object.defineProperty(this, "ownedRequestMsgIds", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new Set
     }), Object.defineProperty(this, "commIdsMappedToParentWidgetModel", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new Map
     }), Object.defineProperty(this, "streamsReAttachedToExecutingCell", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
     }), Object.defineProperty(this, "registerdCommTargets", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new Set
     }), Object.defineProperty(this, "outputsAreSpecificToAWidget", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
     }), Object.defineProperty(this, "versions", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
     }), this.dbtTerminal.debug("NotebookKernelClient", "creating python bridge for notebook:", e), 
     this.python = this.executionInfrastructure.createPythonBridge(Oe.dirname(e)), this.initializeNotebookKernel(e);
    }
    async isInitialized() {
     return new Promise((e => {
      const t = setInterval((() => {
       var o, n;
       this.dbtTerminal.debug("Notebookclient", "isInitialized", !(null == (o = this.kernel) || !o.rawKernel)), 
       null != (n = this.kernel) && n.rawKernel && (e(!0), clearInterval(t));
      }), 500);
     }));
    }
    async dispose() {
     this.disposables.forEach((e => e.dispose()));
     try {
      await (this.python.ex`
        notebook_kernel.close_notebook()
        `);
     } catch (e) {
      this.dbtTerminal.error(u.TelemetryEvents["Notebook/KernelCloseError"], e.exception.message, e);
     }
    }
    get jupyterPackagesVersions() {
     return this.versions;
    }
    async getDependenciesVersion() {
     this.versions = await this.notebookDependencies.getDependenciesVersion();
    }
    async getKernel() {
     return new Promise((e => {
      const t = setInterval((() => {
       var o;
       this.isInitializing || (e(null == (o = this.kernel) ? void 0 : o.rawKernel), clearInterval(t));
      }), 500);
     }));
    }
    async initializeNotebookKernel(e) {
     try {
      if (!await this.notebookDependencies.validateAndInstallNotebookDependencies()) return;
      await (this.python.ex`
        from altimate_notebook_kernel import AltimateNotebookKernel
        notebook_kernel = AltimateNotebookKernel(${e})
        `);
      const t = await this.python.lock((a => a`notebook_kernel.get_connection_file()`)), o = JSON.parse(H.readFileSync(t, {
       encoding: "utf-8"
      })), n = await this.python.lock((a => a`notebook_kernel.get_session_id()`)), s = new Ee({
       connection: o,
       pid: n
      }, _(), _(), {
       name: o.kernel_name,
       id: _()
      });
      this.kernel = s, this.disposables.push(s.postMessage((a => this._postMessageEmitter.fire(a)))), 
      this.dbtTerminal.log(`Notebook Kernel started with PID: ${n} connection: ${JSON.stringify(o)}`), 
      this.getDependenciesVersion();
     } catch (t) {
      let o = t.message;
      t instanceof B.PythonException && (o = t.exception.message), this.dbtTerminal.error(u.TelemetryEvents["Notebook/KernelInitializationError"], o, t), 
      l.window.showErrorMessage(o);
     }
     this.isInitializing = !1;
    }
    onKernelSocketResponse(e) {
     var t;
     null == (t = this.kernel) || t.onKernelSocketResponse(e);
    }
    async storeContext(e) {
     this.dbtTerminal.log(`storeContext: ${e}`), await this.python.lock((t => t`notebook_kernel.store_context(${e})`));
    }
    async storeDataInKernel(e, t) {
     return new Promise((async (o, n) => {
      try {
       this.dbtTerminal.log(`storeDataInKernel: ${e}`), await this.python.lock((i => i`notebook_kernel.store_sql_result(${e}, ${JSON.stringify(t)})`)), 
       o(!0);
      } catch (i) {
       this.dbtTerminal.error(u.TelemetryEvents["Notebook/StoreDataInKernelError"], i.exception.message, i), 
       n(i);
      }
     }));
    }
    async registerCommTarget(e) {
     if (this.registerdCommTargets.has(e)) return void this.dbtTerminal.log(`registerCommTarget already registered: ${e}`);
     this.registerdCommTargets.add(e), this.dbtTerminal.log(`registerCommTarget registering: ${e}`);
     const t = await this.getKernel();
     if (!t) throw this.registerdCommTargets.delete(e), new Error("Kernel not found for registering comm target");
     return t.realKernel.registerCommTarget(e, ((o, n) => {
      this.dbtTerminal.log(`registerCommTarget registered: ${e}`, o, n);
     }));
    }
    async getPythonCodeByType(e, t) {
     return this.dbtTerminal.debug("getPythonCodeByType", e, t), await this.python.lock((o => o`notebook_kernel.get_python_code_by_type(${e}, ${t})`));
    }
    async executePython(e, t, o) {
     return new Promise((async (n, i) => {
      var h, m;
      if (null == (m = null == (h = this.kernel) ? void 0 : h.rawKernel) || !m.realKernel) return void i(new Error("Kernel not found"));
      const s = t.metadata.cellId;
      this.dbtTerminal.log(`Executing python code in cell: ${s}`, e);
      const a = __webpack_require__(50608);
      this.dbtTerminal.log("kernel status", this.kernel.rawKernel.realKernel.status);
      const c = await this.kernel.rawKernel.realKernel.requestExecute({
       code: e,
       silent: !1,
       stop_on_error: !1,
       allow_stdin: !0,
       store_history: !0
      }, !1, {
       cellId: t.document.uri.toString()
      });
      if (!c) return void i(new Error("Unknown request error"));
      c.onReply = p => {
       if (t.document.isClosed) return void c.dispose();
       const f = p.content;
       f.payload && f.payload.forEach((b => {
        if (b.data && b.data.hasOwnProperty("text/plain")) {
         const T = this.addToCellData({
          output_type: "stream",
          text: b.data["text/plain"].toString(),
          name: "stdout",
          metadata: {},
          execution_count: f.execution_count
         }, p, t);
         T && o(T);
        }
       }));
      };
      const d = [];
      return c.done.finally((() => {
       c.dispose(), n(d.filter((p => !!p)));
      })), c.onStdin = p => {
       this.dbtTerminal.log("onStdin", p);
      }, c.onIOPub = p => {
       if (a.KernelMessage.isCommOpenMsg(p)) this.handleCommOpen(p); else if (a.KernelMessage.isExecuteResultMsg(p)) d.push(this.handleExecuteResult(p, t)); else if (a.KernelMessage.isExecuteInputMsg(p)) this.handleExecuteInput(p); else if (a.KernelMessage.isStatusMsg(p)) {
        const f = p;
        this.handleStatusMessage(f);
       } else if (a.KernelMessage.isStreamMsg(p)) {
        const f = this.handleStreamMessage(p, t);
        null == f || f.forEach((b => {
         d.push(b);
        }));
       } else a.KernelMessage.isDisplayDataMsg(p) ? d.push(this.handleDisplayData(p, t)) : a.KernelMessage.isUpdateDisplayDataMsg(p) ? this.handleUpdateDisplayDataMessage(p) : a.KernelMessage.isClearOutputMsg(p) ? this.handleClearOutput(p) : a.KernelMessage.isErrorMsg(p) ? d.push(this.handleError(p, t)) : a.KernelMessage.isCommOpenMsg(p) || (a.KernelMessage.isCommMsgMsg(p) ? this.handleCommMsg(p) : a.KernelMessage.isCommCloseMsg(p) || this.dbtTerminal.warn("NotebookUnknownIOPubMessage", `Unknown message ${p.header.msg_type} : hasData=${"data" in p.content}`));
      }, c;
     }));
    }
    handleUpdateDisplayDataMessage(e) {
     this.dbtTerminal.log("handleUpdateDisplayDataMessage", e), e.content.transient.display_id || this.dbtTerminal.warn("NotebookUpdateDisplayDataMessageReceivedButNoDisplayId", "Update display data message received, but no display id", !1, e.content);
    }
    handleCommOpen(e) {
     var o;
     this.ownedCommIds.add(e.content.comm_id);
     const t = (null == (o = e.content.data) ? void 0 : o.state) || void 0;
     e.content.target_name === I.DefaultCommTarget && t && "@jupyter-widgets/output" === t._model_module && this.commIdsMappedToWidgetOutputModels.add(e.content.comm_id);
    }
    handleCommMsg(e) {
     const t = e.content.data;
     if (t && "update" === t.method && "object" == typeof t.state) if ("msg_id" in t.state && "string" == typeof t.state.msg_id) {
      const o = "msg_id" in e.parent_header ? e.parent_header : void 0;
      (this.ownedRequestMsgIds.has(e.content.comm_id) || o && this.ownedRequestMsgIds.has(o.msg_id)) && (t.state.msg_id ? this.outputsAreSpecificToAWidget.push({
       handlingCommId: e.content.comm_id,
       msgIdsToSwallow: t.state.msg_id
      }) : this.outputsAreSpecificToAWidget.length && this.outputsAreSpecificToAWidget[this.outputsAreSpecificToAWidget.length - 1].handlingCommId === e.content.comm_id && this.outputsAreSpecificToAWidget.pop());
     } else if ("children" in t.state && Array.isArray(t.state.children) && this.ownedCommIds.has(e.content.comm_id)) {
      const o = "IPY_MODEL_";
      t.state.children.forEach((n => {
       if ("string" != typeof n) return this.dbtTerminal.warn("Came across a comm update message a child that isn't a string", n);
       if (!n.startsWith(o)) return this.dbtTerminal.warn(`Came across a comm update message a child that start start with ${o}`, n);
       const i = n.substring(o.length);
       this.ownedCommIds.add(i), this.commIdsMappedToParentWidgetModel.set(i, e.content.comm_id);
      }));
     }
    }
    handleExecuteResult(e, t) {
     return this.addToCellData({
      output_type: "execute_result",
      data: e.content.data,
      metadata: e.content.metadata,
      transient: e.content.transient,
      execution_count: e.content.execution_count
     }, e, t);
    }
    addToCellData(e, t, o) {
     if (e.data && "object" == typeof e.data && O in e.data) {
      const s = e.data[O];
      if (s && "model_id" in s) {
       const a = w.modelIdsOwnedByCells.get(o) || new Set;
       a.add(s.model_id), w.modelIdsOwnedByCells.set(o, a);
      }
     }
     const n = S(e);
     if (o.document.isClosed) return;
     this.dbtTerminal.log(o.document.uri.fsPath, `Update output with mimes ${n.items.map((s => s.mime)).toString()}`);
     const i = N(t);
     return this.outputsAreSpecificToAWidget.length && this.outputsAreSpecificToAWidget[this.outputsAreSpecificToAWidget.length - 1].msgIdsToSwallow === i && n.items.every((s => this.canMimeTypeBeRenderedByWidgetManager(s))) || this.outputsAreSpecificToAWidget.length && this.outputsAreSpecificToAWidget[this.outputsAreSpecificToAWidget.length - 1].msgIdsToSwallow === i && this.dbtTerminal.warn("NotebookAddToCellData", "unknown operation"), 
     n;
    }
    canMimeTypeBeRenderedByWidgetManager(e) {
     const t = e.mime;
     if (t === g.stderr || t === g.stdout || t === g.error) return !0;
     if (t === O) {
      const o = JSON.parse((new TextDecoder).decode(e.data));
      return !("string" == typeof o.model_id && this.commIdsMappedToWidgetOutputModels.has(o.model_id));
     }
     return !t.startsWith("application/vnd");
    }
    handleExecuteInput(e) {}
    handleStatusMessage(e) {}
    handleStreamMessage(e, t) {
     var n;
     if (N(e) && this.outputsAreSpecificToAWidget.length && this.outputsAreSpecificToAWidget[this.outputsAreSpecificToAWidget.length - 1].msgIdsToSwallow === N(e)) return;
     const o = "stdout" === e.content.name ? l.NotebookCellOutputItem.stdout("").mime : l.NotebookCellOutputItem.stderr("").mime;
     if (!this.streamsReAttachedToExecutingCell && !this.lastUsedStreamOutput && t.outputs.length && t.outputs[t.outputs.length - 1].items.length >= 1 && t.outputs[t.outputs.length - 1].items.every((i => i.mime === o)) && (this.lastUsedStreamOutput = {
      output: t.outputs[0],
      stream: e.content.name
     }), this.streamsReAttachedToExecutingCell = !0, (null == (n = this.lastUsedStreamOutput) ? void 0 : n.stream) === e.content.name) return [ S({
      output_type: "stream",
      name: e.content.name,
      text: e.content.text
     }), this.lastUsedStreamOutput.output ];
     {
      const i = function(r) {
       return function(r) {
        for (r = r.replace(/\r+\n/gm, "\n"); r.search(/\r[^$]/g) > -1; ) {
         const e = r.match(/^(.*)\r+/m)[1];
         let t = r.match(/\r+(.*)$/m)[1];
         t += e.slice(t.length, e.length), r = r.replace(/\r+.*$/m, "\r").replace(/^.*\r/m, t);
        }
        return r;
       }(function(r) {
        let e = r;
        do {
         e = (r = e).replace(/[^\n]\x08/gm, "");
        } while (e.length < r.length);
        return r;
       }(r));
      }(D(e.content.text));
      return [ S({
       output_type: "stream",
       name: e.content.name,
       text: i
      }) ];
     }
    }
    handleDisplayData(e, t) {
     const o = {
      output_type: "display_data",
      data: le(e.content.data),
      metadata: e.content.metadata,
      transient: e.content.transient
     };
     return this.addToCellData(o, e, t);
    }
    handleClearOutput(e) {
     this.outputsAreSpecificToAWidget.length && this.outputsAreSpecificToAWidget[this.outputsAreSpecificToAWidget.length - 1].msgIdsToSwallow === N(e) && e.content.wait && this.outputsAreSpecificToAWidget.length && (this.outputsAreSpecificToAWidget[this.outputsAreSpecificToAWidget.length - 1].clearOutputOnNextUpdateToOutput = !0);
    }
    handleError(e, t) {
     const o = e.content.traceback;
     this.dbtTerminal.log(`Traceback for error ${o}`);
     const n = {
      output_type: "error",
      ename: e.content.ename,
      evalue: e.content.evalue,
      traceback: o
     };
     return this.addToCellData(n, e, t);
    }
   }
   Object.defineProperty(w, "modelIdsOwnedByCells", {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: new WeakMap
   });
   exports.NotebookDependencies = class {
    constructor(e, t, o, n) {
     Object.defineProperty(this, "dbtTerminal", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: e
     }), Object.defineProperty(this, "telemetry", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: t
     }), Object.defineProperty(this, "commandProcessExecutionFactory", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: o
     }), Object.defineProperty(this, "pythonEnvironment", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: n
     });
    }
    async checkPythonDependencies(e) {
     const t = [];
     for (const o of e) {
      const n = [ "-m", "pip", "show", o ], {stderr: i} = await this.commandProcessExecutionFactory.createCommandProcessExecution({
       command: this.pythonEnvironment.pythonPath,
       args: n,
       cwd: u.getFirstWorkspacePath(),
       envVars: this.pythonEnvironment.environmentVariables
      }).completeWithTerminalOutput();
      i && t.push(o);
     }
     return t;
    }
    checkDbtDependencies(e, t) {
     return e.map((o => {
      try {
       return t.findPackageVersion(o), null;
      } catch {
       return o;
      }
     })).filter(Boolean);
    }
    async installMissingPythonPackages(e, t) {
     const o = await this.checkPythonDependencies(e);
     if (o.length) {
      if (this.dbtTerminal.debug("Notebook", "asking user to install missing python dependencies for notebook", o), 
      "Install" !== await l.window.showInformationMessage(`You need the following python packages to use this notebook: ${o.join(", ")}`, "Install", "Cancel")) throw this.telemetry.sendTelemetryEvent(u.TelemetryEvents["Notebook/DependenciesInstallCancelled"]), 
      new Error("User cancelled python package installation");
      return this.dbtTerminal.debug("Notebook", "installing required dependencies", o), 
      await l.window.withProgress({
       title: "Installing python packages...",
       location: l.ProgressLocation.Notification,
       cancellable: !1
      }, (async () => {
       try {
        const i = [ "-m", "pip", "install", ...o ], {stdout: s, stderr: a} = await this.commandProcessExecutionFactory.createCommandProcessExecution({
         command: this.pythonEnvironment.pythonPath,
         args: i,
         cwd: u.getFirstWorkspacePath(),
         envVars: this.pythonEnvironment.environmentVariables
        }).completeWithTerminalOutput();
        if (!s.includes("Successfully installed") && !s.includes("Requirement already satisfied") && a) throw new Error(a);
        return this.dbtTerminal.log("Notebook dependencies have been installed successfully."), 
        this.telemetry.sendTelemetryEvent(u.TelemetryEvents["Notebook/DependenciesInstalled"]), 
        await t.initialize(), !0;
       } catch (i) {
        this.telemetry.sendTelemetryError(u.TelemetryEvents["Notebook/DependenciesInstallError"], i), 
        l.window.showErrorMessage(u.extendErrorWithSupportLinks(i.message));
       }
      }));
     }
    }
    async installMissingDbtPackages(e, t) {
     const o = this.checkDbtDependencies(e.map((s => `${s.name}`)), t);
     if (!o.length) return;
     const n = e.filter((s => !!s.name && o.includes(s.name)));
     if (this.dbtTerminal.debug("Notebook", "asking user to install missing dbt dependencies for notebook", n), 
     "Install" !== await l.window.showInformationMessage(`You need following dbt packages to use this notebook: ${n.map((s => `${s.package}`)).join(", ")}`, "Install", "Cancel")) throw this.telemetry.sendTelemetryEvent(u.TelemetryEvents["Notebook/DependenciesInstallCancelled"]), 
     new Error("User cancelled dbt package installation");
     return await l.window.withProgress({
      title: "Installing dbt packages...",
      location: l.ProgressLocation.Notification,
      cancellable: !1
     }, (async () => {
      try {
       const s = n.map((c => `${c.package}@${c.version}`));
       this.dbtTerminal.debug("Notebook", "installing dbt packages", s), await t.installDbtPackages(s), 
       await t.initialize();
       const a = this.checkDbtDependencies(e.map((c => `${c.name}`)), t);
       if (a.length) throw new Error(`Failed to install dbt packages ${a.join(", ")}`);
       return this.dbtTerminal.log("Notebook dependencies have been installed successfully."), 
       this.telemetry.sendTelemetryEvent(u.TelemetryEvents["Notebook/DependenciesInstalled"]), 
       !0;
      } catch (s) {
       this.telemetry.sendTelemetryError(u.TelemetryEvents["Notebook/DependenciesInstallError"], s), 
       l.window.showErrorMessage(u.extendErrorWithSupportLinks(s.message));
      }
     }));
    }
    async verifyAndInstallDependenciesIfNeeded(e, t) {
     this.dbtTerminal.debug("NotebookDependencies", "verifying required dependencies", e), 
     await Promise.all([ this.validateAndInstallNotebookDependencies(), this.installMissingPythonPackages(e.filter((o => "python" === o.type)).map((o => o.package)), t), this.installMissingDbtPackages(e.filter((o => "dbt" === o.type)), t) ]);
    }
    async getDependenciesVersion() {
     const {stdout: t, stderr: o} = await this.commandProcessExecutionFactory.createCommandProcessExecution({
      command: this.pythonEnvironment.pythonPath,
      args: [ "-m", "jupyter", "--version" ],
      cwd: u.getFirstWorkspacePath(),
      envVars: this.pythonEnvironment.environmentVariables
     }).completeWithTerminalOutput();
     if (!t.includes("Successfully installed") && !t.includes("Requirement already satisfied") && o) throw new Error(o);
     const n = t.split("\n"), i = {};
     return n.forEach((s => {
      const [a, c] = s.split(":").map((d => d.trim()));
      a && c && (i[a] = c);
     })), i;
    }
    async validateAndInstallNotebookDependencies() {
     try {
      if (await this.notebookDependenciesAreInstalled()) return this.dbtTerminal.log("Notebook dependencies are already installed."), 
      !0;
      if ("Install" !== await l.window.showInformationMessage("You need [ipykernel](https://pypi.org/project/ipykernel/) and [jupyter_client](https://github.com/jupyter/jupyter_client) to use the notebook", "Install", "Cancel")) return this.telemetry.sendTelemetryEvent(u.TelemetryEvents["Notebook/DependenciesInstallCancelled"]), 
      !1;
      await l.window.withProgress({
       title: "Installing required dependencies...",
       location: l.ProgressLocation.Notification,
       cancellable: !1
      }, (async () => {
       try {
        const o = [ "-m", "pip", "install", "ipykernel", "jupyter_client", "jupyter_contrib_nbextensions", "ipywidgets" ], {stdout: n, stderr: i} = await this.commandProcessExecutionFactory.createCommandProcessExecution({
         command: this.pythonEnvironment.pythonPath,
         args: o,
         cwd: u.getFirstWorkspacePath(),
         envVars: this.pythonEnvironment.environmentVariables
        }).completeWithTerminalOutput();
        if (!n.includes("Successfully installed") && !n.includes("Requirement already satisfied") && i) throw new Error(i);
        return this.dbtTerminal.log("Notebook dependencies have been installed successfully."), 
        this.telemetry.sendTelemetryEvent(u.TelemetryEvents["Notebook/DependenciesInstalled"]), 
        !0;
       } catch (o) {
        return this.telemetry.sendTelemetryError(u.TelemetryEvents["Notebook/DependenciesInstallError"], o), 
        l.window.showErrorMessage(u.extendErrorWithSupportLinks(o.message)), !1;
       }
      })) && "Reload Window" === await l.window.showInformationMessage("Notebook dependencies installed. Please reload the window to use the notebook.", "Reload Window") && l.commands.executeCommand("workbench.action.reloadWindow");
     } catch (e) {
      throw this.dbtTerminal.error(u.TelemetryEvents["Notebook/DependenciesInstallError"], e.message, e), 
      e;
     }
    }
    async notebookDependenciesAreInstalled() {
     try {
      const e = this.commandProcessExecutionFactory.createCommandProcessExecution({
       command: this.pythonEnvironment.pythonPath,
       args: [ "-c", "import jupyter_client" ],
       cwd: u.getFirstWorkspacePath(),
       envVars: this.pythonEnvironment.environmentVariables
      }), {stderr: t} = await e.complete();
      if (t) throw new Error(t);
      return !0;
     } catch {
      return !1;
     }
    }
   }, exports.NotebookDependencies = function(r, e, t, o) {
    var s, n = arguments.length, i = n < 3 ? e : null === o ? o = Object.getOwnPropertyDescriptor(e, t) : o;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) i = Reflect.decorate(r, e, t, o); else for (var a = r.length - 1; a >= 0; a--) (s = r[a]) && (i = (n < 3 ? s(i) : n > 3 ? s(e, t, i) : s(e, t)) || i);
    return n > 3 && i && Object.defineProperty(e, t, i), i;
   }([ u.provideSingleton(exports.NotebookDependencies), function(r, e) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(r, e);
   }("design:paramtypes", [ u.DBTTerminal, u.TelemetryService, u.CommandProcessExecutionFactory, u.PythonEnvironment ]) ], exports.NotebookDependencies);
   let C = class {
    constructor(e, t, o) {
     Object.defineProperty(this, "executionInfrastructure", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: e
     }), Object.defineProperty(this, "notebookDependencies", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: t
     }), Object.defineProperty(this, "dbtTerminal", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: o
     }), Object.defineProperty(this, "clientMap", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new Map
     });
    }
    async initializeNotebookClient(e) {
     if (!this.clientMap.has(e.fsPath)) {
      this.dbtTerminal.debug("ClientMapper", "initializing notebook client", e.fsPath);
      const t = new w(e.fsPath, this.executionInfrastructure, this.notebookDependencies, this.dbtTerminal);
      this.clientMap.set(e.fsPath, new Promise((o => {
       t.getKernel().then((() => o(t)));
      })));
     }
     return this.clientMap.get(e.fsPath);
    }
    getNotebookClient(e) {
     if (!this.clientMap.has(e.fsPath)) throw new Error("Notebook client not initialized");
     return this.clientMap.get(e.fsPath);
    }
   };
   C = function(r, e, t, o) {
    var s, n = arguments.length, i = n < 3 ? e : null === o ? o = Object.getOwnPropertyDescriptor(e, t) : o;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) i = Reflect.decorate(r, e, t, o); else for (var a = r.length - 1; a >= 0; a--) (s = r[a]) && (i = (n < 3 ? s(i) : n > 3 ? s(e, t, i) : s(e, t)) || i);
    return n > 3 && i && Object.defineProperty(e, t, i), i;
   }([ u.provideSingleton(C), function(r, e) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(r, e);
   }("design:paramtypes", [ u.DBTCommandExecutionInfrastructure, exports.NotebookDependencies, u.DBTTerminal ]) ], C);
   const Se = [ "python", "sql", "jinja-sql" ], U = ".notebook", z = "datapilot", v = "datapilot-notebook";
   const Re = __webpack_require__(16928);
   exports.DatapilotNotebookController = class {
    constructor(e, t, o, n, i, s) {
     Object.defineProperty(this, "clientMapper", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: e
     }), Object.defineProperty(this, "queryManifestService", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: t
     }), Object.defineProperty(this, "telemetry", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: o
     }), Object.defineProperty(this, "dbtTerminal", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: n
     }), Object.defineProperty(this, "notebookDependencies", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: i
     }), Object.defineProperty(this, "altimate", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: s
     }), Object.defineProperty(this, "id", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "DatapilotNotebookController"
     }), Object.defineProperty(this, "label", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "Datapilot"
     }), Object.defineProperty(this, "_onNotebookCellEvent", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new l.EventEmitter
     }), Object.defineProperty(this, "onNotebookCellChangeEvent", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this._onNotebookCellEvent.event
     }), Object.defineProperty(this, "disposables", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: [ this._onNotebookCellEvent ]
     }), Object.defineProperty(this, "associatedNotebooks", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new Set
     }), Object.defineProperty(this, "executionOrder", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
     }), Object.defineProperty(this, "controller", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
     }), Object.defineProperty(this, "getRandomString", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: () => (Math.random() + 1).toString(36).substring(7)
     }), this.controller = l.notebooks.createNotebookController(this.id, v, this.label), 
     this.controller.supportedLanguages = Se, this.controller.supportsExecutionOrder = !0, 
     this.controller.executeHandler = this._executeAll.bind(this), this.disposables.push(l.workspace.onDidChangeNotebookDocument((a => {
      a.contentChanges.forEach((async c => {
       c.addedCells && await this.updateCellId(a.notebook.getCells(), a.notebook), c.removedCells && c.removedCells.forEach((d => {
        this._onNotebookCellEvent.fire({
         cellId: d.metadata.cellId,
         notebook: a.notebook.uri.fsPath,
         result: null,
         event: "delete",
         fragment: d.document.uri.fragment,
         languageId: d.document.languageId
        });
       }));
      }));
     }))), this.disposables.push(this.controller), this.controller.onDidChangeSelectedNotebooks(this.onDidChangeSelectedNotebooks, this, this.disposables), 
     this.disposables.push(l.workspace.onDidOpenNotebookDocument((async a => {
      await this.onNotebookOpen(a);
     }))), this.disposables.push(l.workspace.onDidCloseNotebookDocument((async a => {
      await this.onNotebookClose(a);
     })));
    }
    async getNotebookByTemplate(e) {
     var o;
     return this.dbtTerminal.debug("Notebook", "getting notebook by template", e), e ? null == (o = (await this.altimate.getPreConfiguredNotebooks()).find((n => n.name === e))) ? void 0 : o.data : (this.dbtTerminal.debug("Notebook", "sending blank notebook"), 
     {
      cells: [ {
       cell_type: l.NotebookCellKind.Markup,
       source: [ "### Welcome to your new dbt Power User Notebook!", "> Note: Remember, you can delete any or all of these example cells to start fresh with your own work. Enjoy exploring and analyzing your data!", "#### Documentation and Feedback", "For more detailed information on how to use this notebook and the dbt Power User extension, please refer to our documentation:", "[dbt Power User Documentation](https://docs.myaltimate.com/govern/notebooks/)", "  ", "We value your feedback! If you have any suggestions, encounter issues, or want to share your experience, please let us know:", "[Share Feedback](https://docs.google.com/forms/d/e/1FAIpQLScwN3wRTAniQzvcO6Hn3jC0WtBoFE2NP4X_6qGQ09IZKZ3Ojw/viewform?usp=sf_link)", "  ", "Happy analyzing with your new dbt Power User Notebook!", "  ", "This notebook allows you to combine Jinja SQL queries, Python code, and Markdown text. Let's explore each of these features.", "##### 1. Jinja SQL Queries", "You can write and execute Jinja SQL queries directly in this notebook. Here's an example:" ],
       languageId: "markdown",
       metadata: {}
      }, {
       cell_type: l.NotebookCellKind.Code,
       source: [ "select * from {{ ref('your_model_name') }}", "{# Replace 'your_model_name' with the name of your dbt model. #}" ],
       languageId: "jinja-sql",
       metadata: {
        cellId: "jinja_sql_0"
       }
      }, {
       cell_type: l.NotebookCellKind.Markup,
       source: [ "##### 2. Python Code", "You can also write and execute Python code on top of the results of previous `jinja-sql` cell in this notebook. Here's a simple example:" ],
       languageId: "markdown",
       metadata: {}
      }, {
       cell_type: l.NotebookCellKind.Code,
       source: [ "import pandas as pd", "from IPython.display import display, HTML", "from ydata_profiling import ProfileReport", "from io import StringIO", "", "# Extract the data field", "# NOTE: we use the cell id from previous cell to extract the data", "data = cell_jinja_sql_0['data']", "", "# Create a DataFrame", "df = pd.DataFrame(data)", "", "# Display the DataFrame", "# display(HTML(df.to_html()))", "", 'profile = ProfileReport(df, title="Profiling Report")', "profile.to_notebook_iframe()" ],
       languageId: "python",
       metadata: {}
      }, {
       cell_type: l.NotebookCellKind.Markup,
       source: [ "This Python code creates a profile report of your query results. You can customize the code to suit your needs.", "##### 3. Markdown Text", "As you can see, you can use Markdown to structure your notebook with headings, lists, and more. You can also use it to add explanations and documentation to your queries and code.", "##### Tips for Using This Notebook", "- Use Jinja cells for your dbt model queries and data exploration", "- Use Python cells for data analysis, visualization, and custom transformations. The jinja data can be referenced using the cell id", "- Use Markdown cells to explain your process, document your findings, and create a narrative for your analysis" ],
       languageId: "markdown",
       metadata: {}
      } ]
     });
    }
    async modelTestSuggestions(e) {
     this.dbtTerminal.log("modelTestSuggestions", e);
    }
    async generateDbtSourceYaml(e) {
     this.dbtTerminal.log("generateDbtSourceYaml", e);
    }
    async generateDbtDbtModelSql(e) {
     this.dbtTerminal.log("generateDbtDbtModelSql", e);
    }
    async generateDbtDbtModelYaml(e) {
     this.dbtTerminal.log("generateDbtDbtModelYaml", e);
    }
    async generateDbtDbtModelCTE(e) {
     this.dbtTerminal.log("generateDbtDbtModelCTE", e);
    }
    async extractExposuresFromMetabase(e) {
     this.dbtTerminal.log("extractExposuresFromMetabase", e);
    }
    async extractExposuresFromTableau(e) {
     this.dbtTerminal.log("extractExposuresFromTableau", e);
    }
    async getFileName(e, t) {
     if (e) return e;
     const o = function() {
      const r = new Date;
      return `${r.toLocaleDateString("en-GB").replace(/\//g, "-")}-${r.toLocaleTimeString("en-GB", {
       hour12: !1
      }).replace(/:/g, "-")}`;
     }();
     return (await this.altimate.addNotebook({
      name: o,
      description: "",
      data: t ? {
       ...t,
       metadata: {
        ...t.metadata || {},
        isDraft: !0
       }
      } : {},
      tags_list: []
     })).ok && (await this.altimate.getNotebooks(o)).length > 0 ? o : void 0;
    }
    async createNotebook(e) {
     var s;
     const {notebookId: t, template: o, context: n = {}, notebookSchema: i} = e || {};
     if (this.dbtTerminal.info(u.TelemetryEvents["Notebook/Launch"], "creating notebook", !0, e), 
     !n.model && null != (s = l.window.activeTextEditor) && s.document.uri.fsPath.endsWith(".sql")) {
      const a = Re.basename(l.window.activeTextEditor.document.uri.fsPath, ".sql"), c = l.window.activeTextEditor.document.getText();
      n.model = a, n.query = c;
     }
     l.window.withProgress({
      location: l.ProgressLocation.Notification,
      title: "Launching notebook...",
      cancellable: !1
     }, (async () => {
      var a;
      try {
       const c = i || (t ? null : await this.getNotebookByTemplate(o)), d = await this.queryManifestService.getOrPickProjectFromWorkspace();
       if (!d) return void l.window.showErrorMessage("No dbt project selected.");
       if (null != (a = null == c ? void 0 : c.metadata) && a.dependencies && await this.notebookDependencies.verifyAndInstallDependenciesIfNeeded(c.metadata.dependencies, d), 
       n && c) for (const f in n) n.hasOwnProperty(f) && "string" == typeof n[f] && (c.cells[0].source = c.cells[0].source.map((b => b.replace(`%_${f}_%`, n[f]))));
       const h = await this.getFileName(t, c), m = l.Uri.parse(`${d.projectRoot}/${h}${U}`).with({
        scheme: z
       });
       this.dbtTerminal.debug("Notebook", "opening notebook", m);
       const p = await l.workspace.openNotebookDocument(m);
       await l.window.showNotebookDocument(p);
      } catch (c) {
       const d = c instanceof B.PythonException ? c.exception.message : c.message;
       this.dbtTerminal.error(`${u.TelemetryEvents["Notebook/LaunchError"]}`, d, c), l.window.showErrorMessage(u.extendErrorWithSupportLinks(d));
      }
     }));
    }
    sendMessageToPreloadScript(e) {}
    genUniqueId(e) {
     return `${e.document.languageId.replace(/-/g, "_")}_${this.getRandomString()}`;
    }
    async updateCellId(e, t) {
     if (!l.window.visibleNotebookEditors.find((i => i.notebook.uri.fsPath === t.uri.fsPath))) return;
     const n = [];
     if (e.forEach((i => {
      let s = i.metadata.cellId;
      if (!s) {
       s = this.genUniqueId(i);
       const a = {
        ...i.metadata,
        cellId: s
       }, c = l.NotebookEdit.updateCellMetadata(i.index, a);
       n.push(c);
      }
      this._onNotebookCellEvent.fire({
       cellId: s,
       notebook: t.uri.fsPath,
       event: "update",
       fragment: i.document.uri.fragment,
       languageId: i.document.languageId
      });
     })), n.length > 0) {
      const i = new l.WorkspaceEdit;
      i.set(t.uri, n), await l.workspace.applyEdit(i);
     }
    }
    async onNotebookClose(e) {
     if (e.notebookType !== v) return;
     const t = await this.clientMapper.getNotebookClient(e.uri);
     t && t.dispose(), this.dbtTerminal.debug("Notebookcontroller", `notebook closed: ${e.uri.fsPath}`, e.isUntitled), 
     e.isUntitled && await l.workspace.fs.delete(e.uri);
    }
    async onDidChangeSelectedNotebooks({notebook: e, selected: t}) {
     this.dbtTerminal.debug("Notebookcontroller", `notebook controller selected: ${e.uri.fsPath}`, t);
     const o = e.uri.toString();
     t ? this.associatedNotebooks.add(o) : this.associatedNotebooks.delete(o);
    }
    async onNotebookOpen(e) {
     var i;
     if (e.notebookType !== v) return;
     this.controller.updateNotebookAffinity(e, l.NotebookControllerAffinity.Default), 
     this.dbtTerminal.debug("Notebookcontroller", `notebook open and controller associated: ${e.uri.fsPath}`);
     const t = await this.clientMapper.initializeNotebookClient(e.uri), o = await t.getKernel();
     if (null == o || !o.realKernel) throw new Error("Unable to initialize kernel");
     this.disposables.push(t.postMessage((s => {
      this.sendMessageToPreloadScript(s);
     }), this));
     const n = e.getCells();
     await this.updateCellId(n, e);
     try {
      await this.waitForControllerAssociation(e);
     } catch {
      this.dbtTerminal.warn("Notebookcontroller", `Controller association timeout for ${e.uri.fsPath}. Proceeding anyway.`), 
      this.associatedNotebooks.add(e.uri.toString());
     }
     null != (i = e.metadata) && i.autoRun && await this._executeAll(e.getCells(), e, this.controller);
    }
    async waitForControllerAssociation(e, t = 2e3) {
     const o = Date.now();
     for (;!this.isControllerAssociatedWithNotebook(e); ) {
      if (Date.now() - o > t) throw new Error("Timeout waiting for controller association");
      await new Promise((n => setTimeout(n, 500)));
     }
    }
    isControllerAssociatedWithNotebook(e) {
     return this.associatedNotebooks.has(e.uri.toString());
    }
    dispose() {
     this.disposables.forEach((e => e.dispose()));
    }
    async _executeAll(e, t, o) {
     var s, a;
     const n = await this.queryManifestService.getOrPickProjectFromWorkspace();
     if (!n) return void l.window.showErrorMessage("No dbt project selected.");
     null != (s = t.metadata) && s.dependencies && await this.notebookDependencies.verifyAndInstallDependenciesIfNeeded(t.metadata.dependencies, n);
     const i = await this.clientMapper.getNotebookClient(t.uri);
     await this.updateContextVariablesInKernel(n, i, e[0]);
     for (const c of e) await this._doExecution(c, t, null == (a = t.metadata) ? void 0 : a.isUserNotebook, o, n, i);
    }
    filterIPyWidgets(e, t = !1) {
     return e.map((o => {
      const i = o.items.find((s => "application/vnd.jupyter.widget-view+json" === s.mime)) ? t ? [ l.NotebookCellOutputItem.text("IPyWidgets not supported") ] : [] : o.items;
      return new l.NotebookCellOutput(i);
     }));
    }
    updateContextVariablesInKernel(e, t, o) {
     return t.executePython(`\nmanifest_path="${e.getManifestPath()}"\nproject_name="${e.getProjectName()}"\n            `, o, (() => {}));
    }
    async _doExecution(e, t, o, n, i, s) {
     let a;
     this.dbtTerminal.debug("Notebook", "executing cell", e.index, t.uri.fsPath);
     try {
      const c = [];
      switch (a = n.createNotebookCellExecution(e), a.executionOrder = ++this.executionOrder, 
      a.start(Date.now()), a.token.onCancellationRequested((d => {
       null == a || a.end(!0, Date.now());
      })), a.clearOutput(), e.document.languageId) {
      case "markdown":
       break;

      case "python":
       this.telemetry.startTelemetryEvent(u.TelemetryEvents["Notebook/Execute"], {
        language: e.document.languageId
       });
       const d = await (null == s ? void 0 : s.executePython(e.document.getText(), e, (m => {
        null == a || a.appendOutput(this.filterIPyWidgets([ m ], o));
       })));
       d && a.appendOutput(this.filterIPyWidgets(d, o));
       break;

      case "jinja-sql":
      case "sql":
       this.dbtTerminal.debug("Notebook", "executing sql", e.document.getText()), this.telemetry.startTelemetryEvent(u.TelemetryEvents["Notebook/Execute"], {
        language: e.document.languageId
       });
       const {metadata: h} = e;
       if ("compile" === (null == h ? void 0 : h.execution_type)) {
        const m = await i.unsafeCompileQuery(e.document.getText());
        a.appendOutput(new l.NotebookCellOutput([ l.NotebookCellOutputItem.text(m, null == h ? void 0 : h.output_mime_type) ]));
       } else {
        const m = await i.executeSQL(e.document.getText(), "", !0);
        this._onNotebookCellEvent.fire({
         cellId: e.metadata.cellId,
         notebook: t.uri.fsPath,
         result: m,
         event: "add",
         languageId: e.document.languageId
        }), o || (c.push(l.NotebookCellOutputItem.json(m, "application/perspective-json")), 
        a.appendOutput(new l.NotebookCellOutput(c))), await s.storeDataInKernel(e.metadata.cellId, m);
       }
       break;

      default:
       l.window.showErrorMessage(`Language: ${e.document.languageId} not supported`);
      }
      this.telemetry.endTelemetryEvent(u.TelemetryEvents["Notebook/Execute"], {
       language: e.document.languageId
      }), a.end(!0, Date.now());
     } catch (c) {
      this.dbtTerminal.error("Notebook", `Error executing cell: ${c.message}`, c, !1), 
      null == a || a.replaceOutput([ new l.NotebookCellOutput([ l.NotebookCellOutputItem.error(c) ]) ]), 
      this.telemetry.endTelemetryEvent(u.TelemetryEvents["Notebook/Execute"], c, {
       language: e.document.languageId
      }), null == a || a.end(!1, Date.now());
     }
    }
   }, exports.DatapilotNotebookController = function(r, e, t, o) {
    var s, n = arguments.length, i = n < 3 ? e : null === o ? o = Object.getOwnPropertyDescriptor(e, t) : o;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) i = Reflect.decorate(r, e, t, o); else for (var a = r.length - 1; a >= 0; a--) (s = r[a]) && (i = (n < 3 ? s(i) : n > 3 ? s(e, t, i) : s(e, t)) || i);
    return n > 3 && i && Object.defineProperty(e, t, i), i;
   }([ u.provideSingleton(exports.DatapilotNotebookController), function(r, e) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(r, e);
   }("design:paramtypes", [ C, u.QueryManifestService, u.TelemetryService, u.DBTTerminal, exports.NotebookDependencies, u.AltimateRequest ]) ], exports.DatapilotNotebookController);
   class We {
    constructor() {
     Object.defineProperty(this, "_disposables", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
     });
    }
    dispose() {
     this._disposables.forEach((e => e.dispose()));
    }
    provideCellStatusBarItems(e) {
     if ("jinja-sql" !== e.document.languageId) return;
     const t = new l.NotebookCellStatusBarItem("$(globe) Profile your query", l.NotebookCellStatusBarAlignment.Left);
     return t.command = "dbtPowerUser.datapilotProfileYourQuery", t.tooltip = "Profile your query", 
     [];
    }
   }
   const L = __webpack_require__(16928);
   exports.NotebookFileSystemProvider = class {
    constructor(e, t) {
     Object.defineProperty(this, "dbtTerminal", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: e
     }), Object.defineProperty(this, "altimate", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: t
     }), Object.defineProperty(this, "_emitter", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new l.EventEmitter
     }), Object.defineProperty(this, "onDidChangeFile", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this._emitter.event
     }), Object.defineProperty(this, "notebookDataMap", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new Map
     });
    }
    watch(e, t) {
     return new l.Disposable((() => {}));
    }
    stat(e) {
     return {
      type: l.FileType.File,
      ctime: Date.now(),
      mtime: Date.now(),
      size: 0
     };
    }
    readDirectory(e) {
     return [];
    }
    createDirectory(e) {}
    async getNotebookData(e) {
     if (this.notebookDataMap.has(e)) return this.notebookDataMap.get(e);
     const t = await this.altimate.getNotebooks(e) || [];
     return t.length ? t[0] : null;
    }
    async readFile(e) {
     const t = this.getFileNameFromUri(e), o = await this.getNotebookData(t), n = (null == o ? void 0 : o.data) || {};
     return "cells" in n && "metadata" in n && (n.metadata ? n.metadata = {
      ...n.metadata,
      id: null == o ? void 0 : o.id
     } : n.metadata = {
      id: null == o ? void 0 : o.id
     }), o && this.notebookDataMap.set(t, o), (new TextEncoder).encode(JSON.stringify(n));
    }
    async writeFile(e, t, o) {
     await this.customSave(e, t);
    }
    delete(e, t) {
     const o = e.with({
      path: L.posix.dirname(e.path)
     });
     this._emitter.fire([ {
      type: l.FileChangeType.Changed,
      uri: o
     }, {
      uri: e,
      type: l.FileChangeType.Deleted
     } ]);
    }
    rename(e, t, o) {
     this._emitter.fire([ {
      type: l.FileChangeType.Deleted,
      uri: e
     }, {
      type: l.FileChangeType.Created,
      uri: t
     } ]);
    }
    getFileNameFromUri(e) {
     return L.basename(e.fsPath, U);
    }
    async customSave(e, t) {
     var o;
     try {
      console.log("custom save", e, (new TextDecoder).decode(t));
      const n = null == (o = l.window.activeNotebookEditor) ? void 0 : o.notebook;
      if (!n) return this.dbtTerminal.warn(u.TelemetryEvents["Notebook/SaveError"], "No active notebook found"), 
      !1;
      this.dbtTerminal.log("saving notebook", n);
      const {name: i} = n.metadata;
      return await this.saveNotebook(n, i), this._emitter.fire([ {
       type: l.FileChangeType.Changed,
       uri: e
      } ]), !0;
     } catch (n) {
      this.dbtTerminal.error(u.TelemetryEvents["Notebook/SaveError"], n.message, n), l.window.showErrorMessage(u.extendErrorWithSupportLinks(`Failed to save notebook. Error: ${n.message}`));
     }
     return !1;
    }
    async saveNotebook(e, t) {
     try {
      const o = A(e, t);
      this.dbtTerminal.log("saving notebook", t, o), await this.altimate.updateNotebook(e.metadata.id, {
       name: t,
       description: "",
       data: o,
       tags_list: []
      }), this.dbtTerminal.log("notebook saved", t, o);
      const n = this.getFileNameFromUri(e.uri), i = this.notebookDataMap.get(n);
      return i && (i.data = A(e, t, !0), this.notebookDataMap.set(n, i)), o;
     } catch (o) {
      this.dbtTerminal.error(u.TelemetryEvents["Notebook/SaveError"], o.message, o), l.window.showErrorMessage(u.extendErrorWithSupportLinks(`Failed to save notebook. Error: ${o.message}`));
     }
    }
   }, exports.NotebookFileSystemProvider = function(r, e, t, o) {
    var s, n = arguments.length, i = n < 3 ? e : null === o ? o = Object.getOwnPropertyDescriptor(e, t) : o;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) i = Reflect.decorate(r, e, t, o); else for (var a = r.length - 1; a >= 0; a--) (s = r[a]) && (i = (n < 3 ? s(i) : n > 3 ? s(e, t, i) : s(e, t)) || i);
    return n > 3 && i && Object.defineProperty(e, t, i), i;
   }([ u.provideSingleton(exports.NotebookFileSystemProvider), function(r, e) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(r, e);
   }("design:paramtypes", [ u.DBTTerminal, u.AltimateRequest ]) ], exports.NotebookFileSystemProvider);
   exports.NotebookService = class {
    constructor(e) {
     Object.defineProperty(this, "notebookKernel", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: e
     }), Object.defineProperty(this, "disposables", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
     }), Object.defineProperty(this, "cellByNotebookAutocompleteMap", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new Map
     }), this.disposables.push(this.notebookKernel.onNotebookCellChangeEvent((t => {
      this.onNotebookCellChanged(t);
     })));
    }
    dispose() {
     for (;this.disposables.length; ) {
      const e = this.disposables.pop();
      e && e.dispose();
     }
    }
    getCellByNotebookAutocompleteMap() {
     return this.cellByNotebookAutocompleteMap;
    }
    onNotebookCellChanged(e) {
     if (!e.fragment) return;
     const t = {
      cellId: e.cellId,
      fragment: e.fragment,
      languageId: e.languageId
     }, o = this.cellByNotebookAutocompleteMap.get(e.notebook) || [];
     switch (e.event) {
     case "add":
     case "update":
      this.cellByNotebookAutocompleteMap.set(e.notebook, [ ...o.filter((n => n.cellId !== e.cellId)), t ]);
      break;

     case "delete":
      this.cellByNotebookAutocompleteMap.set(e.notebook, o.filter((n => n.cellId !== e.cellId)));
     }
    }
   }, exports.NotebookService = function(r, e, t, o) {
    var s, n = arguments.length, i = n < 3 ? e : null === o ? o = Object.getOwnPropertyDescriptor(e, t) : o;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) i = Reflect.decorate(r, e, t, o); else for (var a = r.length - 1; a >= 0; a--) (s = r[a]) && (i = (n < 3 ? s(i) : n > 3 ? s(e, t, i) : s(e, t)) || i);
    return n > 3 && i && Object.defineProperty(e, t, i), i;
   }([ u.provideSingleton(exports.NotebookService), function(r, e) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(r, e);
   }("design:paramtypes", [ exports.DatapilotNotebookController ]) ], exports.NotebookService);
   const Le = {
    notebooks: [ {
     name: "Profile your query",
     description: "Notebook to profile your query",
     created_at: (new Date).toISOString(),
     updated_at: (new Date).toISOString(),
     id: "1",
     data: {
      cells: [ {
       cell_type: l.NotebookCellKind.Code,
       source: [ "{{context.query}}" ],
       languageId: "jinja-sql",
       metadata: {
        cellId: "jinja_sql_cu6pt"
       }
      }, {
       cell_type: l.NotebookCellKind.Code,
       source: [ "import pandas as pd", "from IPython.display import display, HTML", "from ydata_profiling import ProfileReport", "from io import StringIO", "", "# Extract the data field", "data = cell_jinja_sql_cu6pt['data']", "", "# Create a DataFrame", "df = pd.DataFrame(data)", "", "# Display the DataFrame", "# display(HTML(df.to_html()))", "", 'profile = ProfileReport(df, title="Profiling Report")', "profile.to_notebook_iframe()" ],
       languageId: "python",
       metadata: {}
      } ],
      metadata: {
       dependencies: [ "pandas", "ydata_profiling" ],
       autoRun: !0
      }
     },
     tags: [ "profile" ]
    } ]
   };
   exports.NotebookProviders = class {
    constructor(e, t, o, n) {
     Object.defineProperty(this, "notebookProvider", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: e
     }), Object.defineProperty(this, "notebookController", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: t
     }), Object.defineProperty(this, "notebookFileSystemProvider", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: o
     }), Object.defineProperty(this, "dbtTerminal", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: n
     }), Object.defineProperty(this, "disposables", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
     }), this.disposables.push(l.workspace.onDidChangeConfiguration((i => {
      i.affectsConfiguration("dbt.enableNotebooks") && this.bindNotebookActions();
     }))), this.bindNotebookActions();
    }
    bindNotebookActions() {
     l.workspace.getConfiguration("dbt").get("enableNotebooks", !1) && (this.dbtTerminal.log("Notebooks enabled, binding actions"), 
     this.disposables.push(l.notebooks.registerNotebookCellStatusBarItemProvider(v, new We), l.workspace.registerNotebookSerializer(v, this.notebookProvider, {}), this.notebookController), 
     this.disposables.push(l.workspace.registerFileSystemProvider(z, this.notebookFileSystemProvider, {
      isCaseSensitive: !0,
      isReadonly: !1
     })));
    }
    dispose() {
     for (;this.disposables.length; ) {
      const e = this.disposables.pop();
      e && e.dispose();
     }
    }
   }, exports.NotebookProviders = function(r, e, t, o) {
    var s, n = arguments.length, i = n < 3 ? e : null === o ? o = Object.getOwnPropertyDescriptor(e, t) : o;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) i = Reflect.decorate(r, e, t, o); else for (var a = r.length - 1; a >= 0; a--) (s = r[a]) && (i = (n < 3 ? s(i) : n > 3 ? s(e, t, i) : s(e, t)) || i);
    return n > 3 && i && Object.defineProperty(e, t, i), i;
   }([ u.provideSingleton(exports.NotebookProviders), function(r, e) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(r, e);
   }("design:paramtypes", [ E, exports.DatapilotNotebookController, exports.NotebookFileSystemProvider, u.DBTTerminal ]) ], exports.NotebookProviders), 
   exports.CustomNotebooks = Le, exports.NotebookKernelClient = w;
  },
  54980: module => {
   "use strict";
   module.exports = require("vscode");
  },
  11594: module => {
   "use strict";
   module.exports = require("zeromq");
  },
  90290: module => {
   "use strict";
   module.exports = require("async_hooks");
  },
  20181: module => {
   "use strict";
   module.exports = require("buffer");
  },
  35317: module => {
   "use strict";
   module.exports = require("child_process");
  },
  76982: module => {
   "use strict";
   module.exports = require("crypto");
  },
  24434: module => {
   "use strict";
   module.exports = require("events");
  },
  79896: module => {
   "use strict";
   module.exports = require("fs");
  },
  91943: module => {
   "use strict";
   module.exports = require("fs/promises");
  },
  58611: module => {
   "use strict";
   module.exports = require("http");
  },
  65692: module => {
   "use strict";
   module.exports = require("https");
  },
  69278: module => {
   "use strict";
   module.exports = require("net");
  },
  1708: module => {
   "use strict";
   module.exports = require("node:process");
  },
  37830: module => {
   "use strict";
   module.exports = require("node:stream/web");
  },
  70857: module => {
   "use strict";
   module.exports = require("os");
  },
  16928: module => {
   "use strict";
   module.exports = require("path");
  },
  24876: module => {
   "use strict";
   module.exports = require("punycode");
  },
  2203: module => {
   "use strict";
   module.exports = require("stream");
  },
  64756: module => {
   "use strict";
   module.exports = require("tls");
  },
  87016: module => {
   "use strict";
   module.exports = require("url");
  },
  28167: module => {
   "use strict";
   module.exports = require("worker_threads");
  },
  43106: module => {
   "use strict";
   module.exports = require("zlib");
  },
  93328: (__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {
   if (!globalThis.ReadableStream) try {
    const process = __webpack_require__(1708), {emitWarning} = process;
    try {
     process.emitWarning = () => {}, Object.assign(globalThis, __webpack_require__(37830)), 
     process.emitWarning = emitWarning;
    } catch (error) {
     throw process.emitWarning = emitWarning, error;
    }
   } catch (error) {
    Object.assign(globalThis, __webpack_require__(45010));
   }
   try {
    const {Blob} = __webpack_require__(20181);
    Blob && !Blob.prototype.stream && (Blob.prototype.stream = function(params) {
     let position = 0;
     const blob = this;
     return new ReadableStream({
      type: "bytes",
      async pull(ctrl) {
       const chunk = blob.slice(position, Math.min(blob.size, position + 65536)), buffer = await chunk.arrayBuffer();
       position += buffer.byteLength, ctrl.enqueue(new Uint8Array(buffer)), position === blob.size && ctrl.close();
      }
     });
    });
   } catch (error) {}
  },
  16262: function(__unused_webpack_module, exports, __webpack_require__) {
   "use strict";
   var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    void 0 === k2 && (k2 = k);
    var desc = Object.getOwnPropertyDescriptor(m, k);
    desc && !("get" in desc ? !m.__esModule : desc.writable || desc.configurable) || (desc = {
     enumerable: !0,
     get: function() {
      return m[k];
     }
    }), Object.defineProperty(o, k2, desc);
   } : function(o, m, k, k2) {
    void 0 === k2 && (k2 = k), o[k2] = m[k];
   }), __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
     enumerable: !0,
     value: v
    });
   } : function(o, v) {
    o.default = v;
   }), __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (null != mod) for (var k in mod) "default" !== k && Object.prototype.hasOwnProperty.call(mod, k) && __createBinding(result, mod, k);
    return __setModuleDefault(result, mod), result;
   }, __exportStar = this && this.__exportStar || function(m, exports) {
    for (var p in m) "default" === p || Object.prototype.hasOwnProperty.call(exports, p) || __createBinding(exports, m, p);
   };
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.sync = exports.isexe = exports.posix = exports.win32 = void 0;
   const posix = __importStar(__webpack_require__(71481));
   exports.posix = posix;
   const win32 = __importStar(__webpack_require__(53381));
   exports.win32 = win32, __exportStar(__webpack_require__(10136), exports);
   const impl = "win32" === (process.env._ISEXE_TEST_PLATFORM_ || process.platform) ? win32 : posix;
   exports.isexe = impl.isexe, exports.sync = impl.sync;
  },
  10136: (__unused_webpack_module, exports) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   });
  },
  71481: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.sync = exports.isexe = void 0;
   const fs_1 = __webpack_require__(79896), promises_1 = __webpack_require__(91943);
   exports.isexe = async (path, options = {}) => {
    const {ignoreErrors = !1} = options;
    try {
     return checkStat(await (0, promises_1.stat)(path), options);
    } catch (e) {
     const er = e;
     if (ignoreErrors || "EACCES" === er.code) return !1;
     throw er;
    }
   };
   exports.sync = (path, options = {}) => {
    const {ignoreErrors = !1} = options;
    try {
     return checkStat((0, fs_1.statSync)(path), options);
    } catch (e) {
     const er = e;
     if (ignoreErrors || "EACCES" === er.code) return !1;
     throw er;
    }
   };
   const checkStat = (stat, options) => stat.isFile() && checkMode(stat, options), checkMode = (stat, options) => {
    const myUid = options.uid ?? process.getuid?.(), myGroups = options.groups ?? process.getgroups?.() ?? [], myGid = options.gid ?? process.getgid?.() ?? myGroups[0];
    if (void 0 === myUid || void 0 === myGid) throw new Error("cannot get uid or gid");
    const groups = new Set([ myGid, ...myGroups ]), mod = stat.mode, uid = stat.uid, gid = stat.gid, u = parseInt("100", 8), g = parseInt("010", 8), ug = u | g;
    return !!(mod & parseInt("001", 8) || mod & g && groups.has(gid) || mod & u && uid === myUid || mod & ug && 0 === myUid);
   };
  },
  53381: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   Object.defineProperty(exports, "__esModule", {
    value: !0
   }), exports.sync = exports.isexe = void 0;
   const fs_1 = __webpack_require__(79896), promises_1 = __webpack_require__(91943);
   exports.isexe = async (path, options = {}) => {
    const {ignoreErrors = !1} = options;
    try {
     return checkStat(await (0, promises_1.stat)(path), path, options);
    } catch (e) {
     const er = e;
     if (ignoreErrors || "EACCES" === er.code) return !1;
     throw er;
    }
   };
   exports.sync = (path, options = {}) => {
    const {ignoreErrors = !1} = options;
    try {
     return checkStat((0, fs_1.statSync)(path), path, options);
    } catch (e) {
     const er = e;
     if (ignoreErrors || "EACCES" === er.code) return !1;
     throw er;
    }
   };
   const checkStat = (stat, path, options) => stat.isFile() && ((path, options) => {
    const {pathExt = process.env.PATHEXT || ""} = options, peSplit = pathExt.split(";");
    if (-1 !== peSplit.indexOf("")) return !0;
    for (let i = 0; i < peSplit.length; i++) {
     const p = peSplit[i].toLowerCase(), ext = path.substring(path.length - p.length).toLowerCase();
     if (p && ext === p) return !0;
    }
    return !1;
   })(path, options);
  },
  38630: () => {
   var Reflect;
   !function(Reflect) {
    !function() {
     var root = "object" == typeof globalThis ? globalThis : "object" == typeof global ? global : "object" == typeof self ? self : "object" == typeof this ? this : function() {
      try {
       return Function("return this;")();
      } catch (_) {}
     }() || function() {
      try {
       return (0, eval)("(function() { return this; })()");
      } catch (_) {}
     }(), exporter = makeExporter(Reflect);
     function makeExporter(target, previous) {
      return function(key, value) {
       Object.defineProperty(target, key, {
        configurable: !0,
        writable: !0,
        value
       }), previous && previous(key, value);
      };
     }
     void 0 !== root.Reflect && (exporter = makeExporter(root.Reflect, exporter)), function(exporter, root) {
      var hasOwn = Object.prototype.hasOwnProperty, supportsSymbol = "function" == typeof Symbol, toPrimitiveSymbol = supportsSymbol && void 0 !== Symbol.toPrimitive ? Symbol.toPrimitive : "@@toPrimitive", iteratorSymbol = supportsSymbol && void 0 !== Symbol.iterator ? Symbol.iterator : "@@iterator", supportsCreate = "function" == typeof Object.create, supportsProto = {
       __proto__: []
      } instanceof Array, downLevel = !supportsCreate && !supportsProto, HashMap = {
       create: supportsCreate ? function() {
        return MakeDictionary(Object.create(null));
       } : supportsProto ? function() {
        return MakeDictionary({
         __proto__: null
        });
       } : function() {
        return MakeDictionary({});
       },
       has: downLevel ? function(map, key) {
        return hasOwn.call(map, key);
       } : function(map, key) {
        return key in map;
       },
       get: downLevel ? function(map, key) {
        return hasOwn.call(map, key) ? map[key] : void 0;
       } : function(map, key) {
        return map[key];
       }
      }, functionPrototype = Object.getPrototypeOf(Function), _Map = "function" == typeof Map && "function" == typeof Map.prototype.entries ? Map : CreateMapPolyfill(), _Set = "function" == typeof Set && "function" == typeof Set.prototype.entries ? Set : CreateSetPolyfill(), _WeakMap = "function" == typeof WeakMap ? WeakMap : CreateWeakMapPolyfill(), registrySymbol = supportsSymbol ? Symbol.for("@reflect-metadata:registry") : void 0, metadataRegistry = GetOrCreateMetadataRegistry(), metadataProvider = CreateMetadataProvider(metadataRegistry);
      function decorate(decorators, target, propertyKey, attributes) {
       if (IsUndefined(propertyKey)) {
        if (!IsArray(decorators)) throw new TypeError;
        if (!IsConstructor(target)) throw new TypeError;
        return DecorateConstructor(decorators, target);
       }
       if (!IsArray(decorators)) throw new TypeError;
       if (!IsObject(target)) throw new TypeError;
       if (!IsObject(attributes) && !IsUndefined(attributes) && !IsNull(attributes)) throw new TypeError;
       return IsNull(attributes) && (attributes = void 0), DecorateProperty(decorators, target, propertyKey = ToPropertyKey(propertyKey), attributes);
      }
      function metadata(metadataKey, metadataValue) {
       function decorator(target, propertyKey) {
        if (!IsObject(target)) throw new TypeError;
        if (!IsUndefined(propertyKey) && !IsPropertyKey(propertyKey)) throw new TypeError;
        OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
       }
       return decorator;
      }
      function defineMetadata(metadataKey, metadataValue, target, propertyKey) {
       if (!IsObject(target)) throw new TypeError;
       return IsUndefined(propertyKey) || (propertyKey = ToPropertyKey(propertyKey)), OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
      }
      function hasMetadata(metadataKey, target, propertyKey) {
       if (!IsObject(target)) throw new TypeError;
       return IsUndefined(propertyKey) || (propertyKey = ToPropertyKey(propertyKey)), OrdinaryHasMetadata(metadataKey, target, propertyKey);
      }
      function hasOwnMetadata(metadataKey, target, propertyKey) {
       if (!IsObject(target)) throw new TypeError;
       return IsUndefined(propertyKey) || (propertyKey = ToPropertyKey(propertyKey)), OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);
      }
      function getMetadata(metadataKey, target, propertyKey) {
       if (!IsObject(target)) throw new TypeError;
       return IsUndefined(propertyKey) || (propertyKey = ToPropertyKey(propertyKey)), OrdinaryGetMetadata(metadataKey, target, propertyKey);
      }
      function getOwnMetadata(metadataKey, target, propertyKey) {
       if (!IsObject(target)) throw new TypeError;
       return IsUndefined(propertyKey) || (propertyKey = ToPropertyKey(propertyKey)), OrdinaryGetOwnMetadata(metadataKey, target, propertyKey);
      }
      function getMetadataKeys(target, propertyKey) {
       if (!IsObject(target)) throw new TypeError;
       return IsUndefined(propertyKey) || (propertyKey = ToPropertyKey(propertyKey)), OrdinaryMetadataKeys(target, propertyKey);
      }
      function getOwnMetadataKeys(target, propertyKey) {
       if (!IsObject(target)) throw new TypeError;
       return IsUndefined(propertyKey) || (propertyKey = ToPropertyKey(propertyKey)), OrdinaryOwnMetadataKeys(target, propertyKey);
      }
      function deleteMetadata(metadataKey, target, propertyKey) {
       if (!IsObject(target)) throw new TypeError;
       if (IsUndefined(propertyKey) || (propertyKey = ToPropertyKey(propertyKey)), !IsObject(target)) throw new TypeError;
       IsUndefined(propertyKey) || (propertyKey = ToPropertyKey(propertyKey));
       var provider = GetMetadataProvider(target, propertyKey, !1);
       return !IsUndefined(provider) && provider.OrdinaryDeleteMetadata(metadataKey, target, propertyKey);
      }
      function DecorateConstructor(decorators, target) {
       for (var i = decorators.length - 1; i >= 0; --i) {
        var decorated = (0, decorators[i])(target);
        if (!IsUndefined(decorated) && !IsNull(decorated)) {
         if (!IsConstructor(decorated)) throw new TypeError;
         target = decorated;
        }
       }
       return target;
      }
      function DecorateProperty(decorators, target, propertyKey, descriptor) {
       for (var i = decorators.length - 1; i >= 0; --i) {
        var decorated = (0, decorators[i])(target, propertyKey, descriptor);
        if (!IsUndefined(decorated) && !IsNull(decorated)) {
         if (!IsObject(decorated)) throw new TypeError;
         descriptor = decorated;
        }
       }
       return descriptor;
      }
      function OrdinaryHasMetadata(MetadataKey, O, P) {
       if (OrdinaryHasOwnMetadata(MetadataKey, O, P)) return !0;
       var parent = OrdinaryGetPrototypeOf(O);
       return !IsNull(parent) && OrdinaryHasMetadata(MetadataKey, parent, P);
      }
      function OrdinaryHasOwnMetadata(MetadataKey, O, P) {
       var provider = GetMetadataProvider(O, P, !1);
       return !IsUndefined(provider) && ToBoolean(provider.OrdinaryHasOwnMetadata(MetadataKey, O, P));
      }
      function OrdinaryGetMetadata(MetadataKey, O, P) {
       if (OrdinaryHasOwnMetadata(MetadataKey, O, P)) return OrdinaryGetOwnMetadata(MetadataKey, O, P);
       var parent = OrdinaryGetPrototypeOf(O);
       return IsNull(parent) ? void 0 : OrdinaryGetMetadata(MetadataKey, parent, P);
      }
      function OrdinaryGetOwnMetadata(MetadataKey, O, P) {
       var provider = GetMetadataProvider(O, P, !1);
       if (!IsUndefined(provider)) return provider.OrdinaryGetOwnMetadata(MetadataKey, O, P);
      }
      function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
       GetMetadataProvider(O, P, !0).OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P);
      }
      function OrdinaryMetadataKeys(O, P) {
       var ownKeys = OrdinaryOwnMetadataKeys(O, P), parent = OrdinaryGetPrototypeOf(O);
       if (null === parent) return ownKeys;
       var parentKeys = OrdinaryMetadataKeys(parent, P);
       if (parentKeys.length <= 0) return ownKeys;
       if (ownKeys.length <= 0) return parentKeys;
       for (var set = new _Set, keys = [], _i = 0, ownKeys_1 = ownKeys; _i < ownKeys_1.length; _i++) {
        var key = ownKeys_1[_i];
        set.has(key) || (set.add(key), keys.push(key));
       }
       for (var _a = 0, parentKeys_1 = parentKeys; _a < parentKeys_1.length; _a++) {
        key = parentKeys_1[_a];
        set.has(key) || (set.add(key), keys.push(key));
       }
       return keys;
      }
      function OrdinaryOwnMetadataKeys(O, P) {
       var provider = GetMetadataProvider(O, P, !1);
       return provider ? provider.OrdinaryOwnMetadataKeys(O, P) : [];
      }
      function Type(x) {
       if (null === x) return 1;
       switch (typeof x) {
       case "undefined":
        return 0;

       case "boolean":
        return 2;

       case "string":
        return 3;

       case "symbol":
        return 4;

       case "number":
        return 5;

       case "object":
        return null === x ? 1 : 6;

       default:
        return 6;
       }
      }
      function IsUndefined(x) {
       return void 0 === x;
      }
      function IsNull(x) {
       return null === x;
      }
      function IsSymbol(x) {
       return "symbol" == typeof x;
      }
      function IsObject(x) {
       return "object" == typeof x ? null !== x : "function" == typeof x;
      }
      function ToPrimitive(input, PreferredType) {
       switch (Type(input)) {
       case 0:
       case 1:
       case 2:
       case 3:
       case 4:
       case 5:
        return input;
       }
       var hint = 3 === PreferredType ? "string" : 5 === PreferredType ? "number" : "default", exoticToPrim = GetMethod(input, toPrimitiveSymbol);
       if (void 0 !== exoticToPrim) {
        var result = exoticToPrim.call(input, hint);
        if (IsObject(result)) throw new TypeError;
        return result;
       }
       return OrdinaryToPrimitive(input, "default" === hint ? "number" : hint);
      }
      function OrdinaryToPrimitive(O, hint) {
       if ("string" === hint) {
        var toString_1 = O.toString;
        if (IsCallable(toString_1)) if (!IsObject(result = toString_1.call(O))) return result;
        if (IsCallable(valueOf = O.valueOf)) if (!IsObject(result = valueOf.call(O))) return result;
       } else {
        var valueOf;
        if (IsCallable(valueOf = O.valueOf)) if (!IsObject(result = valueOf.call(O))) return result;
        var result, toString_2 = O.toString;
        if (IsCallable(toString_2)) if (!IsObject(result = toString_2.call(O))) return result;
       }
       throw new TypeError;
      }
      function ToBoolean(argument) {
       return !!argument;
      }
      function ToString(argument) {
       return "" + argument;
      }
      function ToPropertyKey(argument) {
       var key = ToPrimitive(argument, 3);
       return IsSymbol(key) ? key : ToString(key);
      }
      function IsArray(argument) {
       return Array.isArray ? Array.isArray(argument) : argument instanceof Object ? argument instanceof Array : "[object Array]" === Object.prototype.toString.call(argument);
      }
      function IsCallable(argument) {
       return "function" == typeof argument;
      }
      function IsConstructor(argument) {
       return "function" == typeof argument;
      }
      function IsPropertyKey(argument) {
       switch (Type(argument)) {
       case 3:
       case 4:
        return !0;

       default:
        return !1;
       }
      }
      function SameValueZero(x, y) {
       return x === y || x != x && y != y;
      }
      function GetMethod(V, P) {
       var func = V[P];
       if (null != func) {
        if (!IsCallable(func)) throw new TypeError;
        return func;
       }
      }
      function GetIterator(obj) {
       var method = GetMethod(obj, iteratorSymbol);
       if (!IsCallable(method)) throw new TypeError;
       var iterator = method.call(obj);
       if (!IsObject(iterator)) throw new TypeError;
       return iterator;
      }
      function IteratorValue(iterResult) {
       return iterResult.value;
      }
      function IteratorStep(iterator) {
       var result = iterator.next();
       return !result.done && result;
      }
      function IteratorClose(iterator) {
       var f = iterator.return;
       f && f.call(iterator);
      }
      function OrdinaryGetPrototypeOf(O) {
       var proto = Object.getPrototypeOf(O);
       if ("function" != typeof O || O === functionPrototype) return proto;
       if (proto !== functionPrototype) return proto;
       var prototype = O.prototype, prototypeProto = prototype && Object.getPrototypeOf(prototype);
       if (null == prototypeProto || prototypeProto === Object.prototype) return proto;
       var constructor = prototypeProto.constructor;
       return "function" != typeof constructor || constructor === O ? proto : constructor;
      }
      function CreateMetadataRegistry() {
       var fallback, first, second, rest;
       IsUndefined(registrySymbol) || void 0 === root.Reflect || registrySymbol in root.Reflect || "function" != typeof root.Reflect.defineMetadata || (fallback = CreateFallbackProvider(root.Reflect));
       var targetProviderMap = new _WeakMap, registry = {
        registerProvider,
        getProvider,
        setProvider
       };
       return registry;
       function registerProvider(provider) {
        if (!Object.isExtensible(registry)) throw new Error("Cannot add provider to a frozen registry.");
        switch (!0) {
        case fallback === provider:
         break;

        case IsUndefined(first):
         first = provider;
         break;

        case first === provider:
         break;

        case IsUndefined(second):
         second = provider;
         break;

        case second === provider:
         break;

        default:
         void 0 === rest && (rest = new _Set), rest.add(provider);
        }
       }
       function getProviderNoCache(O, P) {
        if (!IsUndefined(first)) {
         if (first.isProviderFor(O, P)) return first;
         if (!IsUndefined(second)) {
          if (second.isProviderFor(O, P)) return first;
          if (!IsUndefined(rest)) for (var iterator = GetIterator(rest); ;) {
           var next = IteratorStep(iterator);
           if (!next) return;
           var provider = IteratorValue(next);
           if (provider.isProviderFor(O, P)) return IteratorClose(iterator), provider;
          }
         }
        }
        if (!IsUndefined(fallback) && fallback.isProviderFor(O, P)) return fallback;
       }
       function getProvider(O, P) {
        var provider, providerMap = targetProviderMap.get(O);
        return IsUndefined(providerMap) || (provider = providerMap.get(P)), IsUndefined(provider) ? (IsUndefined(provider = getProviderNoCache(O, P)) || (IsUndefined(providerMap) && (providerMap = new _Map, 
        targetProviderMap.set(O, providerMap)), providerMap.set(P, provider)), provider) : provider;
       }
       function hasProvider(provider) {
        if (IsUndefined(provider)) throw new TypeError;
        return first === provider || second === provider || !IsUndefined(rest) && rest.has(provider);
       }
       function setProvider(O, P, provider) {
        if (!hasProvider(provider)) throw new Error("Metadata provider not registered.");
        var existingProvider = getProvider(O, P);
        if (existingProvider !== provider) {
         if (!IsUndefined(existingProvider)) return !1;
         var providerMap = targetProviderMap.get(O);
         IsUndefined(providerMap) && (providerMap = new _Map, targetProviderMap.set(O, providerMap)), 
         providerMap.set(P, provider);
        }
        return !0;
       }
      }
      function GetOrCreateMetadataRegistry() {
       var metadataRegistry;
       return !IsUndefined(registrySymbol) && IsObject(root.Reflect) && Object.isExtensible(root.Reflect) && (metadataRegistry = root.Reflect[registrySymbol]), 
       IsUndefined(metadataRegistry) && (metadataRegistry = CreateMetadataRegistry()), 
       !IsUndefined(registrySymbol) && IsObject(root.Reflect) && Object.isExtensible(root.Reflect) && Object.defineProperty(root.Reflect, registrySymbol, {
        enumerable: !1,
        configurable: !1,
        writable: !1,
        value: metadataRegistry
       }), metadataRegistry;
      }
      function CreateMetadataProvider(registry) {
       var metadata = new _WeakMap, provider = {
        isProviderFor: function(O, P) {
         var targetMetadata = metadata.get(O);
         return !IsUndefined(targetMetadata) && targetMetadata.has(P);
        },
        OrdinaryDefineOwnMetadata,
        OrdinaryHasOwnMetadata,
        OrdinaryGetOwnMetadata,
        OrdinaryOwnMetadataKeys,
        OrdinaryDeleteMetadata
       };
       return metadataRegistry.registerProvider(provider), provider;
       function GetOrCreateMetadataMap(O, P, Create) {
        var targetMetadata = metadata.get(O), createdTargetMetadata = !1;
        if (IsUndefined(targetMetadata)) {
         if (!Create) return;
         targetMetadata = new _Map, metadata.set(O, targetMetadata), createdTargetMetadata = !0;
        }
        var metadataMap = targetMetadata.get(P);
        if (IsUndefined(metadataMap)) {
         if (!Create) return;
         if (metadataMap = new _Map, targetMetadata.set(P, metadataMap), !registry.setProvider(O, P, provider)) throw targetMetadata.delete(P), 
         createdTargetMetadata && metadata.delete(O), new Error("Wrong provider for target.");
        }
        return metadataMap;
       }
       function OrdinaryHasOwnMetadata(MetadataKey, O, P) {
        var metadataMap = GetOrCreateMetadataMap(O, P, !1);
        return !IsUndefined(metadataMap) && ToBoolean(metadataMap.has(MetadataKey));
       }
       function OrdinaryGetOwnMetadata(MetadataKey, O, P) {
        var metadataMap = GetOrCreateMetadataMap(O, P, !1);
        if (!IsUndefined(metadataMap)) return metadataMap.get(MetadataKey);
       }
       function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
        GetOrCreateMetadataMap(O, P, !0).set(MetadataKey, MetadataValue);
       }
       function OrdinaryOwnMetadataKeys(O, P) {
        var keys = [], metadataMap = GetOrCreateMetadataMap(O, P, !1);
        if (IsUndefined(metadataMap)) return keys;
        for (var iterator = GetIterator(metadataMap.keys()), k = 0; ;) {
         var next = IteratorStep(iterator);
         if (!next) return keys.length = k, keys;
         var nextValue = IteratorValue(next);
         try {
          keys[k] = nextValue;
         } catch (e) {
          try {
           IteratorClose(iterator);
          } finally {
           throw e;
          }
         }
         k++;
        }
       }
       function OrdinaryDeleteMetadata(MetadataKey, O, P) {
        var metadataMap = GetOrCreateMetadataMap(O, P, !1);
        if (IsUndefined(metadataMap)) return !1;
        if (!metadataMap.delete(MetadataKey)) return !1;
        if (0 === metadataMap.size) {
         var targetMetadata = metadata.get(O);
         IsUndefined(targetMetadata) || (targetMetadata.delete(P), 0 === targetMetadata.size && metadata.delete(targetMetadata));
        }
        return !0;
       }
      }
      function CreateFallbackProvider(reflect) {
       var defineMetadata = reflect.defineMetadata, hasOwnMetadata = reflect.hasOwnMetadata, getOwnMetadata = reflect.getOwnMetadata, getOwnMetadataKeys = reflect.getOwnMetadataKeys, deleteMetadata = reflect.deleteMetadata, metadataOwner = new _WeakMap;
       return {
        isProviderFor: function(O, P) {
         var metadataPropertySet = metadataOwner.get(O);
         return !(IsUndefined(metadataPropertySet) || !metadataPropertySet.has(P)) || !!getOwnMetadataKeys(O, P).length && (IsUndefined(metadataPropertySet) && (metadataPropertySet = new _Set, 
         metadataOwner.set(O, metadataPropertySet)), metadataPropertySet.add(P), !0);
        },
        OrdinaryDefineOwnMetadata: defineMetadata,
        OrdinaryHasOwnMetadata: hasOwnMetadata,
        OrdinaryGetOwnMetadata: getOwnMetadata,
        OrdinaryOwnMetadataKeys: getOwnMetadataKeys,
        OrdinaryDeleteMetadata: deleteMetadata
       };
      }
      function GetMetadataProvider(O, P, Create) {
       var registeredProvider = metadataRegistry.getProvider(O, P);
       if (!IsUndefined(registeredProvider)) return registeredProvider;
       if (Create) {
        if (metadataRegistry.setProvider(O, P, metadataProvider)) return metadataProvider;
        throw new Error("Illegal state.");
       }
      }
      function CreateMapPolyfill() {
       var cacheSentinel = {}, arraySentinel = [], MapIterator = function() {
        function MapIterator(keys, values, selector) {
         this._index = 0, this._keys = keys, this._values = values, this._selector = selector;
        }
        return MapIterator.prototype["@@iterator"] = function() {
         return this;
        }, MapIterator.prototype[iteratorSymbol] = function() {
         return this;
        }, MapIterator.prototype.next = function() {
         var index = this._index;
         if (index >= 0 && index < this._keys.length) {
          var result = this._selector(this._keys[index], this._values[index]);
          return index + 1 >= this._keys.length ? (this._index = -1, this._keys = arraySentinel, 
          this._values = arraySentinel) : this._index++, {
           value: result,
           done: !1
          };
         }
         return {
          value: void 0,
          done: !0
         };
        }, MapIterator.prototype.throw = function(error) {
         throw this._index >= 0 && (this._index = -1, this._keys = arraySentinel, this._values = arraySentinel), 
         error;
        }, MapIterator.prototype.return = function(value) {
         return this._index >= 0 && (this._index = -1, this._keys = arraySentinel, this._values = arraySentinel), 
         {
          value,
          done: !0
         };
        }, MapIterator;
       }();
       return function() {
        function Map() {
         this._keys = [], this._values = [], this._cacheKey = cacheSentinel, this._cacheIndex = -2;
        }
        return Object.defineProperty(Map.prototype, "size", {
         get: function() {
          return this._keys.length;
         },
         enumerable: !0,
         configurable: !0
        }), Map.prototype.has = function(key) {
         return this._find(key, !1) >= 0;
        }, Map.prototype.get = function(key) {
         var index = this._find(key, !1);
         return index >= 0 ? this._values[index] : void 0;
        }, Map.prototype.set = function(key, value) {
         var index = this._find(key, !0);
         return this._values[index] = value, this;
        }, Map.prototype.delete = function(key) {
         var index = this._find(key, !1);
         if (index >= 0) {
          for (var size = this._keys.length, i = index + 1; i < size; i++) this._keys[i - 1] = this._keys[i], 
          this._values[i - 1] = this._values[i];
          return this._keys.length--, this._values.length--, SameValueZero(key, this._cacheKey) && (this._cacheKey = cacheSentinel, 
          this._cacheIndex = -2), !0;
         }
         return !1;
        }, Map.prototype.clear = function() {
         this._keys.length = 0, this._values.length = 0, this._cacheKey = cacheSentinel, 
         this._cacheIndex = -2;
        }, Map.prototype.keys = function() {
         return new MapIterator(this._keys, this._values, getKey);
        }, Map.prototype.values = function() {
         return new MapIterator(this._keys, this._values, getValue);
        }, Map.prototype.entries = function() {
         return new MapIterator(this._keys, this._values, getEntry);
        }, Map.prototype["@@iterator"] = function() {
         return this.entries();
        }, Map.prototype[iteratorSymbol] = function() {
         return this.entries();
        }, Map.prototype._find = function(key, insert) {
         if (!SameValueZero(this._cacheKey, key)) {
          this._cacheIndex = -1;
          for (var i = 0; i < this._keys.length; i++) if (SameValueZero(this._keys[i], key)) {
           this._cacheIndex = i;
           break;
          }
         }
         return this._cacheIndex < 0 && insert && (this._cacheIndex = this._keys.length, 
         this._keys.push(key), this._values.push(void 0)), this._cacheIndex;
        }, Map;
       }();
       function getKey(key, _) {
        return key;
       }
       function getValue(_, value) {
        return value;
       }
       function getEntry(key, value) {
        return [ key, value ];
       }
      }
      function CreateSetPolyfill() {
       return function() {
        function Set() {
         this._map = new _Map;
        }
        return Object.defineProperty(Set.prototype, "size", {
         get: function() {
          return this._map.size;
         },
         enumerable: !0,
         configurable: !0
        }), Set.prototype.has = function(value) {
         return this._map.has(value);
        }, Set.prototype.add = function(value) {
         return this._map.set(value, value), this;
        }, Set.prototype.delete = function(value) {
         return this._map.delete(value);
        }, Set.prototype.clear = function() {
         this._map.clear();
        }, Set.prototype.keys = function() {
         return this._map.keys();
        }, Set.prototype.values = function() {
         return this._map.keys();
        }, Set.prototype.entries = function() {
         return this._map.entries();
        }, Set.prototype["@@iterator"] = function() {
         return this.keys();
        }, Set.prototype[iteratorSymbol] = function() {
         return this.keys();
        }, Set;
       }();
      }
      function CreateWeakMapPolyfill() {
       var UUID_SIZE = 16, keys = HashMap.create(), rootKey = CreateUniqueKey();
       return function() {
        function WeakMap() {
         this._key = CreateUniqueKey();
        }
        return WeakMap.prototype.has = function(target) {
         var table = GetOrCreateWeakMapTable(target, !1);
         return void 0 !== table && HashMap.has(table, this._key);
        }, WeakMap.prototype.get = function(target) {
         var table = GetOrCreateWeakMapTable(target, !1);
         return void 0 !== table ? HashMap.get(table, this._key) : void 0;
        }, WeakMap.prototype.set = function(target, value) {
         return GetOrCreateWeakMapTable(target, !0)[this._key] = value, this;
        }, WeakMap.prototype.delete = function(target) {
         var table = GetOrCreateWeakMapTable(target, !1);
         return void 0 !== table && delete table[this._key];
        }, WeakMap.prototype.clear = function() {
         this._key = CreateUniqueKey();
        }, WeakMap;
       }();
       function CreateUniqueKey() {
        var key;
        do {
         key = "@@WeakMap@@" + CreateUUID();
        } while (HashMap.has(keys, key));
        return keys[key] = !0, key;
       }
       function GetOrCreateWeakMapTable(target, create) {
        if (!hasOwn.call(target, rootKey)) {
         if (!create) return;
         Object.defineProperty(target, rootKey, {
          value: HashMap.create()
         });
        }
        return target[rootKey];
       }
       function FillRandomBytes(buffer, size) {
        for (var i = 0; i < size; ++i) buffer[i] = 255 * Math.random() | 0;
        return buffer;
       }
       function GenRandomBytes(size) {
        if ("function" == typeof Uint8Array) {
         var array = new Uint8Array(size);
         return "undefined" != typeof crypto ? crypto.getRandomValues(array) : "undefined" != typeof msCrypto ? msCrypto.getRandomValues(array) : FillRandomBytes(array, size), 
         array;
        }
        return FillRandomBytes(new Array(size), size);
       }
       function CreateUUID() {
        var data = GenRandomBytes(UUID_SIZE);
        data[6] = 79 & data[6] | 64, data[8] = 191 & data[8] | 128;
        for (var result = "", offset = 0; offset < UUID_SIZE; ++offset) {
         var byte = data[offset];
         4 !== offset && 6 !== offset && 8 !== offset || (result += "-"), byte < 16 && (result += "0"), 
         result += byte.toString(16).toLowerCase();
        }
        return result;
       }
      }
      function MakeDictionary(obj) {
       return obj.__ = void 0, delete obj.__, obj;
      }
      exporter("decorate", decorate), exporter("metadata", metadata), exporter("defineMetadata", defineMetadata), 
      exporter("hasMetadata", hasMetadata), exporter("hasOwnMetadata", hasOwnMetadata), 
      exporter("getMetadata", getMetadata), exporter("getOwnMetadata", getOwnMetadata), 
      exporter("getMetadataKeys", getMetadataKeys), exporter("getOwnMetadataKeys", getOwnMetadataKeys), 
      exporter("deleteMetadata", deleteMetadata);
     }(exporter, root), void 0 === root.Reflect && (root.Reflect = Reflect);
    }();
   }(Reflect || (Reflect = {}));
  },
  50018: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var identity = __webpack_require__(70484), Scalar = __webpack_require__(89714), YAMLMap = __webpack_require__(81755), YAMLSeq = __webpack_require__(36010), resolveBlockMap = __webpack_require__(57434), resolveBlockSeq = __webpack_require__(10483), resolveFlowCollection = __webpack_require__(2291);
   function resolveCollection(CN, ctx, token, onError, tagName, tag) {
    const coll = "block-map" === token.type ? resolveBlockMap.resolveBlockMap(CN, ctx, token, onError, tag) : "block-seq" === token.type ? resolveBlockSeq.resolveBlockSeq(CN, ctx, token, onError, tag) : resolveFlowCollection.resolveFlowCollection(CN, ctx, token, onError, tag), Coll = coll.constructor;
    return "!" === tagName || tagName === Coll.tagName ? (coll.tag = Coll.tagName, coll) : (tagName && (coll.tag = tagName), 
    coll);
   }
   exports.composeCollection = function(CN, ctx, token, props, onError) {
    const tagToken = props.tag, tagName = tagToken ? ctx.directives.tagName(tagToken.source, (msg => onError(tagToken, "TAG_RESOLVE_FAILED", msg))) : null;
    if ("block-seq" === token.type) {
     const {anchor, newlineAfterProp: nl} = props, lastProp = anchor && tagToken ? anchor.offset > tagToken.offset ? anchor : tagToken : anchor ?? tagToken;
     if (lastProp && (!nl || nl.offset < lastProp.offset)) {
      onError(lastProp, "MISSING_CHAR", "Missing newline after block sequence props");
     }
    }
    const expType = "block-map" === token.type ? "map" : "block-seq" === token.type ? "seq" : "{" === token.start.source ? "map" : "seq";
    if (!tagToken || !tagName || "!" === tagName || tagName === YAMLMap.YAMLMap.tagName && "map" === expType || tagName === YAMLSeq.YAMLSeq.tagName && "seq" === expType) return resolveCollection(CN, ctx, token, onError, tagName);
    let tag = ctx.schema.tags.find((t => t.tag === tagName && t.collection === expType));
    if (!tag) {
     const kt = ctx.schema.knownTags[tagName];
     if (!kt || kt.collection !== expType) return kt?.collection ? onError(tagToken, "BAD_COLLECTION_TYPE", `${kt.tag} used for ${expType} collection, but expects ${kt.collection}`, !0) : onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, !0), 
     resolveCollection(CN, ctx, token, onError, tagName);
     ctx.schema.tags.push(Object.assign({}, kt, {
      default: !1
     })), tag = kt;
    }
    const coll = resolveCollection(CN, ctx, token, onError, tagName, tag), res = tag.resolve?.(coll, (msg => onError(tagToken, "TAG_RESOLVE_FAILED", msg)), ctx.options) ?? coll, node = identity.isNode(res) ? res : new Scalar.Scalar(res);
    return node.range = coll.range, node.tag = tagName, tag?.format && (node.format = tag.format), 
    node;
   };
  },
  52206: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var Document = __webpack_require__(9046), composeNode = __webpack_require__(12782), resolveEnd = __webpack_require__(56845), resolveProps = __webpack_require__(11386);
   exports.composeDoc = function(options, directives, {offset, start, value, end}, onError) {
    const opts = Object.assign({
     _directives: directives
    }, options), doc = new Document.Document(void 0, opts), ctx = {
     atRoot: !0,
     directives: doc.directives,
     options: doc.options,
     schema: doc.schema
    }, props = resolveProps.resolveProps(start, {
     indicator: "doc-start",
     next: value ?? end?.[0],
     offset,
     onError,
     parentIndent: 0,
     startOnNewline: !0
    });
    props.found && (doc.directives.docStart = !0, !value || "block-map" !== value.type && "block-seq" !== value.type || props.hasNewline || onError(props.end, "MISSING_CHAR", "Block collection cannot start on same line with directives-end marker")), 
    doc.contents = value ? composeNode.composeNode(ctx, value, props, onError) : composeNode.composeEmptyNode(ctx, props.end, start, null, props, onError);
    const contentEnd = doc.contents.range[2], re = resolveEnd.resolveEnd(end, contentEnd, !1, onError);
    return re.comment && (doc.comment = re.comment), doc.range = [ offset, contentEnd, re.offset ], 
    doc;
   };
  },
  12782: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var Alias = __webpack_require__(41736), composeCollection = __webpack_require__(50018), composeScalar = __webpack_require__(29094), resolveEnd = __webpack_require__(56845), utilEmptyScalarPosition = __webpack_require__(71040);
   const CN = {
    composeNode,
    composeEmptyNode
   };
   function composeNode(ctx, token, props, onError) {
    const {spaceBefore, comment, anchor, tag} = props;
    let node, isSrcToken = !0;
    switch (token.type) {
    case "alias":
     node = function({options}, {offset, source, end}, onError) {
      const alias = new Alias.Alias(source.substring(1));
      "" === alias.source && onError(offset, "BAD_ALIAS", "Alias cannot be an empty string");
      alias.source.endsWith(":") && onError(offset + source.length - 1, "BAD_ALIAS", "Alias ending in : is ambiguous", !0);
      const valueEnd = offset + source.length, re = resolveEnd.resolveEnd(end, valueEnd, options.strict, onError);
      alias.range = [ offset, valueEnd, re.offset ], re.comment && (alias.comment = re.comment);
      return alias;
     }(ctx, token, onError), (anchor || tag) && onError(token, "ALIAS_PROPS", "An alias node must not specify any properties");
     break;

    case "scalar":
    case "single-quoted-scalar":
    case "double-quoted-scalar":
    case "block-scalar":
     node = composeScalar.composeScalar(ctx, token, tag, onError), anchor && (node.anchor = anchor.source.substring(1));
     break;

    case "block-map":
    case "block-seq":
    case "flow-collection":
     node = composeCollection.composeCollection(CN, ctx, token, props, onError), anchor && (node.anchor = anchor.source.substring(1));
     break;

    default:
     onError(token, "UNEXPECTED_TOKEN", "error" === token.type ? token.message : `Unsupported token (type: ${token.type})`), 
     node = composeEmptyNode(ctx, token.offset, void 0, null, props, onError), isSrcToken = !1;
    }
    return anchor && "" === node.anchor && onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string"), 
    spaceBefore && (node.spaceBefore = !0), comment && ("scalar" === token.type && "" === token.source ? node.comment = comment : node.commentBefore = comment), 
    ctx.options.keepSourceTokens && isSrcToken && (node.srcToken = token), node;
   }
   function composeEmptyNode(ctx, offset, before, pos, {spaceBefore, comment, anchor, tag, end}, onError) {
    const token = {
     type: "scalar",
     offset: utilEmptyScalarPosition.emptyScalarPosition(offset, before, pos),
     indent: -1,
     source: ""
    }, node = composeScalar.composeScalar(ctx, token, tag, onError);
    return anchor && (node.anchor = anchor.source.substring(1), "" === node.anchor && onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string")), 
    spaceBefore && (node.spaceBefore = !0), comment && (node.comment = comment, node.range[2] = end), 
    node;
   }
   exports.composeEmptyNode = composeEmptyNode, exports.composeNode = composeNode;
  },
  29094: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var identity = __webpack_require__(70484), Scalar = __webpack_require__(89714), resolveBlockScalar = __webpack_require__(94070), resolveFlowScalar = __webpack_require__(27571);
   exports.composeScalar = function(ctx, token, tagToken, onError) {
    const {value, type, comment, range} = "block-scalar" === token.type ? resolveBlockScalar.resolveBlockScalar(ctx, token, onError) : resolveFlowScalar.resolveFlowScalar(token, ctx.options.strict, onError), tagName = tagToken ? ctx.directives.tagName(tagToken.source, (msg => onError(tagToken, "TAG_RESOLVE_FAILED", msg))) : null, tag = tagToken && tagName ? function(schema, value, tagName, tagToken, onError) {
     if ("!" === tagName) return schema[identity.SCALAR];
     const matchWithTest = [];
     for (const tag of schema.tags) if (!tag.collection && tag.tag === tagName) {
      if (!tag.default || !tag.test) return tag;
      matchWithTest.push(tag);
     }
     for (const tag of matchWithTest) if (tag.test?.test(value)) return tag;
     const kt = schema.knownTags[tagName];
     if (kt && !kt.collection) return schema.tags.push(Object.assign({}, kt, {
      default: !1,
      test: void 0
     })), kt;
     return onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, "tag:yaml.org,2002:str" !== tagName), 
     schema[identity.SCALAR];
    }(ctx.schema, value, tagName, tagToken, onError) : "scalar" === token.type ? function({directives, schema}, value, token, onError) {
     const tag = schema.tags.find((tag => tag.default && tag.test?.test(value))) || schema[identity.SCALAR];
     if (schema.compat) {
      const compat = schema.compat.find((tag => tag.default && tag.test?.test(value))) ?? schema[identity.SCALAR];
      if (tag.tag !== compat.tag) {
       onError(token, "TAG_RESOLVE_FAILED", `Value may be parsed as either ${directives.tagString(tag.tag)} or ${directives.tagString(compat.tag)}`, !0);
      }
     }
     return tag;
    }(ctx, value, token, onError) : ctx.schema[identity.SCALAR];
    let scalar;
    try {
     const res = tag.resolve(value, (msg => onError(tagToken ?? token, "TAG_RESOLVE_FAILED", msg)), ctx.options);
     scalar = identity.isScalar(res) ? res : new Scalar.Scalar(res);
    } catch (error) {
     const msg = error instanceof Error ? error.message : String(error);
     onError(tagToken ?? token, "TAG_RESOLVE_FAILED", msg), scalar = new Scalar.Scalar(value);
    }
    return scalar.range = range, scalar.source = value, type && (scalar.type = type), 
    tagName && (scalar.tag = tagName), tag.format && (scalar.format = tag.format), comment && (scalar.comment = comment), 
    scalar;
   };
  },
  24927: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var directives = __webpack_require__(38673), Document = __webpack_require__(9046), errors = __webpack_require__(44355), identity = __webpack_require__(70484), composeDoc = __webpack_require__(52206), resolveEnd = __webpack_require__(56845);
   function getErrorPos(src) {
    if ("number" == typeof src) return [ src, src + 1 ];
    if (Array.isArray(src)) return 2 === src.length ? src : [ src[0], src[1] ];
    const {offset, source} = src;
    return [ offset, offset + ("string" == typeof source ? source.length : 1) ];
   }
   function parsePrelude(prelude) {
    let comment = "", atComment = !1, afterEmptyLine = !1;
    for (let i = 0; i < prelude.length; ++i) {
     const source = prelude[i];
     switch (source[0]) {
     case "#":
      comment += ("" === comment ? "" : afterEmptyLine ? "\n\n" : "\n") + (source.substring(1) || " "), 
      atComment = !0, afterEmptyLine = !1;
      break;

     case "%":
      "#" !== prelude[i + 1]?.[0] && (i += 1), atComment = !1;
      break;

     default:
      atComment || (afterEmptyLine = !0), atComment = !1;
     }
    }
    return {
     comment,
     afterEmptyLine
    };
   }
   exports.Composer = class {
    constructor(options = {}) {
     this.doc = null, this.atDirectives = !1, this.prelude = [], this.errors = [], this.warnings = [], 
     this.onError = (source, code, message, warning) => {
      const pos = getErrorPos(source);
      warning ? this.warnings.push(new errors.YAMLWarning(pos, code, message)) : this.errors.push(new errors.YAMLParseError(pos, code, message));
     }, this.directives = new directives.Directives({
      version: options.version || "1.2"
     }), this.options = options;
    }
    decorate(doc, afterDoc) {
     const {comment, afterEmptyLine} = parsePrelude(this.prelude);
     if (comment) {
      const dc = doc.contents;
      if (afterDoc) doc.comment = doc.comment ? `${doc.comment}\n${comment}` : comment; else if (afterEmptyLine || doc.directives.docStart || !dc) doc.commentBefore = comment; else if (identity.isCollection(dc) && !dc.flow && dc.items.length > 0) {
       let it = dc.items[0];
       identity.isPair(it) && (it = it.key);
       const cb = it.commentBefore;
       it.commentBefore = cb ? `${comment}\n${cb}` : comment;
      } else {
       const cb = dc.commentBefore;
       dc.commentBefore = cb ? `${comment}\n${cb}` : comment;
      }
     }
     afterDoc ? (Array.prototype.push.apply(doc.errors, this.errors), Array.prototype.push.apply(doc.warnings, this.warnings)) : (doc.errors = this.errors, 
     doc.warnings = this.warnings), this.prelude = [], this.errors = [], this.warnings = [];
    }
    streamInfo() {
     return {
      comment: parsePrelude(this.prelude).comment,
      directives: this.directives,
      errors: this.errors,
      warnings: this.warnings
     };
    }
    * compose(tokens, forceDoc = !1, endOffset = -1) {
     for (const token of tokens) yield* this.next(token);
     yield* this.end(forceDoc, endOffset);
    }
    * next(token) {
     switch (process.env.LOG_STREAM && console.dir(token, {
      depth: null
     }), token.type) {
     case "directive":
      this.directives.add(token.source, ((offset, message, warning) => {
       const pos = getErrorPos(token);
       pos[0] += offset, this.onError(pos, "BAD_DIRECTIVE", message, warning);
      })), this.prelude.push(token.source), this.atDirectives = !0;
      break;

     case "document":
      {
       const doc = composeDoc.composeDoc(this.options, this.directives, token, this.onError);
       this.atDirectives && !doc.directives.docStart && this.onError(token, "MISSING_CHAR", "Missing directives-end/doc-start indicator line"), 
       this.decorate(doc, !1), this.doc && (yield this.doc), this.doc = doc, this.atDirectives = !1;
       break;
      }

     case "byte-order-mark":
     case "space":
      break;

     case "comment":
     case "newline":
      this.prelude.push(token.source);
      break;

     case "error":
      {
       const msg = token.source ? `${token.message}: ${JSON.stringify(token.source)}` : token.message, error = new errors.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg);
       this.atDirectives || !this.doc ? this.errors.push(error) : this.doc.errors.push(error);
       break;
      }

     case "doc-end":
      {
       if (!this.doc) {
        const msg = "Unexpected doc-end without preceding document";
        this.errors.push(new errors.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg));
        break;
       }
       this.doc.directives.docEnd = !0;
       const end = resolveEnd.resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);
       if (this.decorate(this.doc, !0), end.comment) {
        const dc = this.doc.comment;
        this.doc.comment = dc ? `${dc}\n${end.comment}` : end.comment;
       }
       this.doc.range[2] = end.offset;
       break;
      }

     default:
      this.errors.push(new errors.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", `Unsupported token ${token.type}`));
     }
    }
    * end(forceDoc = !1, endOffset = -1) {
     if (this.doc) this.decorate(this.doc, !0), yield this.doc, this.doc = null; else if (forceDoc) {
      const opts = Object.assign({
       _directives: this.directives
      }, this.options), doc = new Document.Document(void 0, opts);
      this.atDirectives && this.onError(endOffset, "MISSING_CHAR", "Missing directives-end indicator line"), 
      doc.range = [ 0, endOffset, endOffset ], this.decorate(doc, !1), yield doc;
     }
    }
   };
  },
  57434: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var Pair = __webpack_require__(27902), YAMLMap = __webpack_require__(81755), resolveProps = __webpack_require__(11386), utilContainsNewline = __webpack_require__(9378), utilFlowIndentCheck = __webpack_require__(68644), utilMapIncludes = __webpack_require__(48334);
   const startColMsg = "All mapping items must start at the same column";
   exports.resolveBlockMap = function({composeNode, composeEmptyNode}, ctx, bm, onError, tag) {
    const map = new (tag?.nodeClass ?? YAMLMap.YAMLMap)(ctx.schema);
    ctx.atRoot && (ctx.atRoot = !1);
    let offset = bm.offset, commentEnd = null;
    for (const collItem of bm.items) {
     const {start, key, sep, value} = collItem, keyProps = resolveProps.resolveProps(start, {
      indicator: "explicit-key-ind",
      next: key ?? sep?.[0],
      offset,
      onError,
      parentIndent: bm.indent,
      startOnNewline: !0
     }), implicitKey = !keyProps.found;
     if (implicitKey) {
      if (key && ("block-seq" === key.type ? onError(offset, "BLOCK_AS_IMPLICIT_KEY", "A block sequence may not be used as an implicit map key") : "indent" in key && key.indent !== bm.indent && onError(offset, "BAD_INDENT", startColMsg)), 
      !keyProps.anchor && !keyProps.tag && !sep) {
       commentEnd = keyProps.end, keyProps.comment && (map.comment ? map.comment += "\n" + keyProps.comment : map.comment = keyProps.comment);
       continue;
      }
      (keyProps.newlineAfterProp || utilContainsNewline.containsNewline(key)) && onError(key ?? start[start.length - 1], "MULTILINE_IMPLICIT_KEY", "Implicit keys need to be on a single line");
     } else keyProps.found?.indent !== bm.indent && onError(offset, "BAD_INDENT", startColMsg);
     const keyStart = keyProps.end, keyNode = key ? composeNode(ctx, key, keyProps, onError) : composeEmptyNode(ctx, keyStart, start, null, keyProps, onError);
     ctx.schema.compat && utilFlowIndentCheck.flowIndentCheck(bm.indent, key, onError), 
     utilMapIncludes.mapIncludes(ctx, map.items, keyNode) && onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
     const valueProps = resolveProps.resolveProps(sep ?? [], {
      indicator: "map-value-ind",
      next: value,
      offset: keyNode.range[2],
      onError,
      parentIndent: bm.indent,
      startOnNewline: !key || "block-scalar" === key.type
     });
     if (offset = valueProps.end, valueProps.found) {
      implicitKey && ("block-map" !== value?.type || valueProps.hasNewline || onError(offset, "BLOCK_AS_IMPLICIT_KEY", "Nested mappings are not allowed in compact mappings"), 
      ctx.options.strict && keyProps.start < valueProps.found.offset - 1024 && onError(keyNode.range, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit block mapping key"));
      const valueNode = value ? composeNode(ctx, value, valueProps, onError) : composeEmptyNode(ctx, offset, sep, null, valueProps, onError);
      ctx.schema.compat && utilFlowIndentCheck.flowIndentCheck(bm.indent, value, onError), 
      offset = valueNode.range[2];
      const pair = new Pair.Pair(keyNode, valueNode);
      ctx.options.keepSourceTokens && (pair.srcToken = collItem), map.items.push(pair);
     } else {
      implicitKey && onError(keyNode.range, "MISSING_CHAR", "Implicit map keys need to be followed by map values"), 
      valueProps.comment && (keyNode.comment ? keyNode.comment += "\n" + valueProps.comment : keyNode.comment = valueProps.comment);
      const pair = new Pair.Pair(keyNode);
      ctx.options.keepSourceTokens && (pair.srcToken = collItem), map.items.push(pair);
     }
    }
    return commentEnd && commentEnd < offset && onError(commentEnd, "IMPOSSIBLE", "Map comment with trailing content"), 
    map.range = [ bm.offset, offset, commentEnd ?? offset ], map;
   };
  },
  94070: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var Scalar = __webpack_require__(89714);
   exports.resolveBlockScalar = function(ctx, scalar, onError) {
    const start = scalar.offset, header = function({offset, props}, strict, onError) {
     if ("block-scalar-header" !== props[0].type) return onError(props[0], "IMPOSSIBLE", "Block scalar header not found"), 
     null;
     const {source} = props[0], mode = source[0];
     let indent = 0, chomp = "", error = -1;
     for (let i = 1; i < source.length; ++i) {
      const ch = source[i];
      if (chomp || "-" !== ch && "+" !== ch) {
       const n = Number(ch);
       !indent && n ? indent = n : -1 === error && (error = offset + i);
      } else chomp = ch;
     }
     -1 !== error && onError(error, "UNEXPECTED_TOKEN", `Block scalar header includes extra characters: ${source}`);
     let hasSpace = !1, comment = "", length = source.length;
     for (let i = 1; i < props.length; ++i) {
      const token = props[i];
      switch (token.type) {
      case "space":
       hasSpace = !0;

      case "newline":
       length += token.source.length;
       break;

      case "comment":
       if (strict && !hasSpace) {
        onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
       }
       length += token.source.length, comment = token.source.substring(1);
       break;

      case "error":
       onError(token, "UNEXPECTED_TOKEN", token.message), length += token.source.length;
       break;

      default:
       {
        onError(token, "UNEXPECTED_TOKEN", `Unexpected token in block scalar header: ${token.type}`);
        const ts = token.source;
        ts && "string" == typeof ts && (length += ts.length);
       }
      }
     }
     return {
      mode,
      indent,
      chomp,
      comment,
      length
     };
    }(scalar, ctx.options.strict, onError);
    if (!header) return {
     value: "",
     type: null,
     comment: "",
     range: [ start, start, start ]
    };
    const type = ">" === header.mode ? Scalar.Scalar.BLOCK_FOLDED : Scalar.Scalar.BLOCK_LITERAL, lines = scalar.source ? function(source) {
     const split = source.split(/\n( *)/), first = split[0], m = first.match(/^( *)/), lines = [ m?.[1] ? [ m[1], first.slice(m[1].length) ] : [ "", first ] ];
     for (let i = 1; i < split.length; i += 2) lines.push([ split[i], split[i + 1] ]);
     return lines;
    }(scalar.source) : [];
    let chompStart = lines.length;
    for (let i = lines.length - 1; i >= 0; --i) {
     const content = lines[i][1];
     if ("" !== content && "\r" !== content) break;
     chompStart = i;
    }
    if (0 === chompStart) {
     const value = "+" === header.chomp && lines.length > 0 ? "\n".repeat(Math.max(1, lines.length - 1)) : "";
     let end = start + header.length;
     return scalar.source && (end += scalar.source.length), {
      value,
      type,
      comment: header.comment,
      range: [ start, end, end ]
     };
    }
    let trimIndent = scalar.indent + header.indent, offset = scalar.offset + header.length, contentStart = 0;
    for (let i = 0; i < chompStart; ++i) {
     const [indent, content] = lines[i];
     if ("" !== content && "\r" !== content) {
      if (indent.length < trimIndent) {
       const message = "Block scalars with more-indented leading empty lines must use an explicit indentation indicator";
       onError(offset + indent.length, "MISSING_CHAR", message);
      }
      if (0 === header.indent && (trimIndent = indent.length), contentStart = i, 0 === trimIndent && !ctx.atRoot) {
       onError(offset, "BAD_INDENT", "Block scalar values in collections must be indented");
      }
      break;
     }
     0 === header.indent && indent.length > trimIndent && (trimIndent = indent.length), 
     offset += indent.length + content.length + 1;
    }
    for (let i = lines.length - 1; i >= chompStart; --i) lines[i][0].length > trimIndent && (chompStart = i + 1);
    let value = "", sep = "", prevMoreIndented = !1;
    for (let i = 0; i < contentStart; ++i) value += lines[i][0].slice(trimIndent) + "\n";
    for (let i = contentStart; i < chompStart; ++i) {
     let [indent, content] = lines[i];
     offset += indent.length + content.length + 1;
     const crlf = "\r" === content[content.length - 1];
     if (crlf && (content = content.slice(0, -1)), content && indent.length < trimIndent) {
      const message = `Block scalar lines must not be less indented than their ${header.indent ? "explicit indentation indicator" : "first line"}`;
      onError(offset - content.length - (crlf ? 2 : 1), "BAD_INDENT", message), indent = "";
     }
     type === Scalar.Scalar.BLOCK_LITERAL ? (value += sep + indent.slice(trimIndent) + content, 
     sep = "\n") : indent.length > trimIndent || "\t" === content[0] ? (" " === sep ? sep = "\n" : prevMoreIndented || "\n" !== sep || (sep = "\n\n"), 
     value += sep + indent.slice(trimIndent) + content, sep = "\n", prevMoreIndented = !0) : "" === content ? "\n" === sep ? value += "\n" : sep = "\n" : (value += sep + content, 
     sep = " ", prevMoreIndented = !1);
    }
    switch (header.chomp) {
    case "-":
     break;

    case "+":
     for (let i = chompStart; i < lines.length; ++i) value += "\n" + lines[i][0].slice(trimIndent);
     "\n" !== value[value.length - 1] && (value += "\n");
     break;

    default:
     value += "\n";
    }
    const end = start + header.length + scalar.source.length;
    return {
     value,
     type,
     comment: header.comment,
     range: [ start, end, end ]
    };
   };
  },
  10483: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var YAMLSeq = __webpack_require__(36010), resolveProps = __webpack_require__(11386), utilFlowIndentCheck = __webpack_require__(68644);
   exports.resolveBlockSeq = function({composeNode, composeEmptyNode}, ctx, bs, onError, tag) {
    const seq = new (tag?.nodeClass ?? YAMLSeq.YAMLSeq)(ctx.schema);
    ctx.atRoot && (ctx.atRoot = !1);
    let offset = bs.offset, commentEnd = null;
    for (const {start, value} of bs.items) {
     const props = resolveProps.resolveProps(start, {
      indicator: "seq-item-ind",
      next: value,
      offset,
      onError,
      parentIndent: bs.indent,
      startOnNewline: !0
     });
     if (!props.found) {
      if (!(props.anchor || props.tag || value)) {
       commentEnd = props.end, props.comment && (seq.comment = props.comment);
       continue;
      }
      value && "block-seq" === value.type ? onError(props.end, "BAD_INDENT", "All sequence items must start at the same column") : onError(offset, "MISSING_CHAR", "Sequence item without - indicator");
     }
     const node = value ? composeNode(ctx, value, props, onError) : composeEmptyNode(ctx, props.end, start, null, props, onError);
     ctx.schema.compat && utilFlowIndentCheck.flowIndentCheck(bs.indent, value, onError), 
     offset = node.range[2], seq.items.push(node);
    }
    return seq.range = [ bs.offset, offset, commentEnd ?? offset ], seq;
   };
  },
  56845: (__unused_webpack_module, exports) => {
   "use strict";
   exports.resolveEnd = function(end, offset, reqSpace, onError) {
    let comment = "";
    if (end) {
     let hasSpace = !1, sep = "";
     for (const token of end) {
      const {source, type} = token;
      switch (type) {
      case "space":
       hasSpace = !0;
       break;

      case "comment":
       {
        reqSpace && !hasSpace && onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
        const cb = source.substring(1) || " ";
        comment ? comment += sep + cb : comment = cb, sep = "";
        break;
       }

      case "newline":
       comment && (sep += source), hasSpace = !0;
       break;

      default:
       onError(token, "UNEXPECTED_TOKEN", `Unexpected ${type} at node end`);
      }
      offset += source.length;
     }
    }
    return {
     comment,
     offset
    };
   };
  },
  2291: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var identity = __webpack_require__(70484), Pair = __webpack_require__(27902), YAMLMap = __webpack_require__(81755), YAMLSeq = __webpack_require__(36010), resolveEnd = __webpack_require__(56845), resolveProps = __webpack_require__(11386), utilContainsNewline = __webpack_require__(9378), utilMapIncludes = __webpack_require__(48334);
   const blockMsg = "Block collections are not allowed within flow collections", isBlock = token => token && ("block-map" === token.type || "block-seq" === token.type);
   exports.resolveFlowCollection = function({composeNode, composeEmptyNode}, ctx, fc, onError, tag) {
    const isMap = "{" === fc.start.source, fcName = isMap ? "flow map" : "flow sequence", coll = new (tag?.nodeClass ?? (isMap ? YAMLMap.YAMLMap : YAMLSeq.YAMLSeq))(ctx.schema);
    coll.flow = !0;
    const atRoot = ctx.atRoot;
    atRoot && (ctx.atRoot = !1);
    let offset = fc.offset + fc.start.source.length;
    for (let i = 0; i < fc.items.length; ++i) {
     const collItem = fc.items[i], {start, key, sep, value} = collItem, props = resolveProps.resolveProps(start, {
      flow: fcName,
      indicator: "explicit-key-ind",
      next: key ?? sep?.[0],
      offset,
      onError,
      parentIndent: fc.indent,
      startOnNewline: !1
     });
     if (!props.found) {
      if (!(props.anchor || props.tag || sep || value)) {
       0 === i && props.comma ? onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`) : i < fc.items.length - 1 && onError(props.start, "UNEXPECTED_TOKEN", `Unexpected empty item in ${fcName}`), 
       props.comment && (coll.comment ? coll.comment += "\n" + props.comment : coll.comment = props.comment), 
       offset = props.end;
       continue;
      }
      !isMap && ctx.options.strict && utilContainsNewline.containsNewline(key) && onError(key, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
     }
     if (0 === i) props.comma && onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`); else if (props.comma || onError(props.start, "MISSING_CHAR", `Missing , between ${fcName} items`), 
     props.comment) {
      let prevItemComment = "";
      loop: for (const st of start) switch (st.type) {
      case "comma":
      case "space":
       break;

      case "comment":
       prevItemComment = st.source.substring(1);
       break loop;

      default:
       break loop;
      }
      if (prevItemComment) {
       let prev = coll.items[coll.items.length - 1];
       identity.isPair(prev) && (prev = prev.value ?? prev.key), prev.comment ? prev.comment += "\n" + prevItemComment : prev.comment = prevItemComment, 
       props.comment = props.comment.substring(prevItemComment.length + 1);
      }
     }
     if (isMap || sep || props.found) {
      const keyStart = props.end, keyNode = key ? composeNode(ctx, key, props, onError) : composeEmptyNode(ctx, keyStart, start, null, props, onError);
      isBlock(key) && onError(keyNode.range, "BLOCK_IN_FLOW", blockMsg);
      const valueProps = resolveProps.resolveProps(sep ?? [], {
       flow: fcName,
       indicator: "map-value-ind",
       next: value,
       offset: keyNode.range[2],
       onError,
       parentIndent: fc.indent,
       startOnNewline: !1
      });
      if (valueProps.found) {
       if (!isMap && !props.found && ctx.options.strict) {
        if (sep) for (const st of sep) {
         if (st === valueProps.found) break;
         if ("newline" === st.type) {
          onError(st, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
          break;
         }
        }
        props.start < valueProps.found.offset - 1024 && onError(valueProps.found, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit flow sequence key");
       }
      } else value && ("source" in value && value.source && ":" === value.source[0] ? onError(value, "MISSING_CHAR", `Missing space after : in ${fcName}`) : onError(valueProps.start, "MISSING_CHAR", `Missing , or : between ${fcName} items`));
      const valueNode = value ? composeNode(ctx, value, valueProps, onError) : valueProps.found ? composeEmptyNode(ctx, valueProps.end, sep, null, valueProps, onError) : null;
      valueNode ? isBlock(value) && onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg) : valueProps.comment && (keyNode.comment ? keyNode.comment += "\n" + valueProps.comment : keyNode.comment = valueProps.comment);
      const pair = new Pair.Pair(keyNode, valueNode);
      if (ctx.options.keepSourceTokens && (pair.srcToken = collItem), isMap) {
       const map = coll;
       utilMapIncludes.mapIncludes(ctx, map.items, keyNode) && onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique"), 
       map.items.push(pair);
      } else {
       const map = new YAMLMap.YAMLMap(ctx.schema);
       map.flow = !0, map.items.push(pair);
       const endRange = (valueNode ?? keyNode).range;
       map.range = [ keyNode.range[0], endRange[1], endRange[2] ], coll.items.push(map);
      }
      offset = valueNode ? valueNode.range[2] : valueProps.end;
     } else {
      const valueNode = value ? composeNode(ctx, value, props, onError) : composeEmptyNode(ctx, props.end, sep, null, props, onError);
      coll.items.push(valueNode), offset = valueNode.range[2], isBlock(value) && onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
     }
    }
    const expectedEnd = isMap ? "}" : "]", [ce, ...ee] = fc.end;
    let cePos = offset;
    if (ce && ce.source === expectedEnd) cePos = ce.offset + ce.source.length; else {
     const name = fcName[0].toUpperCase() + fcName.substring(1);
     onError(offset, atRoot ? "MISSING_CHAR" : "BAD_INDENT", atRoot ? `${name} must end with a ${expectedEnd}` : `${name} in block collection must be sufficiently indented and end with a ${expectedEnd}`), 
     ce && 1 !== ce.source.length && ee.unshift(ce);
    }
    if (ee.length > 0) {
     const end = resolveEnd.resolveEnd(ee, cePos, ctx.options.strict, onError);
     end.comment && (coll.comment ? coll.comment += "\n" + end.comment : coll.comment = end.comment), 
     coll.range = [ fc.offset, cePos, end.offset ];
    } else coll.range = [ fc.offset, cePos, cePos ];
    return coll;
   };
  },
  27571: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var Scalar = __webpack_require__(89714), resolveEnd = __webpack_require__(56845);
   function foldLines(source) {
    let first, line;
    try {
     first = new RegExp("(.*?)(?<![ \t])[ \t]*\r?\n", "sy"), line = new RegExp("[ \t]*(.*?)(?:(?<![ \t])[ \t]*)?\r?\n", "sy");
    } catch {
     first = /(.*?)[ \t]*\r?\n/sy, line = /[ \t]*(.*?)[ \t]*\r?\n/sy;
    }
    let match = first.exec(source);
    if (!match) return source;
    let res = match[1], sep = " ", pos = first.lastIndex;
    for (line.lastIndex = pos; match = line.exec(source); ) "" === match[1] ? "\n" === sep ? res += sep : sep = "\n" : (res += sep + match[1], 
    sep = " "), pos = line.lastIndex;
    const last = /[ \t]*(.*)/sy;
    return last.lastIndex = pos, match = last.exec(source), res + sep + (match?.[1] ?? "");
   }
   function foldNewline(source, offset) {
    let fold = "", ch = source[offset + 1];
    for (;!(" " !== ch && "\t" !== ch && "\n" !== ch && "\r" !== ch || "\r" === ch && "\n" !== source[offset + 2]); ) "\n" === ch && (fold += "\n"), 
    ch = source[(offset += 1) + 1];
    return fold || (fold = " "), {
     fold,
     offset
    };
   }
   const escapeCodes = {
    0: "\0",
    a: "",
    b: "\b",
    e: "",
    f: "\f",
    n: "\n",
    r: "\r",
    t: "\t",
    v: "\v",
    N: "",
    _: " ",
    L: "\u2028",
    P: "\u2029",
    " ": " ",
    '"': '"',
    "/": "/",
    "\\": "\\",
    "\t": "\t"
   };
   function parseCharCode(source, offset, length, onError) {
    const cc = source.substr(offset, length), code = cc.length === length && /^[0-9a-fA-F]+$/.test(cc) ? parseInt(cc, 16) : NaN;
    if (isNaN(code)) {
     const raw = source.substr(offset - 2, length + 2);
     return onError(offset - 2, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`), raw;
    }
    return String.fromCodePoint(code);
   }
   exports.resolveFlowScalar = function(scalar, strict, onError) {
    const {offset, type, source, end} = scalar;
    let _type, value;
    const _onError = (rel, code, msg) => onError(offset + rel, code, msg);
    switch (type) {
    case "scalar":
     _type = Scalar.Scalar.PLAIN, value = function(source, onError) {
      let badChar = "";
      switch (source[0]) {
      case "\t":
       badChar = "a tab character";
       break;

      case ",":
       badChar = "flow indicator character ,";
       break;

      case "%":
       badChar = "directive indicator character %";
       break;

      case "|":
      case ">":
       badChar = `block scalar indicator ${source[0]}`;
       break;

      case "@":
      case "`":
       badChar = `reserved character ${source[0]}`;
      }
      badChar && onError(0, "BAD_SCALAR_START", `Plain value cannot start with ${badChar}`);
      return foldLines(source);
     }(source, _onError);
     break;

    case "single-quoted-scalar":
     _type = Scalar.Scalar.QUOTE_SINGLE, value = function(source, onError) {
      "'" === source[source.length - 1] && 1 !== source.length || onError(source.length, "MISSING_CHAR", "Missing closing 'quote");
      return foldLines(source.slice(1, -1)).replace(/''/g, "'");
     }(source, _onError);
     break;

    case "double-quoted-scalar":
     _type = Scalar.Scalar.QUOTE_DOUBLE, value = function(source, onError) {
      let res = "";
      for (let i = 1; i < source.length - 1; ++i) {
       const ch = source[i];
       if ("\r" !== ch || "\n" !== source[i + 1]) if ("\n" === ch) {
        const {fold, offset} = foldNewline(source, i);
        res += fold, i = offset;
       } else if ("\\" === ch) {
        let next = source[++i];
        const cc = escapeCodes[next];
        if (cc) res += cc; else if ("\n" === next) for (next = source[i + 1]; " " === next || "\t" === next; ) next = source[1 + ++i]; else if ("\r" === next && "\n" === source[i + 1]) for (next = source[1 + ++i]; " " === next || "\t" === next; ) next = source[1 + ++i]; else if ("x" === next || "u" === next || "U" === next) {
         const length = {
          x: 2,
          u: 4,
          U: 8
         }[next];
         res += parseCharCode(source, i + 1, length, onError), i += length;
        } else {
         const raw = source.substr(i - 1, 2);
         onError(i - 1, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`), res += raw;
        }
       } else if (" " === ch || "\t" === ch) {
        const wsStart = i;
        let next = source[i + 1];
        for (;" " === next || "\t" === next; ) next = source[1 + ++i];
        "\n" === next || "\r" === next && "\n" === source[i + 2] || (res += i > wsStart ? source.slice(wsStart, i + 1) : ch);
       } else res += ch;
      }
      '"' === source[source.length - 1] && 1 !== source.length || onError(source.length, "MISSING_CHAR", 'Missing closing "quote');
      return res;
     }(source, _onError);
     break;

    default:
     return onError(scalar, "UNEXPECTED_TOKEN", `Expected a flow scalar value, but found: ${type}`), 
     {
      value: "",
      type: null,
      comment: "",
      range: [ offset, offset + source.length, offset + source.length ]
     };
    }
    const valueEnd = offset + source.length, re = resolveEnd.resolveEnd(end, valueEnd, strict, onError);
    return {
     value,
     type: _type,
     comment: re.comment,
     range: [ offset, valueEnd, re.offset ]
    };
   };
  },
  11386: (__unused_webpack_module, exports) => {
   "use strict";
   exports.resolveProps = function(tokens, {flow, indicator, next, offset, onError, parentIndent, startOnNewline}) {
    let spaceBefore = !1, atNewline = startOnNewline, hasSpace = startOnNewline, comment = "", commentSep = "", hasNewline = !1, reqSpace = !1, tab = null, anchor = null, tag = null, newlineAfterProp = null, comma = null, found = null, start = null;
    for (const token of tokens) switch (reqSpace && ("space" !== token.type && "newline" !== token.type && "comma" !== token.type && onError(token.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space"), 
    reqSpace = !1), tab && (atNewline && "comment" !== token.type && "newline" !== token.type && onError(tab, "TAB_AS_INDENT", "Tabs are not allowed as indentation"), 
    tab = null), token.type) {
    case "space":
     flow || "doc-start" === indicator && "flow-collection" === next?.type || !token.source.includes("\t") || (tab = token), 
     hasSpace = !0;
     break;

    case "comment":
     {
      hasSpace || onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
      const cb = token.source.substring(1) || " ";
      comment ? comment += commentSep + cb : comment = cb, commentSep = "", atNewline = !1;
      break;
     }

    case "newline":
     atNewline ? comment ? comment += token.source : spaceBefore = !0 : commentSep += token.source, 
     atNewline = !0, hasNewline = !0, (anchor || tag) && (newlineAfterProp = token), 
     hasSpace = !0;
     break;

    case "anchor":
     anchor && onError(token, "MULTIPLE_ANCHORS", "A node can have at most one anchor"), 
     token.source.endsWith(":") && onError(token.offset + token.source.length - 1, "BAD_ALIAS", "Anchor ending in : is ambiguous", !0), 
     anchor = token, null === start && (start = token.offset), atNewline = !1, hasSpace = !1, 
     reqSpace = !0;
     break;

    case "tag":
     tag && onError(token, "MULTIPLE_TAGS", "A node can have at most one tag"), tag = token, 
     null === start && (start = token.offset), atNewline = !1, hasSpace = !1, reqSpace = !0;
     break;

    case indicator:
     (anchor || tag) && onError(token, "BAD_PROP_ORDER", `Anchors and tags must be after the ${token.source} indicator`), 
     found && onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.source} in ${flow ?? "collection"}`), 
     found = token, atNewline = "seq-item-ind" === indicator || "explicit-key-ind" === indicator, 
     hasSpace = !1;
     break;

    case "comma":
     if (flow) {
      comma && onError(token, "UNEXPECTED_TOKEN", `Unexpected , in ${flow}`), comma = token, 
      atNewline = !1, hasSpace = !1;
      break;
     }

    default:
     onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.type} token`), atNewline = !1, 
     hasSpace = !1;
    }
    const last = tokens[tokens.length - 1], end = last ? last.offset + last.source.length : offset;
    return reqSpace && next && "space" !== next.type && "newline" !== next.type && "comma" !== next.type && ("scalar" !== next.type || "" !== next.source) && onError(next.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space"), 
    tab && (atNewline && tab.indent <= parentIndent || "block-map" === next?.type || "block-seq" === next?.type) && onError(tab, "TAB_AS_INDENT", "Tabs are not allowed as indentation"), 
    {
     comma,
     found,
     spaceBefore,
     comment,
     hasNewline,
     anchor,
     tag,
     newlineAfterProp,
     end,
     start: start ?? end
    };
   };
  },
  9378: (__unused_webpack_module, exports) => {
   "use strict";
   exports.containsNewline = function containsNewline(key) {
    if (!key) return null;
    switch (key.type) {
    case "alias":
    case "scalar":
    case "double-quoted-scalar":
    case "single-quoted-scalar":
     if (key.source.includes("\n")) return !0;
     if (key.end) for (const st of key.end) if ("newline" === st.type) return !0;
     return !1;

    case "flow-collection":
     for (const it of key.items) {
      for (const st of it.start) if ("newline" === st.type) return !0;
      if (it.sep) for (const st of it.sep) if ("newline" === st.type) return !0;
      if (containsNewline(it.key) || containsNewline(it.value)) return !0;
     }
     return !1;

    default:
     return !0;
    }
   };
  },
  71040: (__unused_webpack_module, exports) => {
   "use strict";
   exports.emptyScalarPosition = function(offset, before, pos) {
    if (before) {
     null === pos && (pos = before.length);
     for (let i = pos - 1; i >= 0; --i) {
      let st = before[i];
      switch (st.type) {
      case "space":
      case "comment":
      case "newline":
       offset -= st.source.length;
       continue;
      }
      for (st = before[++i]; "space" === st?.type; ) offset += st.source.length, st = before[++i];
      break;
     }
    }
    return offset;
   };
  },
  68644: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var utilContainsNewline = __webpack_require__(9378);
   exports.flowIndentCheck = function(indent, fc, onError) {
    if ("flow-collection" === fc?.type) {
     const end = fc.end[0];
     if (end.indent === indent && ("]" === end.source || "}" === end.source) && utilContainsNewline.containsNewline(fc)) {
      onError(end, "BAD_INDENT", "Flow end indicator should be more indented than parent", !0);
     }
    }
   };
  },
  48334: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var identity = __webpack_require__(70484);
   exports.mapIncludes = function(ctx, items, search) {
    const {uniqueKeys} = ctx.options;
    if (!1 === uniqueKeys) return !1;
    const isEqual = "function" == typeof uniqueKeys ? uniqueKeys : (a, b) => a === b || identity.isScalar(a) && identity.isScalar(b) && a.value === b.value && !("<<" === a.value && ctx.schema.merge);
    return items.some((pair => isEqual(pair.key, search)));
   };
  },
  9046: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var Alias = __webpack_require__(41736), Collection = __webpack_require__(21614), identity = __webpack_require__(70484), Pair = __webpack_require__(27902), toJS = __webpack_require__(63732), Schema = __webpack_require__(40625), stringifyDocument = __webpack_require__(71768), anchors = __webpack_require__(46261), applyReviver = __webpack_require__(86906), createNode = __webpack_require__(95219), directives = __webpack_require__(38673);
   class Document {
    constructor(value, replacer, options) {
     this.commentBefore = null, this.comment = null, this.errors = [], this.warnings = [], 
     Object.defineProperty(this, identity.NODE_TYPE, {
      value: identity.DOC
     });
     let _replacer = null;
     "function" == typeof replacer || Array.isArray(replacer) ? _replacer = replacer : void 0 === options && replacer && (options = replacer, 
     replacer = void 0);
     const opt = Object.assign({
      intAsBigInt: !1,
      keepSourceTokens: !1,
      logLevel: "warn",
      prettyErrors: !0,
      strict: !0,
      uniqueKeys: !0,
      version: "1.2"
     }, options);
     this.options = opt;
     let {version} = opt;
     options?._directives ? (this.directives = options._directives.atDocument(), this.directives.yaml.explicit && (version = this.directives.yaml.version)) : this.directives = new directives.Directives({
      version
     }), this.setSchema(version, options), this.contents = void 0 === value ? null : this.createNode(value, _replacer, options);
    }
    clone() {
     const copy = Object.create(Document.prototype, {
      [identity.NODE_TYPE]: {
       value: identity.DOC
      }
     });
     return copy.commentBefore = this.commentBefore, copy.comment = this.comment, copy.errors = this.errors.slice(), 
     copy.warnings = this.warnings.slice(), copy.options = Object.assign({}, this.options), 
     this.directives && (copy.directives = this.directives.clone()), copy.schema = this.schema.clone(), 
     copy.contents = identity.isNode(this.contents) ? this.contents.clone(copy.schema) : this.contents, 
     this.range && (copy.range = this.range.slice()), copy;
    }
    add(value) {
     assertCollection(this.contents) && this.contents.add(value);
    }
    addIn(path, value) {
     assertCollection(this.contents) && this.contents.addIn(path, value);
    }
    createAlias(node, name) {
     if (!node.anchor) {
      const prev = anchors.anchorNames(this);
      node.anchor = !name || prev.has(name) ? anchors.findNewAnchor(name || "a", prev) : name;
     }
     return new Alias.Alias(node.anchor);
    }
    createNode(value, replacer, options) {
     let _replacer;
     if ("function" == typeof replacer) value = replacer.call({
      "": value
     }, "", value), _replacer = replacer; else if (Array.isArray(replacer)) {
      const keyToStr = v => "number" == typeof v || v instanceof String || v instanceof Number, asStr = replacer.filter(keyToStr).map(String);
      asStr.length > 0 && (replacer = replacer.concat(asStr)), _replacer = replacer;
     } else void 0 === options && replacer && (options = replacer, replacer = void 0);
     const {aliasDuplicateObjects, anchorPrefix, flow, keepUndefined, onTagObj, tag} = options ?? {}, {onAnchor, setAnchors, sourceObjects} = anchors.createNodeAnchors(this, anchorPrefix || "a"), ctx = {
      aliasDuplicateObjects: aliasDuplicateObjects ?? !0,
      keepUndefined: keepUndefined ?? !1,
      onAnchor,
      onTagObj,
      replacer: _replacer,
      schema: this.schema,
      sourceObjects
     }, node = createNode.createNode(value, tag, ctx);
     return flow && identity.isCollection(node) && (node.flow = !0), setAnchors(), node;
    }
    createPair(key, value, options = {}) {
     const k = this.createNode(key, null, options), v = this.createNode(value, null, options);
     return new Pair.Pair(k, v);
    }
    delete(key) {
     return !!assertCollection(this.contents) && this.contents.delete(key);
    }
    deleteIn(path) {
     return Collection.isEmptyPath(path) ? null != this.contents && (this.contents = null, 
     !0) : !!assertCollection(this.contents) && this.contents.deleteIn(path);
    }
    get(key, keepScalar) {
     return identity.isCollection(this.contents) ? this.contents.get(key, keepScalar) : void 0;
    }
    getIn(path, keepScalar) {
     return Collection.isEmptyPath(path) ? !keepScalar && identity.isScalar(this.contents) ? this.contents.value : this.contents : identity.isCollection(this.contents) ? this.contents.getIn(path, keepScalar) : void 0;
    }
    has(key) {
     return !!identity.isCollection(this.contents) && this.contents.has(key);
    }
    hasIn(path) {
     return Collection.isEmptyPath(path) ? void 0 !== this.contents : !!identity.isCollection(this.contents) && this.contents.hasIn(path);
    }
    set(key, value) {
     null == this.contents ? this.contents = Collection.collectionFromPath(this.schema, [ key ], value) : assertCollection(this.contents) && this.contents.set(key, value);
    }
    setIn(path, value) {
     Collection.isEmptyPath(path) ? this.contents = value : null == this.contents ? this.contents = Collection.collectionFromPath(this.schema, Array.from(path), value) : assertCollection(this.contents) && this.contents.setIn(path, value);
    }
    setSchema(version, options = {}) {
     let opt;
     switch ("number" == typeof version && (version = String(version)), version) {
     case "1.1":
      this.directives ? this.directives.yaml.version = "1.1" : this.directives = new directives.Directives({
       version: "1.1"
      }), opt = {
       merge: !0,
       resolveKnownTags: !1,
       schema: "yaml-1.1"
      };
      break;

     case "1.2":
     case "next":
      this.directives ? this.directives.yaml.version = version : this.directives = new directives.Directives({
       version
      }), opt = {
       merge: !1,
       resolveKnownTags: !0,
       schema: "core"
      };
      break;

     case null:
      this.directives && delete this.directives, opt = null;
      break;

     default:
      {
       const sv = JSON.stringify(version);
       throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);
      }
     }
     if (options.schema instanceof Object) this.schema = options.schema; else {
      if (!opt) throw new Error("With a null YAML version, the { schema: Schema } option is required");
      this.schema = new Schema.Schema(Object.assign(opt, options));
     }
    }
    toJS({json, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver} = {}) {
     const ctx = {
      anchors: new Map,
      doc: this,
      keep: !json,
      mapAsMap: !0 === mapAsMap,
      mapKeyWarned: !1,
      maxAliasCount: "number" == typeof maxAliasCount ? maxAliasCount : 100
     }, res = toJS.toJS(this.contents, jsonArg ?? "", ctx);
     if ("function" == typeof onAnchor) for (const {count, res} of ctx.anchors.values()) onAnchor(res, count);
     return "function" == typeof reviver ? applyReviver.applyReviver(reviver, {
      "": res
     }, "", res) : res;
    }
    toJSON(jsonArg, onAnchor) {
     return this.toJS({
      json: !0,
      jsonArg,
      mapAsMap: !1,
      onAnchor
     });
    }
    toString(options = {}) {
     if (this.errors.length > 0) throw new Error("Document with errors cannot be stringified");
     if ("indent" in options && (!Number.isInteger(options.indent) || Number(options.indent) <= 0)) {
      const s = JSON.stringify(options.indent);
      throw new Error(`"indent" option must be a positive integer, not ${s}`);
     }
     return stringifyDocument.stringifyDocument(this, options);
    }
   }
   function assertCollection(contents) {
    if (identity.isCollection(contents)) return !0;
    throw new Error("Expected a YAML collection as document contents");
   }
   exports.Document = Document;
  },
  46261: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var identity = __webpack_require__(70484), visit = __webpack_require__(29125);
   function anchorNames(root) {
    const anchors = new Set;
    return visit.visit(root, {
     Value(_key, node) {
      node.anchor && anchors.add(node.anchor);
     }
    }), anchors;
   }
   function findNewAnchor(prefix, exclude) {
    for (let i = 1; ;++i) {
     const name = `${prefix}${i}`;
     if (!exclude.has(name)) return name;
    }
   }
   exports.anchorIsValid = function(anchor) {
    if (/[\x00-\x19\s,[\]{}]/.test(anchor)) {
     const sa = JSON.stringify(anchor);
     throw new Error(`Anchor must not contain whitespace or control characters: ${sa}`);
    }
    return !0;
   }, exports.anchorNames = anchorNames, exports.createNodeAnchors = function(doc, prefix) {
    const aliasObjects = [], sourceObjects = new Map;
    let prevAnchors = null;
    return {
     onAnchor: source => {
      aliasObjects.push(source), prevAnchors || (prevAnchors = anchorNames(doc));
      const anchor = findNewAnchor(prefix, prevAnchors);
      return prevAnchors.add(anchor), anchor;
     },
     setAnchors: () => {
      for (const source of aliasObjects) {
       const ref = sourceObjects.get(source);
       if ("object" != typeof ref || !ref.anchor || !identity.isScalar(ref.node) && !identity.isCollection(ref.node)) {
        const error = new Error("Failed to resolve repeated object (this should not happen)");
        throw error.source = source, error;
       }
       ref.node.anchor = ref.anchor;
      }
     },
     sourceObjects
    };
   }, exports.findNewAnchor = findNewAnchor;
  },
  86906: (__unused_webpack_module, exports) => {
   "use strict";
   exports.applyReviver = function applyReviver(reviver, obj, key, val) {
    if (val && "object" == typeof val) if (Array.isArray(val)) for (let i = 0, len = val.length; i < len; ++i) {
     const v0 = val[i], v1 = applyReviver(reviver, val, String(i), v0);
     void 0 === v1 ? delete val[i] : v1 !== v0 && (val[i] = v1);
    } else if (val instanceof Map) for (const k of Array.from(val.keys())) {
     const v0 = val.get(k), v1 = applyReviver(reviver, val, k, v0);
     void 0 === v1 ? val.delete(k) : v1 !== v0 && val.set(k, v1);
    } else if (val instanceof Set) for (const v0 of Array.from(val)) {
     const v1 = applyReviver(reviver, val, v0, v0);
     void 0 === v1 ? val.delete(v0) : v1 !== v0 && (val.delete(v0), val.add(v1));
    } else for (const [k, v0] of Object.entries(val)) {
     const v1 = applyReviver(reviver, val, k, v0);
     void 0 === v1 ? delete val[k] : v1 !== v0 && (val[k] = v1);
    }
    return reviver.call(obj, key, val);
   };
  },
  95219: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var Alias = __webpack_require__(41736), identity = __webpack_require__(70484), Scalar = __webpack_require__(89714);
   exports.createNode = function(value, tagName, ctx) {
    if (identity.isDocument(value) && (value = value.contents), identity.isNode(value)) return value;
    if (identity.isPair(value)) {
     const map = ctx.schema[identity.MAP].createNode?.(ctx.schema, null, ctx);
     return map.items.push(value), map;
    }
    (value instanceof String || value instanceof Number || value instanceof Boolean || "undefined" != typeof BigInt && value instanceof BigInt) && (value = value.valueOf());
    const {aliasDuplicateObjects, onAnchor, onTagObj, schema, sourceObjects} = ctx;
    let ref;
    if (aliasDuplicateObjects && value && "object" == typeof value) {
     if (ref = sourceObjects.get(value), ref) return ref.anchor || (ref.anchor = onAnchor(value)), 
     new Alias.Alias(ref.anchor);
     ref = {
      anchor: null,
      node: null
     }, sourceObjects.set(value, ref);
    }
    tagName?.startsWith("!!") && (tagName = "tag:yaml.org,2002:" + tagName.slice(2));
    let tagObj = function(value, tagName, tags) {
     if (tagName) {
      const match = tags.filter((t => t.tag === tagName)), tagObj = match.find((t => !t.format)) ?? match[0];
      if (!tagObj) throw new Error(`Tag ${tagName} not found`);
      return tagObj;
     }
     return tags.find((t => t.identify?.(value) && !t.format));
    }(value, tagName, schema.tags);
    if (!tagObj) {
     if (value && "function" == typeof value.toJSON && (value = value.toJSON()), !value || "object" != typeof value) {
      const node = new Scalar.Scalar(value);
      return ref && (ref.node = node), node;
     }
     tagObj = value instanceof Map ? schema[identity.MAP] : Symbol.iterator in Object(value) ? schema[identity.SEQ] : schema[identity.MAP];
    }
    onTagObj && (onTagObj(tagObj), delete ctx.onTagObj);
    const node = tagObj?.createNode ? tagObj.createNode(ctx.schema, value, ctx) : "function" == typeof tagObj?.nodeClass?.from ? tagObj.nodeClass.from(ctx.schema, value, ctx) : new Scalar.Scalar(value);
    return tagName ? node.tag = tagName : tagObj.default || (node.tag = tagObj.tag), 
    ref && (ref.node = node), node;
   };
  },
  38673: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var identity = __webpack_require__(70484), visit = __webpack_require__(29125);
   const escapeChars = {
    "!": "%21",
    ",": "%2C",
    "[": "%5B",
    "]": "%5D",
    "{": "%7B",
    "}": "%7D"
   };
   class Directives {
    constructor(yaml, tags) {
     this.docStart = null, this.docEnd = !1, this.yaml = Object.assign({}, Directives.defaultYaml, yaml), 
     this.tags = Object.assign({}, Directives.defaultTags, tags);
    }
    clone() {
     const copy = new Directives(this.yaml, this.tags);
     return copy.docStart = this.docStart, copy;
    }
    atDocument() {
     const res = new Directives(this.yaml, this.tags);
     switch (this.yaml.version) {
     case "1.1":
      this.atNextDocument = !0;
      break;

     case "1.2":
      this.atNextDocument = !1, this.yaml = {
       explicit: Directives.defaultYaml.explicit,
       version: "1.2"
      }, this.tags = Object.assign({}, Directives.defaultTags);
     }
     return res;
    }
    add(line, onError) {
     this.atNextDocument && (this.yaml = {
      explicit: Directives.defaultYaml.explicit,
      version: "1.1"
     }, this.tags = Object.assign({}, Directives.defaultTags), this.atNextDocument = !1);
     const parts = line.trim().split(/[ \t]+/), name = parts.shift();
     switch (name) {
     case "%TAG":
      {
       if (2 !== parts.length && (onError(0, "%TAG directive should contain exactly two parts"), 
       parts.length < 2)) return !1;
       const [handle, prefix] = parts;
       return this.tags[handle] = prefix, !0;
      }

     case "%YAML":
      {
       if (this.yaml.explicit = !0, 1 !== parts.length) return onError(0, "%YAML directive should contain exactly one part"), 
       !1;
       const [version] = parts;
       if ("1.1" === version || "1.2" === version) return this.yaml.version = version, 
       !0;
       return onError(6, `Unsupported YAML version ${version}`, /^\d+\.\d+$/.test(version)), 
       !1;
      }

     default:
      return onError(0, `Unknown directive ${name}`, !0), !1;
     }
    }
    tagName(source, onError) {
     if ("!" === source) return "!";
     if ("!" !== source[0]) return onError(`Not a valid tag: ${source}`), null;
     if ("<" === source[1]) {
      const verbatim = source.slice(2, -1);
      return "!" === verbatim || "!!" === verbatim ? (onError(`Verbatim tags aren't resolved, so ${source} is invalid.`), 
      null) : (">" !== source[source.length - 1] && onError("Verbatim tags must end with a >"), 
      verbatim);
     }
     const [, handle, suffix] = source.match(/^(.*!)([^!]*)$/s);
     suffix || onError(`The ${source} tag has no suffix`);
     const prefix = this.tags[handle];
     if (prefix) try {
      return prefix + decodeURIComponent(suffix);
     } catch (error) {
      return onError(String(error)), null;
     }
     return "!" === handle ? source : (onError(`Could not resolve tag: ${source}`), null);
    }
    tagString(tag) {
     for (const [handle, prefix] of Object.entries(this.tags)) if (tag.startsWith(prefix)) return handle + tag.substring(prefix.length).replace(/[!,[\]{}]/g, (ch => escapeChars[ch]));
     return "!" === tag[0] ? tag : `!<${tag}>`;
    }
    toString(doc) {
     const lines = this.yaml.explicit ? [ `%YAML ${this.yaml.version || "1.2"}` ] : [], tagEntries = Object.entries(this.tags);
     let tagNames;
     if (doc && tagEntries.length > 0 && identity.isNode(doc.contents)) {
      const tags = {};
      visit.visit(doc.contents, ((_key, node) => {
       identity.isNode(node) && node.tag && (tags[node.tag] = !0);
      })), tagNames = Object.keys(tags);
     } else tagNames = [];
     for (const [handle, prefix] of tagEntries) "!!" === handle && "tag:yaml.org,2002:" === prefix || doc && !tagNames.some((tn => tn.startsWith(prefix))) || lines.push(`%TAG ${handle} ${prefix}`);
     return lines.join("\n");
    }
   }
   Directives.defaultYaml = {
    explicit: !1,
    version: "1.2"
   }, Directives.defaultTags = {
    "!!": "tag:yaml.org,2002:"
   }, exports.Directives = Directives;
  },
  44355: (__unused_webpack_module, exports) => {
   "use strict";
   class YAMLError extends Error {
    constructor(name, pos, code, message) {
     super(), this.name = name, this.code = code, this.message = message, this.pos = pos;
    }
   }
   exports.YAMLError = YAMLError, exports.YAMLParseError = class extends YAMLError {
    constructor(pos, code, message) {
     super("YAMLParseError", pos, code, message);
    }
   }, exports.YAMLWarning = class extends YAMLError {
    constructor(pos, code, message) {
     super("YAMLWarning", pos, code, message);
    }
   }, exports.prettifyError = (src, lc) => error => {
    if (-1 === error.pos[0]) return;
    error.linePos = error.pos.map((pos => lc.linePos(pos)));
    const {line, col} = error.linePos[0];
    error.message += ` at line ${line}, column ${col}`;
    let ci = col - 1, lineStr = src.substring(lc.lineStarts[line - 1], lc.lineStarts[line]).replace(/[\n\r]+$/, "");
    if (ci >= 60 && lineStr.length > 80) {
     const trimStart = Math.min(ci - 39, lineStr.length - 79);
     lineStr = "…" + lineStr.substring(trimStart), ci -= trimStart - 1;
    }
    if (lineStr.length > 80 && (lineStr = lineStr.substring(0, 79) + "…"), line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {
     let prev = src.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1]);
     prev.length > 80 && (prev = prev.substring(0, 79) + "…\n"), lineStr = prev + lineStr;
    }
    if (/[^ ]/.test(lineStr)) {
     let count = 1;
     const end = error.linePos[1];
     end && end.line === line && end.col > col && (count = Math.max(1, Math.min(end.col - col, 80 - ci)));
     const pointer = " ".repeat(ci) + "^".repeat(count);
     error.message += `:\n\n${lineStr}\n${pointer}\n`;
    }
   };
  },
  91198: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var composer = __webpack_require__(24927), Document = __webpack_require__(9046), Schema = __webpack_require__(40625), errors = __webpack_require__(44355), Alias = __webpack_require__(41736), identity = __webpack_require__(70484), Pair = __webpack_require__(27902), Scalar = __webpack_require__(89714), YAMLMap = __webpack_require__(81755), YAMLSeq = __webpack_require__(36010), cst = __webpack_require__(29112), lexer = __webpack_require__(5752), lineCounter = __webpack_require__(40483), parser = __webpack_require__(36247), publicApi = __webpack_require__(61332), visit = __webpack_require__(29125);
   exports.Composer = composer.Composer, exports.Document = Document.Document, exports.Schema = Schema.Schema, 
   exports.YAMLError = errors.YAMLError, exports.YAMLParseError = errors.YAMLParseError, 
   exports.YAMLWarning = errors.YAMLWarning, exports.Alias = Alias.Alias, exports.isAlias = identity.isAlias, 
   exports.isCollection = identity.isCollection, exports.isDocument = identity.isDocument, 
   exports.isMap = identity.isMap, exports.isNode = identity.isNode, exports.isPair = identity.isPair, 
   exports.isScalar = identity.isScalar, exports.isSeq = identity.isSeq, exports.Pair = Pair.Pair, 
   exports.Scalar = Scalar.Scalar, exports.YAMLMap = YAMLMap.YAMLMap, exports.YAMLSeq = YAMLSeq.YAMLSeq, 
   exports.CST = cst, exports.Lexer = lexer.Lexer, exports.LineCounter = lineCounter.LineCounter, 
   exports.Parser = parser.Parser, exports.parse = publicApi.parse, exports.parseAllDocuments = publicApi.parseAllDocuments, 
   exports.parseDocument = publicApi.parseDocument, exports.stringify = publicApi.stringify, 
   exports.visit = visit.visit, exports.visitAsync = visit.visitAsync;
  },
  97444: (__unused_webpack_module, exports) => {
   "use strict";
   exports.debug = function(logLevel, ...messages) {
    "debug" === logLevel && console.log(...messages);
   }, exports.warn = function(logLevel, warning) {
    "debug" !== logLevel && "warn" !== logLevel || ("undefined" != typeof process && process.emitWarning ? process.emitWarning(warning) : console.warn(warning));
   };
  },
  41736: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var anchors = __webpack_require__(46261), visit = __webpack_require__(29125), identity = __webpack_require__(70484), Node = __webpack_require__(98898), toJS = __webpack_require__(63732);
   class Alias extends Node.NodeBase {
    constructor(source) {
     super(identity.ALIAS), this.source = source, Object.defineProperty(this, "tag", {
      set() {
       throw new Error("Alias nodes cannot have tags");
      }
     });
    }
    resolve(doc) {
     let found;
     return visit.visit(doc, {
      Node: (_key, node) => {
       if (node === this) return visit.visit.BREAK;
       node.anchor === this.source && (found = node);
      }
     }), found;
    }
    toJSON(_arg, ctx) {
     if (!ctx) return {
      source: this.source
     };
     const {anchors, doc, maxAliasCount} = ctx, source = this.resolve(doc);
     if (!source) {
      const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
      throw new ReferenceError(msg);
     }
     let data = anchors.get(source);
     if (data || (toJS.toJS(source, null, ctx), data = anchors.get(source)), !data || void 0 === data.res) {
      throw new ReferenceError("This should not happen: Alias anchor was not resolved?");
     }
     if (maxAliasCount >= 0 && (data.count += 1, 0 === data.aliasCount && (data.aliasCount = getAliasCount(doc, source, anchors)), 
     data.count * data.aliasCount > maxAliasCount)) {
      throw new ReferenceError("Excessive alias count indicates a resource exhaustion attack");
     }
     return data.res;
    }
    toString(ctx, _onComment, _onChompKeep) {
     const src = `*${this.source}`;
     if (ctx) {
      if (anchors.anchorIsValid(this.source), ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {
       const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
       throw new Error(msg);
      }
      if (ctx.implicitKey) return `${src} `;
     }
     return src;
    }
   }
   function getAliasCount(doc, node, anchors) {
    if (identity.isAlias(node)) {
     const source = node.resolve(doc), anchor = anchors && source && anchors.get(source);
     return anchor ? anchor.count * anchor.aliasCount : 0;
    }
    if (identity.isCollection(node)) {
     let count = 0;
     for (const item of node.items) {
      const c = getAliasCount(doc, item, anchors);
      c > count && (count = c);
     }
     return count;
    }
    if (identity.isPair(node)) {
     const kc = getAliasCount(doc, node.key, anchors), vc = getAliasCount(doc, node.value, anchors);
     return Math.max(kc, vc);
    }
    return 1;
   }
   exports.Alias = Alias;
  },
  21614: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var createNode = __webpack_require__(95219), identity = __webpack_require__(70484), Node = __webpack_require__(98898);
   function collectionFromPath(schema, path, value) {
    let v = value;
    for (let i = path.length - 1; i >= 0; --i) {
     const k = path[i];
     if ("number" == typeof k && Number.isInteger(k) && k >= 0) {
      const a = [];
      a[k] = v, v = a;
     } else v = new Map([ [ k, v ] ]);
    }
    return createNode.createNode(v, void 0, {
     aliasDuplicateObjects: !1,
     keepUndefined: !1,
     onAnchor: () => {
      throw new Error("This should not happen, please report a bug.");
     },
     schema,
     sourceObjects: new Map
    });
   }
   const isEmptyPath = path => null == path || "object" == typeof path && !!path[Symbol.iterator]().next().done;
   class Collection extends Node.NodeBase {
    constructor(type, schema) {
     super(type), Object.defineProperty(this, "schema", {
      value: schema,
      configurable: !0,
      enumerable: !1,
      writable: !0
     });
    }
    clone(schema) {
     const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
     return schema && (copy.schema = schema), copy.items = copy.items.map((it => identity.isNode(it) || identity.isPair(it) ? it.clone(schema) : it)), 
     this.range && (copy.range = this.range.slice()), copy;
    }
    addIn(path, value) {
     if (isEmptyPath(path)) this.add(value); else {
      const [key, ...rest] = path, node = this.get(key, !0);
      if (identity.isCollection(node)) node.addIn(rest, value); else {
       if (void 0 !== node || !this.schema) throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
       this.set(key, collectionFromPath(this.schema, rest, value));
      }
     }
    }
    deleteIn(path) {
     const [key, ...rest] = path;
     if (0 === rest.length) return this.delete(key);
     const node = this.get(key, !0);
     if (identity.isCollection(node)) return node.deleteIn(rest);
     throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
    }
    getIn(path, keepScalar) {
     const [key, ...rest] = path, node = this.get(key, !0);
     return 0 === rest.length ? !keepScalar && identity.isScalar(node) ? node.value : node : identity.isCollection(node) ? node.getIn(rest, keepScalar) : void 0;
    }
    hasAllNullValues(allowScalar) {
     return this.items.every((node => {
      if (!identity.isPair(node)) return !1;
      const n = node.value;
      return null == n || allowScalar && identity.isScalar(n) && null == n.value && !n.commentBefore && !n.comment && !n.tag;
     }));
    }
    hasIn(path) {
     const [key, ...rest] = path;
     if (0 === rest.length) return this.has(key);
     const node = this.get(key, !0);
     return !!identity.isCollection(node) && node.hasIn(rest);
    }
    setIn(path, value) {
     const [key, ...rest] = path;
     if (0 === rest.length) this.set(key, value); else {
      const node = this.get(key, !0);
      if (identity.isCollection(node)) node.setIn(rest, value); else {
       if (void 0 !== node || !this.schema) throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
       this.set(key, collectionFromPath(this.schema, rest, value));
      }
     }
    }
   }
   exports.Collection = Collection, exports.collectionFromPath = collectionFromPath, 
   exports.isEmptyPath = isEmptyPath;
  },
  98898: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var applyReviver = __webpack_require__(86906), identity = __webpack_require__(70484), toJS = __webpack_require__(63732);
   exports.NodeBase = class {
    constructor(type) {
     Object.defineProperty(this, identity.NODE_TYPE, {
      value: type
     });
    }
    clone() {
     const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
     return this.range && (copy.range = this.range.slice()), copy;
    }
    toJS(doc, {mapAsMap, maxAliasCount, onAnchor, reviver} = {}) {
     if (!identity.isDocument(doc)) throw new TypeError("A document argument is required");
     const ctx = {
      anchors: new Map,
      doc,
      keep: !0,
      mapAsMap: !0 === mapAsMap,
      mapKeyWarned: !1,
      maxAliasCount: "number" == typeof maxAliasCount ? maxAliasCount : 100
     }, res = toJS.toJS(this, "", ctx);
     if ("function" == typeof onAnchor) for (const {count, res} of ctx.anchors.values()) onAnchor(res, count);
     return "function" == typeof reviver ? applyReviver.applyReviver(reviver, {
      "": res
     }, "", res) : res;
    }
   };
  },
  27902: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var createNode = __webpack_require__(95219), stringifyPair = __webpack_require__(8017), addPairToJSMap = __webpack_require__(35139), identity = __webpack_require__(70484);
   class Pair {
    constructor(key, value = null) {
     Object.defineProperty(this, identity.NODE_TYPE, {
      value: identity.PAIR
     }), this.key = key, this.value = value;
    }
    clone(schema) {
     let {key, value} = this;
     return identity.isNode(key) && (key = key.clone(schema)), identity.isNode(value) && (value = value.clone(schema)), 
     new Pair(key, value);
    }
    toJSON(_, ctx) {
     const pair = ctx?.mapAsMap ? new Map : {};
     return addPairToJSMap.addPairToJSMap(ctx, pair, this);
    }
    toString(ctx, onComment, onChompKeep) {
     return ctx?.doc ? stringifyPair.stringifyPair(this, ctx, onComment, onChompKeep) : JSON.stringify(this);
    }
   }
   exports.Pair = Pair, exports.createPair = function(key, value, ctx) {
    const k = createNode.createNode(key, void 0, ctx), v = createNode.createNode(value, void 0, ctx);
    return new Pair(k, v);
   };
  },
  89714: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var identity = __webpack_require__(70484), Node = __webpack_require__(98898), toJS = __webpack_require__(63732);
   class Scalar extends Node.NodeBase {
    constructor(value) {
     super(identity.SCALAR), this.value = value;
    }
    toJSON(arg, ctx) {
     return ctx?.keep ? this.value : toJS.toJS(this.value, arg, ctx);
    }
    toString() {
     return String(this.value);
    }
   }
   Scalar.BLOCK_FOLDED = "BLOCK_FOLDED", Scalar.BLOCK_LITERAL = "BLOCK_LITERAL", Scalar.PLAIN = "PLAIN", 
   Scalar.QUOTE_DOUBLE = "QUOTE_DOUBLE", Scalar.QUOTE_SINGLE = "QUOTE_SINGLE", exports.Scalar = Scalar, 
   exports.isScalarValue = value => !value || "function" != typeof value && "object" != typeof value;
  },
  81755: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var stringifyCollection = __webpack_require__(60081), addPairToJSMap = __webpack_require__(35139), Collection = __webpack_require__(21614), identity = __webpack_require__(70484), Pair = __webpack_require__(27902), Scalar = __webpack_require__(89714);
   function findPair(items, key) {
    const k = identity.isScalar(key) ? key.value : key;
    for (const it of items) if (identity.isPair(it)) {
     if (it.key === key || it.key === k) return it;
     if (identity.isScalar(it.key) && it.key.value === k) return it;
    }
   }
   class YAMLMap extends Collection.Collection {
    static get tagName() {
     return "tag:yaml.org,2002:map";
    }
    constructor(schema) {
     super(identity.MAP, schema), this.items = [];
    }
    static from(schema, obj, ctx) {
     const {keepUndefined, replacer} = ctx, map = new this(schema), add = (key, value) => {
      if ("function" == typeof replacer) value = replacer.call(obj, key, value); else if (Array.isArray(replacer) && !replacer.includes(key)) return;
      (void 0 !== value || keepUndefined) && map.items.push(Pair.createPair(key, value, ctx));
     };
     if (obj instanceof Map) for (const [key, value] of obj) add(key, value); else if (obj && "object" == typeof obj) for (const key of Object.keys(obj)) add(key, obj[key]);
     return "function" == typeof schema.sortMapEntries && map.items.sort(schema.sortMapEntries), 
     map;
    }
    add(pair, overwrite) {
     let _pair;
     _pair = identity.isPair(pair) ? pair : pair && "object" == typeof pair && "key" in pair ? new Pair.Pair(pair.key, pair.value) : new Pair.Pair(pair, pair?.value);
     const prev = findPair(this.items, _pair.key), sortEntries = this.schema?.sortMapEntries;
     if (prev) {
      if (!overwrite) throw new Error(`Key ${_pair.key} already set`);
      identity.isScalar(prev.value) && Scalar.isScalarValue(_pair.value) ? prev.value.value = _pair.value : prev.value = _pair.value;
     } else if (sortEntries) {
      const i = this.items.findIndex((item => sortEntries(_pair, item) < 0));
      -1 === i ? this.items.push(_pair) : this.items.splice(i, 0, _pair);
     } else this.items.push(_pair);
    }
    delete(key) {
     const it = findPair(this.items, key);
     if (!it) return !1;
     return this.items.splice(this.items.indexOf(it), 1).length > 0;
    }
    get(key, keepScalar) {
     const it = findPair(this.items, key), node = it?.value;
     return (!keepScalar && identity.isScalar(node) ? node.value : node) ?? void 0;
    }
    has(key) {
     return !!findPair(this.items, key);
    }
    set(key, value) {
     this.add(new Pair.Pair(key, value), !0);
    }
    toJSON(_, ctx, Type) {
     const map = Type ? new Type : ctx?.mapAsMap ? new Map : {};
     ctx?.onCreate && ctx.onCreate(map);
     for (const item of this.items) addPairToJSMap.addPairToJSMap(ctx, map, item);
     return map;
    }
    toString(ctx, onComment, onChompKeep) {
     if (!ctx) return JSON.stringify(this);
     for (const item of this.items) if (!identity.isPair(item)) throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
     return !ctx.allNullValues && this.hasAllNullValues(!1) && (ctx = Object.assign({}, ctx, {
      allNullValues: !0
     })), stringifyCollection.stringifyCollection(this, ctx, {
      blockItemPrefix: "",
      flowChars: {
       start: "{",
       end: "}"
      },
      itemIndent: ctx.indent || "",
      onChompKeep,
      onComment
     });
    }
   }
   exports.YAMLMap = YAMLMap, exports.findPair = findPair;
  },
  36010: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var createNode = __webpack_require__(95219), stringifyCollection = __webpack_require__(60081), Collection = __webpack_require__(21614), identity = __webpack_require__(70484), Scalar = __webpack_require__(89714), toJS = __webpack_require__(63732);
   class YAMLSeq extends Collection.Collection {
    static get tagName() {
     return "tag:yaml.org,2002:seq";
    }
    constructor(schema) {
     super(identity.SEQ, schema), this.items = [];
    }
    add(value) {
     this.items.push(value);
    }
    delete(key) {
     const idx = asItemIndex(key);
     if ("number" != typeof idx) return !1;
     return this.items.splice(idx, 1).length > 0;
    }
    get(key, keepScalar) {
     const idx = asItemIndex(key);
     if ("number" != typeof idx) return;
     const it = this.items[idx];
     return !keepScalar && identity.isScalar(it) ? it.value : it;
    }
    has(key) {
     const idx = asItemIndex(key);
     return "number" == typeof idx && idx < this.items.length;
    }
    set(key, value) {
     const idx = asItemIndex(key);
     if ("number" != typeof idx) throw new Error(`Expected a valid index, not ${key}.`);
     const prev = this.items[idx];
     identity.isScalar(prev) && Scalar.isScalarValue(value) ? prev.value = value : this.items[idx] = value;
    }
    toJSON(_, ctx) {
     const seq = [];
     ctx?.onCreate && ctx.onCreate(seq);
     let i = 0;
     for (const item of this.items) seq.push(toJS.toJS(item, String(i++), ctx));
     return seq;
    }
    toString(ctx, onComment, onChompKeep) {
     return ctx ? stringifyCollection.stringifyCollection(this, ctx, {
      blockItemPrefix: "- ",
      flowChars: {
       start: "[",
       end: "]"
      },
      itemIndent: (ctx.indent || "") + "  ",
      onChompKeep,
      onComment
     }) : JSON.stringify(this);
    }
    static from(schema, obj, ctx) {
     const {replacer} = ctx, seq = new this(schema);
     if (obj && Symbol.iterator in Object(obj)) {
      let i = 0;
      for (let it of obj) {
       if ("function" == typeof replacer) {
        const key = obj instanceof Set ? it : String(i++);
        it = replacer.call(obj, key, it);
       }
       seq.items.push(createNode.createNode(it, void 0, ctx));
      }
     }
     return seq;
    }
   }
   function asItemIndex(key) {
    let idx = identity.isScalar(key) ? key.value : key;
    return idx && "string" == typeof idx && (idx = Number(idx)), "number" == typeof idx && Number.isInteger(idx) && idx >= 0 ? idx : null;
   }
   exports.YAMLSeq = YAMLSeq;
  },
  35139: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var log = __webpack_require__(97444), stringify = __webpack_require__(93793), identity = __webpack_require__(70484), Scalar = __webpack_require__(89714), toJS = __webpack_require__(63732);
   const isMergeKey = key => "<<" === key || identity.isScalar(key) && "<<" === key.value && (!key.type || key.type === Scalar.Scalar.PLAIN);
   function mergeToJSMap(ctx, map, value) {
    const source = ctx && identity.isAlias(value) ? value.resolve(ctx.doc) : value;
    if (!identity.isMap(source)) throw new Error("Merge sources must be maps or map aliases");
    const srcMap = source.toJSON(null, ctx, Map);
    for (const [key, value] of srcMap) map instanceof Map ? map.has(key) || map.set(key, value) : map instanceof Set ? map.add(key) : Object.prototype.hasOwnProperty.call(map, key) || Object.defineProperty(map, key, {
     value,
     writable: !0,
     enumerable: !0,
     configurable: !0
    });
    return map;
   }
   exports.addPairToJSMap = function(ctx, map, {key, value}) {
    if (ctx?.doc.schema.merge && isMergeKey(key)) if (value = identity.isAlias(value) ? value.resolve(ctx.doc) : value, 
    identity.isSeq(value)) for (const it of value.items) mergeToJSMap(ctx, map, it); else if (Array.isArray(value)) for (const it of value) mergeToJSMap(ctx, map, it); else mergeToJSMap(ctx, map, value); else {
     const jsKey = toJS.toJS(key, "", ctx);
     if (map instanceof Map) map.set(jsKey, toJS.toJS(value, jsKey, ctx)); else if (map instanceof Set) map.add(jsKey); else {
      const stringKey = function(key, jsKey, ctx) {
       if (null === jsKey) return "";
       if ("object" != typeof jsKey) return String(jsKey);
       if (identity.isNode(key) && ctx?.doc) {
        const strCtx = stringify.createStringifyContext(ctx.doc, {});
        strCtx.anchors = new Set;
        for (const node of ctx.anchors.keys()) strCtx.anchors.add(node.anchor);
        strCtx.inFlow = !0, strCtx.inStringifyKey = !0;
        const strKey = key.toString(strCtx);
        if (!ctx.mapKeyWarned) {
         let jsonStr = JSON.stringify(strKey);
         jsonStr.length > 40 && (jsonStr = jsonStr.substring(0, 36) + '..."'), log.warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`), 
         ctx.mapKeyWarned = !0;
        }
        return strKey;
       }
       return JSON.stringify(jsKey);
      }(key, jsKey, ctx), jsValue = toJS.toJS(value, stringKey, ctx);
      stringKey in map ? Object.defineProperty(map, stringKey, {
       value: jsValue,
       writable: !0,
       enumerable: !0,
       configurable: !0
      }) : map[stringKey] = jsValue;
     }
    }
    return map;
   };
  },
  70484: (__unused_webpack_module, exports) => {
   "use strict";
   const ALIAS = Symbol.for("yaml.alias"), DOC = Symbol.for("yaml.document"), MAP = Symbol.for("yaml.map"), PAIR = Symbol.for("yaml.pair"), SCALAR = Symbol.for("yaml.scalar"), SEQ = Symbol.for("yaml.seq"), NODE_TYPE = Symbol.for("yaml.node.type"), isScalar = node => !!node && "object" == typeof node && node[NODE_TYPE] === SCALAR;
   function isCollection(node) {
    if (node && "object" == typeof node) switch (node[NODE_TYPE]) {
    case MAP:
    case SEQ:
     return !0;
    }
    return !1;
   }
   exports.ALIAS = ALIAS, exports.DOC = DOC, exports.MAP = MAP, exports.NODE_TYPE = NODE_TYPE, 
   exports.PAIR = PAIR, exports.SCALAR = SCALAR, exports.SEQ = SEQ, exports.hasAnchor = node => (isScalar(node) || isCollection(node)) && !!node.anchor, 
   exports.isAlias = node => !!node && "object" == typeof node && node[NODE_TYPE] === ALIAS, 
   exports.isCollection = isCollection, exports.isDocument = node => !!node && "object" == typeof node && node[NODE_TYPE] === DOC, 
   exports.isMap = node => !!node && "object" == typeof node && node[NODE_TYPE] === MAP, 
   exports.isNode = function(node) {
    if (node && "object" == typeof node) switch (node[NODE_TYPE]) {
    case ALIAS:
    case MAP:
    case SCALAR:
    case SEQ:
     return !0;
    }
    return !1;
   }, exports.isPair = node => !!node && "object" == typeof node && node[NODE_TYPE] === PAIR, 
   exports.isScalar = isScalar, exports.isSeq = node => !!node && "object" == typeof node && node[NODE_TYPE] === SEQ;
  },
  63732: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var identity = __webpack_require__(70484);
   exports.toJS = function toJS(value, arg, ctx) {
    if (Array.isArray(value)) return value.map(((v, i) => toJS(v, String(i), ctx)));
    if (value && "function" == typeof value.toJSON) {
     if (!ctx || !identity.hasAnchor(value)) return value.toJSON(arg, ctx);
     const data = {
      aliasCount: 0,
      count: 1,
      res: void 0
     };
     ctx.anchors.set(value, data), ctx.onCreate = res => {
      data.res = res, delete ctx.onCreate;
     };
     const res = value.toJSON(arg, ctx);
     return ctx.onCreate && ctx.onCreate(res), res;
    }
    return "bigint" != typeof value || ctx?.keep ? value : Number(value);
   };
  },
  65141: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var resolveBlockScalar = __webpack_require__(94070), resolveFlowScalar = __webpack_require__(27571), errors = __webpack_require__(44355), stringifyString = __webpack_require__(27180);
   function addEndtoBlockProps(props, end) {
    if (end) for (const st of end) switch (st.type) {
    case "space":
    case "comment":
     props.push(st);
     break;

    case "newline":
     return props.push(st), !0;
    }
    return !1;
   }
   function setFlowScalarValue(token, source, type) {
    switch (token.type) {
    case "scalar":
    case "double-quoted-scalar":
    case "single-quoted-scalar":
     token.type = type, token.source = source;
     break;

    case "block-scalar":
     {
      const end = token.props.slice(1);
      let oa = source.length;
      "block-scalar-header" === token.props[0].type && (oa -= token.props[0].source.length);
      for (const tok of end) tok.offset += oa;
      delete token.props, Object.assign(token, {
       type,
       source,
       end
      });
      break;
     }

    case "block-map":
    case "block-seq":
     {
      const nl = {
       type: "newline",
       offset: token.offset + source.length,
       indent: token.indent,
       source: "\n"
      };
      delete token.items, Object.assign(token, {
       type,
       source,
       end: [ nl ]
      });
      break;
     }

    default:
     {
      const indent = "indent" in token ? token.indent : -1, end = "end" in token && Array.isArray(token.end) ? token.end.filter((st => "space" === st.type || "comment" === st.type || "newline" === st.type)) : [];
      for (const key of Object.keys(token)) "type" !== key && "offset" !== key && delete token[key];
      Object.assign(token, {
       type,
       indent,
       source,
       end
      });
     }
    }
   }
   exports.createScalarToken = function(value, context) {
    const {implicitKey = !1, indent, inFlow = !1, offset = -1, type = "PLAIN"} = context, source = stringifyString.stringifyString({
     type,
     value
    }, {
     implicitKey,
     indent: indent > 0 ? " ".repeat(indent) : "",
     inFlow,
     options: {
      blockQuote: !0,
      lineWidth: -1
     }
    }), end = context.end ?? [ {
     type: "newline",
     offset: -1,
     indent,
     source: "\n"
    } ];
    switch (source[0]) {
    case "|":
    case ">":
     {
      const he = source.indexOf("\n"), head = source.substring(0, he), body = source.substring(he + 1) + "\n", props = [ {
       type: "block-scalar-header",
       offset,
       indent,
       source: head
      } ];
      return addEndtoBlockProps(props, end) || props.push({
       type: "newline",
       offset: -1,
       indent,
       source: "\n"
      }), {
       type: "block-scalar",
       offset,
       indent,
       props,
       source: body
      };
     }

    case '"':
     return {
      type: "double-quoted-scalar",
      offset,
      indent,
      source,
      end
     };

    case "'":
     return {
      type: "single-quoted-scalar",
      offset,
      indent,
      source,
      end
     };

    default:
     return {
      type: "scalar",
      offset,
      indent,
      source,
      end
     };
    }
   }, exports.resolveAsScalar = function(token, strict = !0, onError) {
    if (token) {
     const _onError = (pos, code, message) => {
      const offset = "number" == typeof pos ? pos : Array.isArray(pos) ? pos[0] : pos.offset;
      if (!onError) throw new errors.YAMLParseError([ offset, offset + 1 ], code, message);
      onError(offset, code, message);
     };
     switch (token.type) {
     case "scalar":
     case "single-quoted-scalar":
     case "double-quoted-scalar":
      return resolveFlowScalar.resolveFlowScalar(token, strict, _onError);

     case "block-scalar":
      return resolveBlockScalar.resolveBlockScalar({
       options: {
        strict
       }
      }, token, _onError);
     }
    }
    return null;
   }, exports.setScalarValue = function(token, value, context = {}) {
    let {afterKey = !1, implicitKey = !1, inFlow = !1, type} = context, indent = "indent" in token ? token.indent : null;
    if (afterKey && "number" == typeof indent && (indent += 2), !type) switch (token.type) {
    case "single-quoted-scalar":
     type = "QUOTE_SINGLE";
     break;

    case "double-quoted-scalar":
     type = "QUOTE_DOUBLE";
     break;

    case "block-scalar":
     {
      const header = token.props[0];
      if ("block-scalar-header" !== header.type) throw new Error("Invalid block scalar header");
      type = ">" === header.source[0] ? "BLOCK_FOLDED" : "BLOCK_LITERAL";
      break;
     }

    default:
     type = "PLAIN";
    }
    const source = stringifyString.stringifyString({
     type,
     value
    }, {
     implicitKey: implicitKey || null === indent,
     indent: null !== indent && indent > 0 ? " ".repeat(indent) : "",
     inFlow,
     options: {
      blockQuote: !0,
      lineWidth: -1
     }
    });
    switch (source[0]) {
    case "|":
    case ">":
     !function(token, source) {
      const he = source.indexOf("\n"), head = source.substring(0, he), body = source.substring(he + 1) + "\n";
      if ("block-scalar" === token.type) {
       const header = token.props[0];
       if ("block-scalar-header" !== header.type) throw new Error("Invalid block scalar header");
       header.source = head, token.source = body;
      } else {
       const {offset} = token, indent = "indent" in token ? token.indent : -1, props = [ {
        type: "block-scalar-header",
        offset,
        indent,
        source: head
       } ];
       addEndtoBlockProps(props, "end" in token ? token.end : void 0) || props.push({
        type: "newline",
        offset: -1,
        indent,
        source: "\n"
       });
       for (const key of Object.keys(token)) "type" !== key && "offset" !== key && delete token[key];
       Object.assign(token, {
        type: "block-scalar",
        indent,
        props,
        source: body
       });
      }
     }(token, source);
     break;

    case '"':
     setFlowScalarValue(token, source, "double-quoted-scalar");
     break;

    case "'":
     setFlowScalarValue(token, source, "single-quoted-scalar");
     break;

    default:
     setFlowScalarValue(token, source, "scalar");
    }
   };
  },
  67808: (__unused_webpack_module, exports) => {
   "use strict";
   function stringifyToken(token) {
    switch (token.type) {
    case "block-scalar":
     {
      let res = "";
      for (const tok of token.props) res += stringifyToken(tok);
      return res + token.source;
     }

    case "block-map":
    case "block-seq":
     {
      let res = "";
      for (const item of token.items) res += stringifyItem(item);
      return res;
     }

    case "flow-collection":
     {
      let res = token.start.source;
      for (const item of token.items) res += stringifyItem(item);
      for (const st of token.end) res += st.source;
      return res;
     }

    case "document":
     {
      let res = stringifyItem(token);
      if (token.end) for (const st of token.end) res += st.source;
      return res;
     }

    default:
     {
      let res = token.source;
      if ("end" in token && token.end) for (const st of token.end) res += st.source;
      return res;
     }
    }
   }
   function stringifyItem({start, key, sep, value}) {
    let res = "";
    for (const st of start) res += st.source;
    if (key && (res += stringifyToken(key)), sep) for (const st of sep) res += st.source;
    return value && (res += stringifyToken(value)), res;
   }
   exports.stringify = cst => "type" in cst ? stringifyToken(cst) : stringifyItem(cst);
  },
  95970: (__unused_webpack_module, exports) => {
   "use strict";
   const BREAK = Symbol("break visit"), SKIP = Symbol("skip children"), REMOVE = Symbol("remove item");
   function visit(cst, visitor) {
    "type" in cst && "document" === cst.type && (cst = {
     start: cst.start,
     value: cst.value
    }), _visit(Object.freeze([]), cst, visitor);
   }
   function _visit(path, item, visitor) {
    let ctrl = visitor(item, path);
    if ("symbol" == typeof ctrl) return ctrl;
    for (const field of [ "key", "value" ]) {
     const token = item[field];
     if (token && "items" in token) {
      for (let i = 0; i < token.items.length; ++i) {
       const ci = _visit(Object.freeze(path.concat([ [ field, i ] ])), token.items[i], visitor);
       if ("number" == typeof ci) i = ci - 1; else {
        if (ci === BREAK) return BREAK;
        ci === REMOVE && (token.items.splice(i, 1), i -= 1);
       }
      }
      "function" == typeof ctrl && "key" === field && (ctrl = ctrl(item, path));
     }
    }
    return "function" == typeof ctrl ? ctrl(item, path) : ctrl;
   }
   visit.BREAK = BREAK, visit.SKIP = SKIP, visit.REMOVE = REMOVE, visit.itemAtPath = (cst, path) => {
    let item = cst;
    for (const [field, index] of path) {
     const tok = item?.[field];
     if (!tok || !("items" in tok)) return;
     item = tok.items[index];
    }
    return item;
   }, visit.parentCollection = (cst, path) => {
    const parent = visit.itemAtPath(cst, path.slice(0, -1)), field = path[path.length - 1][0], coll = parent?.[field];
    if (coll && "items" in coll) return coll;
    throw new Error("Parent collection not found");
   }, exports.visit = visit;
  },
  29112: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var cstScalar = __webpack_require__(65141), cstStringify = __webpack_require__(67808), cstVisit = __webpack_require__(95970);
   exports.createScalarToken = cstScalar.createScalarToken, exports.resolveAsScalar = cstScalar.resolveAsScalar, 
   exports.setScalarValue = cstScalar.setScalarValue, exports.stringify = cstStringify.stringify, 
   exports.visit = cstVisit.visit, exports.BOM = "\ufeff", exports.DOCUMENT = "", 
   exports.FLOW_END = "", exports.SCALAR = "", exports.isCollection = token => !!token && "items" in token, 
   exports.isScalar = token => !!token && ("scalar" === token.type || "single-quoted-scalar" === token.type || "double-quoted-scalar" === token.type || "block-scalar" === token.type), 
   exports.prettyToken = function(token) {
    switch (token) {
    case "\ufeff":
     return "<BOM>";

    case "":
     return "<DOC>";

    case "":
     return "<FLOW_END>";

    case "":
     return "<SCALAR>";

    default:
     return JSON.stringify(token);
    }
   }, exports.tokenType = function(source) {
    switch (source) {
    case "\ufeff":
     return "byte-order-mark";

    case "":
     return "doc-mode";

    case "":
     return "flow-error-end";

    case "":
     return "scalar";

    case "---":
     return "doc-start";

    case "...":
     return "doc-end";

    case "":
    case "\n":
    case "\r\n":
     return "newline";

    case "-":
     return "seq-item-ind";

    case "?":
     return "explicit-key-ind";

    case ":":
     return "map-value-ind";

    case "{":
     return "flow-map-start";

    case "}":
     return "flow-map-end";

    case "[":
     return "flow-seq-start";

    case "]":
     return "flow-seq-end";

    case ",":
     return "comma";
    }
    switch (source[0]) {
    case " ":
    case "\t":
     return "space";

    case "#":
     return "comment";

    case "%":
     return "directive-line";

    case "*":
     return "alias";

    case "&":
     return "anchor";

    case "!":
     return "tag";

    case "'":
     return "single-quoted-scalar";

    case '"':
     return "double-quoted-scalar";

    case "|":
    case ">":
     return "block-scalar-header";
    }
    return null;
   };
  },
  5752: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var cst = __webpack_require__(29112);
   function isEmpty(ch) {
    switch (ch) {
    case void 0:
    case " ":
    case "\n":
    case "\r":
    case "\t":
     return !0;

    default:
     return !1;
    }
   }
   const hexDigits = new Set("0123456789ABCDEFabcdef"), tagChars = new Set("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()"), flowIndicatorChars = new Set(",[]{}"), invalidAnchorChars = new Set(" ,[]{}\n\r\t"), isNotAnchorChar = ch => !ch || invalidAnchorChars.has(ch);
   exports.Lexer = class {
    constructor() {
     this.atEnd = !1, this.blockScalarIndent = -1, this.blockScalarKeep = !1, this.buffer = "", 
     this.flowKey = !1, this.flowLevel = 0, this.indentNext = 0, this.indentValue = 0, 
     this.lineEndPos = null, this.next = null, this.pos = 0;
    }
    * lex(source, incomplete = !1) {
     if (source) {
      if ("string" != typeof source) throw TypeError("source is not a string");
      this.buffer = this.buffer ? this.buffer + source : source, this.lineEndPos = null;
     }
     this.atEnd = !incomplete;
     let next = this.next ?? "stream";
     for (;next && (incomplete || this.hasChars(1)); ) next = yield* this.parseNext(next);
    }
    atLineEnd() {
     let i = this.pos, ch = this.buffer[i];
     for (;" " === ch || "\t" === ch; ) ch = this.buffer[++i];
     return !ch || "#" === ch || "\n" === ch || "\r" === ch && "\n" === this.buffer[i + 1];
    }
    charAt(n) {
     return this.buffer[this.pos + n];
    }
    continueScalar(offset) {
     let ch = this.buffer[offset];
     if (this.indentNext > 0) {
      let indent = 0;
      for (;" " === ch; ) ch = this.buffer[++indent + offset];
      if ("\r" === ch) {
       const next = this.buffer[indent + offset + 1];
       if ("\n" === next || !next && !this.atEnd) return offset + indent + 1;
      }
      return "\n" === ch || indent >= this.indentNext || !ch && !this.atEnd ? offset + indent : -1;
     }
     if ("-" === ch || "." === ch) {
      const dt = this.buffer.substr(offset, 3);
      if (("---" === dt || "..." === dt) && isEmpty(this.buffer[offset + 3])) return -1;
     }
     return offset;
    }
    getLine() {
     let end = this.lineEndPos;
     return ("number" != typeof end || -1 !== end && end < this.pos) && (end = this.buffer.indexOf("\n", this.pos), 
     this.lineEndPos = end), -1 === end ? this.atEnd ? this.buffer.substring(this.pos) : null : ("\r" === this.buffer[end - 1] && (end -= 1), 
     this.buffer.substring(this.pos, end));
    }
    hasChars(n) {
     return this.pos + n <= this.buffer.length;
    }
    setNext(state) {
     return this.buffer = this.buffer.substring(this.pos), this.pos = 0, this.lineEndPos = null, 
     this.next = state, null;
    }
    peek(n) {
     return this.buffer.substr(this.pos, n);
    }
    * parseNext(next) {
     switch (next) {
     case "stream":
      return yield* this.parseStream();

     case "line-start":
      return yield* this.parseLineStart();

     case "block-start":
      return yield* this.parseBlockStart();

     case "doc":
      return yield* this.parseDocument();

     case "flow":
      return yield* this.parseFlowCollection();

     case "quoted-scalar":
      return yield* this.parseQuotedScalar();

     case "block-scalar":
      return yield* this.parseBlockScalar();

     case "plain-scalar":
      return yield* this.parsePlainScalar();
     }
    }
    * parseStream() {
     let line = this.getLine();
     if (null === line) return this.setNext("stream");
     if (line[0] === cst.BOM && (yield* this.pushCount(1), line = line.substring(1)), 
     "%" === line[0]) {
      let dirEnd = line.length, cs = line.indexOf("#");
      for (;-1 !== cs; ) {
       const ch = line[cs - 1];
       if (" " === ch || "\t" === ch) {
        dirEnd = cs - 1;
        break;
       }
       cs = line.indexOf("#", cs + 1);
      }
      for (;;) {
       const ch = line[dirEnd - 1];
       if (" " !== ch && "\t" !== ch) break;
       dirEnd -= 1;
      }
      const n = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(!0));
      return yield* this.pushCount(line.length - n), this.pushNewline(), "stream";
     }
     if (this.atLineEnd()) {
      const sp = yield* this.pushSpaces(!0);
      return yield* this.pushCount(line.length - sp), yield* this.pushNewline(), "stream";
     }
     return yield cst.DOCUMENT, yield* this.parseLineStart();
    }
    * parseLineStart() {
     const ch = this.charAt(0);
     if (!ch && !this.atEnd) return this.setNext("line-start");
     if ("-" === ch || "." === ch) {
      if (!this.atEnd && !this.hasChars(4)) return this.setNext("line-start");
      const s = this.peek(3);
      if (("---" === s || "..." === s) && isEmpty(this.charAt(3))) return yield* this.pushCount(3), 
      this.indentValue = 0, this.indentNext = 0, "---" === s ? "doc" : "stream";
     }
     return this.indentValue = yield* this.pushSpaces(!1), this.indentNext > this.indentValue && !isEmpty(this.charAt(1)) && (this.indentNext = this.indentValue), 
     yield* this.parseBlockStart();
    }
    * parseBlockStart() {
     const [ch0, ch1] = this.peek(2);
     if (!ch1 && !this.atEnd) return this.setNext("block-start");
     if (("-" === ch0 || "?" === ch0 || ":" === ch0) && isEmpty(ch1)) {
      const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(!0));
      return this.indentNext = this.indentValue + 1, this.indentValue += n, yield* this.parseBlockStart();
     }
     return "doc";
    }
    * parseDocument() {
     yield* this.pushSpaces(!0);
     const line = this.getLine();
     if (null === line) return this.setNext("doc");
     let n = yield* this.pushIndicators();
     switch (line[n]) {
     case "#":
      yield* this.pushCount(line.length - n);

     case void 0:
      return yield* this.pushNewline(), yield* this.parseLineStart();

     case "{":
     case "[":
      return yield* this.pushCount(1), this.flowKey = !1, this.flowLevel = 1, "flow";

     case "}":
     case "]":
      return yield* this.pushCount(1), "doc";

     case "*":
      return yield* this.pushUntil(isNotAnchorChar), "doc";

     case '"':
     case "'":
      return yield* this.parseQuotedScalar();

     case "|":
     case ">":
      return n += (yield* this.parseBlockScalarHeader()), n += (yield* this.pushSpaces(!0)), 
      yield* this.pushCount(line.length - n), yield* this.pushNewline(), yield* this.parseBlockScalar();

     default:
      return yield* this.parsePlainScalar();
     }
    }
    * parseFlowCollection() {
     let nl, sp, indent = -1;
     do {
      nl = yield* this.pushNewline(), nl > 0 ? (sp = yield* this.pushSpaces(!1), this.indentValue = indent = sp) : sp = 0, 
      sp += (yield* this.pushSpaces(!0));
     } while (nl + sp > 0);
     const line = this.getLine();
     if (null === line) return this.setNext("flow");
     if (-1 !== indent && indent < this.indentNext && "#" !== line[0] || 0 === indent && (line.startsWith("---") || line.startsWith("...")) && isEmpty(line[3])) {
      if (!(indent === this.indentNext - 1 && 1 === this.flowLevel && ("]" === line[0] || "}" === line[0]))) return this.flowLevel = 0, 
      yield cst.FLOW_END, yield* this.parseLineStart();
     }
     let n = 0;
     for (;"," === line[n]; ) n += (yield* this.pushCount(1)), n += (yield* this.pushSpaces(!0)), 
     this.flowKey = !1;
     switch (n += (yield* this.pushIndicators()), line[n]) {
     case void 0:
      return "flow";

     case "#":
      return yield* this.pushCount(line.length - n), "flow";

     case "{":
     case "[":
      return yield* this.pushCount(1), this.flowKey = !1, this.flowLevel += 1, "flow";

     case "}":
     case "]":
      return yield* this.pushCount(1), this.flowKey = !0, this.flowLevel -= 1, this.flowLevel ? "flow" : "doc";

     case "*":
      return yield* this.pushUntil(isNotAnchorChar), "flow";

     case '"':
     case "'":
      return this.flowKey = !0, yield* this.parseQuotedScalar();

     case ":":
      {
       const next = this.charAt(1);
       if (this.flowKey || isEmpty(next) || "," === next) return this.flowKey = !1, yield* this.pushCount(1), 
       yield* this.pushSpaces(!0), "flow";
      }

     default:
      return this.flowKey = !1, yield* this.parsePlainScalar();
     }
    }
    * parseQuotedScalar() {
     const quote = this.charAt(0);
     let end = this.buffer.indexOf(quote, this.pos + 1);
     if ("'" === quote) for (;-1 !== end && "'" === this.buffer[end + 1]; ) end = this.buffer.indexOf("'", end + 2); else for (;-1 !== end; ) {
      let n = 0;
      for (;"\\" === this.buffer[end - 1 - n]; ) n += 1;
      if (n % 2 == 0) break;
      end = this.buffer.indexOf('"', end + 1);
     }
     const qb = this.buffer.substring(0, end);
     let nl = qb.indexOf("\n", this.pos);
     if (-1 !== nl) {
      for (;-1 !== nl; ) {
       const cs = this.continueScalar(nl + 1);
       if (-1 === cs) break;
       nl = qb.indexOf("\n", cs);
      }
      -1 !== nl && (end = nl - ("\r" === qb[nl - 1] ? 2 : 1));
     }
     if (-1 === end) {
      if (!this.atEnd) return this.setNext("quoted-scalar");
      end = this.buffer.length;
     }
     return yield* this.pushToIndex(end + 1, !1), this.flowLevel ? "flow" : "doc";
    }
    * parseBlockScalarHeader() {
     this.blockScalarIndent = -1, this.blockScalarKeep = !1;
     let i = this.pos;
     for (;;) {
      const ch = this.buffer[++i];
      if ("+" === ch) this.blockScalarKeep = !0; else if (ch > "0" && ch <= "9") this.blockScalarIndent = Number(ch) - 1; else if ("-" !== ch) break;
     }
     return yield* this.pushUntil((ch => isEmpty(ch) || "#" === ch));
    }
    * parseBlockScalar() {
     let ch, nl = this.pos - 1, indent = 0;
     loop: for (let i = this.pos; ch = this.buffer[i]; ++i) switch (ch) {
     case " ":
      indent += 1;
      break;

     case "\n":
      nl = i, indent = 0;
      break;

     case "\r":
      {
       const next = this.buffer[i + 1];
       if (!next && !this.atEnd) return this.setNext("block-scalar");
       if ("\n" === next) break;
      }

     default:
      break loop;
     }
     if (!ch && !this.atEnd) return this.setNext("block-scalar");
     if (indent >= this.indentNext) {
      -1 === this.blockScalarIndent ? this.indentNext = indent : this.indentNext = this.blockScalarIndent + (0 === this.indentNext ? 1 : this.indentNext);
      do {
       const cs = this.continueScalar(nl + 1);
       if (-1 === cs) break;
       nl = this.buffer.indexOf("\n", cs);
      } while (-1 !== nl);
      if (-1 === nl) {
       if (!this.atEnd) return this.setNext("block-scalar");
       nl = this.buffer.length;
      }
     }
     let i = nl + 1;
     for (ch = this.buffer[i]; " " === ch; ) ch = this.buffer[++i];
     if ("\t" === ch) {
      for (;"\t" === ch || " " === ch || "\r" === ch || "\n" === ch; ) ch = this.buffer[++i];
      nl = i - 1;
     } else if (!this.blockScalarKeep) for (;;) {
      let i = nl - 1, ch = this.buffer[i];
      "\r" === ch && (ch = this.buffer[--i]);
      const lastChar = i;
      for (;" " === ch; ) ch = this.buffer[--i];
      if (!("\n" === ch && i >= this.pos && i + 1 + indent > lastChar)) break;
      nl = i;
     }
     return yield cst.SCALAR, yield* this.pushToIndex(nl + 1, !0), yield* this.parseLineStart();
    }
    * parsePlainScalar() {
     const inFlow = this.flowLevel > 0;
     let ch, end = this.pos - 1, i = this.pos - 1;
     for (;ch = this.buffer[++i]; ) if (":" === ch) {
      const next = this.buffer[i + 1];
      if (isEmpty(next) || inFlow && flowIndicatorChars.has(next)) break;
      end = i;
     } else if (isEmpty(ch)) {
      let next = this.buffer[i + 1];
      if ("\r" === ch && ("\n" === next ? (i += 1, ch = "\n", next = this.buffer[i + 1]) : end = i), 
      "#" === next || inFlow && flowIndicatorChars.has(next)) break;
      if ("\n" === ch) {
       const cs = this.continueScalar(i + 1);
       if (-1 === cs) break;
       i = Math.max(i, cs - 2);
      }
     } else {
      if (inFlow && flowIndicatorChars.has(ch)) break;
      end = i;
     }
     return ch || this.atEnd ? (yield cst.SCALAR, yield* this.pushToIndex(end + 1, !0), 
     inFlow ? "flow" : "doc") : this.setNext("plain-scalar");
    }
    * pushCount(n) {
     return n > 0 ? (yield this.buffer.substr(this.pos, n), this.pos += n, n) : 0;
    }
    * pushToIndex(i, allowEmpty) {
     const s = this.buffer.slice(this.pos, i);
     return s ? (yield s, this.pos += s.length, s.length) : (allowEmpty && (yield ""), 
     0);
    }
    * pushIndicators() {
     switch (this.charAt(0)) {
     case "!":
      return (yield* this.pushTag()) + (yield* this.pushSpaces(!0)) + (yield* this.pushIndicators());

     case "&":
      return (yield* this.pushUntil(isNotAnchorChar)) + (yield* this.pushSpaces(!0)) + (yield* this.pushIndicators());

     case "-":
     case "?":
     case ":":
      {
       const inFlow = this.flowLevel > 0, ch1 = this.charAt(1);
       if (isEmpty(ch1) || inFlow && flowIndicatorChars.has(ch1)) return inFlow ? this.flowKey && (this.flowKey = !1) : this.indentNext = this.indentValue + 1, 
       (yield* this.pushCount(1)) + (yield* this.pushSpaces(!0)) + (yield* this.pushIndicators());
      }
     }
     return 0;
    }
    * pushTag() {
     if ("<" === this.charAt(1)) {
      let i = this.pos + 2, ch = this.buffer[i];
      for (;!isEmpty(ch) && ">" !== ch; ) ch = this.buffer[++i];
      return yield* this.pushToIndex(">" === ch ? i + 1 : i, !1);
     }
     {
      let i = this.pos + 1, ch = this.buffer[i];
      for (;ch; ) if (tagChars.has(ch)) ch = this.buffer[++i]; else {
       if ("%" !== ch || !hexDigits.has(this.buffer[i + 1]) || !hexDigits.has(this.buffer[i + 2])) break;
       ch = this.buffer[i += 3];
      }
      return yield* this.pushToIndex(i, !1);
     }
    }
    * pushNewline() {
     const ch = this.buffer[this.pos];
     return "\n" === ch ? yield* this.pushCount(1) : "\r" === ch && "\n" === this.charAt(1) ? yield* this.pushCount(2) : 0;
    }
    * pushSpaces(allowTabs) {
     let ch, i = this.pos - 1;
     do {
      ch = this.buffer[++i];
     } while (" " === ch || allowTabs && "\t" === ch);
     const n = i - this.pos;
     return n > 0 && (yield this.buffer.substr(this.pos, n), this.pos = i), n;
    }
    * pushUntil(test) {
     let i = this.pos, ch = this.buffer[i];
     for (;!test(ch); ) ch = this.buffer[++i];
     return yield* this.pushToIndex(i, !1);
    }
   };
  },
  40483: (__unused_webpack_module, exports) => {
   "use strict";
   exports.LineCounter = class {
    constructor() {
     this.lineStarts = [], this.addNewLine = offset => this.lineStarts.push(offset), 
     this.linePos = offset => {
      let low = 0, high = this.lineStarts.length;
      for (;low < high; ) {
       const mid = low + high >> 1;
       this.lineStarts[mid] < offset ? low = mid + 1 : high = mid;
      }
      if (this.lineStarts[low] === offset) return {
       line: low + 1,
       col: 1
      };
      if (0 === low) return {
       line: 0,
       col: offset
      };
      return {
       line: low,
       col: offset - this.lineStarts[low - 1] + 1
      };
     };
    }
   };
  },
  36247: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var cst = __webpack_require__(29112), lexer = __webpack_require__(5752);
   function includesToken(list, type) {
    for (let i = 0; i < list.length; ++i) if (list[i].type === type) return !0;
    return !1;
   }
   function findNonEmptyIndex(list) {
    for (let i = 0; i < list.length; ++i) switch (list[i].type) {
    case "space":
    case "comment":
    case "newline":
     break;

    default:
     return i;
    }
    return -1;
   }
   function isFlowToken(token) {
    switch (token?.type) {
    case "alias":
    case "scalar":
    case "single-quoted-scalar":
    case "double-quoted-scalar":
    case "flow-collection":
     return !0;

    default:
     return !1;
    }
   }
   function getPrevProps(parent) {
    switch (parent.type) {
    case "document":
     return parent.start;

    case "block-map":
     {
      const it = parent.items[parent.items.length - 1];
      return it.sep ?? it.start;
     }

    case "block-seq":
     return parent.items[parent.items.length - 1].start;

    default:
     return [];
    }
   }
   function getFirstKeyStartProps(prev) {
    if (0 === prev.length) return [];
    let i = prev.length;
    loop: for (;--i >= 0; ) switch (prev[i].type) {
    case "doc-start":
    case "explicit-key-ind":
    case "map-value-ind":
    case "seq-item-ind":
    case "newline":
     break loop;
    }
    for (;"space" === prev[++i]?.type; ) ;
    return prev.splice(i, prev.length);
   }
   function fixFlowSeqItems(fc) {
    if ("flow-seq-start" === fc.start.type) for (const it of fc.items) !it.sep || it.value || includesToken(it.start, "explicit-key-ind") || includesToken(it.sep, "map-value-ind") || (it.key && (it.value = it.key), 
    delete it.key, isFlowToken(it.value) ? it.value.end ? Array.prototype.push.apply(it.value.end, it.sep) : it.value.end = it.sep : Array.prototype.push.apply(it.start, it.sep), 
    delete it.sep);
   }
   exports.Parser = class {
    constructor(onNewLine) {
     this.atNewLine = !0, this.atScalar = !1, this.indent = 0, this.offset = 0, this.onKeyLine = !1, 
     this.stack = [], this.source = "", this.type = "", this.lexer = new lexer.Lexer, 
     this.onNewLine = onNewLine;
    }
    * parse(source, incomplete = !1) {
     this.onNewLine && 0 === this.offset && this.onNewLine(0);
     for (const lexeme of this.lexer.lex(source, incomplete)) yield* this.next(lexeme);
     incomplete || (yield* this.end());
    }
    * next(source) {
     if (this.source = source, process.env.LOG_TOKENS && console.log("|", cst.prettyToken(source)), 
     this.atScalar) return this.atScalar = !1, yield* this.step(), void (this.offset += source.length);
     const type = cst.tokenType(source);
     if (type) if ("scalar" === type) this.atNewLine = !1, this.atScalar = !0, this.type = "scalar"; else {
      switch (this.type = type, yield* this.step(), type) {
      case "newline":
       this.atNewLine = !0, this.indent = 0, this.onNewLine && this.onNewLine(this.offset + source.length);
       break;

      case "space":
       this.atNewLine && " " === source[0] && (this.indent += source.length);
       break;

      case "explicit-key-ind":
      case "map-value-ind":
      case "seq-item-ind":
       this.atNewLine && (this.indent += source.length);
       break;

      case "doc-mode":
      case "flow-error-end":
       return;

      default:
       this.atNewLine = !1;
      }
      this.offset += source.length;
     } else {
      const message = `Not a YAML token: ${source}`;
      yield* this.pop({
       type: "error",
       offset: this.offset,
       message,
       source
      }), this.offset += source.length;
     }
    }
    * end() {
     for (;this.stack.length > 0; ) yield* this.pop();
    }
    get sourceToken() {
     return {
      type: this.type,
      offset: this.offset,
      indent: this.indent,
      source: this.source
     };
    }
    * step() {
     const top = this.peek(1);
     if ("doc-end" !== this.type || top && "doc-end" === top.type) {
      if (!top) return yield* this.stream();
      switch (top.type) {
      case "document":
       return yield* this.document(top);

      case "alias":
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
       return yield* this.scalar(top);

      case "block-scalar":
       return yield* this.blockScalar(top);

      case "block-map":
       return yield* this.blockMap(top);

      case "block-seq":
       return yield* this.blockSequence(top);

      case "flow-collection":
       return yield* this.flowCollection(top);

      case "doc-end":
       return yield* this.documentEnd(top);
      }
      yield* this.pop();
     } else {
      for (;this.stack.length > 0; ) yield* this.pop();
      this.stack.push({
       type: "doc-end",
       offset: this.offset,
       source: this.source
      });
     }
    }
    peek(n) {
     return this.stack[this.stack.length - n];
    }
    * pop(error) {
     const token = error ?? this.stack.pop();
     if (token) if (0 === this.stack.length) yield token; else {
      const top = this.peek(1);
      switch ("block-scalar" === token.type ? token.indent = "indent" in top ? top.indent : 0 : "flow-collection" === token.type && "document" === top.type && (token.indent = 0), 
      "flow-collection" === token.type && fixFlowSeqItems(token), top.type) {
      case "document":
       top.value = token;
       break;

      case "block-scalar":
       top.props.push(token);
       break;

      case "block-map":
       {
        const it = top.items[top.items.length - 1];
        if (it.value) return top.items.push({
         start: [],
         key: token,
         sep: []
        }), void (this.onKeyLine = !0);
        if (!it.sep) return Object.assign(it, {
         key: token,
         sep: []
        }), void (this.onKeyLine = !it.explicitKey);
        it.value = token;
        break;
       }

      case "block-seq":
       {
        const it = top.items[top.items.length - 1];
        it.value ? top.items.push({
         start: [],
         value: token
        }) : it.value = token;
        break;
       }

      case "flow-collection":
       {
        const it = top.items[top.items.length - 1];
        return void (!it || it.value ? top.items.push({
         start: [],
         key: token,
         sep: []
        }) : it.sep ? it.value = token : Object.assign(it, {
         key: token,
         sep: []
        }));
       }

      default:
       yield* this.pop(), yield* this.pop(token);
      }
      if (!("document" !== top.type && "block-map" !== top.type && "block-seq" !== top.type || "block-map" !== token.type && "block-seq" !== token.type)) {
       const last = token.items[token.items.length - 1];
       last && !last.sep && !last.value && last.start.length > 0 && -1 === findNonEmptyIndex(last.start) && (0 === token.indent || last.start.every((st => "comment" !== st.type || st.indent < token.indent))) && ("document" === top.type ? top.end = last.start : top.items.push({
        start: last.start
       }), token.items.splice(-1, 1));
      }
     } else {
      const message = "Tried to pop an empty stack";
      yield {
       type: "error",
       offset: this.offset,
       source: "",
       message
      };
     }
    }
    * stream() {
     switch (this.type) {
     case "directive-line":
      return void (yield {
       type: "directive",
       offset: this.offset,
       source: this.source
      });

     case "byte-order-mark":
     case "space":
     case "comment":
     case "newline":
      return void (yield this.sourceToken);

     case "doc-mode":
     case "doc-start":
      {
       const doc = {
        type: "document",
        offset: this.offset,
        start: []
       };
       return "doc-start" === this.type && doc.start.push(this.sourceToken), void this.stack.push(doc);
      }
     }
     yield {
      type: "error",
      offset: this.offset,
      message: `Unexpected ${this.type} token in YAML stream`,
      source: this.source
     };
    }
    * document(doc) {
     if (doc.value) return yield* this.lineEnd(doc);
     switch (this.type) {
     case "doc-start":
      return void (-1 !== findNonEmptyIndex(doc.start) ? (yield* this.pop(), yield* this.step()) : doc.start.push(this.sourceToken));

     case "anchor":
     case "tag":
     case "space":
     case "comment":
     case "newline":
      return void doc.start.push(this.sourceToken);
     }
     const bv = this.startBlockValue(doc);
     bv ? this.stack.push(bv) : yield {
      type: "error",
      offset: this.offset,
      message: `Unexpected ${this.type} token in YAML document`,
      source: this.source
     };
    }
    * scalar(scalar) {
     if ("map-value-ind" === this.type) {
      const start = getFirstKeyStartProps(getPrevProps(this.peek(2)));
      let sep;
      scalar.end ? (sep = scalar.end, sep.push(this.sourceToken), delete scalar.end) : sep = [ this.sourceToken ];
      const map = {
       type: "block-map",
       offset: scalar.offset,
       indent: scalar.indent,
       items: [ {
        start,
        key: scalar,
        sep
       } ]
      };
      this.onKeyLine = !0, this.stack[this.stack.length - 1] = map;
     } else yield* this.lineEnd(scalar);
    }
    * blockScalar(scalar) {
     switch (this.type) {
     case "space":
     case "comment":
     case "newline":
      return void scalar.props.push(this.sourceToken);

     case "scalar":
      if (scalar.source = this.source, this.atNewLine = !0, this.indent = 0, this.onNewLine) {
       let nl = this.source.indexOf("\n") + 1;
       for (;0 !== nl; ) this.onNewLine(this.offset + nl), nl = this.source.indexOf("\n", nl) + 1;
      }
      yield* this.pop();
      break;

     default:
      yield* this.pop(), yield* this.step();
     }
    }
    * blockMap(map) {
     const it = map.items[map.items.length - 1];
     switch (this.type) {
     case "newline":
      if (this.onKeyLine = !1, it.value) {
       const end = "end" in it.value ? it.value.end : void 0, last = Array.isArray(end) ? end[end.length - 1] : void 0;
       "comment" === last?.type ? end?.push(this.sourceToken) : map.items.push({
        start: [ this.sourceToken ]
       });
      } else it.sep ? it.sep.push(this.sourceToken) : it.start.push(this.sourceToken);
      return;

     case "space":
     case "comment":
      if (it.value) map.items.push({
       start: [ this.sourceToken ]
      }); else if (it.sep) it.sep.push(this.sourceToken); else {
       if (this.atIndentedComment(it.start, map.indent)) {
        const prev = map.items[map.items.length - 2], end = prev?.value?.end;
        if (Array.isArray(end)) return Array.prototype.push.apply(end, it.start), end.push(this.sourceToken), 
        void map.items.pop();
       }
       it.start.push(this.sourceToken);
      }
      return;
     }
     if (this.indent >= map.indent) {
      const atMapIndent = !this.onKeyLine && this.indent === map.indent, atNextItem = atMapIndent && (it.sep || it.explicitKey) && "seq-item-ind" !== this.type;
      let start = [];
      if (atNextItem && it.sep && !it.value) {
       const nl = [];
       for (let i = 0; i < it.sep.length; ++i) {
        const st = it.sep[i];
        switch (st.type) {
        case "newline":
         nl.push(i);
         break;

        case "space":
         break;

        case "comment":
         st.indent > map.indent && (nl.length = 0);
         break;

        default:
         nl.length = 0;
        }
       }
       nl.length >= 2 && (start = it.sep.splice(nl[1]));
      }
      switch (this.type) {
      case "anchor":
      case "tag":
       return void (atNextItem || it.value ? (start.push(this.sourceToken), map.items.push({
        start
       }), this.onKeyLine = !0) : it.sep ? it.sep.push(this.sourceToken) : it.start.push(this.sourceToken));

      case "explicit-key-ind":
       return it.sep || it.explicitKey ? atNextItem || it.value ? (start.push(this.sourceToken), 
       map.items.push({
        start,
        explicitKey: !0
       })) : this.stack.push({
        type: "block-map",
        offset: this.offset,
        indent: this.indent,
        items: [ {
         start: [ this.sourceToken ],
         explicitKey: !0
        } ]
       }) : (it.start.push(this.sourceToken), it.explicitKey = !0), void (this.onKeyLine = !0);

      case "map-value-ind":
       if (it.explicitKey) if (it.sep) if (it.value) map.items.push({
        start: [],
        key: null,
        sep: [ this.sourceToken ]
       }); else if (includesToken(it.sep, "map-value-ind")) this.stack.push({
        type: "block-map",
        offset: this.offset,
        indent: this.indent,
        items: [ {
         start,
         key: null,
         sep: [ this.sourceToken ]
        } ]
       }); else if (isFlowToken(it.key) && !includesToken(it.sep, "newline")) {
        const start = getFirstKeyStartProps(it.start), key = it.key, sep = it.sep;
        sep.push(this.sourceToken), delete it.key, delete it.sep, this.stack.push({
         type: "block-map",
         offset: this.offset,
         indent: this.indent,
         items: [ {
          start,
          key,
          sep
         } ]
        });
       } else start.length > 0 ? it.sep = it.sep.concat(start, this.sourceToken) : it.sep.push(this.sourceToken); else if (includesToken(it.start, "newline")) Object.assign(it, {
        key: null,
        sep: [ this.sourceToken ]
       }); else {
        const start = getFirstKeyStartProps(it.start);
        this.stack.push({
         type: "block-map",
         offset: this.offset,
         indent: this.indent,
         items: [ {
          start,
          key: null,
          sep: [ this.sourceToken ]
         } ]
        });
       } else it.sep ? it.value || atNextItem ? map.items.push({
        start,
        key: null,
        sep: [ this.sourceToken ]
       }) : includesToken(it.sep, "map-value-ind") ? this.stack.push({
        type: "block-map",
        offset: this.offset,
        indent: this.indent,
        items: [ {
         start: [],
         key: null,
         sep: [ this.sourceToken ]
        } ]
       }) : it.sep.push(this.sourceToken) : Object.assign(it, {
        key: null,
        sep: [ this.sourceToken ]
       });
       return void (this.onKeyLine = !0);

      case "alias":
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
       {
        const fs = this.flowScalar(this.type);
        return void (atNextItem || it.value ? (map.items.push({
         start,
         key: fs,
         sep: []
        }), this.onKeyLine = !0) : it.sep ? this.stack.push(fs) : (Object.assign(it, {
         key: fs,
         sep: []
        }), this.onKeyLine = !0));
       }

      default:
       {
        const bv = this.startBlockValue(map);
        if (bv) return atMapIndent && "block-seq" !== bv.type && map.items.push({
         start
        }), void this.stack.push(bv);
       }
      }
     }
     yield* this.pop(), yield* this.step();
    }
    * blockSequence(seq) {
     const it = seq.items[seq.items.length - 1];
     switch (this.type) {
     case "newline":
      if (it.value) {
       const end = "end" in it.value ? it.value.end : void 0, last = Array.isArray(end) ? end[end.length - 1] : void 0;
       "comment" === last?.type ? end?.push(this.sourceToken) : seq.items.push({
        start: [ this.sourceToken ]
       });
      } else it.start.push(this.sourceToken);
      return;

     case "space":
     case "comment":
      if (it.value) seq.items.push({
       start: [ this.sourceToken ]
      }); else {
       if (this.atIndentedComment(it.start, seq.indent)) {
        const prev = seq.items[seq.items.length - 2], end = prev?.value?.end;
        if (Array.isArray(end)) return Array.prototype.push.apply(end, it.start), end.push(this.sourceToken), 
        void seq.items.pop();
       }
       it.start.push(this.sourceToken);
      }
      return;

     case "anchor":
     case "tag":
      if (it.value || this.indent <= seq.indent) break;
      return void it.start.push(this.sourceToken);

     case "seq-item-ind":
      if (this.indent !== seq.indent) break;
      return void (it.value || includesToken(it.start, "seq-item-ind") ? seq.items.push({
       start: [ this.sourceToken ]
      }) : it.start.push(this.sourceToken));
     }
     if (this.indent > seq.indent) {
      const bv = this.startBlockValue(seq);
      if (bv) return void this.stack.push(bv);
     }
     yield* this.pop(), yield* this.step();
    }
    * flowCollection(fc) {
     const it = fc.items[fc.items.length - 1];
     if ("flow-error-end" === this.type) {
      let top;
      do {
       yield* this.pop(), top = this.peek(1);
      } while (top && "flow-collection" === top.type);
     } else if (0 === fc.end.length) {
      switch (this.type) {
      case "comma":
      case "explicit-key-ind":
       return void (!it || it.sep ? fc.items.push({
        start: [ this.sourceToken ]
       }) : it.start.push(this.sourceToken));

      case "map-value-ind":
       return void (!it || it.value ? fc.items.push({
        start: [],
        key: null,
        sep: [ this.sourceToken ]
       }) : it.sep ? it.sep.push(this.sourceToken) : Object.assign(it, {
        key: null,
        sep: [ this.sourceToken ]
       }));

      case "space":
      case "comment":
      case "newline":
      case "anchor":
      case "tag":
       return void (!it || it.value ? fc.items.push({
        start: [ this.sourceToken ]
       }) : it.sep ? it.sep.push(this.sourceToken) : it.start.push(this.sourceToken));

      case "alias":
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
       {
        const fs = this.flowScalar(this.type);
        return void (!it || it.value ? fc.items.push({
         start: [],
         key: fs,
         sep: []
        }) : it.sep ? this.stack.push(fs) : Object.assign(it, {
         key: fs,
         sep: []
        }));
       }

      case "flow-map-end":
      case "flow-seq-end":
       return void fc.end.push(this.sourceToken);
      }
      const bv = this.startBlockValue(fc);
      bv ? this.stack.push(bv) : (yield* this.pop(), yield* this.step());
     } else {
      const parent = this.peek(2);
      if ("block-map" === parent.type && ("map-value-ind" === this.type && parent.indent === fc.indent || "newline" === this.type && !parent.items[parent.items.length - 1].sep)) yield* this.pop(), 
      yield* this.step(); else if ("map-value-ind" === this.type && "flow-collection" !== parent.type) {
       const start = getFirstKeyStartProps(getPrevProps(parent));
       fixFlowSeqItems(fc);
       const sep = fc.end.splice(1, fc.end.length);
       sep.push(this.sourceToken);
       const map = {
        type: "block-map",
        offset: fc.offset,
        indent: fc.indent,
        items: [ {
         start,
         key: fc,
         sep
        } ]
       };
       this.onKeyLine = !0, this.stack[this.stack.length - 1] = map;
      } else yield* this.lineEnd(fc);
     }
    }
    flowScalar(type) {
     if (this.onNewLine) {
      let nl = this.source.indexOf("\n") + 1;
      for (;0 !== nl; ) this.onNewLine(this.offset + nl), nl = this.source.indexOf("\n", nl) + 1;
     }
     return {
      type,
      offset: this.offset,
      indent: this.indent,
      source: this.source
     };
    }
    startBlockValue(parent) {
     switch (this.type) {
     case "alias":
     case "scalar":
     case "single-quoted-scalar":
     case "double-quoted-scalar":
      return this.flowScalar(this.type);

     case "block-scalar-header":
      return {
       type: "block-scalar",
       offset: this.offset,
       indent: this.indent,
       props: [ this.sourceToken ],
       source: ""
      };

     case "flow-map-start":
     case "flow-seq-start":
      return {
       type: "flow-collection",
       offset: this.offset,
       indent: this.indent,
       start: this.sourceToken,
       items: [],
       end: []
      };

     case "seq-item-ind":
      return {
       type: "block-seq",
       offset: this.offset,
       indent: this.indent,
       items: [ {
        start: [ this.sourceToken ]
       } ]
      };

     case "explicit-key-ind":
      {
       this.onKeyLine = !0;
       const start = getFirstKeyStartProps(getPrevProps(parent));
       return start.push(this.sourceToken), {
        type: "block-map",
        offset: this.offset,
        indent: this.indent,
        items: [ {
         start,
         explicitKey: !0
        } ]
       };
      }

     case "map-value-ind":
      {
       this.onKeyLine = !0;
       const start = getFirstKeyStartProps(getPrevProps(parent));
       return {
        type: "block-map",
        offset: this.offset,
        indent: this.indent,
        items: [ {
         start,
         key: null,
         sep: [ this.sourceToken ]
        } ]
       };
      }
     }
     return null;
    }
    atIndentedComment(start, indent) {
     return "comment" === this.type && (!(this.indent <= indent) && start.every((st => "newline" === st.type || "space" === st.type)));
    }
    * documentEnd(docEnd) {
     "doc-mode" !== this.type && (docEnd.end ? docEnd.end.push(this.sourceToken) : docEnd.end = [ this.sourceToken ], 
     "newline" === this.type && (yield* this.pop()));
    }
    * lineEnd(token) {
     switch (this.type) {
     case "comma":
     case "doc-start":
     case "doc-end":
     case "flow-seq-end":
     case "flow-map-end":
     case "map-value-ind":
      yield* this.pop(), yield* this.step();
      break;

     case "newline":
      this.onKeyLine = !1;

     default:
      token.end ? token.end.push(this.sourceToken) : token.end = [ this.sourceToken ], 
      "newline" === this.type && (yield* this.pop());
     }
    }
   };
  },
  61332: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var composer = __webpack_require__(24927), Document = __webpack_require__(9046), errors = __webpack_require__(44355), log = __webpack_require__(97444), lineCounter = __webpack_require__(40483), parser = __webpack_require__(36247);
   function parseOptions(options) {
    const prettyErrors = !1 !== options.prettyErrors;
    return {
     lineCounter: options.lineCounter || prettyErrors && new lineCounter.LineCounter || null,
     prettyErrors
    };
   }
   function parseDocument(source, options = {}) {
    const {lineCounter, prettyErrors} = parseOptions(options), parser$1 = new parser.Parser(lineCounter?.addNewLine), composer$1 = new composer.Composer(options);
    let doc = null;
    for (const _doc of composer$1.compose(parser$1.parse(source), !0, source.length)) if (doc) {
     if ("silent" !== doc.options.logLevel) {
      doc.errors.push(new errors.YAMLParseError(_doc.range.slice(0, 2), "MULTIPLE_DOCS", "Source contains multiple documents; please use YAML.parseAllDocuments()"));
      break;
     }
    } else doc = _doc;
    return prettyErrors && lineCounter && (doc.errors.forEach(errors.prettifyError(source, lineCounter)), 
    doc.warnings.forEach(errors.prettifyError(source, lineCounter))), doc;
   }
   exports.parse = function(src, reviver, options) {
    let _reviver;
    "function" == typeof reviver ? _reviver = reviver : void 0 === options && reviver && "object" == typeof reviver && (options = reviver);
    const doc = parseDocument(src, options);
    if (!doc) return null;
    if (doc.warnings.forEach((warning => log.warn(doc.options.logLevel, warning))), 
    doc.errors.length > 0) {
     if ("silent" !== doc.options.logLevel) throw doc.errors[0];
     doc.errors = [];
    }
    return doc.toJS(Object.assign({
     reviver: _reviver
    }, options));
   }, exports.parseAllDocuments = function(source, options = {}) {
    const {lineCounter, prettyErrors} = parseOptions(options), parser$1 = new parser.Parser(lineCounter?.addNewLine), composer$1 = new composer.Composer(options), docs = Array.from(composer$1.compose(parser$1.parse(source)));
    if (prettyErrors && lineCounter) for (const doc of docs) doc.errors.forEach(errors.prettifyError(source, lineCounter)), 
    doc.warnings.forEach(errors.prettifyError(source, lineCounter));
    return docs.length > 0 ? docs : Object.assign([], {
     empty: !0
    }, composer$1.streamInfo());
   }, exports.parseDocument = parseDocument, exports.stringify = function(value, replacer, options) {
    let _replacer = null;
    if ("function" == typeof replacer || Array.isArray(replacer) ? _replacer = replacer : void 0 === options && replacer && (options = replacer), 
    "string" == typeof options && (options = options.length), "number" == typeof options) {
     const indent = Math.round(options);
     options = indent < 1 ? void 0 : indent > 8 ? {
      indent: 8
     } : {
      indent
     };
    }
    if (void 0 === value) {
     const {keepUndefined} = options ?? replacer ?? {};
     if (!keepUndefined) return;
    }
    return new Document.Document(value, _replacer, options).toString(options);
   };
  },
  40625: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var identity = __webpack_require__(70484), map = __webpack_require__(63334), seq = __webpack_require__(21919), string = __webpack_require__(58531), tags = __webpack_require__(50975);
   const sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;
   class Schema {
    constructor({compat, customTags, merge, resolveKnownTags, schema, sortMapEntries, toStringDefaults}) {
     this.compat = Array.isArray(compat) ? tags.getTags(compat, "compat") : compat ? tags.getTags(null, compat) : null, 
     this.merge = !!merge, this.name = "string" == typeof schema && schema || "core", 
     this.knownTags = resolveKnownTags ? tags.coreKnownTags : {}, this.tags = tags.getTags(customTags, this.name), 
     this.toStringOptions = toStringDefaults ?? null, Object.defineProperty(this, identity.MAP, {
      value: map.map
     }), Object.defineProperty(this, identity.SCALAR, {
      value: string.string
     }), Object.defineProperty(this, identity.SEQ, {
      value: seq.seq
     }), this.sortMapEntries = "function" == typeof sortMapEntries ? sortMapEntries : !0 === sortMapEntries ? sortMapEntriesByKey : null;
    }
    clone() {
     const copy = Object.create(Schema.prototype, Object.getOwnPropertyDescriptors(this));
     return copy.tags = this.tags.slice(), copy;
    }
   }
   exports.Schema = Schema;
  },
  63334: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var identity = __webpack_require__(70484), YAMLMap = __webpack_require__(81755);
   const map = {
    collection: "map",
    default: !0,
    nodeClass: YAMLMap.YAMLMap,
    tag: "tag:yaml.org,2002:map",
    resolve: (map, onError) => (identity.isMap(map) || onError("Expected a mapping for this tag"), 
    map),
    createNode: (schema, obj, ctx) => YAMLMap.YAMLMap.from(schema, obj, ctx)
   };
   exports.map = map;
  },
  86055: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var Scalar = __webpack_require__(89714);
   const nullTag = {
    identify: value => null == value,
    createNode: () => new Scalar.Scalar(null),
    default: !0,
    tag: "tag:yaml.org,2002:null",
    test: /^(?:~|[Nn]ull|NULL)?$/,
    resolve: () => new Scalar.Scalar(null),
    stringify: ({source}, ctx) => "string" == typeof source && nullTag.test.test(source) ? source : ctx.options.nullStr
   };
   exports.nullTag = nullTag;
  },
  21919: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var identity = __webpack_require__(70484), YAMLSeq = __webpack_require__(36010);
   const seq = {
    collection: "seq",
    default: !0,
    nodeClass: YAMLSeq.YAMLSeq,
    tag: "tag:yaml.org,2002:seq",
    resolve: (seq, onError) => (identity.isSeq(seq) || onError("Expected a sequence for this tag"), 
    seq),
    createNode: (schema, obj, ctx) => YAMLSeq.YAMLSeq.from(schema, obj, ctx)
   };
   exports.seq = seq;
  },
  58531: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var stringifyString = __webpack_require__(27180);
   const string = {
    identify: value => "string" == typeof value,
    default: !0,
    tag: "tag:yaml.org,2002:str",
    resolve: str => str,
    stringify: (item, ctx, onComment, onChompKeep) => (ctx = Object.assign({
     actualString: !0
    }, ctx), stringifyString.stringifyString(item, ctx, onComment, onChompKeep))
   };
   exports.string = string;
  },
  5132: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var Scalar = __webpack_require__(89714);
   const boolTag = {
    identify: value => "boolean" == typeof value,
    default: !0,
    tag: "tag:yaml.org,2002:bool",
    test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
    resolve: str => new Scalar.Scalar("t" === str[0] || "T" === str[0]),
    stringify({source, value}, ctx) {
     if (source && boolTag.test.test(source)) {
      if (value === ("t" === source[0] || "T" === source[0])) return source;
     }
     return value ? ctx.options.trueStr : ctx.options.falseStr;
    }
   };
   exports.boolTag = boolTag;
  },
  20988: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var Scalar = __webpack_require__(89714), stringifyNumber = __webpack_require__(3144);
   const floatNaN = {
    identify: value => "number" == typeof value,
    default: !0,
    tag: "tag:yaml.org,2002:float",
    test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
    resolve: str => "nan" === str.slice(-3).toLowerCase() ? NaN : "-" === str[0] ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
    stringify: stringifyNumber.stringifyNumber
   }, floatExp = {
    identify: value => "number" == typeof value,
    default: !0,
    tag: "tag:yaml.org,2002:float",
    format: "EXP",
    test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
    resolve: str => parseFloat(str),
    stringify(node) {
     const num = Number(node.value);
     return isFinite(num) ? num.toExponential() : stringifyNumber.stringifyNumber(node);
    }
   }, float = {
    identify: value => "number" == typeof value,
    default: !0,
    tag: "tag:yaml.org,2002:float",
    test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
    resolve(str) {
     const node = new Scalar.Scalar(parseFloat(str)), dot = str.indexOf(".");
     return -1 !== dot && "0" === str[str.length - 1] && (node.minFractionDigits = str.length - dot - 1), 
     node;
    },
    stringify: stringifyNumber.stringifyNumber
   };
   exports.float = float, exports.floatExp = floatExp, exports.floatNaN = floatNaN;
  },
  12891: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var stringifyNumber = __webpack_require__(3144);
   const intIdentify = value => "bigint" == typeof value || Number.isInteger(value), intResolve = (str, offset, radix, {intAsBigInt}) => intAsBigInt ? BigInt(str) : parseInt(str.substring(offset), radix);
   function intStringify(node, radix, prefix) {
    const {value} = node;
    return intIdentify(value) && value >= 0 ? prefix + value.toString(radix) : stringifyNumber.stringifyNumber(node);
   }
   const intOct = {
    identify: value => intIdentify(value) && value >= 0,
    default: !0,
    tag: "tag:yaml.org,2002:int",
    format: "OCT",
    test: /^0o[0-7]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 2, 8, opt),
    stringify: node => intStringify(node, 8, "0o")
   }, int = {
    identify: intIdentify,
    default: !0,
    tag: "tag:yaml.org,2002:int",
    test: /^[-+]?[0-9]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
    stringify: stringifyNumber.stringifyNumber
   }, intHex = {
    identify: value => intIdentify(value) && value >= 0,
    default: !0,
    tag: "tag:yaml.org,2002:int",
    format: "HEX",
    test: /^0x[0-9a-fA-F]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
    stringify: node => intStringify(node, 16, "0x")
   };
   exports.int = int, exports.intHex = intHex, exports.intOct = intOct;
  },
  68523: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var map = __webpack_require__(63334), _null = __webpack_require__(86055), seq = __webpack_require__(21919), string = __webpack_require__(58531), bool = __webpack_require__(5132), float = __webpack_require__(20988), int = __webpack_require__(12891);
   const schema = [ map.map, seq.seq, string.string, _null.nullTag, bool.boolTag, int.intOct, int.int, int.intHex, float.floatNaN, float.floatExp, float.float ];
   exports.schema = schema;
  },
  94988: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var Scalar = __webpack_require__(89714), map = __webpack_require__(63334), seq = __webpack_require__(21919);
   function intIdentify(value) {
    return "bigint" == typeof value || Number.isInteger(value);
   }
   const stringifyJSON = ({value}) => JSON.stringify(value), jsonScalars = [ {
    identify: value => "string" == typeof value,
    default: !0,
    tag: "tag:yaml.org,2002:str",
    resolve: str => str,
    stringify: stringifyJSON
   }, {
    identify: value => null == value,
    createNode: () => new Scalar.Scalar(null),
    default: !0,
    tag: "tag:yaml.org,2002:null",
    test: /^null$/,
    resolve: () => null,
    stringify: stringifyJSON
   }, {
    identify: value => "boolean" == typeof value,
    default: !0,
    tag: "tag:yaml.org,2002:bool",
    test: /^true|false$/,
    resolve: str => "true" === str,
    stringify: stringifyJSON
   }, {
    identify: intIdentify,
    default: !0,
    tag: "tag:yaml.org,2002:int",
    test: /^-?(?:0|[1-9][0-9]*)$/,
    resolve: (str, _onError, {intAsBigInt}) => intAsBigInt ? BigInt(str) : parseInt(str, 10),
    stringify: ({value}) => intIdentify(value) ? value.toString() : JSON.stringify(value)
   }, {
    identify: value => "number" == typeof value,
    default: !0,
    tag: "tag:yaml.org,2002:float",
    test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
    resolve: str => parseFloat(str),
    stringify: stringifyJSON
   } ], jsonError = {
    default: !0,
    tag: "",
    test: /^/,
    resolve: (str, onError) => (onError(`Unresolved plain scalar ${JSON.stringify(str)}`), 
    str)
   }, schema = [ map.map, seq.seq ].concat(jsonScalars, jsonError);
   exports.schema = schema;
  },
  50975: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var map = __webpack_require__(63334), _null = __webpack_require__(86055), seq = __webpack_require__(21919), string = __webpack_require__(58531), bool = __webpack_require__(5132), float = __webpack_require__(20988), int = __webpack_require__(12891), schema = __webpack_require__(68523), schema$1 = __webpack_require__(94988), binary = __webpack_require__(98080), omap = __webpack_require__(90692), pairs = __webpack_require__(8416), schema$2 = __webpack_require__(15822), set = __webpack_require__(52557), timestamp = __webpack_require__(15437);
   const schemas = new Map([ [ "core", schema.schema ], [ "failsafe", [ map.map, seq.seq, string.string ] ], [ "json", schema$1.schema ], [ "yaml11", schema$2.schema ], [ "yaml-1.1", schema$2.schema ] ]), tagsByName = {
    binary: binary.binary,
    bool: bool.boolTag,
    float: float.float,
    floatExp: float.floatExp,
    floatNaN: float.floatNaN,
    floatTime: timestamp.floatTime,
    int: int.int,
    intHex: int.intHex,
    intOct: int.intOct,
    intTime: timestamp.intTime,
    map: map.map,
    null: _null.nullTag,
    omap: omap.omap,
    pairs: pairs.pairs,
    seq: seq.seq,
    set: set.set,
    timestamp: timestamp.timestamp
   }, coreKnownTags = {
    "tag:yaml.org,2002:binary": binary.binary,
    "tag:yaml.org,2002:omap": omap.omap,
    "tag:yaml.org,2002:pairs": pairs.pairs,
    "tag:yaml.org,2002:set": set.set,
    "tag:yaml.org,2002:timestamp": timestamp.timestamp
   };
   exports.coreKnownTags = coreKnownTags, exports.getTags = function(customTags, schemaName) {
    let tags = schemas.get(schemaName);
    if (!tags) {
     if (!Array.isArray(customTags)) {
      const keys = Array.from(schemas.keys()).filter((key => "yaml11" !== key)).map((key => JSON.stringify(key))).join(", ");
      throw new Error(`Unknown schema "${schemaName}"; use one of ${keys} or define customTags array`);
     }
     tags = [];
    }
    if (Array.isArray(customTags)) for (const tag of customTags) tags = tags.concat(tag); else "function" == typeof customTags && (tags = customTags(tags.slice()));
    return tags.map((tag => {
     if ("string" != typeof tag) return tag;
     const tagObj = tagsByName[tag];
     if (tagObj) return tagObj;
     const keys = Object.keys(tagsByName).map((key => JSON.stringify(key))).join(", ");
     throw new Error(`Unknown custom tag "${tag}"; use one of ${keys}`);
    }));
   };
  },
  98080: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var Scalar = __webpack_require__(89714), stringifyString = __webpack_require__(27180);
   const binary = {
    identify: value => value instanceof Uint8Array,
    default: !1,
    tag: "tag:yaml.org,2002:binary",
    resolve(src, onError) {
     if ("function" == typeof Buffer) return Buffer.from(src, "base64");
     if ("function" == typeof atob) {
      const str = atob(src.replace(/[\n\r]/g, "")), buffer = new Uint8Array(str.length);
      for (let i = 0; i < str.length; ++i) buffer[i] = str.charCodeAt(i);
      return buffer;
     }
     return onError("This environment does not support reading binary tags; either Buffer or atob is required"), 
     src;
    },
    stringify({comment, type, value}, ctx, onComment, onChompKeep) {
     const buf = value;
     let str;
     if ("function" == typeof Buffer) str = buf instanceof Buffer ? buf.toString("base64") : Buffer.from(buf.buffer).toString("base64"); else {
      if ("function" != typeof btoa) throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
      {
       let s = "";
       for (let i = 0; i < buf.length; ++i) s += String.fromCharCode(buf[i]);
       str = btoa(s);
      }
     }
     if (type || (type = Scalar.Scalar.BLOCK_LITERAL), type !== Scalar.Scalar.QUOTE_DOUBLE) {
      const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth), n = Math.ceil(str.length / lineWidth), lines = new Array(n);
      for (let i = 0, o = 0; i < n; ++i, o += lineWidth) lines[i] = str.substr(o, lineWidth);
      str = lines.join(type === Scalar.Scalar.BLOCK_LITERAL ? "\n" : " ");
     }
     return stringifyString.stringifyString({
      comment,
      type,
      value: str
     }, ctx, onComment, onChompKeep);
    }
   };
   exports.binary = binary;
  },
  17969: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var Scalar = __webpack_require__(89714);
   function boolStringify({value, source}, ctx) {
    return source && (value ? trueTag : falseTag).test.test(source) ? source : value ? ctx.options.trueStr : ctx.options.falseStr;
   }
   const trueTag = {
    identify: value => !0 === value,
    default: !0,
    tag: "tag:yaml.org,2002:bool",
    test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
    resolve: () => new Scalar.Scalar(!0),
    stringify: boolStringify
   }, falseTag = {
    identify: value => !1 === value,
    default: !0,
    tag: "tag:yaml.org,2002:bool",
    test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/,
    resolve: () => new Scalar.Scalar(!1),
    stringify: boolStringify
   };
   exports.falseTag = falseTag, exports.trueTag = trueTag;
  },
  47191: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var Scalar = __webpack_require__(89714), stringifyNumber = __webpack_require__(3144);
   const floatNaN = {
    identify: value => "number" == typeof value,
    default: !0,
    tag: "tag:yaml.org,2002:float",
    test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
    resolve: str => "nan" === str.slice(-3).toLowerCase() ? NaN : "-" === str[0] ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
    stringify: stringifyNumber.stringifyNumber
   }, floatExp = {
    identify: value => "number" == typeof value,
    default: !0,
    tag: "tag:yaml.org,2002:float",
    format: "EXP",
    test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
    resolve: str => parseFloat(str.replace(/_/g, "")),
    stringify(node) {
     const num = Number(node.value);
     return isFinite(num) ? num.toExponential() : stringifyNumber.stringifyNumber(node);
    }
   }, float = {
    identify: value => "number" == typeof value,
    default: !0,
    tag: "tag:yaml.org,2002:float",
    test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
    resolve(str) {
     const node = new Scalar.Scalar(parseFloat(str.replace(/_/g, ""))), dot = str.indexOf(".");
     if (-1 !== dot) {
      const f = str.substring(dot + 1).replace(/_/g, "");
      "0" === f[f.length - 1] && (node.minFractionDigits = f.length);
     }
     return node;
    },
    stringify: stringifyNumber.stringifyNumber
   };
   exports.float = float, exports.floatExp = floatExp, exports.floatNaN = floatNaN;
  },
  76936: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var stringifyNumber = __webpack_require__(3144);
   const intIdentify = value => "bigint" == typeof value || Number.isInteger(value);
   function intResolve(str, offset, radix, {intAsBigInt}) {
    const sign = str[0];
    if ("-" !== sign && "+" !== sign || (offset += 1), str = str.substring(offset).replace(/_/g, ""), 
    intAsBigInt) {
     switch (radix) {
     case 2:
      str = `0b${str}`;
      break;

     case 8:
      str = `0o${str}`;
      break;

     case 16:
      str = `0x${str}`;
     }
     const n = BigInt(str);
     return "-" === sign ? BigInt(-1) * n : n;
    }
    const n = parseInt(str, radix);
    return "-" === sign ? -1 * n : n;
   }
   function intStringify(node, radix, prefix) {
    const {value} = node;
    if (intIdentify(value)) {
     const str = value.toString(radix);
     return value < 0 ? "-" + prefix + str.substr(1) : prefix + str;
    }
    return stringifyNumber.stringifyNumber(node);
   }
   const intBin = {
    identify: intIdentify,
    default: !0,
    tag: "tag:yaml.org,2002:int",
    format: "BIN",
    test: /^[-+]?0b[0-1_]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 2, 2, opt),
    stringify: node => intStringify(node, 2, "0b")
   }, intOct = {
    identify: intIdentify,
    default: !0,
    tag: "tag:yaml.org,2002:int",
    format: "OCT",
    test: /^[-+]?0[0-7_]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 1, 8, opt),
    stringify: node => intStringify(node, 8, "0")
   }, int = {
    identify: intIdentify,
    default: !0,
    tag: "tag:yaml.org,2002:int",
    test: /^[-+]?[0-9][0-9_]*$/,
    resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
    stringify: stringifyNumber.stringifyNumber
   }, intHex = {
    identify: intIdentify,
    default: !0,
    tag: "tag:yaml.org,2002:int",
    format: "HEX",
    test: /^[-+]?0x[0-9a-fA-F_]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
    stringify: node => intStringify(node, 16, "0x")
   };
   exports.int = int, exports.intBin = intBin, exports.intHex = intHex, exports.intOct = intOct;
  },
  90692: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var identity = __webpack_require__(70484), toJS = __webpack_require__(63732), YAMLMap = __webpack_require__(81755), YAMLSeq = __webpack_require__(36010), pairs = __webpack_require__(8416);
   class YAMLOMap extends YAMLSeq.YAMLSeq {
    constructor() {
     super(), this.add = YAMLMap.YAMLMap.prototype.add.bind(this), this.delete = YAMLMap.YAMLMap.prototype.delete.bind(this), 
     this.get = YAMLMap.YAMLMap.prototype.get.bind(this), this.has = YAMLMap.YAMLMap.prototype.has.bind(this), 
     this.set = YAMLMap.YAMLMap.prototype.set.bind(this), this.tag = YAMLOMap.tag;
    }
    toJSON(_, ctx) {
     if (!ctx) return super.toJSON(_);
     const map = new Map;
     ctx?.onCreate && ctx.onCreate(map);
     for (const pair of this.items) {
      let key, value;
      if (identity.isPair(pair) ? (key = toJS.toJS(pair.key, "", ctx), value = toJS.toJS(pair.value, key, ctx)) : key = toJS.toJS(pair, "", ctx), 
      map.has(key)) throw new Error("Ordered maps must not include duplicate keys");
      map.set(key, value);
     }
     return map;
    }
    static from(schema, iterable, ctx) {
     const pairs$1 = pairs.createPairs(schema, iterable, ctx), omap = new this;
     return omap.items = pairs$1.items, omap;
    }
   }
   YAMLOMap.tag = "tag:yaml.org,2002:omap";
   const omap = {
    collection: "seq",
    identify: value => value instanceof Map,
    nodeClass: YAMLOMap,
    default: !1,
    tag: "tag:yaml.org,2002:omap",
    resolve(seq, onError) {
     const pairs$1 = pairs.resolvePairs(seq, onError), seenKeys = [];
     for (const {key} of pairs$1.items) identity.isScalar(key) && (seenKeys.includes(key.value) ? onError(`Ordered maps must not include duplicate keys: ${key.value}`) : seenKeys.push(key.value));
     return Object.assign(new YAMLOMap, pairs$1);
    },
    createNode: (schema, iterable, ctx) => YAMLOMap.from(schema, iterable, ctx)
   };
   exports.YAMLOMap = YAMLOMap, exports.omap = omap;
  },
  8416: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var identity = __webpack_require__(70484), Pair = __webpack_require__(27902), Scalar = __webpack_require__(89714), YAMLSeq = __webpack_require__(36010);
   function resolvePairs(seq, onError) {
    if (identity.isSeq(seq)) for (let i = 0; i < seq.items.length; ++i) {
     let item = seq.items[i];
     if (!identity.isPair(item)) {
      if (identity.isMap(item)) {
       item.items.length > 1 && onError("Each pair must have its own sequence indicator");
       const pair = item.items[0] || new Pair.Pair(new Scalar.Scalar(null));
       if (item.commentBefore && (pair.key.commentBefore = pair.key.commentBefore ? `${item.commentBefore}\n${pair.key.commentBefore}` : item.commentBefore), 
       item.comment) {
        const cn = pair.value ?? pair.key;
        cn.comment = cn.comment ? `${item.comment}\n${cn.comment}` : item.comment;
       }
       item = pair;
      }
      seq.items[i] = identity.isPair(item) ? item : new Pair.Pair(item);
     }
    } else onError("Expected a sequence for this tag");
    return seq;
   }
   function createPairs(schema, iterable, ctx) {
    const {replacer} = ctx, pairs = new YAMLSeq.YAMLSeq(schema);
    pairs.tag = "tag:yaml.org,2002:pairs";
    let i = 0;
    if (iterable && Symbol.iterator in Object(iterable)) for (let it of iterable) {
     let key, value;
     if ("function" == typeof replacer && (it = replacer.call(iterable, String(i++), it)), 
     Array.isArray(it)) {
      if (2 !== it.length) throw new TypeError(`Expected [key, value] tuple: ${it}`);
      key = it[0], value = it[1];
     } else if (it && it instanceof Object) {
      const keys = Object.keys(it);
      if (1 !== keys.length) throw new TypeError(`Expected tuple with one key, not ${keys.length} keys`);
      key = keys[0], value = it[key];
     } else key = it;
     pairs.items.push(Pair.createPair(key, value, ctx));
    }
    return pairs;
   }
   const pairs = {
    collection: "seq",
    default: !1,
    tag: "tag:yaml.org,2002:pairs",
    resolve: resolvePairs,
    createNode: createPairs
   };
   exports.createPairs = createPairs, exports.pairs = pairs, exports.resolvePairs = resolvePairs;
  },
  15822: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var map = __webpack_require__(63334), _null = __webpack_require__(86055), seq = __webpack_require__(21919), string = __webpack_require__(58531), binary = __webpack_require__(98080), bool = __webpack_require__(17969), float = __webpack_require__(47191), int = __webpack_require__(76936), omap = __webpack_require__(90692), pairs = __webpack_require__(8416), set = __webpack_require__(52557), timestamp = __webpack_require__(15437);
   const schema = [ map.map, seq.seq, string.string, _null.nullTag, bool.trueTag, bool.falseTag, int.intBin, int.intOct, int.int, int.intHex, float.floatNaN, float.floatExp, float.float, binary.binary, omap.omap, pairs.pairs, set.set, timestamp.intTime, timestamp.floatTime, timestamp.timestamp ];
   exports.schema = schema;
  },
  52557: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var identity = __webpack_require__(70484), Pair = __webpack_require__(27902), YAMLMap = __webpack_require__(81755);
   class YAMLSet extends YAMLMap.YAMLMap {
    constructor(schema) {
     super(schema), this.tag = YAMLSet.tag;
    }
    add(key) {
     let pair;
     pair = identity.isPair(key) ? key : key && "object" == typeof key && "key" in key && "value" in key && null === key.value ? new Pair.Pair(key.key, null) : new Pair.Pair(key, null);
     YAMLMap.findPair(this.items, pair.key) || this.items.push(pair);
    }
    get(key, keepPair) {
     const pair = YAMLMap.findPair(this.items, key);
     return !keepPair && identity.isPair(pair) ? identity.isScalar(pair.key) ? pair.key.value : pair.key : pair;
    }
    set(key, value) {
     if ("boolean" != typeof value) throw new Error("Expected boolean value for set(key, value) in a YAML set, not " + typeof value);
     const prev = YAMLMap.findPair(this.items, key);
     prev && !value ? this.items.splice(this.items.indexOf(prev), 1) : !prev && value && this.items.push(new Pair.Pair(key));
    }
    toJSON(_, ctx) {
     return super.toJSON(_, ctx, Set);
    }
    toString(ctx, onComment, onChompKeep) {
     if (!ctx) return JSON.stringify(this);
     if (this.hasAllNullValues(!0)) return super.toString(Object.assign({}, ctx, {
      allNullValues: !0
     }), onComment, onChompKeep);
     throw new Error("Set items must all have null values");
    }
    static from(schema, iterable, ctx) {
     const {replacer} = ctx, set = new this(schema);
     if (iterable && Symbol.iterator in Object(iterable)) for (let value of iterable) "function" == typeof replacer && (value = replacer.call(iterable, value, value)), 
     set.items.push(Pair.createPair(value, null, ctx));
     return set;
    }
   }
   YAMLSet.tag = "tag:yaml.org,2002:set";
   const set = {
    collection: "map",
    identify: value => value instanceof Set,
    nodeClass: YAMLSet,
    default: !1,
    tag: "tag:yaml.org,2002:set",
    createNode: (schema, iterable, ctx) => YAMLSet.from(schema, iterable, ctx),
    resolve(map, onError) {
     if (identity.isMap(map)) {
      if (map.hasAllNullValues(!0)) return Object.assign(new YAMLSet, map);
      onError("Set items must all have null values");
     } else onError("Expected a mapping for this tag");
     return map;
    }
   };
   exports.YAMLSet = YAMLSet, exports.set = set;
  },
  15437: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var stringifyNumber = __webpack_require__(3144);
   function parseSexagesimal(str, asBigInt) {
    const sign = str[0], parts = "-" === sign || "+" === sign ? str.substring(1) : str, num = n => asBigInt ? BigInt(n) : Number(n), res = parts.replace(/_/g, "").split(":").reduce(((res, p) => res * num(60) + num(p)), num(0));
    return "-" === sign ? num(-1) * res : res;
   }
   function stringifySexagesimal(node) {
    let {value} = node, num = n => n;
    if ("bigint" == typeof value) num = n => BigInt(n); else if (isNaN(value) || !isFinite(value)) return stringifyNumber.stringifyNumber(node);
    let sign = "";
    value < 0 && (sign = "-", value *= num(-1));
    const _60 = num(60), parts = [ value % _60 ];
    return value < 60 ? parts.unshift(0) : (value = (value - parts[0]) / _60, parts.unshift(value % _60), 
    value >= 60 && (value = (value - parts[0]) / _60, parts.unshift(value))), sign + parts.map((n => String(n).padStart(2, "0"))).join(":").replace(/000000\d*$/, "");
   }
   const intTime = {
    identify: value => "bigint" == typeof value || Number.isInteger(value),
    default: !0,
    tag: "tag:yaml.org,2002:int",
    format: "TIME",
    test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
    resolve: (str, _onError, {intAsBigInt}) => parseSexagesimal(str, intAsBigInt),
    stringify: stringifySexagesimal
   }, floatTime = {
    identify: value => "number" == typeof value,
    default: !0,
    tag: "tag:yaml.org,2002:float",
    format: "TIME",
    test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
    resolve: str => parseSexagesimal(str, !1),
    stringify: stringifySexagesimal
   }, timestamp = {
    identify: value => value instanceof Date,
    default: !0,
    tag: "tag:yaml.org,2002:timestamp",
    test: RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?$"),
    resolve(str) {
     const match = str.match(timestamp.test);
     if (!match) throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");
     const [, year, month, day, hour, minute, second] = match.map(Number), millisec = match[7] ? Number((match[7] + "00").substr(1, 3)) : 0;
     let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec);
     const tz = match[8];
     if (tz && "Z" !== tz) {
      let d = parseSexagesimal(tz, !1);
      Math.abs(d) < 30 && (d *= 60), date -= 6e4 * d;
     }
     return new Date(date);
    },
    stringify: ({value}) => value.toISOString().replace(/((T00:00)?:00)?\.000Z$/, "")
   };
   exports.floatTime = floatTime, exports.intTime = intTime, exports.timestamp = timestamp;
  },
  46170: (__unused_webpack_module, exports) => {
   "use strict";
   function consumeMoreIndentedLines(text, i, indent) {
    let end = i, start = i + 1, ch = text[start];
    for (;" " === ch || "\t" === ch; ) if (i < start + indent) ch = text[++i]; else {
     do {
      ch = text[++i];
     } while (ch && "\n" !== ch);
     end = i, start = i + 1, ch = text[start];
    }
    return end;
   }
   exports.FOLD_BLOCK = "block", exports.FOLD_FLOW = "flow", exports.FOLD_QUOTED = "quoted", 
   exports.foldFlowLines = function(text, indent, mode = "flow", {indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow} = {}) {
    if (!lineWidth || lineWidth < 0) return text;
    lineWidth < minContentWidth && (minContentWidth = 0);
    const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
    if (text.length <= endStep) return text;
    const folds = [], escapedFolds = {};
    let split, prev, end = lineWidth - indent.length;
    "number" == typeof indentAtStart && (indentAtStart > lineWidth - Math.max(2, minContentWidth) ? folds.push(0) : end = lineWidth - indentAtStart);
    let overflow = !1, i = -1, escStart = -1, escEnd = -1;
    "block" === mode && (i = consumeMoreIndentedLines(text, i, indent.length), -1 !== i && (end = i + endStep));
    for (let ch; ch = text[i += 1]; ) {
     if ("quoted" === mode && "\\" === ch) {
      switch (escStart = i, text[i + 1]) {
      case "x":
       i += 3;
       break;

      case "u":
       i += 5;
       break;

      case "U":
       i += 9;
       break;

      default:
       i += 1;
      }
      escEnd = i;
     }
     if ("\n" === ch) "block" === mode && (i = consumeMoreIndentedLines(text, i, indent.length)), 
     end = i + indent.length + endStep, split = void 0; else {
      if (" " === ch && prev && " " !== prev && "\n" !== prev && "\t" !== prev) {
       const next = text[i + 1];
       next && " " !== next && "\n" !== next && "\t" !== next && (split = i);
      }
      if (i >= end) if (split) folds.push(split), end = split + endStep, split = void 0; else if ("quoted" === mode) {
       for (;" " === prev || "\t" === prev; ) prev = ch, ch = text[i += 1], overflow = !0;
       const j = i > escEnd + 1 ? i - 2 : escStart - 1;
       if (escapedFolds[j]) return text;
       folds.push(j), escapedFolds[j] = !0, end = j + endStep, split = void 0;
      } else overflow = !0;
     }
     prev = ch;
    }
    if (overflow && onOverflow && onOverflow(), 0 === folds.length) return text;
    onFold && onFold();
    let res = text.slice(0, folds[0]);
    for (let i = 0; i < folds.length; ++i) {
     const fold = folds[i], end = folds[i + 1] || text.length;
     0 === fold ? res = `\n${indent}${text.slice(0, end)}` : ("quoted" === mode && escapedFolds[fold] && (res += `${text[fold]}\\`), 
     res += `\n${indent}${text.slice(fold + 1, end)}`);
    }
    return res;
   };
  },
  93793: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var anchors = __webpack_require__(46261), identity = __webpack_require__(70484), stringifyComment = __webpack_require__(40248), stringifyString = __webpack_require__(27180);
   exports.createStringifyContext = function(doc, options) {
    const opt = Object.assign({
     blockQuote: !0,
     commentString: stringifyComment.stringifyComment,
     defaultKeyType: null,
     defaultStringType: "PLAIN",
     directives: null,
     doubleQuotedAsJSON: !1,
     doubleQuotedMinMultiLineLength: 40,
     falseStr: "false",
     flowCollectionPadding: !0,
     indentSeq: !0,
     lineWidth: 80,
     minContentWidth: 20,
     nullStr: "null",
     simpleKeys: !1,
     singleQuote: null,
     trueStr: "true",
     verifyAliasOrder: !0
    }, doc.schema.toStringOptions, options);
    let inFlow;
    switch (opt.collectionStyle) {
    case "block":
     inFlow = !1;
     break;

    case "flow":
     inFlow = !0;
     break;

    default:
     inFlow = null;
    }
    return {
     anchors: new Set,
     doc,
     flowCollectionPadding: opt.flowCollectionPadding ? " " : "",
     indent: "",
     indentStep: "number" == typeof opt.indent ? " ".repeat(opt.indent) : "  ",
     inFlow,
     options: opt
    };
   }, exports.stringify = function(item, ctx, onComment, onChompKeep) {
    if (identity.isPair(item)) return item.toString(ctx, onComment, onChompKeep);
    if (identity.isAlias(item)) {
     if (ctx.doc.directives) return item.toString(ctx);
     if (ctx.resolvedAliases?.has(item)) throw new TypeError("Cannot stringify circular structure without alias nodes");
     ctx.resolvedAliases ? ctx.resolvedAliases.add(item) : ctx.resolvedAliases = new Set([ item ]), 
     item = item.resolve(ctx.doc);
    }
    let tagObj;
    const node = identity.isNode(item) ? item : ctx.doc.createNode(item, {
     onTagObj: o => tagObj = o
    });
    tagObj || (tagObj = function(tags, item) {
     if (item.tag) {
      const match = tags.filter((t => t.tag === item.tag));
      if (match.length > 0) return match.find((t => t.format === item.format)) ?? match[0];
     }
     let tagObj, obj;
     if (identity.isScalar(item)) {
      obj = item.value;
      const match = tags.filter((t => t.identify?.(obj)));
      tagObj = match.find((t => t.format === item.format)) ?? match.find((t => !t.format));
     } else obj = item, tagObj = tags.find((t => t.nodeClass && obj instanceof t.nodeClass));
     if (!tagObj) throw new Error(`Tag not resolved for ${obj?.constructor?.name ?? typeof obj} value`);
     return tagObj;
    }(ctx.doc.schema.tags, node));
    const props = function(node, tagObj, {anchors: anchors$1, doc}) {
     if (!doc.directives) return "";
     const props = [], anchor = (identity.isScalar(node) || identity.isCollection(node)) && node.anchor;
     anchor && anchors.anchorIsValid(anchor) && (anchors$1.add(anchor), props.push(`&${anchor}`));
     const tag = node.tag ? node.tag : tagObj.default ? null : tagObj.tag;
     return tag && props.push(doc.directives.tagString(tag)), props.join(" ");
    }(node, tagObj, ctx);
    props.length > 0 && (ctx.indentAtStart = (ctx.indentAtStart ?? 0) + props.length + 1);
    const str = "function" == typeof tagObj.stringify ? tagObj.stringify(node, ctx, onComment, onChompKeep) : identity.isScalar(node) ? stringifyString.stringifyString(node, ctx, onComment, onChompKeep) : node.toString(ctx, onComment, onChompKeep);
    return props ? identity.isScalar(node) || "{" === str[0] || "[" === str[0] ? `${props} ${str}` : `${props}\n${ctx.indent}${str}` : str;
   };
  },
  60081: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var identity = __webpack_require__(70484), stringify = __webpack_require__(93793), stringifyComment = __webpack_require__(40248);
   function stringifyBlockCollection({comment, items}, ctx, {blockItemPrefix, flowChars, itemIndent, onChompKeep, onComment}) {
    const {indent, options: {commentString}} = ctx, itemCtx = Object.assign({}, ctx, {
     indent: itemIndent,
     type: null
    });
    let chompKeep = !1;
    const lines = [];
    for (let i = 0; i < items.length; ++i) {
     const item = items[i];
     let comment = null;
     if (identity.isNode(item)) !chompKeep && item.spaceBefore && lines.push(""), addCommentBefore(ctx, lines, item.commentBefore, chompKeep), 
     item.comment && (comment = item.comment); else if (identity.isPair(item)) {
      const ik = identity.isNode(item.key) ? item.key : null;
      ik && (!chompKeep && ik.spaceBefore && lines.push(""), addCommentBefore(ctx, lines, ik.commentBefore, chompKeep));
     }
     chompKeep = !1;
     let str = stringify.stringify(item, itemCtx, (() => comment = null), (() => chompKeep = !0));
     comment && (str += stringifyComment.lineComment(str, itemIndent, commentString(comment))), 
     chompKeep && comment && (chompKeep = !1), lines.push(blockItemPrefix + str);
    }
    let str;
    if (0 === lines.length) str = flowChars.start + flowChars.end; else {
     str = lines[0];
     for (let i = 1; i < lines.length; ++i) {
      const line = lines[i];
      str += line ? `\n${indent}${line}` : "\n";
     }
    }
    return comment ? (str += "\n" + stringifyComment.indentComment(commentString(comment), indent), 
    onComment && onComment()) : chompKeep && onChompKeep && onChompKeep(), str;
   }
   function stringifyFlowCollection({items}, ctx, {flowChars, itemIndent}) {
    const {indent, indentStep, flowCollectionPadding: fcPadding, options: {commentString}} = ctx;
    itemIndent += indentStep;
    const itemCtx = Object.assign({}, ctx, {
     indent: itemIndent,
     inFlow: !0,
     type: null
    });
    let reqNewline = !1, linesAtValue = 0;
    const lines = [];
    for (let i = 0; i < items.length; ++i) {
     const item = items[i];
     let comment = null;
     if (identity.isNode(item)) item.spaceBefore && lines.push(""), addCommentBefore(ctx, lines, item.commentBefore, !1), 
     item.comment && (comment = item.comment); else if (identity.isPair(item)) {
      const ik = identity.isNode(item.key) ? item.key : null;
      ik && (ik.spaceBefore && lines.push(""), addCommentBefore(ctx, lines, ik.commentBefore, !1), 
      ik.comment && (reqNewline = !0));
      const iv = identity.isNode(item.value) ? item.value : null;
      iv ? (iv.comment && (comment = iv.comment), iv.commentBefore && (reqNewline = !0)) : null == item.value && ik?.comment && (comment = ik.comment);
     }
     comment && (reqNewline = !0);
     let str = stringify.stringify(item, itemCtx, (() => comment = null));
     i < items.length - 1 && (str += ","), comment && (str += stringifyComment.lineComment(str, itemIndent, commentString(comment))), 
     !reqNewline && (lines.length > linesAtValue || str.includes("\n")) && (reqNewline = !0), 
     lines.push(str), linesAtValue = lines.length;
    }
    const {start, end} = flowChars;
    if (0 === lines.length) return start + end;
    if (!reqNewline) {
     const len = lines.reduce(((sum, line) => sum + line.length + 2), 2);
     reqNewline = ctx.options.lineWidth > 0 && len > ctx.options.lineWidth;
    }
    if (reqNewline) {
     let str = start;
     for (const line of lines) str += line ? `\n${indentStep}${indent}${line}` : "\n";
     return `${str}\n${indent}${end}`;
    }
    return `${start}${fcPadding}${lines.join(" ")}${fcPadding}${end}`;
   }
   function addCommentBefore({indent, options: {commentString}}, lines, comment, chompKeep) {
    if (comment && chompKeep && (comment = comment.replace(/^\n+/, "")), comment) {
     const ic = stringifyComment.indentComment(commentString(comment), indent);
     lines.push(ic.trimStart());
    }
   }
   exports.stringifyCollection = function(collection, ctx, options) {
    return (ctx.inFlow ?? collection.flow ? stringifyFlowCollection : stringifyBlockCollection)(collection, ctx, options);
   };
  },
  40248: (__unused_webpack_module, exports) => {
   "use strict";
   function indentComment(comment, indent) {
    return /^\n+$/.test(comment) ? comment.substring(1) : indent ? comment.replace(/^(?! *$)/gm, indent) : comment;
   }
   exports.indentComment = indentComment, exports.lineComment = (str, indent, comment) => str.endsWith("\n") ? indentComment(comment, indent) : comment.includes("\n") ? "\n" + indentComment(comment, indent) : (str.endsWith(" ") ? "" : " ") + comment, 
   exports.stringifyComment = str => str.replace(/^(?!$)(?: $)?/gm, "#");
  },
  71768: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var identity = __webpack_require__(70484), stringify = __webpack_require__(93793), stringifyComment = __webpack_require__(40248);
   exports.stringifyDocument = function(doc, options) {
    const lines = [];
    let hasDirectives = !0 === options.directives;
    if (!1 !== options.directives && doc.directives) {
     const dir = doc.directives.toString(doc);
     dir ? (lines.push(dir), hasDirectives = !0) : doc.directives.docStart && (hasDirectives = !0);
    }
    hasDirectives && lines.push("---");
    const ctx = stringify.createStringifyContext(doc, options), {commentString} = ctx.options;
    if (doc.commentBefore) {
     1 !== lines.length && lines.unshift("");
     const cs = commentString(doc.commentBefore);
     lines.unshift(stringifyComment.indentComment(cs, ""));
    }
    let chompKeep = !1, contentComment = null;
    if (doc.contents) {
     if (identity.isNode(doc.contents)) {
      if (doc.contents.spaceBefore && hasDirectives && lines.push(""), doc.contents.commentBefore) {
       const cs = commentString(doc.contents.commentBefore);
       lines.push(stringifyComment.indentComment(cs, ""));
      }
      ctx.forceBlockIndent = !!doc.comment, contentComment = doc.contents.comment;
     }
     const onChompKeep = contentComment ? void 0 : () => chompKeep = !0;
     let body = stringify.stringify(doc.contents, ctx, (() => contentComment = null), onChompKeep);
     contentComment && (body += stringifyComment.lineComment(body, "", commentString(contentComment))), 
     "|" !== body[0] && ">" !== body[0] || "---" !== lines[lines.length - 1] ? lines.push(body) : lines[lines.length - 1] = `--- ${body}`;
    } else lines.push(stringify.stringify(doc.contents, ctx));
    if (doc.directives?.docEnd) if (doc.comment) {
     const cs = commentString(doc.comment);
     cs.includes("\n") ? (lines.push("..."), lines.push(stringifyComment.indentComment(cs, ""))) : lines.push(`... ${cs}`);
    } else lines.push("..."); else {
     let dc = doc.comment;
     dc && chompKeep && (dc = dc.replace(/^\n+/, "")), dc && (chompKeep && !contentComment || "" === lines[lines.length - 1] || lines.push(""), 
     lines.push(stringifyComment.indentComment(commentString(dc), "")));
    }
    return lines.join("\n") + "\n";
   };
  },
  3144: (__unused_webpack_module, exports) => {
   "use strict";
   exports.stringifyNumber = function({format, minFractionDigits, tag, value}) {
    if ("bigint" == typeof value) return String(value);
    const num = "number" == typeof value ? value : Number(value);
    if (!isFinite(num)) return isNaN(num) ? ".nan" : num < 0 ? "-.inf" : ".inf";
    let n = JSON.stringify(value);
    if (!format && minFractionDigits && (!tag || "tag:yaml.org,2002:float" === tag) && /^\d/.test(n)) {
     let i = n.indexOf(".");
     i < 0 && (i = n.length, n += ".");
     let d = minFractionDigits - (n.length - i - 1);
     for (;d-- > 0; ) n += "0";
    }
    return n;
   };
  },
  8017: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var identity = __webpack_require__(70484), Scalar = __webpack_require__(89714), stringify = __webpack_require__(93793), stringifyComment = __webpack_require__(40248);
   exports.stringifyPair = function({key, value}, ctx, onComment, onChompKeep) {
    const {allNullValues, doc, indent, indentStep, options: {commentString, indentSeq, simpleKeys}} = ctx;
    let keyComment = identity.isNode(key) && key.comment || null;
    if (simpleKeys) {
     if (keyComment) throw new Error("With simple keys, key nodes cannot have comments");
     if (identity.isCollection(key) || !identity.isNode(key) && "object" == typeof key) {
      throw new Error("With simple keys, collection cannot be used as a key value");
     }
    }
    let explicitKey = !simpleKeys && (!key || keyComment && null == value && !ctx.inFlow || identity.isCollection(key) || (identity.isScalar(key) ? key.type === Scalar.Scalar.BLOCK_FOLDED || key.type === Scalar.Scalar.BLOCK_LITERAL : "object" == typeof key));
    ctx = Object.assign({}, ctx, {
     allNullValues: !1,
     implicitKey: !explicitKey && (simpleKeys || !allNullValues),
     indent: indent + indentStep
    });
    let vsb, vcb, valueComment, keyCommentDone = !1, chompKeep = !1, str = stringify.stringify(key, ctx, (() => keyCommentDone = !0), (() => chompKeep = !0));
    if (!explicitKey && !ctx.inFlow && str.length > 1024) {
     if (simpleKeys) throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
     explicitKey = !0;
    }
    if (ctx.inFlow) {
     if (allNullValues || null == value) return keyCommentDone && onComment && onComment(), 
     "" === str ? "?" : explicitKey ? `? ${str}` : str;
    } else if (allNullValues && !simpleKeys || null == value && explicitKey) return str = `? ${str}`, 
    keyComment && !keyCommentDone ? str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment)) : chompKeep && onChompKeep && onChompKeep(), 
    str;
    keyCommentDone && (keyComment = null), explicitKey ? (keyComment && (str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment))), 
    str = `? ${str}\n${indent}:`) : (str = `${str}:`, keyComment && (str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment)))), 
    identity.isNode(value) ? (vsb = !!value.spaceBefore, vcb = value.commentBefore, 
    valueComment = value.comment) : (vsb = !1, vcb = null, valueComment = null, value && "object" == typeof value && (value = doc.createNode(value))), 
    ctx.implicitKey = !1, explicitKey || keyComment || !identity.isScalar(value) || (ctx.indentAtStart = str.length + 1), 
    chompKeep = !1, indentSeq || !(indentStep.length >= 2) || ctx.inFlow || explicitKey || !identity.isSeq(value) || value.flow || value.tag || value.anchor || (ctx.indent = ctx.indent.substring(2));
    let valueCommentDone = !1;
    const valueStr = stringify.stringify(value, ctx, (() => valueCommentDone = !0), (() => chompKeep = !0));
    let ws = " ";
    if (keyComment || vsb || vcb) {
     if (ws = vsb ? "\n" : "", vcb) {
      const cs = commentString(vcb);
      ws += `\n${stringifyComment.indentComment(cs, ctx.indent)}`;
     }
     "" !== valueStr || ctx.inFlow ? ws += `\n${ctx.indent}` : "\n" === ws && (ws = "\n\n");
    } else if (!explicitKey && identity.isCollection(value)) {
     const vs0 = valueStr[0], nl0 = valueStr.indexOf("\n"), hasNewline = -1 !== nl0, flow = ctx.inFlow ?? value.flow ?? 0 === value.items.length;
     if (hasNewline || !flow) {
      let hasPropsLine = !1;
      if (hasNewline && ("&" === vs0 || "!" === vs0)) {
       let sp0 = valueStr.indexOf(" ");
       "&" === vs0 && -1 !== sp0 && sp0 < nl0 && "!" === valueStr[sp0 + 1] && (sp0 = valueStr.indexOf(" ", sp0 + 1)), 
       (-1 === sp0 || nl0 < sp0) && (hasPropsLine = !0);
      }
      hasPropsLine || (ws = `\n${ctx.indent}`);
     }
    } else "" !== valueStr && "\n" !== valueStr[0] || (ws = "");
    return str += ws + valueStr, ctx.inFlow ? valueCommentDone && onComment && onComment() : valueComment && !valueCommentDone ? str += stringifyComment.lineComment(str, ctx.indent, commentString(valueComment)) : chompKeep && onChompKeep && onChompKeep(), 
    str;
   };
  },
  27180: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var Scalar = __webpack_require__(89714), foldFlowLines = __webpack_require__(46170);
   const getFoldOptions = (ctx, isBlock) => ({
    indentAtStart: isBlock ? ctx.indent.length : ctx.indentAtStart,
    lineWidth: ctx.options.lineWidth,
    minContentWidth: ctx.options.minContentWidth
   }), containsDocumentMarker = str => /^(%|---|\.\.\.)/m.test(str);
   function doubleQuotedString(value, ctx) {
    const json = JSON.stringify(value);
    if (ctx.options.doubleQuotedAsJSON) return json;
    const {implicitKey} = ctx, minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength, indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
    let str = "", start = 0;
    for (let i = 0, ch = json[i]; ch; ch = json[++i]) if (" " === ch && "\\" === json[i + 1] && "n" === json[i + 2] && (str += json.slice(start, i) + "\\ ", 
    i += 1, start = i, ch = "\\"), "\\" === ch) switch (json[i + 1]) {
    case "u":
     {
      str += json.slice(start, i);
      const code = json.substr(i + 2, 4);
      switch (code) {
      case "0000":
       str += "\\0";
       break;

      case "0007":
       str += "\\a";
       break;

      case "000b":
       str += "\\v";
       break;

      case "001b":
       str += "\\e";
       break;

      case "0085":
       str += "\\N";
       break;

      case "00a0":
       str += "\\_";
       break;

      case "2028":
       str += "\\L";
       break;

      case "2029":
       str += "\\P";
       break;

      default:
       "00" === code.substr(0, 2) ? str += "\\x" + code.substr(2) : str += json.substr(i, 6);
      }
      i += 5, start = i + 1;
     }
     break;

    case "n":
     if (implicitKey || '"' === json[i + 2] || json.length < minMultiLineLength) i += 1; else {
      for (str += json.slice(start, i) + "\n\n"; "\\" === json[i + 2] && "n" === json[i + 3] && '"' !== json[i + 4]; ) str += "\n", 
      i += 2;
      str += indent, " " === json[i + 2] && (str += "\\"), i += 1, start = i + 1;
     }
     break;

    default:
     i += 1;
    }
    return str = start ? str + json.slice(start) : json, implicitKey ? str : foldFlowLines.foldFlowLines(str, indent, foldFlowLines.FOLD_QUOTED, getFoldOptions(ctx, !1));
   }
   function singleQuotedString(value, ctx) {
    if (!1 === ctx.options.singleQuote || ctx.implicitKey && value.includes("\n") || /[ \t]\n|\n[ \t]/.test(value)) return doubleQuotedString(value, ctx);
    const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : ""), res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&\n${indent}`) + "'";
    return ctx.implicitKey ? res : foldFlowLines.foldFlowLines(res, indent, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx, !1));
   }
   function quotedString(value, ctx) {
    const {singleQuote} = ctx.options;
    let qs;
    if (!1 === singleQuote) qs = doubleQuotedString; else {
     const hasDouble = value.includes('"'), hasSingle = value.includes("'");
     qs = hasDouble && !hasSingle ? singleQuotedString : hasSingle && !hasDouble ? doubleQuotedString : singleQuote ? singleQuotedString : doubleQuotedString;
    }
    return qs(value, ctx);
   }
   let blockEndNewlines;
   try {
    blockEndNewlines = new RegExp("(^|(?<!\n))\n+(?!\n|$)", "g");
   } catch {
    blockEndNewlines = /\n+(?!\n|$)/g;
   }
   function blockString({comment, type, value}, ctx, onComment, onChompKeep) {
    const {blockQuote, commentString, lineWidth} = ctx.options;
    if (!blockQuote || /\n[\t ]+$/.test(value) || /^\s*$/.test(value)) return quotedString(value, ctx);
    const indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? "  " : ""), literal = "literal" === blockQuote || "folded" !== blockQuote && type !== Scalar.Scalar.BLOCK_FOLDED && (type === Scalar.Scalar.BLOCK_LITERAL || !function(str, lineWidth, indentLength) {
     if (!lineWidth || lineWidth < 0) return !1;
     const limit = lineWidth - indentLength, strLen = str.length;
     if (strLen <= limit) return !1;
     for (let i = 0, start = 0; i < strLen; ++i) if ("\n" === str[i]) {
      if (i - start > limit) return !0;
      if (start = i + 1, strLen - start <= limit) return !1;
     }
     return !0;
    }(value, lineWidth, indent.length));
    if (!value) return literal ? "|\n" : ">\n";
    let chomp, endStart;
    for (endStart = value.length; endStart > 0; --endStart) {
     const ch = value[endStart - 1];
     if ("\n" !== ch && "\t" !== ch && " " !== ch) break;
    }
    let end = value.substring(endStart);
    const endNlPos = end.indexOf("\n");
    -1 === endNlPos ? chomp = "-" : value === end || endNlPos !== end.length - 1 ? (chomp = "+", 
    onChompKeep && onChompKeep()) : chomp = "", end && (value = value.slice(0, -end.length), 
    "\n" === end[end.length - 1] && (end = end.slice(0, -1)), end = end.replace(blockEndNewlines, `$&${indent}`));
    let startEnd, startWithSpace = !1, startNlPos = -1;
    for (startEnd = 0; startEnd < value.length; ++startEnd) {
     const ch = value[startEnd];
     if (" " === ch) startWithSpace = !0; else {
      if ("\n" !== ch) break;
      startNlPos = startEnd;
     }
    }
    let start = value.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);
    start && (value = value.substring(start.length), start = start.replace(/\n+/g, `$&${indent}`));
    let header = (literal ? "|" : ">") + (startWithSpace ? indent ? "2" : "1" : "") + chomp;
    if (comment && (header += " " + commentString(comment.replace(/ ?[\r\n]+/g, " ")), 
    onComment && onComment()), literal) return `${header}\n${indent}${start}${value = value.replace(/\n+/g, `$&${indent}`)}${end}`;
    value = value.replace(/\n+/g, "\n$&").replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${indent}`);
    return `${header}\n${indent}${foldFlowLines.foldFlowLines(`${start}${value}${end}`, indent, foldFlowLines.FOLD_BLOCK, getFoldOptions(ctx, !0))}`;
   }
   exports.stringifyString = function(item, ctx, onComment, onChompKeep) {
    const {implicitKey, inFlow} = ctx, ss = "string" == typeof item.value ? item : Object.assign({}, item, {
     value: String(item.value)
    });
    let {type} = item;
    type !== Scalar.Scalar.QUOTE_DOUBLE && /[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(ss.value) && (type = Scalar.Scalar.QUOTE_DOUBLE);
    const _stringify = _type => {
     switch (_type) {
     case Scalar.Scalar.BLOCK_FOLDED:
     case Scalar.Scalar.BLOCK_LITERAL:
      return implicitKey || inFlow ? quotedString(ss.value, ctx) : blockString(ss, ctx, onComment, onChompKeep);

     case Scalar.Scalar.QUOTE_DOUBLE:
      return doubleQuotedString(ss.value, ctx);

     case Scalar.Scalar.QUOTE_SINGLE:
      return singleQuotedString(ss.value, ctx);

     case Scalar.Scalar.PLAIN:
      return function(item, ctx, onComment, onChompKeep) {
       const {type, value} = item, {actualString, implicitKey, indent, indentStep, inFlow} = ctx;
       if (implicitKey && value.includes("\n") || inFlow && /[[\]{},]/.test(value)) return quotedString(value, ctx);
       if (!value || /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) return implicitKey || inFlow || !value.includes("\n") ? quotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);
       if (!implicitKey && !inFlow && type !== Scalar.Scalar.PLAIN && value.includes("\n")) return blockString(item, ctx, onComment, onChompKeep);
       if (containsDocumentMarker(value)) {
        if ("" === indent) return ctx.forceBlockIndent = !0, blockString(item, ctx, onComment, onChompKeep);
        if (implicitKey && indent === indentStep) return quotedString(value, ctx);
       }
       const str = value.replace(/\n+/g, `$&\n${indent}`);
       if (actualString) {
        const test = tag => tag.default && "tag:yaml.org,2002:str" !== tag.tag && tag.test?.test(str), {compat, tags} = ctx.doc.schema;
        if (tags.some(test) || compat?.some(test)) return quotedString(value, ctx);
       }
       return implicitKey ? str : foldFlowLines.foldFlowLines(str, indent, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx, !1));
      }(ss, ctx, onComment, onChompKeep);

     default:
      return null;
     }
    };
    let res = _stringify(type);
    if (null === res) {
     const {defaultKeyType, defaultStringType} = ctx.options, t = implicitKey && defaultKeyType || defaultStringType;
     if (res = _stringify(t), null === res) throw new Error(`Unsupported default string type ${t}`);
    }
    return res;
   };
  },
  29125: (__unused_webpack_module, exports, __webpack_require__) => {
   "use strict";
   var identity = __webpack_require__(70484);
   const BREAK = Symbol("break visit"), SKIP = Symbol("skip children"), REMOVE = Symbol("remove node");
   function visit(node, visitor) {
    const visitor_ = initVisitor(visitor);
    if (identity.isDocument(node)) {
     visit_(null, node.contents, visitor_, Object.freeze([ node ])) === REMOVE && (node.contents = null);
    } else visit_(null, node, visitor_, Object.freeze([]));
   }
   function visit_(key, node, visitor, path) {
    const ctrl = callVisitor(key, node, visitor, path);
    if (identity.isNode(ctrl) || identity.isPair(ctrl)) return replaceNode(key, path, ctrl), 
    visit_(key, ctrl, visitor, path);
    if ("symbol" != typeof ctrl) if (identity.isCollection(node)) {
     path = Object.freeze(path.concat(node));
     for (let i = 0; i < node.items.length; ++i) {
      const ci = visit_(i, node.items[i], visitor, path);
      if ("number" == typeof ci) i = ci - 1; else {
       if (ci === BREAK) return BREAK;
       ci === REMOVE && (node.items.splice(i, 1), i -= 1);
      }
     }
    } else if (identity.isPair(node)) {
     path = Object.freeze(path.concat(node));
     const ck = visit_("key", node.key, visitor, path);
     if (ck === BREAK) return BREAK;
     ck === REMOVE && (node.key = null);
     const cv = visit_("value", node.value, visitor, path);
     if (cv === BREAK) return BREAK;
     cv === REMOVE && (node.value = null);
    }
    return ctrl;
   }
   async function visitAsync(node, visitor) {
    const visitor_ = initVisitor(visitor);
    if (identity.isDocument(node)) {
     await visitAsync_(null, node.contents, visitor_, Object.freeze([ node ])) === REMOVE && (node.contents = null);
    } else await visitAsync_(null, node, visitor_, Object.freeze([]));
   }
   async function visitAsync_(key, node, visitor, path) {
    const ctrl = await callVisitor(key, node, visitor, path);
    if (identity.isNode(ctrl) || identity.isPair(ctrl)) return replaceNode(key, path, ctrl), 
    visitAsync_(key, ctrl, visitor, path);
    if ("symbol" != typeof ctrl) if (identity.isCollection(node)) {
     path = Object.freeze(path.concat(node));
     for (let i = 0; i < node.items.length; ++i) {
      const ci = await visitAsync_(i, node.items[i], visitor, path);
      if ("number" == typeof ci) i = ci - 1; else {
       if (ci === BREAK) return BREAK;
       ci === REMOVE && (node.items.splice(i, 1), i -= 1);
      }
     }
    } else if (identity.isPair(node)) {
     path = Object.freeze(path.concat(node));
     const ck = await visitAsync_("key", node.key, visitor, path);
     if (ck === BREAK) return BREAK;
     ck === REMOVE && (node.key = null);
     const cv = await visitAsync_("value", node.value, visitor, path);
     if (cv === BREAK) return BREAK;
     cv === REMOVE && (node.value = null);
    }
    return ctrl;
   }
   function initVisitor(visitor) {
    return "object" == typeof visitor && (visitor.Collection || visitor.Node || visitor.Value) ? Object.assign({
     Alias: visitor.Node,
     Map: visitor.Node,
     Scalar: visitor.Node,
     Seq: visitor.Node
    }, visitor.Value && {
     Map: visitor.Value,
     Scalar: visitor.Value,
     Seq: visitor.Value
    }, visitor.Collection && {
     Map: visitor.Collection,
     Seq: visitor.Collection
    }, visitor) : visitor;
   }
   function callVisitor(key, node, visitor, path) {
    return "function" == typeof visitor ? visitor(key, node, path) : identity.isMap(node) ? visitor.Map?.(key, node, path) : identity.isSeq(node) ? visitor.Seq?.(key, node, path) : identity.isPair(node) ? visitor.Pair?.(key, node, path) : identity.isScalar(node) ? visitor.Scalar?.(key, node, path) : identity.isAlias(node) ? visitor.Alias?.(key, node, path) : void 0;
   }
   function replaceNode(key, path, node) {
    const parent = path[path.length - 1];
    if (identity.isCollection(parent)) parent.items[key] = node; else if (identity.isPair(parent)) "key" === key ? parent.key = node : parent.value = node; else {
     if (!identity.isDocument(parent)) {
      const pt = identity.isAlias(parent) ? "alias" : "scalar";
      throw new Error(`Cannot replace node with ${pt} parent`);
     }
     parent.contents = node;
    }
   }
   visit.BREAK = BREAK, visit.SKIP = SKIP, visit.REMOVE = REMOVE, visitAsync.BREAK = BREAK, 
   visitAsync.SKIP = SKIP, visitAsync.REMOVE = REMOVE, exports.visit = visit, exports.visitAsync = visitAsync;
  },
  37615: (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.r(__webpack_exports__), __webpack_require__.d(__webpack_exports__, {
    AbortError: () => AbortError,
    FetchError: () => FetchError,
    Headers: () => Headers,
    Request: () => Request,
    Response: () => Response,
    default: () => __WEBPACK_DEFAULT_EXPORT__
   });
   var stream__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2203), http__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(58611), url__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(87016), whatwg_url__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(53417), https__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(65692), zlib__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(43106);
   const Readable = stream__WEBPACK_IMPORTED_MODULE_0__.Readable, BUFFER = Symbol("buffer"), TYPE = Symbol("type");
   class Blob {
    constructor() {
     this[TYPE] = "";
     const blobParts = arguments[0], options = arguments[1], buffers = [];
     let size = 0;
     if (blobParts) {
      const a = blobParts, length = Number(a.length);
      for (let i = 0; i < length; i++) {
       const element = a[i];
       let buffer;
       buffer = element instanceof Buffer ? element : ArrayBuffer.isView(element) ? Buffer.from(element.buffer, element.byteOffset, element.byteLength) : element instanceof ArrayBuffer ? Buffer.from(element) : element instanceof Blob ? element[BUFFER] : Buffer.from("string" == typeof element ? element : String(element)), 
       size += buffer.length, buffers.push(buffer);
      }
     }
     this[BUFFER] = Buffer.concat(buffers);
     let type = options && void 0 !== options.type && String(options.type).toLowerCase();
     type && !/[^\u0020-\u007E]/.test(type) && (this[TYPE] = type);
    }
    get size() {
     return this[BUFFER].length;
    }
    get type() {
     return this[TYPE];
    }
    text() {
     return Promise.resolve(this[BUFFER].toString());
    }
    arrayBuffer() {
     const buf = this[BUFFER], ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
     return Promise.resolve(ab);
    }
    stream() {
     const readable = new Readable;
     return readable._read = function() {}, readable.push(this[BUFFER]), readable.push(null), 
     readable;
    }
    toString() {
     return "[object Blob]";
    }
    slice() {
     const size = this.size, start = arguments[0], end = arguments[1];
     let relativeStart, relativeEnd;
     relativeStart = void 0 === start ? 0 : start < 0 ? Math.max(size + start, 0) : Math.min(start, size), 
     relativeEnd = void 0 === end ? size : end < 0 ? Math.max(size + end, 0) : Math.min(end, size);
     const span = Math.max(relativeEnd - relativeStart, 0), slicedBuffer = this[BUFFER].slice(relativeStart, relativeStart + span), blob = new Blob([], {
      type: arguments[2]
     });
     return blob[BUFFER] = slicedBuffer, blob;
    }
   }
   function FetchError(message, type, systemError) {
    Error.call(this, message), this.message = message, this.type = type, systemError && (this.code = this.errno = systemError.code), 
    Error.captureStackTrace(this, this.constructor);
   }
   let convert;
   Object.defineProperties(Blob.prototype, {
    size: {
     enumerable: !0
    },
    type: {
     enumerable: !0
    },
    slice: {
     enumerable: !0
    }
   }), Object.defineProperty(Blob.prototype, Symbol.toStringTag, {
    value: "Blob",
    writable: !1,
    enumerable: !1,
    configurable: !0
   }), FetchError.prototype = Object.create(Error.prototype), FetchError.prototype.constructor = FetchError, 
   FetchError.prototype.name = "FetchError";
   try {
    convert = require("encoding").convert;
   } catch (e) {}
   const INTERNALS = Symbol("Body internals"), PassThrough = stream__WEBPACK_IMPORTED_MODULE_0__.PassThrough;
   function Body(body) {
    var _this = this, _ref = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, _ref$size = _ref.size;
    let size = void 0 === _ref$size ? 0 : _ref$size;
    var _ref$timeout = _ref.timeout;
    let timeout = void 0 === _ref$timeout ? 0 : _ref$timeout;
    null == body ? body = null : isURLSearchParams(body) ? body = Buffer.from(body.toString()) : isBlob(body) || Buffer.isBuffer(body) || ("[object ArrayBuffer]" === Object.prototype.toString.call(body) ? body = Buffer.from(body) : ArrayBuffer.isView(body) ? body = Buffer.from(body.buffer, body.byteOffset, body.byteLength) : body instanceof stream__WEBPACK_IMPORTED_MODULE_0__ || (body = Buffer.from(String(body)))), 
    this[INTERNALS] = {
     body,
     disturbed: !1,
     error: null
    }, this.size = size, this.timeout = timeout, body instanceof stream__WEBPACK_IMPORTED_MODULE_0__ && body.on("error", (function(err) {
     const error = "AbortError" === err.name ? err : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, "system", err);
     _this[INTERNALS].error = error;
    }));
   }
   function consumeBody() {
    var _this4 = this;
    if (this[INTERNALS].disturbed) return Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));
    if (this[INTERNALS].disturbed = !0, this[INTERNALS].error) return Body.Promise.reject(this[INTERNALS].error);
    let body = this.body;
    if (null === body) return Body.Promise.resolve(Buffer.alloc(0));
    if (isBlob(body) && (body = body.stream()), Buffer.isBuffer(body)) return Body.Promise.resolve(body);
    if (!(body instanceof stream__WEBPACK_IMPORTED_MODULE_0__)) return Body.Promise.resolve(Buffer.alloc(0));
    let accum = [], accumBytes = 0, abort = !1;
    return new Body.Promise((function(resolve, reject) {
     let resTimeout;
     _this4.timeout && (resTimeout = setTimeout((function() {
      abort = !0, reject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, "body-timeout"));
     }), _this4.timeout)), body.on("error", (function(err) {
      "AbortError" === err.name ? (abort = !0, reject(err)) : reject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, "system", err));
     })), body.on("data", (function(chunk) {
      if (!abort && null !== chunk) {
       if (_this4.size && accumBytes + chunk.length > _this4.size) return abort = !0, void reject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, "max-size"));
       accumBytes += chunk.length, accum.push(chunk);
      }
     })), body.on("end", (function() {
      if (!abort) {
       clearTimeout(resTimeout);
       try {
        resolve(Buffer.concat(accum, accumBytes));
       } catch (err) {
        reject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, "system", err));
       }
      }
     }));
    }));
   }
   function isURLSearchParams(obj) {
    return "object" == typeof obj && "function" == typeof obj.append && "function" == typeof obj.delete && "function" == typeof obj.get && "function" == typeof obj.getAll && "function" == typeof obj.has && "function" == typeof obj.set && ("URLSearchParams" === obj.constructor.name || "[object URLSearchParams]" === Object.prototype.toString.call(obj) || "function" == typeof obj.sort);
   }
   function isBlob(obj) {
    return "object" == typeof obj && "function" == typeof obj.arrayBuffer && "string" == typeof obj.type && "function" == typeof obj.stream && "function" == typeof obj.constructor && "string" == typeof obj.constructor.name && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);
   }
   function clone(instance) {
    let p1, p2, body = instance.body;
    if (instance.bodyUsed) throw new Error("cannot clone body after it is used");
    return body instanceof stream__WEBPACK_IMPORTED_MODULE_0__ && "function" != typeof body.getBoundary && (p1 = new PassThrough, 
    p2 = new PassThrough, body.pipe(p1), body.pipe(p2), instance[INTERNALS].body = p1, 
    body = p2), body;
   }
   function extractContentType(body) {
    return null === body ? null : "string" == typeof body ? "text/plain;charset=UTF-8" : isURLSearchParams(body) ? "application/x-www-form-urlencoded;charset=UTF-8" : isBlob(body) ? body.type || null : Buffer.isBuffer(body) || "[object ArrayBuffer]" === Object.prototype.toString.call(body) || ArrayBuffer.isView(body) ? null : "function" == typeof body.getBoundary ? `multipart/form-data;boundary=${body.getBoundary()}` : body instanceof stream__WEBPACK_IMPORTED_MODULE_0__ ? null : "text/plain;charset=UTF-8";
   }
   function getTotalBytes(instance) {
    const body = instance.body;
    return null === body ? 0 : isBlob(body) ? body.size : Buffer.isBuffer(body) ? body.length : body && "function" == typeof body.getLengthSync && (body._lengthRetrievers && 0 == body._lengthRetrievers.length || body.hasKnownLength && body.hasKnownLength()) ? body.getLengthSync() : null;
   }
   Body.prototype = {
    get body() {
     return this[INTERNALS].body;
    },
    get bodyUsed() {
     return this[INTERNALS].disturbed;
    },
    arrayBuffer() {
     return consumeBody.call(this).then((function(buf) {
      return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
     }));
    },
    blob() {
     let ct = this.headers && this.headers.get("content-type") || "";
     return consumeBody.call(this).then((function(buf) {
      return Object.assign(new Blob([], {
       type: ct.toLowerCase()
      }), {
       [BUFFER]: buf
      });
     }));
    },
    json() {
     var _this2 = this;
     return consumeBody.call(this).then((function(buffer) {
      try {
       return JSON.parse(buffer.toString());
      } catch (err) {
       return Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, "invalid-json"));
      }
     }));
    },
    text() {
     return consumeBody.call(this).then((function(buffer) {
      return buffer.toString();
     }));
    },
    buffer() {
     return consumeBody.call(this);
    },
    textConverted() {
     var _this3 = this;
     return consumeBody.call(this).then((function(buffer) {
      return function(buffer, headers) {
       if ("function" != typeof convert) throw new Error("The package `encoding` must be installed to use the textConverted() function");
       const ct = headers.get("content-type");
       let res, str, charset = "utf-8";
       ct && (res = /charset=([^;]*)/i.exec(ct));
       str = buffer.slice(0, 1024).toString(), !res && str && (res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str));
       !res && str && (res = /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(str), 
       res || (res = /<meta[\s]+?content=(['"])(.+?)\1[\s]+?http-equiv=(['"])content-type\3/i.exec(str), 
       res && res.pop()), res && (res = /charset=(.*)/i.exec(res.pop())));
       !res && str && (res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str));
       res && (charset = res.pop(), "gb2312" !== charset && "gbk" !== charset || (charset = "gb18030"));
       return convert(buffer, "UTF-8", charset).toString();
      }(buffer, _this3.headers);
     }));
    }
   }, Object.defineProperties(Body.prototype, {
    body: {
     enumerable: !0
    },
    bodyUsed: {
     enumerable: !0
    },
    arrayBuffer: {
     enumerable: !0
    },
    blob: {
     enumerable: !0
    },
    json: {
     enumerable: !0
    },
    text: {
     enumerable: !0
    }
   }), Body.mixIn = function(proto) {
    for (const name of Object.getOwnPropertyNames(Body.prototype)) if (!(name in proto)) {
     const desc = Object.getOwnPropertyDescriptor(Body.prototype, name);
     Object.defineProperty(proto, name, desc);
    }
   }, Body.Promise = global.Promise;
   const invalidTokenRegex = /[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/, invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
   function validateName(name) {
    if (name = `${name}`, invalidTokenRegex.test(name) || "" === name) throw new TypeError(`${name} is not a legal HTTP header name`);
   }
   function validateValue(value) {
    if (value = `${value}`, invalidHeaderCharRegex.test(value)) throw new TypeError(`${value} is not a legal HTTP header value`);
   }
   function find(map, name) {
    name = name.toLowerCase();
    for (const key in map) if (key.toLowerCase() === name) return key;
   }
   const MAP = Symbol("map");
   class Headers {
    constructor() {
     let init = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : void 0;
     if (this[MAP] = Object.create(null), init instanceof Headers) {
      const rawHeaders = init.raw(), headerNames = Object.keys(rawHeaders);
      for (const headerName of headerNames) for (const value of rawHeaders[headerName]) this.append(headerName, value);
     } else if (null == init) ; else {
      if ("object" != typeof init) throw new TypeError("Provided initializer must be an object");
      {
       const method = init[Symbol.iterator];
       if (null != method) {
        if ("function" != typeof method) throw new TypeError("Header pairs must be iterable");
        const pairs = [];
        for (const pair of init) {
         if ("object" != typeof pair || "function" != typeof pair[Symbol.iterator]) throw new TypeError("Each header pair must be iterable");
         pairs.push(Array.from(pair));
        }
        for (const pair of pairs) {
         if (2 !== pair.length) throw new TypeError("Each header pair must be a name/value tuple");
         this.append(pair[0], pair[1]);
        }
       } else for (const key of Object.keys(init)) {
        const value = init[key];
        this.append(key, value);
       }
      }
     }
    }
    get(name) {
     validateName(name = `${name}`);
     const key = find(this[MAP], name);
     return void 0 === key ? null : this[MAP][key].join(", ");
    }
    forEach(callback) {
     let thisArg = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : void 0, pairs = getHeaders(this), i = 0;
     for (;i < pairs.length; ) {
      var _pairs$i = pairs[i];
      const name = _pairs$i[0], value = _pairs$i[1];
      callback.call(thisArg, value, name, this), pairs = getHeaders(this), i++;
     }
    }
    set(name, value) {
     value = `${value}`, validateName(name = `${name}`), validateValue(value);
     const key = find(this[MAP], name);
     this[MAP][void 0 !== key ? key : name] = [ value ];
    }
    append(name, value) {
     value = `${value}`, validateName(name = `${name}`), validateValue(value);
     const key = find(this[MAP], name);
     void 0 !== key ? this[MAP][key].push(value) : this[MAP][name] = [ value ];
    }
    has(name) {
     return validateName(name = `${name}`), void 0 !== find(this[MAP], name);
    }
    delete(name) {
     validateName(name = `${name}`);
     const key = find(this[MAP], name);
     void 0 !== key && delete this[MAP][key];
    }
    raw() {
     return this[MAP];
    }
    keys() {
     return createHeadersIterator(this, "key");
    }
    values() {
     return createHeadersIterator(this, "value");
    }
    [Symbol.iterator]() {
     return createHeadersIterator(this, "key+value");
    }
   }
   function getHeaders(headers) {
    let kind = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "key+value";
    return Object.keys(headers[MAP]).sort().map("key" === kind ? function(k) {
     return k.toLowerCase();
    } : "value" === kind ? function(k) {
     return headers[MAP][k].join(", ");
    } : function(k) {
     return [ k.toLowerCase(), headers[MAP][k].join(", ") ];
    });
   }
   Headers.prototype.entries = Headers.prototype[Symbol.iterator], Object.defineProperty(Headers.prototype, Symbol.toStringTag, {
    value: "Headers",
    writable: !1,
    enumerable: !1,
    configurable: !0
   }), Object.defineProperties(Headers.prototype, {
    get: {
     enumerable: !0
    },
    forEach: {
     enumerable: !0
    },
    set: {
     enumerable: !0
    },
    append: {
     enumerable: !0
    },
    has: {
     enumerable: !0
    },
    delete: {
     enumerable: !0
    },
    keys: {
     enumerable: !0
    },
    values: {
     enumerable: !0
    },
    entries: {
     enumerable: !0
    }
   });
   const INTERNAL = Symbol("internal");
   function createHeadersIterator(target, kind) {
    const iterator = Object.create(HeadersIteratorPrototype);
    return iterator[INTERNAL] = {
     target,
     kind,
     index: 0
    }, iterator;
   }
   const HeadersIteratorPrototype = Object.setPrototypeOf({
    next() {
     if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) throw new TypeError("Value of `this` is not a HeadersIterator");
     var _INTERNAL = this[INTERNAL];
     const target = _INTERNAL.target, kind = _INTERNAL.kind, index = _INTERNAL.index, values = getHeaders(target, kind);
     return index >= values.length ? {
      value: void 0,
      done: !0
     } : (this[INTERNAL].index = index + 1, {
      value: values[index],
      done: !1
     });
    }
   }, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));
   function exportNodeCompatibleHeaders(headers) {
    const obj = Object.assign({
     __proto__: null
    }, headers[MAP]), hostHeaderKey = find(headers[MAP], "Host");
    return void 0 !== hostHeaderKey && (obj[hostHeaderKey] = obj[hostHeaderKey][0]), 
    obj;
   }
   Object.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {
    value: "HeadersIterator",
    writable: !1,
    enumerable: !1,
    configurable: !0
   });
   const INTERNALS$1 = Symbol("Response internals"), STATUS_CODES = http__WEBPACK_IMPORTED_MODULE_1__.STATUS_CODES;
   class Response {
    constructor() {
     let body = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, opts = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
     Body.call(this, body, opts);
     const status = opts.status || 200, headers = new Headers(opts.headers);
     if (null != body && !headers.has("Content-Type")) {
      const contentType = extractContentType(body);
      contentType && headers.append("Content-Type", contentType);
     }
     this[INTERNALS$1] = {
      url: opts.url,
      status,
      statusText: opts.statusText || STATUS_CODES[status],
      headers,
      counter: opts.counter
     };
    }
    get url() {
     return this[INTERNALS$1].url || "";
    }
    get status() {
     return this[INTERNALS$1].status;
    }
    get ok() {
     return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
    }
    get redirected() {
     return this[INTERNALS$1].counter > 0;
    }
    get statusText() {
     return this[INTERNALS$1].statusText;
    }
    get headers() {
     return this[INTERNALS$1].headers;
    }
    clone() {
     return new Response(clone(this), {
      url: this.url,
      status: this.status,
      statusText: this.statusText,
      headers: this.headers,
      ok: this.ok,
      redirected: this.redirected
     });
    }
   }
   Body.mixIn(Response.prototype), Object.defineProperties(Response.prototype, {
    url: {
     enumerable: !0
    },
    status: {
     enumerable: !0
    },
    ok: {
     enumerable: !0
    },
    redirected: {
     enumerable: !0
    },
    statusText: {
     enumerable: !0
    },
    headers: {
     enumerable: !0
    },
    clone: {
     enumerable: !0
    }
   }), Object.defineProperty(Response.prototype, Symbol.toStringTag, {
    value: "Response",
    writable: !1,
    enumerable: !1,
    configurable: !0
   });
   const INTERNALS$2 = Symbol("Request internals"), URL = url__WEBPACK_IMPORTED_MODULE_2__.URL || whatwg_url__WEBPACK_IMPORTED_MODULE_3__.URL, parse_url = url__WEBPACK_IMPORTED_MODULE_2__.parse, format_url = url__WEBPACK_IMPORTED_MODULE_2__.format;
   function parseURL(urlStr) {
    return /^[a-zA-Z][a-zA-Z\d+\-.]*:/.exec(urlStr) && (urlStr = new URL(urlStr).toString()), 
    parse_url(urlStr);
   }
   const streamDestructionSupported = "destroy" in stream__WEBPACK_IMPORTED_MODULE_0__.Readable.prototype;
   function isRequest(input) {
    return "object" == typeof input && "object" == typeof input[INTERNALS$2];
   }
   class Request {
    constructor(input) {
     let parsedURL, init = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
     isRequest(input) ? parsedURL = parseURL(input.url) : (parsedURL = input && input.href ? parseURL(input.href) : parseURL(`${input}`), 
     input = {});
     let method = init.method || input.method || "GET";
     if (method = method.toUpperCase(), (null != init.body || isRequest(input) && null !== input.body) && ("GET" === method || "HEAD" === method)) throw new TypeError("Request with GET/HEAD method cannot have body");
     let inputBody = null != init.body ? init.body : isRequest(input) && null !== input.body ? clone(input) : null;
     Body.call(this, inputBody, {
      timeout: init.timeout || input.timeout || 0,
      size: init.size || input.size || 0
     });
     const headers = new Headers(init.headers || input.headers || {});
     if (null != inputBody && !headers.has("Content-Type")) {
      const contentType = extractContentType(inputBody);
      contentType && headers.append("Content-Type", contentType);
     }
     let signal = isRequest(input) ? input.signal : null;
     if ("signal" in init && (signal = init.signal), null != signal && !function isAbortSignal(signal) {
      const proto = signal && "object" == typeof signal && Object.getPrototypeOf(signal);
      return !(!proto || "AbortSignal" !== proto.constructor.name);
     }(signal)) throw new TypeError("Expected signal to be an instanceof AbortSignal");
     this[INTERNALS$2] = {
      method,
      redirect: init.redirect || input.redirect || "follow",
      headers,
      parsedURL,
      signal
     }, this.follow = void 0 !== init.follow ? init.follow : void 0 !== input.follow ? input.follow : 20, 
     this.compress = void 0 !== init.compress ? init.compress : void 0 === input.compress || input.compress, 
     this.counter = init.counter || input.counter || 0, this.agent = init.agent || input.agent;
    }
    get method() {
     return this[INTERNALS$2].method;
    }
    get url() {
     return format_url(this[INTERNALS$2].parsedURL);
    }
    get headers() {
     return this[INTERNALS$2].headers;
    }
    get redirect() {
     return this[INTERNALS$2].redirect;
    }
    get signal() {
     return this[INTERNALS$2].signal;
    }
    clone() {
     return new Request(this);
    }
   }
   function AbortError(message) {
    Error.call(this, message), this.type = "aborted", this.message = message, Error.captureStackTrace(this, this.constructor);
   }
   Body.mixIn(Request.prototype), Object.defineProperty(Request.prototype, Symbol.toStringTag, {
    value: "Request",
    writable: !1,
    enumerable: !1,
    configurable: !0
   }), Object.defineProperties(Request.prototype, {
    method: {
     enumerable: !0
    },
    url: {
     enumerable: !0
    },
    headers: {
     enumerable: !0
    },
    redirect: {
     enumerable: !0
    },
    clone: {
     enumerable: !0
    },
    signal: {
     enumerable: !0
    }
   }), AbortError.prototype = Object.create(Error.prototype), AbortError.prototype.constructor = AbortError, 
   AbortError.prototype.name = "AbortError";
   const URL$1 = url__WEBPACK_IMPORTED_MODULE_2__.URL || whatwg_url__WEBPACK_IMPORTED_MODULE_3__.URL, PassThrough$1 = stream__WEBPACK_IMPORTED_MODULE_0__.PassThrough;
   function fetch(url, opts) {
    if (!fetch.Promise) throw new Error("native promise missing, set fetch.Promise to your favorite alternative");
    return Body.Promise = fetch.Promise, new fetch.Promise((function(resolve, reject) {
     const request = new Request(url, opts), options = function(request) {
      const parsedURL = request[INTERNALS$2].parsedURL, headers = new Headers(request[INTERNALS$2].headers);
      if (headers.has("Accept") || headers.set("Accept", "*/*"), !parsedURL.protocol || !parsedURL.hostname) throw new TypeError("Only absolute URLs are supported");
      if (!/^https?:$/.test(parsedURL.protocol)) throw new TypeError("Only HTTP(S) protocols are supported");
      if (request.signal && request.body instanceof stream__WEBPACK_IMPORTED_MODULE_0__.Readable && !streamDestructionSupported) throw new Error("Cancellation of streamed requests with AbortSignal is not supported in node < 8");
      let contentLengthValue = null;
      if (null == request.body && /^(POST|PUT)$/i.test(request.method) && (contentLengthValue = "0"), 
      null != request.body) {
       const totalBytes = getTotalBytes(request);
       "number" == typeof totalBytes && (contentLengthValue = String(totalBytes));
      }
      contentLengthValue && headers.set("Content-Length", contentLengthValue), headers.has("User-Agent") || headers.set("User-Agent", "node-fetch/1.0 (+https://github.com/bitinn/node-fetch)"), 
      request.compress && !headers.has("Accept-Encoding") && headers.set("Accept-Encoding", "gzip,deflate");
      let agent = request.agent;
      return "function" == typeof agent && (agent = agent(parsedURL)), Object.assign({}, parsedURL, {
       method: request.method,
       headers: exportNodeCompatibleHeaders(headers),
       agent
      });
     }(request), send = ("https:" === options.protocol ? https__WEBPACK_IMPORTED_MODULE_4__ : http__WEBPACK_IMPORTED_MODULE_1__).request, signal = request.signal;
     let response = null;
     const abort = function() {
      let error = new AbortError("The user aborted a request.");
      reject(error), request.body && request.body instanceof stream__WEBPACK_IMPORTED_MODULE_0__.Readable && destroyStream(request.body, error), 
      response && response.body && response.body.emit("error", error);
     };
     if (signal && signal.aborted) return void abort();
     const abortAndFinalize = function() {
      abort(), finalize();
     }, req = send(options);
     let reqTimeout;
     function finalize() {
      req.abort(), signal && signal.removeEventListener("abort", abortAndFinalize), clearTimeout(reqTimeout);
     }
     signal && signal.addEventListener("abort", abortAndFinalize), request.timeout && req.once("socket", (function(socket) {
      reqTimeout = setTimeout((function() {
       reject(new FetchError(`network timeout at: ${request.url}`, "request-timeout")), 
       finalize();
      }), request.timeout);
     })), req.on("error", (function(err) {
      reject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, "system", err)), 
      response && response.body && destroyStream(response.body, err), finalize();
     })), function(request, errorCallback) {
      let socket;
      request.on("socket", (function(s) {
       socket = s;
      })), request.on("response", (function(response) {
       const headers = response.headers;
       "chunked" !== headers["transfer-encoding"] || headers["content-length"] || response.once("close", (function(hadError) {
        if (socket && socket.listenerCount("data") > 0 && !hadError) {
         const err = new Error("Premature close");
         err.code = "ERR_STREAM_PREMATURE_CLOSE", errorCallback(err);
        }
       }));
      }));
     }(req, (function(err) {
      signal && signal.aborted || response && response.body && destroyStream(response.body, err);
     })), parseInt(process.version.substring(1)) < 14 && req.on("socket", (function(s) {
      s.addListener("close", (function(hadError) {
       const hasDataListener = s.listenerCount("data") > 0;
       if (response && hasDataListener && !hadError && (!signal || !signal.aborted)) {
        const err = new Error("Premature close");
        err.code = "ERR_STREAM_PREMATURE_CLOSE", response.body.emit("error", err);
       }
      }));
     })), req.on("response", (function(res) {
      clearTimeout(reqTimeout);
      const headers = function(obj) {
       const headers = new Headers;
       for (const name of Object.keys(obj)) if (!invalidTokenRegex.test(name)) if (Array.isArray(obj[name])) for (const val of obj[name]) invalidHeaderCharRegex.test(val) || (void 0 === headers[MAP][name] ? headers[MAP][name] = [ val ] : headers[MAP][name].push(val)); else invalidHeaderCharRegex.test(obj[name]) || (headers[MAP][name] = [ obj[name] ]);
       return headers;
      }(res.headers);
      if (fetch.isRedirect(res.statusCode)) {
       const location = headers.get("Location");
       let locationURL = null;
       try {
        locationURL = null === location ? null : new URL$1(location, request.url).toString();
       } catch (err) {
        if ("manual" !== request.redirect) return reject(new FetchError(`uri requested responds with an invalid redirect URL: ${location}`, "invalid-redirect")), 
        void finalize();
       }
       switch (request.redirect) {
       case "error":
        return reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, "no-redirect")), 
        void finalize();

       case "manual":
        if (null !== locationURL) try {
         headers.set("Location", locationURL);
        } catch (err) {
         reject(err);
        }
        break;

       case "follow":
        if (null === locationURL) break;
        if (request.counter >= request.follow) return reject(new FetchError(`maximum redirect reached at: ${request.url}`, "max-redirect")), 
        void finalize();
        const requestOpts = {
         headers: new Headers(request.headers),
         follow: request.follow,
         counter: request.counter + 1,
         agent: request.agent,
         compress: request.compress,
         method: request.method,
         body: request.body,
         signal: request.signal,
         timeout: request.timeout,
         size: request.size
        };
        if (!function(destination, original) {
         const orig = new URL$1(original).hostname, dest = new URL$1(destination).hostname;
         return orig === dest || "." === orig[orig.length - dest.length - 1] && orig.endsWith(dest);
        }(request.url, locationURL) || (destination = request.url, new URL$1(locationURL).protocol !== new URL$1(destination).protocol)) for (const name of [ "authorization", "www-authenticate", "cookie", "cookie2" ]) requestOpts.headers.delete(name);
        return 303 !== res.statusCode && request.body && null === getTotalBytes(request) ? (reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect")), 
        void finalize()) : (303 !== res.statusCode && (301 !== res.statusCode && 302 !== res.statusCode || "POST" !== request.method) || (requestOpts.method = "GET", 
        requestOpts.body = void 0, requestOpts.headers.delete("content-length")), resolve(fetch(new Request(locationURL, requestOpts))), 
        void finalize());
       }
      }
      var destination;
      res.once("end", (function() {
       signal && signal.removeEventListener("abort", abortAndFinalize);
      }));
      let body = res.pipe(new PassThrough$1);
      const response_options = {
       url: request.url,
       status: res.statusCode,
       statusText: res.statusMessage,
       headers,
       size: request.size,
       timeout: request.timeout,
       counter: request.counter
      }, codings = headers.get("Content-Encoding");
      if (!request.compress || "HEAD" === request.method || null === codings || 204 === res.statusCode || 304 === res.statusCode) return response = new Response(body, response_options), 
      void resolve(response);
      const zlibOptions = {
       flush: zlib__WEBPACK_IMPORTED_MODULE_5__.Z_SYNC_FLUSH,
       finishFlush: zlib__WEBPACK_IMPORTED_MODULE_5__.Z_SYNC_FLUSH
      };
      if ("gzip" == codings || "x-gzip" == codings) return body = body.pipe(zlib__WEBPACK_IMPORTED_MODULE_5__.createGunzip(zlibOptions)), 
      response = new Response(body, response_options), void resolve(response);
      if ("deflate" == codings || "x-deflate" == codings) {
       const raw = res.pipe(new PassThrough$1);
       return raw.once("data", (function(chunk) {
        body = 8 == (15 & chunk[0]) ? body.pipe(zlib__WEBPACK_IMPORTED_MODULE_5__.createInflate()) : body.pipe(zlib__WEBPACK_IMPORTED_MODULE_5__.createInflateRaw()), 
        response = new Response(body, response_options), resolve(response);
       })), void raw.on("end", (function() {
        response || (response = new Response(body, response_options), resolve(response));
       }));
      }
      if ("br" == codings && "function" == typeof zlib__WEBPACK_IMPORTED_MODULE_5__.createBrotliDecompress) return body = body.pipe(zlib__WEBPACK_IMPORTED_MODULE_5__.createBrotliDecompress()), 
      response = new Response(body, response_options), void resolve(response);
      response = new Response(body, response_options), resolve(response);
     })), function(dest, instance) {
      const body = instance.body;
      null === body ? dest.end() : isBlob(body) ? body.stream().pipe(dest) : Buffer.isBuffer(body) ? (dest.write(body), 
      dest.end()) : body.pipe(dest);
     }(req, request);
    }));
   }
   function destroyStream(stream, err) {
    stream.destroy ? stream.destroy(err) : (stream.emit("error", err), stream.end());
   }
   fetch.isRedirect = function(code) {
    return 301 === code || 302 === code || 303 === code || 307 === code || 308 === code;
   }, fetch.Promise = global.Promise;
   const __WEBPACK_DEFAULT_EXPORT__ = fetch;
  },
  47288: (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    A: () => __WEBPACK_DEFAULT_EXPORT__
   });
   var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(63720);
   const __WEBPACK_DEFAULT_EXPORT__ = class extends _index_js__WEBPACK_IMPORTED_MODULE_0__.A {
    #lastModified=0;
    #name="";
    constructor(fileBits, fileName, options = {}) {
     if (arguments.length < 2) throw new TypeError(`Failed to construct 'File': 2 arguments required, but only ${arguments.length} present.`);
     super(fileBits, options), null === options && (options = {});
     const lastModified = void 0 === options.lastModified ? Date.now() : Number(options.lastModified);
     Number.isNaN(lastModified) || (this.#lastModified = lastModified), this.#name = String(fileName);
    }
    get name() {
     return this.#name;
    }
    get lastModified() {
     return this.#lastModified;
    }
    get [Symbol.toStringTag]() {
     return "File";
    }
    static [Symbol.hasInstance](object) {
     return !!object && object instanceof _index_js__WEBPACK_IMPORTED_MODULE_0__.A && /^(File)$/.test(object[Symbol.toStringTag]);
    }
   };
  },
  69730: (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    YQ: () => fetch_blob.A,
    ZH: () => file.A,
    k4: () => blobFrom,
    F8: () => blobFromSync,
    NX: () => fileFrom,
    _M: () => fileFromSync
   });
   const external_node_fs_namespaceObject = require("node:fs"), external_node_path_namespaceObject = require("node:path");
   var node_domexception = __webpack_require__(45157), file = __webpack_require__(47288), fetch_blob = __webpack_require__(63720);
   const {stat} = external_node_fs_namespaceObject.promises, blobFromSync = (path, type) => fromBlob((0, 
   external_node_fs_namespaceObject.statSync)(path), path, type), blobFrom = (path, type) => stat(path).then((stat => fromBlob(stat, path, type))), fileFrom = (path, type) => stat(path).then((stat => fromFile(stat, path, type))), fileFromSync = (path, type) => fromFile((0, 
   external_node_fs_namespaceObject.statSync)(path), path, type), fromBlob = (stat, path, type = "") => new fetch_blob.A([ new BlobDataItem({
    path,
    size: stat.size,
    lastModified: stat.mtimeMs,
    start: 0
   }) ], {
    type
   }), fromFile = (stat, path, type = "") => new file.A([ new BlobDataItem({
    path,
    size: stat.size,
    lastModified: stat.mtimeMs,
    start: 0
   }) ], (0, external_node_path_namespaceObject.basename)(path), {
    type,
    lastModified: stat.mtimeMs
   });
   class BlobDataItem {
    #path;
    #start;
    constructor(options) {
     this.#path = options.path, this.#start = options.start, this.size = options.size, 
     this.lastModified = options.lastModified;
    }
    slice(start, end) {
     return new BlobDataItem({
      path: this.#path,
      lastModified: this.lastModified,
      size: end - start,
      start: this.#start + start
     });
    }
    async* stream() {
     const {mtimeMs} = await stat(this.#path);
     if (mtimeMs > this.lastModified) throw new node_domexception("The requested file could not be read, typically due to permission problems that have occurred after a reference to a file was acquired.", "NotReadableError");
     yield* (0, external_node_fs_namespaceObject.createReadStream)(this.#path, {
      start: this.#start,
      end: this.#start + this.size - 1
     });
    }
    get [Symbol.toStringTag]() {
     return "Blob";
    }
   }
  },
  63720: (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    A: () => __WEBPACK_DEFAULT_EXPORT__
   });
   __webpack_require__(93328);
   async function* toIterator(parts, clone = !0) {
    for (const part of parts) if ("stream" in part) yield* part.stream(); else if (ArrayBuffer.isView(part)) if (clone) {
     let position = part.byteOffset;
     const end = part.byteOffset + part.byteLength;
     for (;position !== end; ) {
      const size = Math.min(end - position, 65536), chunk = part.buffer.slice(position, position + size);
      position += chunk.byteLength, yield new Uint8Array(chunk);
     }
    } else yield part; else {
     let position = 0, b = part;
     for (;position !== b.size; ) {
      const chunk = b.slice(position, Math.min(b.size, position + 65536)), buffer = await chunk.arrayBuffer();
      position += buffer.byteLength, yield new Uint8Array(buffer);
     }
    }
   }
   const _Blob = class Blob {
    #parts=[];
    #type="";
    #size=0;
    #endings="transparent";
    constructor(blobParts = [], options = {}) {
     if ("object" != typeof blobParts || null === blobParts) throw new TypeError("Failed to construct 'Blob': The provided value cannot be converted to a sequence.");
     if ("function" != typeof blobParts[Symbol.iterator]) throw new TypeError("Failed to construct 'Blob': The object must have a callable @@iterator property.");
     if ("object" != typeof options && "function" != typeof options) throw new TypeError("Failed to construct 'Blob': parameter 2 cannot convert to dictionary.");
     null === options && (options = {});
     const encoder = new TextEncoder;
     for (const element of blobParts) {
      let part;
      part = ArrayBuffer.isView(element) ? new Uint8Array(element.buffer.slice(element.byteOffset, element.byteOffset + element.byteLength)) : element instanceof ArrayBuffer ? new Uint8Array(element.slice(0)) : element instanceof Blob ? element : encoder.encode(`${element}`), 
      this.#size += ArrayBuffer.isView(part) ? part.byteLength : part.size, this.#parts.push(part);
     }
     this.#endings = `${void 0 === options.endings ? "transparent" : options.endings}`;
     const type = void 0 === options.type ? "" : String(options.type);
     this.#type = /^[\x20-\x7E]*$/.test(type) ? type : "";
    }
    get size() {
     return this.#size;
    }
    get type() {
     return this.#type;
    }
    async text() {
     const decoder = new TextDecoder;
     let str = "";
     for await (const part of toIterator(this.#parts, !1)) str += decoder.decode(part, {
      stream: !0
     });
     return str += decoder.decode(), str;
    }
    async arrayBuffer() {
     const data = new Uint8Array(this.size);
     let offset = 0;
     for await (const chunk of toIterator(this.#parts, !1)) data.set(chunk, offset), 
     offset += chunk.length;
     return data.buffer;
    }
    stream() {
     const it = toIterator(this.#parts, !0);
     return new globalThis.ReadableStream({
      type: "bytes",
      async pull(ctrl) {
       const chunk = await it.next();
       chunk.done ? ctrl.close() : ctrl.enqueue(chunk.value);
      },
      async cancel() {
       await it.return();
      }
     });
    }
    slice(start = 0, end = this.size, type = "") {
     const {size} = this;
     let relativeStart = start < 0 ? Math.max(size + start, 0) : Math.min(start, size), relativeEnd = end < 0 ? Math.max(size + end, 0) : Math.min(end, size);
     const span = Math.max(relativeEnd - relativeStart, 0), parts = this.#parts, blobParts = [];
     let added = 0;
     for (const part of parts) {
      if (added >= span) break;
      const size = ArrayBuffer.isView(part) ? part.byteLength : part.size;
      if (relativeStart && size <= relativeStart) relativeStart -= size, relativeEnd -= size; else {
       let chunk;
       ArrayBuffer.isView(part) ? (chunk = part.subarray(relativeStart, Math.min(size, relativeEnd)), 
       added += chunk.byteLength) : (chunk = part.slice(relativeStart, Math.min(size, relativeEnd)), 
       added += chunk.size), relativeEnd -= size, blobParts.push(chunk), relativeStart = 0;
      }
     }
     const blob = new Blob([], {
      type: String(type).toLowerCase()
     });
     return blob.#size = span, blob.#parts = blobParts, blob;
    }
    get [Symbol.toStringTag]() {
     return "Blob";
    }
    static [Symbol.hasInstance](object) {
     return object && "object" == typeof object && "function" == typeof object.constructor && ("function" == typeof object.stream || "function" == typeof object.arrayBuffer) && /^(Blob|File)$/.test(object[Symbol.toStringTag]);
    }
   };
   Object.defineProperties(_Blob.prototype, {
    size: {
     enumerable: !0
    },
    type: {
     enumerable: !0
    },
    slice: {
     enumerable: !0
    }
   });
   const __WEBPACK_DEFAULT_EXPORT__ = _Blob;
  },
  98435: (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.d(__webpack_exports__, {
    $n: () => formDataToBlob,
    fS: () => FormData
   });
   var fetch_blob__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(63720), fetch_blob_file_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(47288), {toStringTag: t, iterator: i, hasInstance: h} = Symbol, r = Math.random, m = "append,set,get,getAll,delete,keys,values,entries,forEach,constructor".split(","), f = (a, b, c) => (a += "", 
   /^(Blob|File)$/.test(b && b[t]) ? [ (c = void 0 !== c ? c + "" : "File" == b[t] ? b.name : "blob", 
   a), b.name !== c || "blob" == b[t] ? new fetch_blob_file_js__WEBPACK_IMPORTED_MODULE_1__.A([ b ], c, b) : b ] : [ a, b + "" ]), e = (c, f) => (f ? c : c.replace(/\r?\n|\r/g, "\r\n")).replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22"), x = (n, a, e) => {
    if (a.length < e) throw new TypeError(`Failed to execute '${n}' on 'FormData': ${e} arguments required, but only ${a.length} present.`);
   };
   const FormData = class {
    #d=[];
    constructor(...a) {
     if (a.length) throw new TypeError("Failed to construct 'FormData': parameter 1 is not of type 'HTMLFormElement'.");
    }
    get [t]() {
     return "FormData";
    }
    [i]() {
     return this.entries();
    }
    static [h](o) {
     return o && "object" == typeof o && "FormData" === o[t] && !m.some((m => "function" != typeof o[m]));
    }
    append(...a) {
     x("append", arguments, 2), this.#d.push(f(...a));
    }
    delete(a) {
     x("delete", arguments, 1), a += "", this.#d = this.#d.filter((([b]) => b !== a));
    }
    get(a) {
     x("get", arguments, 1), a += "";
     for (var b = this.#d, l = b.length, c = 0; c < l; c++) if (b[c][0] === a) return b[c][1];
     return null;
    }
    getAll(a, b) {
     return x("getAll", arguments, 1), b = [], a += "", this.#d.forEach((c => c[0] === a && b.push(c[1]))), 
     b;
    }
    has(a) {
     return x("has", arguments, 1), a += "", this.#d.some((b => b[0] === a));
    }
    forEach(a, b) {
     for (var [c, d] of (x("forEach", arguments, 1), this)) a.call(b, d, c, this);
    }
    set(...a) {
     x("set", arguments, 2);
     var b = [], c = !0;
     a = f(...a), this.#d.forEach((d => {
      d[0] === a[0] ? c && (c = !b.push(a)) : b.push(d);
     })), c && b.push(a), this.#d = b;
    }
    * entries() {
     yield* this.#d;
    }
    * keys() {
     for (var [a] of this) yield a;
    }
    * values() {
     for (var [, a] of this) yield a;
    }
   };
   function formDataToBlob(F, B = fetch_blob__WEBPACK_IMPORTED_MODULE_0__.A) {
    var b = `${r()}${r()}`.replace(/\./g, "").slice(-28).padStart(32, "-"), c = [], p = `--${b}\r\nContent-Disposition: form-data; name="`;
    return F.forEach(((v, n) => "string" == typeof v ? c.push(p + e(n) + `"\r\n\r\n${v.replace(/\r(?!\n)|(?<!\r)\n/g, "\r\n")}\r\n`) : c.push(p + e(n) + `"; filename="${e(v.name, 1)}"\r\nContent-Type: ${v.type || "application/octet-stream"}\r\n\r\n`, v, "\r\n"))), 
    c.push(`--${b}--`), new B(c, {
     type: "multipart/form-data; boundary=" + b
    });
   }
  },
  82065: (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.r(__webpack_exports__), __webpack_require__.d(__webpack_exports__, {
    AbortError: () => AbortError,
    Blob: () => from.YQ,
    FetchError: () => FetchError,
    File: () => from.ZH,
    FormData: () => esm_min.fS,
    Headers: () => Headers,
    Request: () => Request,
    Response: () => Response,
    blobFrom: () => from.k4,
    blobFromSync: () => from.F8,
    default: () => fetch,
    fileFrom: () => from.NX,
    fileFromSync: () => from._M,
    isRedirect: () => isRedirect
   });
   const external_node_http_namespaceObject = require("node:http"), external_node_https_namespaceObject = require("node:https"), external_node_zlib_namespaceObject = require("node:zlib"), external_node_stream_namespaceObject = require("node:stream"), external_node_buffer_namespaceObject = require("node:buffer");
   const dist = function(uri) {
    if (!/^data:/i.test(uri)) throw new TypeError('`uri` does not appear to be a Data URI (must begin with "data:")');
    const firstComma = (uri = uri.replace(/\r?\n/g, "")).indexOf(",");
    if (-1 === firstComma || firstComma <= 4) throw new TypeError("malformed data: URI");
    const meta = uri.substring(5, firstComma).split(";");
    let charset = "", base64 = !1;
    const type = meta[0] || "text/plain";
    let typeFull = type;
    for (let i = 1; i < meta.length; i++) "base64" === meta[i] ? base64 = !0 : meta[i] && (typeFull += `;${meta[i]}`, 
    0 === meta[i].indexOf("charset=") && (charset = meta[i].substring(8)));
    meta[0] || charset.length || (typeFull += ";charset=US-ASCII", charset = "US-ASCII");
    const encoding = base64 ? "base64" : "ascii", data = unescape(uri.substring(firstComma + 1)), buffer = Buffer.from(data, encoding);
    return buffer.type = type, buffer.typeFull = typeFull, buffer.charset = charset, 
    buffer;
   }, external_node_util_namespaceObject = require("node:util");
   var fetch_blob = __webpack_require__(63720), esm_min = __webpack_require__(98435);
   class FetchBaseError extends Error {
    constructor(message, type) {
     super(message), Error.captureStackTrace(this, this.constructor), this.type = type;
    }
    get name() {
     return this.constructor.name;
    }
    get [Symbol.toStringTag]() {
     return this.constructor.name;
    }
   }
   class FetchError extends FetchBaseError {
    constructor(message, type, systemError) {
     super(message, type), systemError && (this.code = this.errno = systemError.code, 
     this.erroredSysCall = systemError.syscall);
    }
   }
   const NAME = Symbol.toStringTag, isURLSearchParameters = object => "object" == typeof object && "function" == typeof object.append && "function" == typeof object.delete && "function" == typeof object.get && "function" == typeof object.getAll && "function" == typeof object.has && "function" == typeof object.set && "function" == typeof object.sort && "URLSearchParams" === object[NAME], isBlob = object => object && "object" == typeof object && "function" == typeof object.arrayBuffer && "string" == typeof object.type && "function" == typeof object.stream && "function" == typeof object.constructor && /^(Blob|File)$/.test(object[NAME]), isDomainOrSubdomain = (destination, original) => {
    const orig = new URL(original).hostname, dest = new URL(destination).hostname;
    return orig === dest || orig.endsWith(`.${dest}`);
   }, isSameProtocol = (destination, original) => new URL(original).protocol === new URL(destination).protocol, pipeline = (0, 
   external_node_util_namespaceObject.promisify)(external_node_stream_namespaceObject.pipeline), INTERNALS = Symbol("Body internals");
   class Body {
    constructor(body, {size = 0} = {}) {
     let boundary = null;
     null === body ? body = null : isURLSearchParameters(body) ? body = external_node_buffer_namespaceObject.Buffer.from(body.toString()) : isBlob(body) || external_node_buffer_namespaceObject.Buffer.isBuffer(body) || (external_node_util_namespaceObject.types.isAnyArrayBuffer(body) ? body = external_node_buffer_namespaceObject.Buffer.from(body) : ArrayBuffer.isView(body) ? body = external_node_buffer_namespaceObject.Buffer.from(body.buffer, body.byteOffset, body.byteLength) : body instanceof external_node_stream_namespaceObject || (body instanceof esm_min.fS ? boundary = (body = (0, 
     esm_min.$n)(body)).type.split("=")[1] : body = external_node_buffer_namespaceObject.Buffer.from(String(body))));
     let stream = body;
     external_node_buffer_namespaceObject.Buffer.isBuffer(body) ? stream = external_node_stream_namespaceObject.Readable.from(body) : isBlob(body) && (stream = external_node_stream_namespaceObject.Readable.from(body.stream())), 
     this[INTERNALS] = {
      body,
      stream,
      boundary,
      disturbed: !1,
      error: null
     }, this.size = size, body instanceof external_node_stream_namespaceObject && body.on("error", (error_ => {
      const error = error_ instanceof FetchBaseError ? error_ : new FetchError(`Invalid response body while trying to fetch ${this.url}: ${error_.message}`, "system", error_);
      this[INTERNALS].error = error;
     }));
    }
    get body() {
     return this[INTERNALS].stream;
    }
    get bodyUsed() {
     return this[INTERNALS].disturbed;
    }
    async arrayBuffer() {
     const {buffer, byteOffset, byteLength} = await consumeBody(this);
     return buffer.slice(byteOffset, byteOffset + byteLength);
    }
    async formData() {
     const ct = this.headers.get("content-type");
     if (ct.startsWith("application/x-www-form-urlencoded")) {
      const formData = new esm_min.fS, parameters = new URLSearchParams(await this.text());
      for (const [name, value] of parameters) formData.append(name, value);
      return formData;
     }
     const {toFormData} = await __webpack_require__.e(460).then(__webpack_require__.bind(__webpack_require__, 87460));
     return toFormData(this.body, ct);
    }
    async blob() {
     const ct = this.headers && this.headers.get("content-type") || this[INTERNALS].body && this[INTERNALS].body.type || "", buf = await this.arrayBuffer();
     return new fetch_blob.A([ buf ], {
      type: ct
     });
    }
    async json() {
     const text = await this.text();
     return JSON.parse(text);
    }
    async text() {
     const buffer = await consumeBody(this);
     return (new TextDecoder).decode(buffer);
    }
    buffer() {
     return consumeBody(this);
    }
   }
   async function consumeBody(data) {
    if (data[INTERNALS].disturbed) throw new TypeError(`body used already for: ${data.url}`);
    if (data[INTERNALS].disturbed = !0, data[INTERNALS].error) throw data[INTERNALS].error;
    const {body} = data;
    if (null === body) return external_node_buffer_namespaceObject.Buffer.alloc(0);
    if (!(body instanceof external_node_stream_namespaceObject)) return external_node_buffer_namespaceObject.Buffer.alloc(0);
    const accum = [];
    let accumBytes = 0;
    try {
     for await (const chunk of body) {
      if (data.size > 0 && accumBytes + chunk.length > data.size) {
       const error = new FetchError(`content size at ${data.url} over limit: ${data.size}`, "max-size");
       throw body.destroy(error), error;
      }
      accumBytes += chunk.length, accum.push(chunk);
     }
    } catch (error) {
     throw error instanceof FetchBaseError ? error : new FetchError(`Invalid response body while trying to fetch ${data.url}: ${error.message}`, "system", error);
    }
    if (!0 !== body.readableEnded && !0 !== body._readableState.ended) throw new FetchError(`Premature close of server response while trying to fetch ${data.url}`);
    try {
     return accum.every((c => "string" == typeof c)) ? external_node_buffer_namespaceObject.Buffer.from(accum.join("")) : external_node_buffer_namespaceObject.Buffer.concat(accum, accumBytes);
    } catch (error) {
     throw new FetchError(`Could not create Buffer from response body for ${data.url}: ${error.message}`, "system", error);
    }
   }
   Body.prototype.buffer = (0, external_node_util_namespaceObject.deprecate)(Body.prototype.buffer, "Please use 'response.arrayBuffer()' instead of 'response.buffer()'", "node-fetch#buffer"), 
   Object.defineProperties(Body.prototype, {
    body: {
     enumerable: !0
    },
    bodyUsed: {
     enumerable: !0
    },
    arrayBuffer: {
     enumerable: !0
    },
    blob: {
     enumerable: !0
    },
    json: {
     enumerable: !0
    },
    text: {
     enumerable: !0
    },
    data: {
     get: (0, external_node_util_namespaceObject.deprecate)((() => {}), "data doesn't exist, use json(), text(), arrayBuffer(), or body instead", "https://github.com/node-fetch/node-fetch/issues/1000 (response)")
    }
   });
   const clone = (instance, highWaterMark) => {
    let p1, p2, {body} = instance[INTERNALS];
    if (instance.bodyUsed) throw new Error("cannot clone body after it is used");
    return body instanceof external_node_stream_namespaceObject && "function" != typeof body.getBoundary && (p1 = new external_node_stream_namespaceObject.PassThrough({
     highWaterMark
    }), p2 = new external_node_stream_namespaceObject.PassThrough({
     highWaterMark
    }), body.pipe(p1), body.pipe(p2), instance[INTERNALS].stream = p1, body = p2), body;
   }, getNonSpecFormDataBoundary = (0, external_node_util_namespaceObject.deprecate)((body => body.getBoundary()), "form-data doesn't follow the spec and requires special treatment. Use alternative package", "https://github.com/node-fetch/node-fetch/issues/1167"), extractContentType = (body, request) => null === body ? null : "string" == typeof body ? "text/plain;charset=UTF-8" : isURLSearchParameters(body) ? "application/x-www-form-urlencoded;charset=UTF-8" : isBlob(body) ? body.type || null : external_node_buffer_namespaceObject.Buffer.isBuffer(body) || external_node_util_namespaceObject.types.isAnyArrayBuffer(body) || ArrayBuffer.isView(body) ? null : body instanceof esm_min.fS ? `multipart/form-data; boundary=${request[INTERNALS].boundary}` : body && "function" == typeof body.getBoundary ? `multipart/form-data;boundary=${getNonSpecFormDataBoundary(body)}` : body instanceof external_node_stream_namespaceObject ? null : "text/plain;charset=UTF-8", writeToStream = async (dest, {body}) => {
    null === body ? dest.end() : await pipeline(body, dest);
   }, validateHeaderName = "function" == typeof external_node_http_namespaceObject.validateHeaderName ? external_node_http_namespaceObject.validateHeaderName : name => {
    if (!/^[\^`\-\w!#$%&'*+.|~]+$/.test(name)) {
     const error = new TypeError(`Header name must be a valid HTTP token [${name}]`);
     throw Object.defineProperty(error, "code", {
      value: "ERR_INVALID_HTTP_TOKEN"
     }), error;
    }
   }, validateHeaderValue = "function" == typeof external_node_http_namespaceObject.validateHeaderValue ? external_node_http_namespaceObject.validateHeaderValue : (name, value) => {
    if (/[^\t\u0020-\u007E\u0080-\u00FF]/.test(value)) {
     const error = new TypeError(`Invalid character in header content ["${name}"]`);
     throw Object.defineProperty(error, "code", {
      value: "ERR_INVALID_CHAR"
     }), error;
    }
   };
   class Headers extends URLSearchParams {
    constructor(init) {
     let result = [];
     if (init instanceof Headers) {
      const raw = init.raw();
      for (const [name, values] of Object.entries(raw)) result.push(...values.map((value => [ name, value ])));
     } else if (null == init) ; else {
      if ("object" != typeof init || external_node_util_namespaceObject.types.isBoxedPrimitive(init)) throw new TypeError("Failed to construct 'Headers': The provided value is not of type '(sequence<sequence<ByteString>> or record<ByteString, ByteString>)");
      {
       const method = init[Symbol.iterator];
       if (null == method) result.push(...Object.entries(init)); else {
        if ("function" != typeof method) throw new TypeError("Header pairs must be iterable");
        result = [ ...init ].map((pair => {
         if ("object" != typeof pair || external_node_util_namespaceObject.types.isBoxedPrimitive(pair)) throw new TypeError("Each header pair must be an iterable object");
         return [ ...pair ];
        })).map((pair => {
         if (2 !== pair.length) throw new TypeError("Each header pair must be a name/value tuple");
         return [ ...pair ];
        }));
       }
      }
     }
     return result = result.length > 0 ? result.map((([name, value]) => (validateHeaderName(name), 
     validateHeaderValue(name, String(value)), [ String(name).toLowerCase(), String(value) ]))) : void 0, 
     super(result), new Proxy(this, {
      get(target, p, receiver) {
       switch (p) {
       case "append":
       case "set":
        return (name, value) => (validateHeaderName(name), validateHeaderValue(name, String(value)), 
        URLSearchParams.prototype[p].call(target, String(name).toLowerCase(), String(value)));

       case "delete":
       case "has":
       case "getAll":
        return name => (validateHeaderName(name), URLSearchParams.prototype[p].call(target, String(name).toLowerCase()));

       case "keys":
        return () => (target.sort(), new Set(URLSearchParams.prototype.keys.call(target)).keys());

       default:
        return Reflect.get(target, p, receiver);
       }
      }
     });
    }
    get [Symbol.toStringTag]() {
     return this.constructor.name;
    }
    toString() {
     return Object.prototype.toString.call(this);
    }
    get(name) {
     const values = this.getAll(name);
     if (0 === values.length) return null;
     let value = values.join(", ");
     return /^content-encoding$/i.test(name) && (value = value.toLowerCase()), value;
    }
    forEach(callback, thisArg = void 0) {
     for (const name of this.keys()) Reflect.apply(callback, thisArg, [ this.get(name), name, this ]);
    }
    * values() {
     for (const name of this.keys()) yield this.get(name);
    }
    * entries() {
     for (const name of this.keys()) yield [ name, this.get(name) ];
    }
    [Symbol.iterator]() {
     return this.entries();
    }
    raw() {
     return [ ...this.keys() ].reduce(((result, key) => (result[key] = this.getAll(key), 
     result)), {});
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
     return [ ...this.keys() ].reduce(((result, key) => {
      const values = this.getAll(key);
      return result[key] = "host" === key ? values[0] : values.length > 1 ? values : values[0], 
      result;
     }), {});
    }
   }
   Object.defineProperties(Headers.prototype, [ "get", "entries", "forEach", "values" ].reduce(((result, property) => (result[property] = {
    enumerable: !0
   }, result)), {}));
   const redirectStatus = new Set([ 301, 302, 303, 307, 308 ]), isRedirect = code => redirectStatus.has(code), response_INTERNALS = Symbol("Response internals");
   class Response extends Body {
    constructor(body = null, options = {}) {
     super(body, options);
     const status = null != options.status ? options.status : 200, headers = new Headers(options.headers);
     if (null !== body && !headers.has("Content-Type")) {
      const contentType = extractContentType(body, this);
      contentType && headers.append("Content-Type", contentType);
     }
     this[response_INTERNALS] = {
      type: "default",
      url: options.url,
      status,
      statusText: options.statusText || "",
      headers,
      counter: options.counter,
      highWaterMark: options.highWaterMark
     };
    }
    get type() {
     return this[response_INTERNALS].type;
    }
    get url() {
     return this[response_INTERNALS].url || "";
    }
    get status() {
     return this[response_INTERNALS].status;
    }
    get ok() {
     return this[response_INTERNALS].status >= 200 && this[response_INTERNALS].status < 300;
    }
    get redirected() {
     return this[response_INTERNALS].counter > 0;
    }
    get statusText() {
     return this[response_INTERNALS].statusText;
    }
    get headers() {
     return this[response_INTERNALS].headers;
    }
    get highWaterMark() {
     return this[response_INTERNALS].highWaterMark;
    }
    clone() {
     return new Response(clone(this, this.highWaterMark), {
      type: this.type,
      url: this.url,
      status: this.status,
      statusText: this.statusText,
      headers: this.headers,
      ok: this.ok,
      redirected: this.redirected,
      size: this.size,
      highWaterMark: this.highWaterMark
     });
    }
    static redirect(url, status = 302) {
     if (!isRedirect(status)) throw new RangeError('Failed to execute "redirect" on "response": Invalid status code');
     return new Response(null, {
      headers: {
       location: new URL(url).toString()
      },
      status
     });
    }
    static error() {
     const response = new Response(null, {
      status: 0,
      statusText: ""
     });
     return response[response_INTERNALS].type = "error", response;
    }
    static json(data = void 0, init = {}) {
     const body = JSON.stringify(data);
     if (void 0 === body) throw new TypeError("data is not JSON serializable");
     const headers = new Headers(init && init.headers);
     return headers.has("content-type") || headers.set("content-type", "application/json"), 
     new Response(body, {
      ...init,
      headers
     });
    }
    get [Symbol.toStringTag]() {
     return "Response";
    }
   }
   Object.defineProperties(Response.prototype, {
    type: {
     enumerable: !0
    },
    url: {
     enumerable: !0
    },
    status: {
     enumerable: !0
    },
    ok: {
     enumerable: !0
    },
    redirected: {
     enumerable: !0
    },
    statusText: {
     enumerable: !0
    },
    headers: {
     enumerable: !0
    },
    clone: {
     enumerable: !0
    }
   });
   const external_node_url_namespaceObject = require("node:url"), external_node_net_namespaceObject = require("node:net");
   function stripURLForUseAsAReferrer(url, originOnly = !1) {
    return null == url ? "no-referrer" : (url = new URL(url), /^(about|blob|data):$/.test(url.protocol) ? "no-referrer" : (url.username = "", 
    url.password = "", url.hash = "", originOnly && (url.pathname = "", url.search = ""), 
    url));
   }
   const ReferrerPolicy = new Set([ "", "no-referrer", "no-referrer-when-downgrade", "same-origin", "origin", "strict-origin", "origin-when-cross-origin", "strict-origin-when-cross-origin", "unsafe-url" ]);
   function isUrlPotentiallyTrustworthy(url) {
    return !!/^about:(blank|srcdoc)$/.test(url) || ("data:" === url.protocol || (!!/^(blob|filesystem):$/.test(url.protocol) || function(url) {
     if (/^(http|ws)s:$/.test(url.protocol)) return !0;
     const hostIp = url.host.replace(/(^\[)|(]$)/g, ""), hostIPVersion = (0, external_node_net_namespaceObject.isIP)(hostIp);
     return !(4 !== hostIPVersion || !/^127\./.test(hostIp)) || !(6 !== hostIPVersion || !/^(((0+:){7})|(::(0+:){0,6}))0*1$/.test(hostIp)) || "localhost" !== url.host && !url.host.endsWith(".localhost") && "file:" === url.protocol;
    }(url)));
   }
   const request_INTERNALS = Symbol("Request internals"), isRequest = object => "object" == typeof object && "object" == typeof object[request_INTERNALS], doBadDataWarn = (0, 
   external_node_util_namespaceObject.deprecate)((() => {}), ".data is not a valid RequestInit property, use .body instead", "https://github.com/node-fetch/node-fetch/issues/1000 (request)");
   class Request extends Body {
    constructor(input, init = {}) {
     let parsedURL;
     if (isRequest(input) ? parsedURL = new URL(input.url) : (parsedURL = new URL(input), 
     input = {}), "" !== parsedURL.username || "" !== parsedURL.password) throw new TypeError(`${parsedURL} is an url with embedded credentials.`);
     let method = init.method || input.method || "GET";
     if (/^(delete|get|head|options|post|put)$/i.test(method) && (method = method.toUpperCase()), 
     !isRequest(init) && "data" in init && doBadDataWarn(), (null != init.body || isRequest(input) && null !== input.body) && ("GET" === method || "HEAD" === method)) throw new TypeError("Request with GET/HEAD method cannot have body");
     const inputBody = init.body ? init.body : isRequest(input) && null !== input.body ? clone(input) : null;
     super(inputBody, {
      size: init.size || input.size || 0
     });
     const headers = new Headers(init.headers || input.headers || {});
     if (null !== inputBody && !headers.has("Content-Type")) {
      const contentType = extractContentType(inputBody, this);
      contentType && headers.set("Content-Type", contentType);
     }
     let signal = isRequest(input) ? input.signal : null;
     if ("signal" in init && (signal = init.signal), null != signal && ("object" != typeof (object = signal) || "AbortSignal" !== object[NAME] && "EventTarget" !== object[NAME])) throw new TypeError("Expected signal to be an instanceof AbortSignal or EventTarget");
     var object;
     let referrer = null == init.referrer ? input.referrer : init.referrer;
     if ("" === referrer) referrer = "no-referrer"; else if (referrer) {
      const parsedReferrer = new URL(referrer);
      referrer = /^about:(\/\/)?client$/.test(parsedReferrer) ? "client" : parsedReferrer;
     } else referrer = void 0;
     this[request_INTERNALS] = {
      method,
      redirect: init.redirect || input.redirect || "follow",
      headers,
      parsedURL,
      signal,
      referrer
     }, this.follow = void 0 === init.follow ? void 0 === input.follow ? 20 : input.follow : init.follow, 
     this.compress = void 0 === init.compress ? void 0 === input.compress || input.compress : init.compress, 
     this.counter = init.counter || input.counter || 0, this.agent = init.agent || input.agent, 
     this.highWaterMark = init.highWaterMark || input.highWaterMark || 16384, this.insecureHTTPParser = init.insecureHTTPParser || input.insecureHTTPParser || !1, 
     this.referrerPolicy = init.referrerPolicy || input.referrerPolicy || "";
    }
    get method() {
     return this[request_INTERNALS].method;
    }
    get url() {
     return (0, external_node_url_namespaceObject.format)(this[request_INTERNALS].parsedURL);
    }
    get headers() {
     return this[request_INTERNALS].headers;
    }
    get redirect() {
     return this[request_INTERNALS].redirect;
    }
    get signal() {
     return this[request_INTERNALS].signal;
    }
    get referrer() {
     return "no-referrer" === this[request_INTERNALS].referrer ? "" : "client" === this[request_INTERNALS].referrer ? "about:client" : this[request_INTERNALS].referrer ? this[request_INTERNALS].referrer.toString() : void 0;
    }
    get referrerPolicy() {
     return this[request_INTERNALS].referrerPolicy;
    }
    set referrerPolicy(referrerPolicy) {
     this[request_INTERNALS].referrerPolicy = function(referrerPolicy) {
      if (!ReferrerPolicy.has(referrerPolicy)) throw new TypeError(`Invalid referrerPolicy: ${referrerPolicy}`);
      return referrerPolicy;
     }(referrerPolicy);
    }
    clone() {
     return new Request(this);
    }
    get [Symbol.toStringTag]() {
     return "Request";
    }
   }
   Object.defineProperties(Request.prototype, {
    method: {
     enumerable: !0
    },
    url: {
     enumerable: !0
    },
    headers: {
     enumerable: !0
    },
    redirect: {
     enumerable: !0
    },
    clone: {
     enumerable: !0
    },
    signal: {
     enumerable: !0
    },
    referrer: {
     enumerable: !0
    },
    referrerPolicy: {
     enumerable: !0
    }
   });
   const getNodeRequestOptions = request => {
    const {parsedURL} = request[request_INTERNALS], headers = new Headers(request[request_INTERNALS].headers);
    headers.has("Accept") || headers.set("Accept", "*/*");
    let contentLengthValue = null;
    if (null === request.body && /^(post|put)$/i.test(request.method) && (contentLengthValue = "0"), 
    null !== request.body) {
     const totalBytes = (request => {
      const {body} = request[INTERNALS];
      return null === body ? 0 : isBlob(body) ? body.size : external_node_buffer_namespaceObject.Buffer.isBuffer(body) ? body.length : body && "function" == typeof body.getLengthSync && body.hasKnownLength && body.hasKnownLength() ? body.getLengthSync() : null;
     })(request);
     "number" != typeof totalBytes || Number.isNaN(totalBytes) || (contentLengthValue = String(totalBytes));
    }
    contentLengthValue && headers.set("Content-Length", contentLengthValue), "" === request.referrerPolicy && (request.referrerPolicy = "strict-origin-when-cross-origin"), 
    request.referrer && "no-referrer" !== request.referrer ? request[request_INTERNALS].referrer = function(request, {referrerURLCallback, referrerOriginCallback} = {}) {
     if ("no-referrer" === request.referrer || "" === request.referrerPolicy) return null;
     const policy = request.referrerPolicy;
     if ("about:client" === request.referrer) return "no-referrer";
     const referrerSource = request.referrer;
     let referrerURL = stripURLForUseAsAReferrer(referrerSource), referrerOrigin = stripURLForUseAsAReferrer(referrerSource, !0);
     referrerURL.toString().length > 4096 && (referrerURL = referrerOrigin), referrerURLCallback && (referrerURL = referrerURLCallback(referrerURL)), 
     referrerOriginCallback && (referrerOrigin = referrerOriginCallback(referrerOrigin));
     const currentURL = new URL(request.url);
     switch (policy) {
     case "no-referrer":
      return "no-referrer";

     case "origin":
      return referrerOrigin;

     case "unsafe-url":
      return referrerURL;

     case "strict-origin":
      return isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL) ? "no-referrer" : referrerOrigin.toString();

     case "strict-origin-when-cross-origin":
      return referrerURL.origin === currentURL.origin ? referrerURL : isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL) ? "no-referrer" : referrerOrigin;

     case "same-origin":
      return referrerURL.origin === currentURL.origin ? referrerURL : "no-referrer";

     case "origin-when-cross-origin":
      return referrerURL.origin === currentURL.origin ? referrerURL : referrerOrigin;

     case "no-referrer-when-downgrade":
      return isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL) ? "no-referrer" : referrerURL;

     default:
      throw new TypeError(`Invalid referrerPolicy: ${policy}`);
     }
    }(request) : request[request_INTERNALS].referrer = "no-referrer", request[request_INTERNALS].referrer instanceof URL && headers.set("Referer", request.referrer), 
    headers.has("User-Agent") || headers.set("User-Agent", "node-fetch"), request.compress && !headers.has("Accept-Encoding") && headers.set("Accept-Encoding", "gzip, deflate, br");
    let {agent} = request;
    "function" == typeof agent && (agent = agent(parsedURL));
    const search = (parsedURL => {
     if (parsedURL.search) return parsedURL.search;
     const lastOffset = parsedURL.href.length - 1, hash = parsedURL.hash || ("#" === parsedURL.href[lastOffset] ? "#" : "");
     return "?" === parsedURL.href[lastOffset - hash.length] ? "?" : "";
    })(parsedURL);
    return {
     parsedURL,
     options: {
      path: parsedURL.pathname + search,
      method: request.method,
      headers: headers[Symbol.for("nodejs.util.inspect.custom")](),
      insecureHTTPParser: request.insecureHTTPParser,
      agent
     }
    };
   };
   class AbortError extends FetchBaseError {
    constructor(message, type = "aborted") {
     super(message, type);
    }
   }
   var from = __webpack_require__(69730);
   const supportedSchemas = new Set([ "data:", "http:", "https:" ]);
   async function fetch(url, options_) {
    return new Promise(((resolve, reject) => {
     const request = new Request(url, options_), {parsedURL, options} = getNodeRequestOptions(request);
     if (!supportedSchemas.has(parsedURL.protocol)) throw new TypeError(`node-fetch cannot load ${url}. URL scheme "${parsedURL.protocol.replace(/:$/, "")}" is not supported.`);
     if ("data:" === parsedURL.protocol) {
      const data = dist(request.url), response = new Response(data, {
       headers: {
        "Content-Type": data.typeFull
       }
      });
      return void resolve(response);
     }
     const send = ("https:" === parsedURL.protocol ? external_node_https_namespaceObject : external_node_http_namespaceObject).request, {signal} = request;
     let response = null;
     const abort = () => {
      const error = new AbortError("The operation was aborted.");
      reject(error), request.body && request.body instanceof external_node_stream_namespaceObject.Readable && request.body.destroy(error), 
      response && response.body && response.body.emit("error", error);
     };
     if (signal && signal.aborted) return void abort();
     const abortAndFinalize = () => {
      abort(), finalize();
     }, request_ = send(parsedURL.toString(), options);
     signal && signal.addEventListener("abort", abortAndFinalize);
     const finalize = () => {
      request_.abort(), signal && signal.removeEventListener("abort", abortAndFinalize);
     };
     request_.on("error", (error => {
      reject(new FetchError(`request to ${request.url} failed, reason: ${error.message}`, "system", error)), 
      finalize();
     })), function(request, errorCallback) {
      const LAST_CHUNK = external_node_buffer_namespaceObject.Buffer.from("0\r\n\r\n");
      let previousChunk, isChunkedTransfer = !1, properLastChunkReceived = !1;
      request.on("response", (response => {
       const {headers} = response;
       isChunkedTransfer = "chunked" === headers["transfer-encoding"] && !headers["content-length"];
      })), request.on("socket", (socket => {
       const onSocketClose = () => {
        if (isChunkedTransfer && !properLastChunkReceived) {
         const error = new Error("Premature close");
         error.code = "ERR_STREAM_PREMATURE_CLOSE", errorCallback(error);
        }
       }, onData = buf => {
        properLastChunkReceived = 0 === external_node_buffer_namespaceObject.Buffer.compare(buf.slice(-5), LAST_CHUNK), 
        !properLastChunkReceived && previousChunk && (properLastChunkReceived = 0 === external_node_buffer_namespaceObject.Buffer.compare(previousChunk.slice(-3), LAST_CHUNK.slice(0, 3)) && 0 === external_node_buffer_namespaceObject.Buffer.compare(buf.slice(-2), LAST_CHUNK.slice(3))), 
        previousChunk = buf;
       };
       socket.prependListener("close", onSocketClose), socket.on("data", onData), request.on("close", (() => {
        socket.removeListener("close", onSocketClose), socket.removeListener("data", onData);
       }));
      }));
     }(request_, (error => {
      response && response.body && response.body.destroy(error);
     })), process.version < "v14" && request_.on("socket", (s => {
      let endedWithEventsCount;
      s.prependListener("end", (() => {
       endedWithEventsCount = s._eventsCount;
      })), s.prependListener("close", (hadError => {
       if (response && endedWithEventsCount < s._eventsCount && !hadError) {
        const error = new Error("Premature close");
        error.code = "ERR_STREAM_PREMATURE_CLOSE", response.body.emit("error", error);
       }
      }));
     })), request_.on("response", (response_ => {
      request_.setTimeout(0);
      const headers = function(headers = []) {
       return new Headers(headers.reduce(((result, value, index, array) => (index % 2 == 0 && result.push(array.slice(index, index + 2)), 
       result)), []).filter((([name, value]) => {
        try {
         return validateHeaderName(name), validateHeaderValue(name, String(value)), !0;
        } catch {
         return !1;
        }
       })));
      }(response_.rawHeaders);
      if (isRedirect(response_.statusCode)) {
       const location = headers.get("Location");
       let locationURL = null;
       try {
        locationURL = null === location ? null : new URL(location, request.url);
       } catch {
        if ("manual" !== request.redirect) return reject(new FetchError(`uri requested responds with an invalid redirect URL: ${location}`, "invalid-redirect")), 
        void finalize();
       }
       switch (request.redirect) {
       case "error":
        return reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, "no-redirect")), 
        void finalize();

       case "manual":
        break;

       case "follow":
        {
         if (null === locationURL) break;
         if (request.counter >= request.follow) return reject(new FetchError(`maximum redirect reached at: ${request.url}`, "max-redirect")), 
         void finalize();
         const requestOptions = {
          headers: new Headers(request.headers),
          follow: request.follow,
          counter: request.counter + 1,
          agent: request.agent,
          compress: request.compress,
          method: request.method,
          body: clone(request),
          signal: request.signal,
          size: request.size,
          referrer: request.referrer,
          referrerPolicy: request.referrerPolicy
         };
         if (!isDomainOrSubdomain(request.url, locationURL) || !isSameProtocol(request.url, locationURL)) for (const name of [ "authorization", "www-authenticate", "cookie", "cookie2" ]) requestOptions.headers.delete(name);
         if (303 !== response_.statusCode && request.body && options_.body instanceof external_node_stream_namespaceObject.Readable) return reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect")), 
         void finalize();
         303 !== response_.statusCode && (301 !== response_.statusCode && 302 !== response_.statusCode || "POST" !== request.method) || (requestOptions.method = "GET", 
         requestOptions.body = void 0, requestOptions.headers.delete("content-length"));
         const responseReferrerPolicy = function(headers) {
          const policyTokens = (headers.get("referrer-policy") || "").split(/[,\s]+/);
          let policy = "";
          for (const token of policyTokens) token && ReferrerPolicy.has(token) && (policy = token);
          return policy;
         }(headers);
         return responseReferrerPolicy && (requestOptions.referrerPolicy = responseReferrerPolicy), 
         resolve(fetch(new Request(locationURL, requestOptions))), void finalize();
        }

       default:
        return reject(new TypeError(`Redirect option '${request.redirect}' is not a valid value of RequestRedirect`));
       }
      }
      signal && response_.once("end", (() => {
       signal.removeEventListener("abort", abortAndFinalize);
      }));
      let body = (0, external_node_stream_namespaceObject.pipeline)(response_, new external_node_stream_namespaceObject.PassThrough, (error => {
       error && reject(error);
      }));
      process.version < "v12.10" && response_.on("aborted", abortAndFinalize);
      const responseOptions = {
       url: request.url,
       status: response_.statusCode,
       statusText: response_.statusMessage,
       headers,
       size: request.size,
       counter: request.counter,
       highWaterMark: request.highWaterMark
      }, codings = headers.get("Content-Encoding");
      if (!request.compress || "HEAD" === request.method || null === codings || 204 === response_.statusCode || 304 === response_.statusCode) return response = new Response(body, responseOptions), 
      void resolve(response);
      const zlibOptions = {
       flush: external_node_zlib_namespaceObject.Z_SYNC_FLUSH,
       finishFlush: external_node_zlib_namespaceObject.Z_SYNC_FLUSH
      };
      if ("gzip" === codings || "x-gzip" === codings) return body = (0, external_node_stream_namespaceObject.pipeline)(body, external_node_zlib_namespaceObject.createGunzip(zlibOptions), (error => {
       error && reject(error);
      })), response = new Response(body, responseOptions), void resolve(response);
      if ("deflate" === codings || "x-deflate" === codings) {
       const raw = (0, external_node_stream_namespaceObject.pipeline)(response_, new external_node_stream_namespaceObject.PassThrough, (error => {
        error && reject(error);
       }));
       return raw.once("data", (chunk => {
        body = 8 == (15 & chunk[0]) ? (0, external_node_stream_namespaceObject.pipeline)(body, external_node_zlib_namespaceObject.createInflate(), (error => {
         error && reject(error);
        })) : (0, external_node_stream_namespaceObject.pipeline)(body, external_node_zlib_namespaceObject.createInflateRaw(), (error => {
         error && reject(error);
        })), response = new Response(body, responseOptions), resolve(response);
       })), void raw.once("end", (() => {
        response || (response = new Response(body, responseOptions), resolve(response));
       }));
      }
      if ("br" === codings) return body = (0, external_node_stream_namespaceObject.pipeline)(body, external_node_zlib_namespaceObject.createBrotliDecompress(), (error => {
       error && reject(error);
      })), response = new Response(body, responseOptions), void resolve(response);
      response = new Response(body, responseOptions), resolve(response);
     })), writeToStream(request_, request).catch(reject);
    }));
   }
  },
  31635: (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
   "use strict";
   __webpack_require__.r(__webpack_exports__), __webpack_require__.d(__webpack_exports__, {
    __addDisposableResource: () => __addDisposableResource,
    __assign: () => __assign,
    __asyncDelegator: () => __asyncDelegator,
    __asyncGenerator: () => __asyncGenerator,
    __asyncValues: () => __asyncValues,
    __await: () => __await,
    __awaiter: () => __awaiter,
    __classPrivateFieldGet: () => __classPrivateFieldGet,
    __classPrivateFieldIn: () => __classPrivateFieldIn,
    __classPrivateFieldSet: () => __classPrivateFieldSet,
    __createBinding: () => __createBinding,
    __decorate: () => __decorate,
    __disposeResources: () => __disposeResources,
    __esDecorate: () => __esDecorate,
    __exportStar: () => __exportStar,
    __extends: () => __extends,
    __generator: () => __generator,
    __importDefault: () => __importDefault,
    __importStar: () => __importStar,
    __makeTemplateObject: () => __makeTemplateObject,
    __metadata: () => __metadata,
    __param: () => __param,
    __propKey: () => __propKey,
    __read: () => __read,
    __rest: () => __rest,
    __runInitializers: () => __runInitializers,
    __setFunctionName: () => __setFunctionName,
    __spread: () => __spread,
    __spreadArray: () => __spreadArray,
    __spreadArrays: () => __spreadArrays,
    __values: () => __values,
    default: () => __WEBPACK_DEFAULT_EXPORT__
   });
   var extendStatics = function(d, b) {
    return extendStatics = Object.setPrototypeOf || {
     __proto__: []
    } instanceof Array && function(d, b) {
     d.__proto__ = b;
    } || function(d, b) {
     for (var p in b) Object.prototype.hasOwnProperty.call(b, p) && (d[p] = b[p]);
    }, extendStatics(d, b);
   };
   function __extends(d, b) {
    if ("function" != typeof b && null !== b) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    function __() {
     this.constructor = d;
    }
    extendStatics(d, b), d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, 
    new __);
   }
   var __assign = function() {
    return __assign = Object.assign || function(t) {
     for (var s, i = 1, n = arguments.length; i < n; i++) for (var p in s = arguments[i]) Object.prototype.hasOwnProperty.call(s, p) && (t[p] = s[p]);
     return t;
    }, __assign.apply(this, arguments);
   };
   function __rest(s, e) {
    var t = {};
    for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0 && (t[p] = s[p]);
    if (null != s && "function" == typeof Object.getOwnPropertySymbols) {
     var i = 0;
     for (p = Object.getOwnPropertySymbols(s); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t[p[i]] = s[p[i]]);
    }
    return t;
   }
   function __decorate(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
   }
   function __param(paramIndex, decorator) {
    return function(target, key) {
     decorator(target, key, paramIndex);
    };
   }
   function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) {
     if (void 0 !== f && "function" != typeof f) throw new TypeError("Function expected");
     return f;
    }
    for (var _, kind = contextIn.kind, key = "getter" === kind ? "get" : "setter" === kind ? "set" : "value", target = !descriptorIn && ctor ? contextIn.static ? ctor : ctor.prototype : null, descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {}), done = !1, i = decorators.length - 1; i >= 0; i--) {
     var context = {};
     for (var p in contextIn) context[p] = "access" === p ? {} : contextIn[p];
     for (var p in contextIn.access) context.access[p] = contextIn.access[p];
     context.addInitializer = function(f) {
      if (done) throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
     };
     var result = (0, decorators[i])("accessor" === kind ? {
      get: descriptor.get,
      set: descriptor.set
     } : descriptor[key], context);
     if ("accessor" === kind) {
      if (void 0 === result) continue;
      if (null === result || "object" != typeof result) throw new TypeError("Object expected");
      (_ = accept(result.get)) && (descriptor.get = _), (_ = accept(result.set)) && (descriptor.set = _), 
      (_ = accept(result.init)) && initializers.unshift(_);
     } else (_ = accept(result)) && ("field" === kind ? initializers.unshift(_) : descriptor[key] = _);
    }
    target && Object.defineProperty(target, contextIn.name, descriptor), done = !0;
   }
   function __runInitializers(thisArg, initializers, value) {
    for (var useValue = arguments.length > 2, i = 0; i < initializers.length; i++) value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    return useValue ? value : void 0;
   }
   function __propKey(x) {
    return "symbol" == typeof x ? x : "".concat(x);
   }
   function __setFunctionName(f, name, prefix) {
    return "symbol" == typeof name && (name = name.description ? "[".concat(name.description, "]") : ""), 
    Object.defineProperty(f, "name", {
     configurable: !0,
     value: prefix ? "".concat(prefix, " ", name) : name
    });
   }
   function __metadata(metadataKey, metadataValue) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(metadataKey, metadataValue);
   }
   function __awaiter(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))((function(resolve, reject) {
     function fulfilled(value) {
      try {
       step(generator.next(value));
      } catch (e) {
       reject(e);
      }
     }
     function rejected(value) {
      try {
       step(generator.throw(value));
      } catch (e) {
       reject(e);
      }
     }
     function step(result) {
      var value;
      result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P((function(resolve) {
       resolve(value);
      }))).then(fulfilled, rejected);
     }
     step((generator = generator.apply(thisArg, _arguments || [])).next());
    }));
   }
   function __generator(thisArg, body) {
    var f, y, t, _ = {
     label: 0,
     sent: function() {
      if (1 & t[0]) throw t[1];
      return t[1];
     },
     trys: [],
     ops: []
    }, g = Object.create(("function" == typeof Iterator ? Iterator : Object).prototype);
    return g.next = verb(0), g.throw = verb(1), g.return = verb(2), "function" == typeof Symbol && (g[Symbol.iterator] = function() {
     return this;
    }), g;
    function verb(n) {
     return function(v) {
      return function(op) {
       if (f) throw new TypeError("Generator is already executing.");
       for (;g && (g = 0, op[0] && (_ = 0)), _; ) try {
        if (f = 1, y && (t = 2 & op[0] ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 
        0) : y.next) && !(t = t.call(y, op[1])).done) return t;
        switch (y = 0, t && (op = [ 2 & op[0], t.value ]), op[0]) {
        case 0:
        case 1:
         t = op;
         break;

        case 4:
         return _.label++, {
          value: op[1],
          done: !1
         };

        case 5:
         _.label++, y = op[1], op = [ 0 ];
         continue;

        case 7:
         op = _.ops.pop(), _.trys.pop();
         continue;

        default:
         if (!(t = _.trys, (t = t.length > 0 && t[t.length - 1]) || 6 !== op[0] && 2 !== op[0])) {
          _ = 0;
          continue;
         }
         if (3 === op[0] && (!t || op[1] > t[0] && op[1] < t[3])) {
          _.label = op[1];
          break;
         }
         if (6 === op[0] && _.label < t[1]) {
          _.label = t[1], t = op;
          break;
         }
         if (t && _.label < t[2]) {
          _.label = t[2], _.ops.push(op);
          break;
         }
         t[2] && _.ops.pop(), _.trys.pop();
         continue;
        }
        op = body.call(thisArg, _);
       } catch (e) {
        op = [ 6, e ], y = 0;
       } finally {
        f = t = 0;
       }
       if (5 & op[0]) throw op[1];
       return {
        value: op[0] ? op[1] : void 0,
        done: !0
       };
      }([ n, v ]);
     };
    }
   }
   var __createBinding = Object.create ? function(o, m, k, k2) {
    void 0 === k2 && (k2 = k);
    var desc = Object.getOwnPropertyDescriptor(m, k);
    desc && !("get" in desc ? !m.__esModule : desc.writable || desc.configurable) || (desc = {
     enumerable: !0,
     get: function() {
      return m[k];
     }
    }), Object.defineProperty(o, k2, desc);
   } : function(o, m, k, k2) {
    void 0 === k2 && (k2 = k), o[k2] = m[k];
   };
   function __exportStar(m, o) {
    for (var p in m) "default" === p || Object.prototype.hasOwnProperty.call(o, p) || __createBinding(o, m, p);
   }
   function __values(o) {
    var s = "function" == typeof Symbol && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && "number" == typeof o.length) return {
     next: function() {
      return o && i >= o.length && (o = void 0), {
       value: o && o[i++],
       done: !o
      };
     }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
   }
   function __read(o, n) {
    var m = "function" == typeof Symbol && o[Symbol.iterator];
    if (!m) return o;
    var r, e, i = m.call(o), ar = [];
    try {
     for (;(void 0 === n || n-- > 0) && !(r = i.next()).done; ) ar.push(r.value);
    } catch (error) {
     e = {
      error
     };
    } finally {
     try {
      r && !r.done && (m = i.return) && m.call(i);
     } finally {
      if (e) throw e.error;
     }
    }
    return ar;
   }
   function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
   }
   function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    var r = Array(s), k = 0;
    for (i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, 
    k++) r[k] = a[j];
    return r;
   }
   function __spreadArray(to, from, pack) {
    if (pack || 2 === arguments.length) for (var ar, i = 0, l = from.length; i < l; i++) !ar && i in from || (ar || (ar = Array.prototype.slice.call(from, 0, i)), 
    ar[i] = from[i]);
    return to.concat(ar || Array.prototype.slice.call(from));
   }
   function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
   }
   function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var i, g = generator.apply(thisArg, _arguments || []), q = [];
    return i = Object.create(("function" == typeof AsyncIterator ? AsyncIterator : Object).prototype), 
    verb("next"), verb("throw"), verb("return", (function(f) {
     return function(v) {
      return Promise.resolve(v).then(f, reject);
     };
    })), i[Symbol.asyncIterator] = function() {
     return this;
    }, i;
    function verb(n, f) {
     g[n] && (i[n] = function(v) {
      return new Promise((function(a, b) {
       q.push([ n, v, a, b ]) > 1 || resume(n, v);
      }));
     }, f && (i[n] = f(i[n])));
    }
    function resume(n, v) {
     try {
      (r = g[n](v)).value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
     } catch (e) {
      settle(q[0][3], e);
     }
     var r;
    }
    function fulfill(value) {
     resume("next", value);
    }
    function reject(value) {
     resume("throw", value);
    }
    function settle(f, v) {
     f(v), q.shift(), q.length && resume(q[0][0], q[0][1]);
    }
   }
   function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", (function(e) {
     throw e;
    })), verb("return"), i[Symbol.iterator] = function() {
     return this;
    }, i;
    function verb(n, f) {
     i[n] = o[n] ? function(v) {
      return (p = !p) ? {
       value: __await(o[n](v)),
       done: !1
      } : f ? f(v) : v;
     } : f;
    }
   }
   function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var i, m = o[Symbol.asyncIterator];
    return m ? m.call(o) : (o = __values(o), i = {}, verb("next"), verb("throw"), verb("return"), 
    i[Symbol.asyncIterator] = function() {
     return this;
    }, i);
    function verb(n) {
     i[n] = o[n] && function(v) {
      return new Promise((function(resolve, reject) {
       (function(resolve, reject, d, v) {
        Promise.resolve(v).then((function(v) {
         resolve({
          value: v,
          done: d
         });
        }), reject);
       })(resolve, reject, (v = o[n](v)).done, v.value);
      }));
     };
    }
   }
   function __makeTemplateObject(cooked, raw) {
    return Object.defineProperty ? Object.defineProperty(cooked, "raw", {
     value: raw
    }) : cooked.raw = raw, cooked;
   }
   var __setModuleDefault = Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
     enumerable: !0,
     value: v
    });
   } : function(o, v) {
    o.default = v;
   };
   function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (null != mod) for (var k in mod) "default" !== k && Object.prototype.hasOwnProperty.call(mod, k) && __createBinding(result, mod, k);
    return __setModuleDefault(result, mod), result;
   }
   function __importDefault(mod) {
    return mod && mod.__esModule ? mod : {
     default: mod
    };
   }
   function __classPrivateFieldGet(receiver, state, kind, f) {
    if ("a" === kind && !f) throw new TypeError("Private accessor was defined without a getter");
    if ("function" == typeof state ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return "m" === kind ? f : "a" === kind ? f.call(receiver) : f ? f.value : state.get(receiver);
   }
   function __classPrivateFieldSet(receiver, state, value, kind, f) {
    if ("m" === kind) throw new TypeError("Private method is not writable");
    if ("a" === kind && !f) throw new TypeError("Private accessor was defined without a setter");
    if ("function" == typeof state ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return "a" === kind ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), 
    value;
   }
   function __classPrivateFieldIn(state, receiver) {
    if (null === receiver || "object" != typeof receiver && "function" != typeof receiver) throw new TypeError("Cannot use 'in' operator on non-object");
    return "function" == typeof state ? receiver === state : state.has(receiver);
   }
   function __addDisposableResource(env, value, async) {
    if (null != value) {
     if ("object" != typeof value && "function" != typeof value) throw new TypeError("Object expected.");
     var dispose, inner;
     if (async) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
     }
     if (void 0 === dispose) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose], async && (inner = dispose);
     }
     if ("function" != typeof dispose) throw new TypeError("Object not disposable.");
     inner && (dispose = function() {
      try {
       inner.call(this);
      } catch (e) {
       return Promise.reject(e);
      }
     }), env.stack.push({
      value,
      dispose,
      async
     });
    } else async && env.stack.push({
     async: !0
    });
    return value;
   }
   var _SuppressedError = "function" == typeof SuppressedError ? SuppressedError : function(error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
   };
   function __disposeResources(env) {
    function fail(e) {
     env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e, 
     env.hasError = !0;
    }
    var r, s = 0;
    return function next() {
     for (;r = env.stack.pop(); ) try {
      if (!r.async && 1 === s) return s = 0, env.stack.push(r), Promise.resolve().then(next);
      if (r.dispose) {
       var result = r.dispose.call(r.value);
       if (r.async) return s |= 2, Promise.resolve(result).then(next, (function(e) {
        return fail(e), next();
       }));
      } else s |= 1;
     } catch (e) {
      fail(e);
     }
     if (1 === s) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
     if (env.hasError) throw env.error;
    }();
   }
   const __WEBPACK_DEFAULT_EXPORT__ = {
    __extends,
    __assign,
    __rest,
    __decorate,
    __param,
    __metadata,
    __awaiter,
    __generator,
    __createBinding,
    __exportStar,
    __values,
    __read,
    __spread,
    __spreadArrays,
    __spreadArray,
    __await,
    __asyncGenerator,
    __asyncDelegator,
    __asyncValues,
    __makeTemplateObject,
    __importStar,
    __importDefault,
    __classPrivateFieldGet,
    __classPrivateFieldSet,
    __classPrivateFieldIn,
    __addDisposableResource,
    __disposeResources
   };
  },
  92472: module => {
   "use strict";
   module.exports = JSON.parse('[[[0,44],"disallowed_STD3_valid"],[[45,46],"valid"],[[47,47],"disallowed_STD3_valid"],[[48,57],"valid"],[[58,64],"disallowed_STD3_valid"],[[65,65],"mapped",[97]],[[66,66],"mapped",[98]],[[67,67],"mapped",[99]],[[68,68],"mapped",[100]],[[69,69],"mapped",[101]],[[70,70],"mapped",[102]],[[71,71],"mapped",[103]],[[72,72],"mapped",[104]],[[73,73],"mapped",[105]],[[74,74],"mapped",[106]],[[75,75],"mapped",[107]],[[76,76],"mapped",[108]],[[77,77],"mapped",[109]],[[78,78],"mapped",[110]],[[79,79],"mapped",[111]],[[80,80],"mapped",[112]],[[81,81],"mapped",[113]],[[82,82],"mapped",[114]],[[83,83],"mapped",[115]],[[84,84],"mapped",[116]],[[85,85],"mapped",[117]],[[86,86],"mapped",[118]],[[87,87],"mapped",[119]],[[88,88],"mapped",[120]],[[89,89],"mapped",[121]],[[90,90],"mapped",[122]],[[91,96],"disallowed_STD3_valid"],[[97,122],"valid"],[[123,127],"disallowed_STD3_valid"],[[128,159],"disallowed"],[[160,160],"disallowed_STD3_mapped",[32]],[[161,167],"valid",[],"NV8"],[[168,168],"disallowed_STD3_mapped",[32,776]],[[169,169],"valid",[],"NV8"],[[170,170],"mapped",[97]],[[171,172],"valid",[],"NV8"],[[173,173],"ignored"],[[174,174],"valid",[],"NV8"],[[175,175],"disallowed_STD3_mapped",[32,772]],[[176,177],"valid",[],"NV8"],[[178,178],"mapped",[50]],[[179,179],"mapped",[51]],[[180,180],"disallowed_STD3_mapped",[32,769]],[[181,181],"mapped",[956]],[[182,182],"valid",[],"NV8"],[[183,183],"valid"],[[184,184],"disallowed_STD3_mapped",[32,807]],[[185,185],"mapped",[49]],[[186,186],"mapped",[111]],[[187,187],"valid",[],"NV8"],[[188,188],"mapped",[49,8260,52]],[[189,189],"mapped",[49,8260,50]],[[190,190],"mapped",[51,8260,52]],[[191,191],"valid",[],"NV8"],[[192,192],"mapped",[224]],[[193,193],"mapped",[225]],[[194,194],"mapped",[226]],[[195,195],"mapped",[227]],[[196,196],"mapped",[228]],[[197,197],"mapped",[229]],[[198,198],"mapped",[230]],[[199,199],"mapped",[231]],[[200,200],"mapped",[232]],[[201,201],"mapped",[233]],[[202,202],"mapped",[234]],[[203,203],"mapped",[235]],[[204,204],"mapped",[236]],[[205,205],"mapped",[237]],[[206,206],"mapped",[238]],[[207,207],"mapped",[239]],[[208,208],"mapped",[240]],[[209,209],"mapped",[241]],[[210,210],"mapped",[242]],[[211,211],"mapped",[243]],[[212,212],"mapped",[244]],[[213,213],"mapped",[245]],[[214,214],"mapped",[246]],[[215,215],"valid",[],"NV8"],[[216,216],"mapped",[248]],[[217,217],"mapped",[249]],[[218,218],"mapped",[250]],[[219,219],"mapped",[251]],[[220,220],"mapped",[252]],[[221,221],"mapped",[253]],[[222,222],"mapped",[254]],[[223,223],"deviation",[115,115]],[[224,246],"valid"],[[247,247],"valid",[],"NV8"],[[248,255],"valid"],[[256,256],"mapped",[257]],[[257,257],"valid"],[[258,258],"mapped",[259]],[[259,259],"valid"],[[260,260],"mapped",[261]],[[261,261],"valid"],[[262,262],"mapped",[263]],[[263,263],"valid"],[[264,264],"mapped",[265]],[[265,265],"valid"],[[266,266],"mapped",[267]],[[267,267],"valid"],[[268,268],"mapped",[269]],[[269,269],"valid"],[[270,270],"mapped",[271]],[[271,271],"valid"],[[272,272],"mapped",[273]],[[273,273],"valid"],[[274,274],"mapped",[275]],[[275,275],"valid"],[[276,276],"mapped",[277]],[[277,277],"valid"],[[278,278],"mapped",[279]],[[279,279],"valid"],[[280,280],"mapped",[281]],[[281,281],"valid"],[[282,282],"mapped",[283]],[[283,283],"valid"],[[284,284],"mapped",[285]],[[285,285],"valid"],[[286,286],"mapped",[287]],[[287,287],"valid"],[[288,288],"mapped",[289]],[[289,289],"valid"],[[290,290],"mapped",[291]],[[291,291],"valid"],[[292,292],"mapped",[293]],[[293,293],"valid"],[[294,294],"mapped",[295]],[[295,295],"valid"],[[296,296],"mapped",[297]],[[297,297],"valid"],[[298,298],"mapped",[299]],[[299,299],"valid"],[[300,300],"mapped",[301]],[[301,301],"valid"],[[302,302],"mapped",[303]],[[303,303],"valid"],[[304,304],"mapped",[105,775]],[[305,305],"valid"],[[306,307],"mapped",[105,106]],[[308,308],"mapped",[309]],[[309,309],"valid"],[[310,310],"mapped",[311]],[[311,312],"valid"],[[313,313],"mapped",[314]],[[314,314],"valid"],[[315,315],"mapped",[316]],[[316,316],"valid"],[[317,317],"mapped",[318]],[[318,318],"valid"],[[319,320],"mapped",[108,183]],[[321,321],"mapped",[322]],[[322,322],"valid"],[[323,323],"mapped",[324]],[[324,324],"valid"],[[325,325],"mapped",[326]],[[326,326],"valid"],[[327,327],"mapped",[328]],[[328,328],"valid"],[[329,329],"mapped",[700,110]],[[330,330],"mapped",[331]],[[331,331],"valid"],[[332,332],"mapped",[333]],[[333,333],"valid"],[[334,334],"mapped",[335]],[[335,335],"valid"],[[336,336],"mapped",[337]],[[337,337],"valid"],[[338,338],"mapped",[339]],[[339,339],"valid"],[[340,340],"mapped",[341]],[[341,341],"valid"],[[342,342],"mapped",[343]],[[343,343],"valid"],[[344,344],"mapped",[345]],[[345,345],"valid"],[[346,346],"mapped",[347]],[[347,347],"valid"],[[348,348],"mapped",[349]],[[349,349],"valid"],[[350,350],"mapped",[351]],[[351,351],"valid"],[[352,352],"mapped",[353]],[[353,353],"valid"],[[354,354],"mapped",[355]],[[355,355],"valid"],[[356,356],"mapped",[357]],[[357,357],"valid"],[[358,358],"mapped",[359]],[[359,359],"valid"],[[360,360],"mapped",[361]],[[361,361],"valid"],[[362,362],"mapped",[363]],[[363,363],"valid"],[[364,364],"mapped",[365]],[[365,365],"valid"],[[366,366],"mapped",[367]],[[367,367],"valid"],[[368,368],"mapped",[369]],[[369,369],"valid"],[[370,370],"mapped",[371]],[[371,371],"valid"],[[372,372],"mapped",[373]],[[373,373],"valid"],[[374,374],"mapped",[375]],[[375,375],"valid"],[[376,376],"mapped",[255]],[[377,377],"mapped",[378]],[[378,378],"valid"],[[379,379],"mapped",[380]],[[380,380],"valid"],[[381,381],"mapped",[382]],[[382,382],"valid"],[[383,383],"mapped",[115]],[[384,384],"valid"],[[385,385],"mapped",[595]],[[386,386],"mapped",[387]],[[387,387],"valid"],[[388,388],"mapped",[389]],[[389,389],"valid"],[[390,390],"mapped",[596]],[[391,391],"mapped",[392]],[[392,392],"valid"],[[393,393],"mapped",[598]],[[394,394],"mapped",[599]],[[395,395],"mapped",[396]],[[396,397],"valid"],[[398,398],"mapped",[477]],[[399,399],"mapped",[601]],[[400,400],"mapped",[603]],[[401,401],"mapped",[402]],[[402,402],"valid"],[[403,403],"mapped",[608]],[[404,404],"mapped",[611]],[[405,405],"valid"],[[406,406],"mapped",[617]],[[407,407],"mapped",[616]],[[408,408],"mapped",[409]],[[409,411],"valid"],[[412,412],"mapped",[623]],[[413,413],"mapped",[626]],[[414,414],"valid"],[[415,415],"mapped",[629]],[[416,416],"mapped",[417]],[[417,417],"valid"],[[418,418],"mapped",[419]],[[419,419],"valid"],[[420,420],"mapped",[421]],[[421,421],"valid"],[[422,422],"mapped",[640]],[[423,423],"mapped",[424]],[[424,424],"valid"],[[425,425],"mapped",[643]],[[426,427],"valid"],[[428,428],"mapped",[429]],[[429,429],"valid"],[[430,430],"mapped",[648]],[[431,431],"mapped",[432]],[[432,432],"valid"],[[433,433],"mapped",[650]],[[434,434],"mapped",[651]],[[435,435],"mapped",[436]],[[436,436],"valid"],[[437,437],"mapped",[438]],[[438,438],"valid"],[[439,439],"mapped",[658]],[[440,440],"mapped",[441]],[[441,443],"valid"],[[444,444],"mapped",[445]],[[445,451],"valid"],[[452,454],"mapped",[100,382]],[[455,457],"mapped",[108,106]],[[458,460],"mapped",[110,106]],[[461,461],"mapped",[462]],[[462,462],"valid"],[[463,463],"mapped",[464]],[[464,464],"valid"],[[465,465],"mapped",[466]],[[466,466],"valid"],[[467,467],"mapped",[468]],[[468,468],"valid"],[[469,469],"mapped",[470]],[[470,470],"valid"],[[471,471],"mapped",[472]],[[472,472],"valid"],[[473,473],"mapped",[474]],[[474,474],"valid"],[[475,475],"mapped",[476]],[[476,477],"valid"],[[478,478],"mapped",[479]],[[479,479],"valid"],[[480,480],"mapped",[481]],[[481,481],"valid"],[[482,482],"mapped",[483]],[[483,483],"valid"],[[484,484],"mapped",[485]],[[485,485],"valid"],[[486,486],"mapped",[487]],[[487,487],"valid"],[[488,488],"mapped",[489]],[[489,489],"valid"],[[490,490],"mapped",[491]],[[491,491],"valid"],[[492,492],"mapped",[493]],[[493,493],"valid"],[[494,494],"mapped",[495]],[[495,496],"valid"],[[497,499],"mapped",[100,122]],[[500,500],"mapped",[501]],[[501,501],"valid"],[[502,502],"mapped",[405]],[[503,503],"mapped",[447]],[[504,504],"mapped",[505]],[[505,505],"valid"],[[506,506],"mapped",[507]],[[507,507],"valid"],[[508,508],"mapped",[509]],[[509,509],"valid"],[[510,510],"mapped",[511]],[[511,511],"valid"],[[512,512],"mapped",[513]],[[513,513],"valid"],[[514,514],"mapped",[515]],[[515,515],"valid"],[[516,516],"mapped",[517]],[[517,517],"valid"],[[518,518],"mapped",[519]],[[519,519],"valid"],[[520,520],"mapped",[521]],[[521,521],"valid"],[[522,522],"mapped",[523]],[[523,523],"valid"],[[524,524],"mapped",[525]],[[525,525],"valid"],[[526,526],"mapped",[527]],[[527,527],"valid"],[[528,528],"mapped",[529]],[[529,529],"valid"],[[530,530],"mapped",[531]],[[531,531],"valid"],[[532,532],"mapped",[533]],[[533,533],"valid"],[[534,534],"mapped",[535]],[[535,535],"valid"],[[536,536],"mapped",[537]],[[537,537],"valid"],[[538,538],"mapped",[539]],[[539,539],"valid"],[[540,540],"mapped",[541]],[[541,541],"valid"],[[542,542],"mapped",[543]],[[543,543],"valid"],[[544,544],"mapped",[414]],[[545,545],"valid"],[[546,546],"mapped",[547]],[[547,547],"valid"],[[548,548],"mapped",[549]],[[549,549],"valid"],[[550,550],"mapped",[551]],[[551,551],"valid"],[[552,552],"mapped",[553]],[[553,553],"valid"],[[554,554],"mapped",[555]],[[555,555],"valid"],[[556,556],"mapped",[557]],[[557,557],"valid"],[[558,558],"mapped",[559]],[[559,559],"valid"],[[560,560],"mapped",[561]],[[561,561],"valid"],[[562,562],"mapped",[563]],[[563,563],"valid"],[[564,566],"valid"],[[567,569],"valid"],[[570,570],"mapped",[11365]],[[571,571],"mapped",[572]],[[572,572],"valid"],[[573,573],"mapped",[410]],[[574,574],"mapped",[11366]],[[575,576],"valid"],[[577,577],"mapped",[578]],[[578,578],"valid"],[[579,579],"mapped",[384]],[[580,580],"mapped",[649]],[[581,581],"mapped",[652]],[[582,582],"mapped",[583]],[[583,583],"valid"],[[584,584],"mapped",[585]],[[585,585],"valid"],[[586,586],"mapped",[587]],[[587,587],"valid"],[[588,588],"mapped",[589]],[[589,589],"valid"],[[590,590],"mapped",[591]],[[591,591],"valid"],[[592,680],"valid"],[[681,685],"valid"],[[686,687],"valid"],[[688,688],"mapped",[104]],[[689,689],"mapped",[614]],[[690,690],"mapped",[106]],[[691,691],"mapped",[114]],[[692,692],"mapped",[633]],[[693,693],"mapped",[635]],[[694,694],"mapped",[641]],[[695,695],"mapped",[119]],[[696,696],"mapped",[121]],[[697,705],"valid"],[[706,709],"valid",[],"NV8"],[[710,721],"valid"],[[722,727],"valid",[],"NV8"],[[728,728],"disallowed_STD3_mapped",[32,774]],[[729,729],"disallowed_STD3_mapped",[32,775]],[[730,730],"disallowed_STD3_mapped",[32,778]],[[731,731],"disallowed_STD3_mapped",[32,808]],[[732,732],"disallowed_STD3_mapped",[32,771]],[[733,733],"disallowed_STD3_mapped",[32,779]],[[734,734],"valid",[],"NV8"],[[735,735],"valid",[],"NV8"],[[736,736],"mapped",[611]],[[737,737],"mapped",[108]],[[738,738],"mapped",[115]],[[739,739],"mapped",[120]],[[740,740],"mapped",[661]],[[741,745],"valid",[],"NV8"],[[746,747],"valid",[],"NV8"],[[748,748],"valid"],[[749,749],"valid",[],"NV8"],[[750,750],"valid"],[[751,767],"valid",[],"NV8"],[[768,831],"valid"],[[832,832],"mapped",[768]],[[833,833],"mapped",[769]],[[834,834],"valid"],[[835,835],"mapped",[787]],[[836,836],"mapped",[776,769]],[[837,837],"mapped",[953]],[[838,846],"valid"],[[847,847],"ignored"],[[848,855],"valid"],[[856,860],"valid"],[[861,863],"valid"],[[864,865],"valid"],[[866,866],"valid"],[[867,879],"valid"],[[880,880],"mapped",[881]],[[881,881],"valid"],[[882,882],"mapped",[883]],[[883,883],"valid"],[[884,884],"mapped",[697]],[[885,885],"valid"],[[886,886],"mapped",[887]],[[887,887],"valid"],[[888,889],"disallowed"],[[890,890],"disallowed_STD3_mapped",[32,953]],[[891,893],"valid"],[[894,894],"disallowed_STD3_mapped",[59]],[[895,895],"mapped",[1011]],[[896,899],"disallowed"],[[900,900],"disallowed_STD3_mapped",[32,769]],[[901,901],"disallowed_STD3_mapped",[32,776,769]],[[902,902],"mapped",[940]],[[903,903],"mapped",[183]],[[904,904],"mapped",[941]],[[905,905],"mapped",[942]],[[906,906],"mapped",[943]],[[907,907],"disallowed"],[[908,908],"mapped",[972]],[[909,909],"disallowed"],[[910,910],"mapped",[973]],[[911,911],"mapped",[974]],[[912,912],"valid"],[[913,913],"mapped",[945]],[[914,914],"mapped",[946]],[[915,915],"mapped",[947]],[[916,916],"mapped",[948]],[[917,917],"mapped",[949]],[[918,918],"mapped",[950]],[[919,919],"mapped",[951]],[[920,920],"mapped",[952]],[[921,921],"mapped",[953]],[[922,922],"mapped",[954]],[[923,923],"mapped",[955]],[[924,924],"mapped",[956]],[[925,925],"mapped",[957]],[[926,926],"mapped",[958]],[[927,927],"mapped",[959]],[[928,928],"mapped",[960]],[[929,929],"mapped",[961]],[[930,930],"disallowed"],[[931,931],"mapped",[963]],[[932,932],"mapped",[964]],[[933,933],"mapped",[965]],[[934,934],"mapped",[966]],[[935,935],"mapped",[967]],[[936,936],"mapped",[968]],[[937,937],"mapped",[969]],[[938,938],"mapped",[970]],[[939,939],"mapped",[971]],[[940,961],"valid"],[[962,962],"deviation",[963]],[[963,974],"valid"],[[975,975],"mapped",[983]],[[976,976],"mapped",[946]],[[977,977],"mapped",[952]],[[978,978],"mapped",[965]],[[979,979],"mapped",[973]],[[980,980],"mapped",[971]],[[981,981],"mapped",[966]],[[982,982],"mapped",[960]],[[983,983],"valid"],[[984,984],"mapped",[985]],[[985,985],"valid"],[[986,986],"mapped",[987]],[[987,987],"valid"],[[988,988],"mapped",[989]],[[989,989],"valid"],[[990,990],"mapped",[991]],[[991,991],"valid"],[[992,992],"mapped",[993]],[[993,993],"valid"],[[994,994],"mapped",[995]],[[995,995],"valid"],[[996,996],"mapped",[997]],[[997,997],"valid"],[[998,998],"mapped",[999]],[[999,999],"valid"],[[1000,1000],"mapped",[1001]],[[1001,1001],"valid"],[[1002,1002],"mapped",[1003]],[[1003,1003],"valid"],[[1004,1004],"mapped",[1005]],[[1005,1005],"valid"],[[1006,1006],"mapped",[1007]],[[1007,1007],"valid"],[[1008,1008],"mapped",[954]],[[1009,1009],"mapped",[961]],[[1010,1010],"mapped",[963]],[[1011,1011],"valid"],[[1012,1012],"mapped",[952]],[[1013,1013],"mapped",[949]],[[1014,1014],"valid",[],"NV8"],[[1015,1015],"mapped",[1016]],[[1016,1016],"valid"],[[1017,1017],"mapped",[963]],[[1018,1018],"mapped",[1019]],[[1019,1019],"valid"],[[1020,1020],"valid"],[[1021,1021],"mapped",[891]],[[1022,1022],"mapped",[892]],[[1023,1023],"mapped",[893]],[[1024,1024],"mapped",[1104]],[[1025,1025],"mapped",[1105]],[[1026,1026],"mapped",[1106]],[[1027,1027],"mapped",[1107]],[[1028,1028],"mapped",[1108]],[[1029,1029],"mapped",[1109]],[[1030,1030],"mapped",[1110]],[[1031,1031],"mapped",[1111]],[[1032,1032],"mapped",[1112]],[[1033,1033],"mapped",[1113]],[[1034,1034],"mapped",[1114]],[[1035,1035],"mapped",[1115]],[[1036,1036],"mapped",[1116]],[[1037,1037],"mapped",[1117]],[[1038,1038],"mapped",[1118]],[[1039,1039],"mapped",[1119]],[[1040,1040],"mapped",[1072]],[[1041,1041],"mapped",[1073]],[[1042,1042],"mapped",[1074]],[[1043,1043],"mapped",[1075]],[[1044,1044],"mapped",[1076]],[[1045,1045],"mapped",[1077]],[[1046,1046],"mapped",[1078]],[[1047,1047],"mapped",[1079]],[[1048,1048],"mapped",[1080]],[[1049,1049],"mapped",[1081]],[[1050,1050],"mapped",[1082]],[[1051,1051],"mapped",[1083]],[[1052,1052],"mapped",[1084]],[[1053,1053],"mapped",[1085]],[[1054,1054],"mapped",[1086]],[[1055,1055],"mapped",[1087]],[[1056,1056],"mapped",[1088]],[[1057,1057],"mapped",[1089]],[[1058,1058],"mapped",[1090]],[[1059,1059],"mapped",[1091]],[[1060,1060],"mapped",[1092]],[[1061,1061],"mapped",[1093]],[[1062,1062],"mapped",[1094]],[[1063,1063],"mapped",[1095]],[[1064,1064],"mapped",[1096]],[[1065,1065],"mapped",[1097]],[[1066,1066],"mapped",[1098]],[[1067,1067],"mapped",[1099]],[[1068,1068],"mapped",[1100]],[[1069,1069],"mapped",[1101]],[[1070,1070],"mapped",[1102]],[[1071,1071],"mapped",[1103]],[[1072,1103],"valid"],[[1104,1104],"valid"],[[1105,1116],"valid"],[[1117,1117],"valid"],[[1118,1119],"valid"],[[1120,1120],"mapped",[1121]],[[1121,1121],"valid"],[[1122,1122],"mapped",[1123]],[[1123,1123],"valid"],[[1124,1124],"mapped",[1125]],[[1125,1125],"valid"],[[1126,1126],"mapped",[1127]],[[1127,1127],"valid"],[[1128,1128],"mapped",[1129]],[[1129,1129],"valid"],[[1130,1130],"mapped",[1131]],[[1131,1131],"valid"],[[1132,1132],"mapped",[1133]],[[1133,1133],"valid"],[[1134,1134],"mapped",[1135]],[[1135,1135],"valid"],[[1136,1136],"mapped",[1137]],[[1137,1137],"valid"],[[1138,1138],"mapped",[1139]],[[1139,1139],"valid"],[[1140,1140],"mapped",[1141]],[[1141,1141],"valid"],[[1142,1142],"mapped",[1143]],[[1143,1143],"valid"],[[1144,1144],"mapped",[1145]],[[1145,1145],"valid"],[[1146,1146],"mapped",[1147]],[[1147,1147],"valid"],[[1148,1148],"mapped",[1149]],[[1149,1149],"valid"],[[1150,1150],"mapped",[1151]],[[1151,1151],"valid"],[[1152,1152],"mapped",[1153]],[[1153,1153],"valid"],[[1154,1154],"valid",[],"NV8"],[[1155,1158],"valid"],[[1159,1159],"valid"],[[1160,1161],"valid",[],"NV8"],[[1162,1162],"mapped",[1163]],[[1163,1163],"valid"],[[1164,1164],"mapped",[1165]],[[1165,1165],"valid"],[[1166,1166],"mapped",[1167]],[[1167,1167],"valid"],[[1168,1168],"mapped",[1169]],[[1169,1169],"valid"],[[1170,1170],"mapped",[1171]],[[1171,1171],"valid"],[[1172,1172],"mapped",[1173]],[[1173,1173],"valid"],[[1174,1174],"mapped",[1175]],[[1175,1175],"valid"],[[1176,1176],"mapped",[1177]],[[1177,1177],"valid"],[[1178,1178],"mapped",[1179]],[[1179,1179],"valid"],[[1180,1180],"mapped",[1181]],[[1181,1181],"valid"],[[1182,1182],"mapped",[1183]],[[1183,1183],"valid"],[[1184,1184],"mapped",[1185]],[[1185,1185],"valid"],[[1186,1186],"mapped",[1187]],[[1187,1187],"valid"],[[1188,1188],"mapped",[1189]],[[1189,1189],"valid"],[[1190,1190],"mapped",[1191]],[[1191,1191],"valid"],[[1192,1192],"mapped",[1193]],[[1193,1193],"valid"],[[1194,1194],"mapped",[1195]],[[1195,1195],"valid"],[[1196,1196],"mapped",[1197]],[[1197,1197],"valid"],[[1198,1198],"mapped",[1199]],[[1199,1199],"valid"],[[1200,1200],"mapped",[1201]],[[1201,1201],"valid"],[[1202,1202],"mapped",[1203]],[[1203,1203],"valid"],[[1204,1204],"mapped",[1205]],[[1205,1205],"valid"],[[1206,1206],"mapped",[1207]],[[1207,1207],"valid"],[[1208,1208],"mapped",[1209]],[[1209,1209],"valid"],[[1210,1210],"mapped",[1211]],[[1211,1211],"valid"],[[1212,1212],"mapped",[1213]],[[1213,1213],"valid"],[[1214,1214],"mapped",[1215]],[[1215,1215],"valid"],[[1216,1216],"disallowed"],[[1217,1217],"mapped",[1218]],[[1218,1218],"valid"],[[1219,1219],"mapped",[1220]],[[1220,1220],"valid"],[[1221,1221],"mapped",[1222]],[[1222,1222],"valid"],[[1223,1223],"mapped",[1224]],[[1224,1224],"valid"],[[1225,1225],"mapped",[1226]],[[1226,1226],"valid"],[[1227,1227],"mapped",[1228]],[[1228,1228],"valid"],[[1229,1229],"mapped",[1230]],[[1230,1230],"valid"],[[1231,1231],"valid"],[[1232,1232],"mapped",[1233]],[[1233,1233],"valid"],[[1234,1234],"mapped",[1235]],[[1235,1235],"valid"],[[1236,1236],"mapped",[1237]],[[1237,1237],"valid"],[[1238,1238],"mapped",[1239]],[[1239,1239],"valid"],[[1240,1240],"mapped",[1241]],[[1241,1241],"valid"],[[1242,1242],"mapped",[1243]],[[1243,1243],"valid"],[[1244,1244],"mapped",[1245]],[[1245,1245],"valid"],[[1246,1246],"mapped",[1247]],[[1247,1247],"valid"],[[1248,1248],"mapped",[1249]],[[1249,1249],"valid"],[[1250,1250],"mapped",[1251]],[[1251,1251],"valid"],[[1252,1252],"mapped",[1253]],[[1253,1253],"valid"],[[1254,1254],"mapped",[1255]],[[1255,1255],"valid"],[[1256,1256],"mapped",[1257]],[[1257,1257],"valid"],[[1258,1258],"mapped",[1259]],[[1259,1259],"valid"],[[1260,1260],"mapped",[1261]],[[1261,1261],"valid"],[[1262,1262],"mapped",[1263]],[[1263,1263],"valid"],[[1264,1264],"mapped",[1265]],[[1265,1265],"valid"],[[1266,1266],"mapped",[1267]],[[1267,1267],"valid"],[[1268,1268],"mapped",[1269]],[[1269,1269],"valid"],[[1270,1270],"mapped",[1271]],[[1271,1271],"valid"],[[1272,1272],"mapped",[1273]],[[1273,1273],"valid"],[[1274,1274],"mapped",[1275]],[[1275,1275],"valid"],[[1276,1276],"mapped",[1277]],[[1277,1277],"valid"],[[1278,1278],"mapped",[1279]],[[1279,1279],"valid"],[[1280,1280],"mapped",[1281]],[[1281,1281],"valid"],[[1282,1282],"mapped",[1283]],[[1283,1283],"valid"],[[1284,1284],"mapped",[1285]],[[1285,1285],"valid"],[[1286,1286],"mapped",[1287]],[[1287,1287],"valid"],[[1288,1288],"mapped",[1289]],[[1289,1289],"valid"],[[1290,1290],"mapped",[1291]],[[1291,1291],"valid"],[[1292,1292],"mapped",[1293]],[[1293,1293],"valid"],[[1294,1294],"mapped",[1295]],[[1295,1295],"valid"],[[1296,1296],"mapped",[1297]],[[1297,1297],"valid"],[[1298,1298],"mapped",[1299]],[[1299,1299],"valid"],[[1300,1300],"mapped",[1301]],[[1301,1301],"valid"],[[1302,1302],"mapped",[1303]],[[1303,1303],"valid"],[[1304,1304],"mapped",[1305]],[[1305,1305],"valid"],[[1306,1306],"mapped",[1307]],[[1307,1307],"valid"],[[1308,1308],"mapped",[1309]],[[1309,1309],"valid"],[[1310,1310],"mapped",[1311]],[[1311,1311],"valid"],[[1312,1312],"mapped",[1313]],[[1313,1313],"valid"],[[1314,1314],"mapped",[1315]],[[1315,1315],"valid"],[[1316,1316],"mapped",[1317]],[[1317,1317],"valid"],[[1318,1318],"mapped",[1319]],[[1319,1319],"valid"],[[1320,1320],"mapped",[1321]],[[1321,1321],"valid"],[[1322,1322],"mapped",[1323]],[[1323,1323],"valid"],[[1324,1324],"mapped",[1325]],[[1325,1325],"valid"],[[1326,1326],"mapped",[1327]],[[1327,1327],"valid"],[[1328,1328],"disallowed"],[[1329,1329],"mapped",[1377]],[[1330,1330],"mapped",[1378]],[[1331,1331],"mapped",[1379]],[[1332,1332],"mapped",[1380]],[[1333,1333],"mapped",[1381]],[[1334,1334],"mapped",[1382]],[[1335,1335],"mapped",[1383]],[[1336,1336],"mapped",[1384]],[[1337,1337],"mapped",[1385]],[[1338,1338],"mapped",[1386]],[[1339,1339],"mapped",[1387]],[[1340,1340],"mapped",[1388]],[[1341,1341],"mapped",[1389]],[[1342,1342],"mapped",[1390]],[[1343,1343],"mapped",[1391]],[[1344,1344],"mapped",[1392]],[[1345,1345],"mapped",[1393]],[[1346,1346],"mapped",[1394]],[[1347,1347],"mapped",[1395]],[[1348,1348],"mapped",[1396]],[[1349,1349],"mapped",[1397]],[[1350,1350],"mapped",[1398]],[[1351,1351],"mapped",[1399]],[[1352,1352],"mapped",[1400]],[[1353,1353],"mapped",[1401]],[[1354,1354],"mapped",[1402]],[[1355,1355],"mapped",[1403]],[[1356,1356],"mapped",[1404]],[[1357,1357],"mapped",[1405]],[[1358,1358],"mapped",[1406]],[[1359,1359],"mapped",[1407]],[[1360,1360],"mapped",[1408]],[[1361,1361],"mapped",[1409]],[[1362,1362],"mapped",[1410]],[[1363,1363],"mapped",[1411]],[[1364,1364],"mapped",[1412]],[[1365,1365],"mapped",[1413]],[[1366,1366],"mapped",[1414]],[[1367,1368],"disallowed"],[[1369,1369],"valid"],[[1370,1375],"valid",[],"NV8"],[[1376,1376],"disallowed"],[[1377,1414],"valid"],[[1415,1415],"mapped",[1381,1410]],[[1416,1416],"disallowed"],[[1417,1417],"valid",[],"NV8"],[[1418,1418],"valid",[],"NV8"],[[1419,1420],"disallowed"],[[1421,1422],"valid",[],"NV8"],[[1423,1423],"valid",[],"NV8"],[[1424,1424],"disallowed"],[[1425,1441],"valid"],[[1442,1442],"valid"],[[1443,1455],"valid"],[[1456,1465],"valid"],[[1466,1466],"valid"],[[1467,1469],"valid"],[[1470,1470],"valid",[],"NV8"],[[1471,1471],"valid"],[[1472,1472],"valid",[],"NV8"],[[1473,1474],"valid"],[[1475,1475],"valid",[],"NV8"],[[1476,1476],"valid"],[[1477,1477],"valid"],[[1478,1478],"valid",[],"NV8"],[[1479,1479],"valid"],[[1480,1487],"disallowed"],[[1488,1514],"valid"],[[1515,1519],"disallowed"],[[1520,1524],"valid"],[[1525,1535],"disallowed"],[[1536,1539],"disallowed"],[[1540,1540],"disallowed"],[[1541,1541],"disallowed"],[[1542,1546],"valid",[],"NV8"],[[1547,1547],"valid",[],"NV8"],[[1548,1548],"valid",[],"NV8"],[[1549,1551],"valid",[],"NV8"],[[1552,1557],"valid"],[[1558,1562],"valid"],[[1563,1563],"valid",[],"NV8"],[[1564,1564],"disallowed"],[[1565,1565],"disallowed"],[[1566,1566],"valid",[],"NV8"],[[1567,1567],"valid",[],"NV8"],[[1568,1568],"valid"],[[1569,1594],"valid"],[[1595,1599],"valid"],[[1600,1600],"valid",[],"NV8"],[[1601,1618],"valid"],[[1619,1621],"valid"],[[1622,1624],"valid"],[[1625,1630],"valid"],[[1631,1631],"valid"],[[1632,1641],"valid"],[[1642,1645],"valid",[],"NV8"],[[1646,1647],"valid"],[[1648,1652],"valid"],[[1653,1653],"mapped",[1575,1652]],[[1654,1654],"mapped",[1608,1652]],[[1655,1655],"mapped",[1735,1652]],[[1656,1656],"mapped",[1610,1652]],[[1657,1719],"valid"],[[1720,1721],"valid"],[[1722,1726],"valid"],[[1727,1727],"valid"],[[1728,1742],"valid"],[[1743,1743],"valid"],[[1744,1747],"valid"],[[1748,1748],"valid",[],"NV8"],[[1749,1756],"valid"],[[1757,1757],"disallowed"],[[1758,1758],"valid",[],"NV8"],[[1759,1768],"valid"],[[1769,1769],"valid",[],"NV8"],[[1770,1773],"valid"],[[1774,1775],"valid"],[[1776,1785],"valid"],[[1786,1790],"valid"],[[1791,1791],"valid"],[[1792,1805],"valid",[],"NV8"],[[1806,1806],"disallowed"],[[1807,1807],"disallowed"],[[1808,1836],"valid"],[[1837,1839],"valid"],[[1840,1866],"valid"],[[1867,1868],"disallowed"],[[1869,1871],"valid"],[[1872,1901],"valid"],[[1902,1919],"valid"],[[1920,1968],"valid"],[[1969,1969],"valid"],[[1970,1983],"disallowed"],[[1984,2037],"valid"],[[2038,2042],"valid",[],"NV8"],[[2043,2047],"disallowed"],[[2048,2093],"valid"],[[2094,2095],"disallowed"],[[2096,2110],"valid",[],"NV8"],[[2111,2111],"disallowed"],[[2112,2139],"valid"],[[2140,2141],"disallowed"],[[2142,2142],"valid",[],"NV8"],[[2143,2207],"disallowed"],[[2208,2208],"valid"],[[2209,2209],"valid"],[[2210,2220],"valid"],[[2221,2226],"valid"],[[2227,2228],"valid"],[[2229,2274],"disallowed"],[[2275,2275],"valid"],[[2276,2302],"valid"],[[2303,2303],"valid"],[[2304,2304],"valid"],[[2305,2307],"valid"],[[2308,2308],"valid"],[[2309,2361],"valid"],[[2362,2363],"valid"],[[2364,2381],"valid"],[[2382,2382],"valid"],[[2383,2383],"valid"],[[2384,2388],"valid"],[[2389,2389],"valid"],[[2390,2391],"valid"],[[2392,2392],"mapped",[2325,2364]],[[2393,2393],"mapped",[2326,2364]],[[2394,2394],"mapped",[2327,2364]],[[2395,2395],"mapped",[2332,2364]],[[2396,2396],"mapped",[2337,2364]],[[2397,2397],"mapped",[2338,2364]],[[2398,2398],"mapped",[2347,2364]],[[2399,2399],"mapped",[2351,2364]],[[2400,2403],"valid"],[[2404,2405],"valid",[],"NV8"],[[2406,2415],"valid"],[[2416,2416],"valid",[],"NV8"],[[2417,2418],"valid"],[[2419,2423],"valid"],[[2424,2424],"valid"],[[2425,2426],"valid"],[[2427,2428],"valid"],[[2429,2429],"valid"],[[2430,2431],"valid"],[[2432,2432],"valid"],[[2433,2435],"valid"],[[2436,2436],"disallowed"],[[2437,2444],"valid"],[[2445,2446],"disallowed"],[[2447,2448],"valid"],[[2449,2450],"disallowed"],[[2451,2472],"valid"],[[2473,2473],"disallowed"],[[2474,2480],"valid"],[[2481,2481],"disallowed"],[[2482,2482],"valid"],[[2483,2485],"disallowed"],[[2486,2489],"valid"],[[2490,2491],"disallowed"],[[2492,2492],"valid"],[[2493,2493],"valid"],[[2494,2500],"valid"],[[2501,2502],"disallowed"],[[2503,2504],"valid"],[[2505,2506],"disallowed"],[[2507,2509],"valid"],[[2510,2510],"valid"],[[2511,2518],"disallowed"],[[2519,2519],"valid"],[[2520,2523],"disallowed"],[[2524,2524],"mapped",[2465,2492]],[[2525,2525],"mapped",[2466,2492]],[[2526,2526],"disallowed"],[[2527,2527],"mapped",[2479,2492]],[[2528,2531],"valid"],[[2532,2533],"disallowed"],[[2534,2545],"valid"],[[2546,2554],"valid",[],"NV8"],[[2555,2555],"valid",[],"NV8"],[[2556,2560],"disallowed"],[[2561,2561],"valid"],[[2562,2562],"valid"],[[2563,2563],"valid"],[[2564,2564],"disallowed"],[[2565,2570],"valid"],[[2571,2574],"disallowed"],[[2575,2576],"valid"],[[2577,2578],"disallowed"],[[2579,2600],"valid"],[[2601,2601],"disallowed"],[[2602,2608],"valid"],[[2609,2609],"disallowed"],[[2610,2610],"valid"],[[2611,2611],"mapped",[2610,2620]],[[2612,2612],"disallowed"],[[2613,2613],"valid"],[[2614,2614],"mapped",[2616,2620]],[[2615,2615],"disallowed"],[[2616,2617],"valid"],[[2618,2619],"disallowed"],[[2620,2620],"valid"],[[2621,2621],"disallowed"],[[2622,2626],"valid"],[[2627,2630],"disallowed"],[[2631,2632],"valid"],[[2633,2634],"disallowed"],[[2635,2637],"valid"],[[2638,2640],"disallowed"],[[2641,2641],"valid"],[[2642,2648],"disallowed"],[[2649,2649],"mapped",[2582,2620]],[[2650,2650],"mapped",[2583,2620]],[[2651,2651],"mapped",[2588,2620]],[[2652,2652],"valid"],[[2653,2653],"disallowed"],[[2654,2654],"mapped",[2603,2620]],[[2655,2661],"disallowed"],[[2662,2676],"valid"],[[2677,2677],"valid"],[[2678,2688],"disallowed"],[[2689,2691],"valid"],[[2692,2692],"disallowed"],[[2693,2699],"valid"],[[2700,2700],"valid"],[[2701,2701],"valid"],[[2702,2702],"disallowed"],[[2703,2705],"valid"],[[2706,2706],"disallowed"],[[2707,2728],"valid"],[[2729,2729],"disallowed"],[[2730,2736],"valid"],[[2737,2737],"disallowed"],[[2738,2739],"valid"],[[2740,2740],"disallowed"],[[2741,2745],"valid"],[[2746,2747],"disallowed"],[[2748,2757],"valid"],[[2758,2758],"disallowed"],[[2759,2761],"valid"],[[2762,2762],"disallowed"],[[2763,2765],"valid"],[[2766,2767],"disallowed"],[[2768,2768],"valid"],[[2769,2783],"disallowed"],[[2784,2784],"valid"],[[2785,2787],"valid"],[[2788,2789],"disallowed"],[[2790,2799],"valid"],[[2800,2800],"valid",[],"NV8"],[[2801,2801],"valid",[],"NV8"],[[2802,2808],"disallowed"],[[2809,2809],"valid"],[[2810,2816],"disallowed"],[[2817,2819],"valid"],[[2820,2820],"disallowed"],[[2821,2828],"valid"],[[2829,2830],"disallowed"],[[2831,2832],"valid"],[[2833,2834],"disallowed"],[[2835,2856],"valid"],[[2857,2857],"disallowed"],[[2858,2864],"valid"],[[2865,2865],"disallowed"],[[2866,2867],"valid"],[[2868,2868],"disallowed"],[[2869,2869],"valid"],[[2870,2873],"valid"],[[2874,2875],"disallowed"],[[2876,2883],"valid"],[[2884,2884],"valid"],[[2885,2886],"disallowed"],[[2887,2888],"valid"],[[2889,2890],"disallowed"],[[2891,2893],"valid"],[[2894,2901],"disallowed"],[[2902,2903],"valid"],[[2904,2907],"disallowed"],[[2908,2908],"mapped",[2849,2876]],[[2909,2909],"mapped",[2850,2876]],[[2910,2910],"disallowed"],[[2911,2913],"valid"],[[2914,2915],"valid"],[[2916,2917],"disallowed"],[[2918,2927],"valid"],[[2928,2928],"valid",[],"NV8"],[[2929,2929],"valid"],[[2930,2935],"valid",[],"NV8"],[[2936,2945],"disallowed"],[[2946,2947],"valid"],[[2948,2948],"disallowed"],[[2949,2954],"valid"],[[2955,2957],"disallowed"],[[2958,2960],"valid"],[[2961,2961],"disallowed"],[[2962,2965],"valid"],[[2966,2968],"disallowed"],[[2969,2970],"valid"],[[2971,2971],"disallowed"],[[2972,2972],"valid"],[[2973,2973],"disallowed"],[[2974,2975],"valid"],[[2976,2978],"disallowed"],[[2979,2980],"valid"],[[2981,2983],"disallowed"],[[2984,2986],"valid"],[[2987,2989],"disallowed"],[[2990,2997],"valid"],[[2998,2998],"valid"],[[2999,3001],"valid"],[[3002,3005],"disallowed"],[[3006,3010],"valid"],[[3011,3013],"disallowed"],[[3014,3016],"valid"],[[3017,3017],"disallowed"],[[3018,3021],"valid"],[[3022,3023],"disallowed"],[[3024,3024],"valid"],[[3025,3030],"disallowed"],[[3031,3031],"valid"],[[3032,3045],"disallowed"],[[3046,3046],"valid"],[[3047,3055],"valid"],[[3056,3058],"valid",[],"NV8"],[[3059,3066],"valid",[],"NV8"],[[3067,3071],"disallowed"],[[3072,3072],"valid"],[[3073,3075],"valid"],[[3076,3076],"disallowed"],[[3077,3084],"valid"],[[3085,3085],"disallowed"],[[3086,3088],"valid"],[[3089,3089],"disallowed"],[[3090,3112],"valid"],[[3113,3113],"disallowed"],[[3114,3123],"valid"],[[3124,3124],"valid"],[[3125,3129],"valid"],[[3130,3132],"disallowed"],[[3133,3133],"valid"],[[3134,3140],"valid"],[[3141,3141],"disallowed"],[[3142,3144],"valid"],[[3145,3145],"disallowed"],[[3146,3149],"valid"],[[3150,3156],"disallowed"],[[3157,3158],"valid"],[[3159,3159],"disallowed"],[[3160,3161],"valid"],[[3162,3162],"valid"],[[3163,3167],"disallowed"],[[3168,3169],"valid"],[[3170,3171],"valid"],[[3172,3173],"disallowed"],[[3174,3183],"valid"],[[3184,3191],"disallowed"],[[3192,3199],"valid",[],"NV8"],[[3200,3200],"disallowed"],[[3201,3201],"valid"],[[3202,3203],"valid"],[[3204,3204],"disallowed"],[[3205,3212],"valid"],[[3213,3213],"disallowed"],[[3214,3216],"valid"],[[3217,3217],"disallowed"],[[3218,3240],"valid"],[[3241,3241],"disallowed"],[[3242,3251],"valid"],[[3252,3252],"disallowed"],[[3253,3257],"valid"],[[3258,3259],"disallowed"],[[3260,3261],"valid"],[[3262,3268],"valid"],[[3269,3269],"disallowed"],[[3270,3272],"valid"],[[3273,3273],"disallowed"],[[3274,3277],"valid"],[[3278,3284],"disallowed"],[[3285,3286],"valid"],[[3287,3293],"disallowed"],[[3294,3294],"valid"],[[3295,3295],"disallowed"],[[3296,3297],"valid"],[[3298,3299],"valid"],[[3300,3301],"disallowed"],[[3302,3311],"valid"],[[3312,3312],"disallowed"],[[3313,3314],"valid"],[[3315,3328],"disallowed"],[[3329,3329],"valid"],[[3330,3331],"valid"],[[3332,3332],"disallowed"],[[3333,3340],"valid"],[[3341,3341],"disallowed"],[[3342,3344],"valid"],[[3345,3345],"disallowed"],[[3346,3368],"valid"],[[3369,3369],"valid"],[[3370,3385],"valid"],[[3386,3386],"valid"],[[3387,3388],"disallowed"],[[3389,3389],"valid"],[[3390,3395],"valid"],[[3396,3396],"valid"],[[3397,3397],"disallowed"],[[3398,3400],"valid"],[[3401,3401],"disallowed"],[[3402,3405],"valid"],[[3406,3406],"valid"],[[3407,3414],"disallowed"],[[3415,3415],"valid"],[[3416,3422],"disallowed"],[[3423,3423],"valid"],[[3424,3425],"valid"],[[3426,3427],"valid"],[[3428,3429],"disallowed"],[[3430,3439],"valid"],[[3440,3445],"valid",[],"NV8"],[[3446,3448],"disallowed"],[[3449,3449],"valid",[],"NV8"],[[3450,3455],"valid"],[[3456,3457],"disallowed"],[[3458,3459],"valid"],[[3460,3460],"disallowed"],[[3461,3478],"valid"],[[3479,3481],"disallowed"],[[3482,3505],"valid"],[[3506,3506],"disallowed"],[[3507,3515],"valid"],[[3516,3516],"disallowed"],[[3517,3517],"valid"],[[3518,3519],"disallowed"],[[3520,3526],"valid"],[[3527,3529],"disallowed"],[[3530,3530],"valid"],[[3531,3534],"disallowed"],[[3535,3540],"valid"],[[3541,3541],"disallowed"],[[3542,3542],"valid"],[[3543,3543],"disallowed"],[[3544,3551],"valid"],[[3552,3557],"disallowed"],[[3558,3567],"valid"],[[3568,3569],"disallowed"],[[3570,3571],"valid"],[[3572,3572],"valid",[],"NV8"],[[3573,3584],"disallowed"],[[3585,3634],"valid"],[[3635,3635],"mapped",[3661,3634]],[[3636,3642],"valid"],[[3643,3646],"disallowed"],[[3647,3647],"valid",[],"NV8"],[[3648,3662],"valid"],[[3663,3663],"valid",[],"NV8"],[[3664,3673],"valid"],[[3674,3675],"valid",[],"NV8"],[[3676,3712],"disallowed"],[[3713,3714],"valid"],[[3715,3715],"disallowed"],[[3716,3716],"valid"],[[3717,3718],"disallowed"],[[3719,3720],"valid"],[[3721,3721],"disallowed"],[[3722,3722],"valid"],[[3723,3724],"disallowed"],[[3725,3725],"valid"],[[3726,3731],"disallowed"],[[3732,3735],"valid"],[[3736,3736],"disallowed"],[[3737,3743],"valid"],[[3744,3744],"disallowed"],[[3745,3747],"valid"],[[3748,3748],"disallowed"],[[3749,3749],"valid"],[[3750,3750],"disallowed"],[[3751,3751],"valid"],[[3752,3753],"disallowed"],[[3754,3755],"valid"],[[3756,3756],"disallowed"],[[3757,3762],"valid"],[[3763,3763],"mapped",[3789,3762]],[[3764,3769],"valid"],[[3770,3770],"disallowed"],[[3771,3773],"valid"],[[3774,3775],"disallowed"],[[3776,3780],"valid"],[[3781,3781],"disallowed"],[[3782,3782],"valid"],[[3783,3783],"disallowed"],[[3784,3789],"valid"],[[3790,3791],"disallowed"],[[3792,3801],"valid"],[[3802,3803],"disallowed"],[[3804,3804],"mapped",[3755,3737]],[[3805,3805],"mapped",[3755,3745]],[[3806,3807],"valid"],[[3808,3839],"disallowed"],[[3840,3840],"valid"],[[3841,3850],"valid",[],"NV8"],[[3851,3851],"valid"],[[3852,3852],"mapped",[3851]],[[3853,3863],"valid",[],"NV8"],[[3864,3865],"valid"],[[3866,3871],"valid",[],"NV8"],[[3872,3881],"valid"],[[3882,3892],"valid",[],"NV8"],[[3893,3893],"valid"],[[3894,3894],"valid",[],"NV8"],[[3895,3895],"valid"],[[3896,3896],"valid",[],"NV8"],[[3897,3897],"valid"],[[3898,3901],"valid",[],"NV8"],[[3902,3906],"valid"],[[3907,3907],"mapped",[3906,4023]],[[3908,3911],"valid"],[[3912,3912],"disallowed"],[[3913,3916],"valid"],[[3917,3917],"mapped",[3916,4023]],[[3918,3921],"valid"],[[3922,3922],"mapped",[3921,4023]],[[3923,3926],"valid"],[[3927,3927],"mapped",[3926,4023]],[[3928,3931],"valid"],[[3932,3932],"mapped",[3931,4023]],[[3933,3944],"valid"],[[3945,3945],"mapped",[3904,4021]],[[3946,3946],"valid"],[[3947,3948],"valid"],[[3949,3952],"disallowed"],[[3953,3954],"valid"],[[3955,3955],"mapped",[3953,3954]],[[3956,3956],"valid"],[[3957,3957],"mapped",[3953,3956]],[[3958,3958],"mapped",[4018,3968]],[[3959,3959],"mapped",[4018,3953,3968]],[[3960,3960],"mapped",[4019,3968]],[[3961,3961],"mapped",[4019,3953,3968]],[[3962,3968],"valid"],[[3969,3969],"mapped",[3953,3968]],[[3970,3972],"valid"],[[3973,3973],"valid",[],"NV8"],[[3974,3979],"valid"],[[3980,3983],"valid"],[[3984,3986],"valid"],[[3987,3987],"mapped",[3986,4023]],[[3988,3989],"valid"],[[3990,3990],"valid"],[[3991,3991],"valid"],[[3992,3992],"disallowed"],[[3993,3996],"valid"],[[3997,3997],"mapped",[3996,4023]],[[3998,4001],"valid"],[[4002,4002],"mapped",[4001,4023]],[[4003,4006],"valid"],[[4007,4007],"mapped",[4006,4023]],[[4008,4011],"valid"],[[4012,4012],"mapped",[4011,4023]],[[4013,4013],"valid"],[[4014,4016],"valid"],[[4017,4023],"valid"],[[4024,4024],"valid"],[[4025,4025],"mapped",[3984,4021]],[[4026,4028],"valid"],[[4029,4029],"disallowed"],[[4030,4037],"valid",[],"NV8"],[[4038,4038],"valid"],[[4039,4044],"valid",[],"NV8"],[[4045,4045],"disallowed"],[[4046,4046],"valid",[],"NV8"],[[4047,4047],"valid",[],"NV8"],[[4048,4049],"valid",[],"NV8"],[[4050,4052],"valid",[],"NV8"],[[4053,4056],"valid",[],"NV8"],[[4057,4058],"valid",[],"NV8"],[[4059,4095],"disallowed"],[[4096,4129],"valid"],[[4130,4130],"valid"],[[4131,4135],"valid"],[[4136,4136],"valid"],[[4137,4138],"valid"],[[4139,4139],"valid"],[[4140,4146],"valid"],[[4147,4149],"valid"],[[4150,4153],"valid"],[[4154,4159],"valid"],[[4160,4169],"valid"],[[4170,4175],"valid",[],"NV8"],[[4176,4185],"valid"],[[4186,4249],"valid"],[[4250,4253],"valid"],[[4254,4255],"valid",[],"NV8"],[[4256,4293],"disallowed"],[[4294,4294],"disallowed"],[[4295,4295],"mapped",[11559]],[[4296,4300],"disallowed"],[[4301,4301],"mapped",[11565]],[[4302,4303],"disallowed"],[[4304,4342],"valid"],[[4343,4344],"valid"],[[4345,4346],"valid"],[[4347,4347],"valid",[],"NV8"],[[4348,4348],"mapped",[4316]],[[4349,4351],"valid"],[[4352,4441],"valid",[],"NV8"],[[4442,4446],"valid",[],"NV8"],[[4447,4448],"disallowed"],[[4449,4514],"valid",[],"NV8"],[[4515,4519],"valid",[],"NV8"],[[4520,4601],"valid",[],"NV8"],[[4602,4607],"valid",[],"NV8"],[[4608,4614],"valid"],[[4615,4615],"valid"],[[4616,4678],"valid"],[[4679,4679],"valid"],[[4680,4680],"valid"],[[4681,4681],"disallowed"],[[4682,4685],"valid"],[[4686,4687],"disallowed"],[[4688,4694],"valid"],[[4695,4695],"disallowed"],[[4696,4696],"valid"],[[4697,4697],"disallowed"],[[4698,4701],"valid"],[[4702,4703],"disallowed"],[[4704,4742],"valid"],[[4743,4743],"valid"],[[4744,4744],"valid"],[[4745,4745],"disallowed"],[[4746,4749],"valid"],[[4750,4751],"disallowed"],[[4752,4782],"valid"],[[4783,4783],"valid"],[[4784,4784],"valid"],[[4785,4785],"disallowed"],[[4786,4789],"valid"],[[4790,4791],"disallowed"],[[4792,4798],"valid"],[[4799,4799],"disallowed"],[[4800,4800],"valid"],[[4801,4801],"disallowed"],[[4802,4805],"valid"],[[4806,4807],"disallowed"],[[4808,4814],"valid"],[[4815,4815],"valid"],[[4816,4822],"valid"],[[4823,4823],"disallowed"],[[4824,4846],"valid"],[[4847,4847],"valid"],[[4848,4878],"valid"],[[4879,4879],"valid"],[[4880,4880],"valid"],[[4881,4881],"disallowed"],[[4882,4885],"valid"],[[4886,4887],"disallowed"],[[4888,4894],"valid"],[[4895,4895],"valid"],[[4896,4934],"valid"],[[4935,4935],"valid"],[[4936,4954],"valid"],[[4955,4956],"disallowed"],[[4957,4958],"valid"],[[4959,4959],"valid"],[[4960,4960],"valid",[],"NV8"],[[4961,4988],"valid",[],"NV8"],[[4989,4991],"disallowed"],[[4992,5007],"valid"],[[5008,5017],"valid",[],"NV8"],[[5018,5023],"disallowed"],[[5024,5108],"valid"],[[5109,5109],"valid"],[[5110,5111],"disallowed"],[[5112,5112],"mapped",[5104]],[[5113,5113],"mapped",[5105]],[[5114,5114],"mapped",[5106]],[[5115,5115],"mapped",[5107]],[[5116,5116],"mapped",[5108]],[[5117,5117],"mapped",[5109]],[[5118,5119],"disallowed"],[[5120,5120],"valid",[],"NV8"],[[5121,5740],"valid"],[[5741,5742],"valid",[],"NV8"],[[5743,5750],"valid"],[[5751,5759],"valid"],[[5760,5760],"disallowed"],[[5761,5786],"valid"],[[5787,5788],"valid",[],"NV8"],[[5789,5791],"disallowed"],[[5792,5866],"valid"],[[5867,5872],"valid",[],"NV8"],[[5873,5880],"valid"],[[5881,5887],"disallowed"],[[5888,5900],"valid"],[[5901,5901],"disallowed"],[[5902,5908],"valid"],[[5909,5919],"disallowed"],[[5920,5940],"valid"],[[5941,5942],"valid",[],"NV8"],[[5943,5951],"disallowed"],[[5952,5971],"valid"],[[5972,5983],"disallowed"],[[5984,5996],"valid"],[[5997,5997],"disallowed"],[[5998,6000],"valid"],[[6001,6001],"disallowed"],[[6002,6003],"valid"],[[6004,6015],"disallowed"],[[6016,6067],"valid"],[[6068,6069],"disallowed"],[[6070,6099],"valid"],[[6100,6102],"valid",[],"NV8"],[[6103,6103],"valid"],[[6104,6107],"valid",[],"NV8"],[[6108,6108],"valid"],[[6109,6109],"valid"],[[6110,6111],"disallowed"],[[6112,6121],"valid"],[[6122,6127],"disallowed"],[[6128,6137],"valid",[],"NV8"],[[6138,6143],"disallowed"],[[6144,6149],"valid",[],"NV8"],[[6150,6150],"disallowed"],[[6151,6154],"valid",[],"NV8"],[[6155,6157],"ignored"],[[6158,6158],"disallowed"],[[6159,6159],"disallowed"],[[6160,6169],"valid"],[[6170,6175],"disallowed"],[[6176,6263],"valid"],[[6264,6271],"disallowed"],[[6272,6313],"valid"],[[6314,6314],"valid"],[[6315,6319],"disallowed"],[[6320,6389],"valid"],[[6390,6399],"disallowed"],[[6400,6428],"valid"],[[6429,6430],"valid"],[[6431,6431],"disallowed"],[[6432,6443],"valid"],[[6444,6447],"disallowed"],[[6448,6459],"valid"],[[6460,6463],"disallowed"],[[6464,6464],"valid",[],"NV8"],[[6465,6467],"disallowed"],[[6468,6469],"valid",[],"NV8"],[[6470,6509],"valid"],[[6510,6511],"disallowed"],[[6512,6516],"valid"],[[6517,6527],"disallowed"],[[6528,6569],"valid"],[[6570,6571],"valid"],[[6572,6575],"disallowed"],[[6576,6601],"valid"],[[6602,6607],"disallowed"],[[6608,6617],"valid"],[[6618,6618],"valid",[],"XV8"],[[6619,6621],"disallowed"],[[6622,6623],"valid",[],"NV8"],[[6624,6655],"valid",[],"NV8"],[[6656,6683],"valid"],[[6684,6685],"disallowed"],[[6686,6687],"valid",[],"NV8"],[[6688,6750],"valid"],[[6751,6751],"disallowed"],[[6752,6780],"valid"],[[6781,6782],"disallowed"],[[6783,6793],"valid"],[[6794,6799],"disallowed"],[[6800,6809],"valid"],[[6810,6815],"disallowed"],[[6816,6822],"valid",[],"NV8"],[[6823,6823],"valid"],[[6824,6829],"valid",[],"NV8"],[[6830,6831],"disallowed"],[[6832,6845],"valid"],[[6846,6846],"valid",[],"NV8"],[[6847,6911],"disallowed"],[[6912,6987],"valid"],[[6988,6991],"disallowed"],[[6992,7001],"valid"],[[7002,7018],"valid",[],"NV8"],[[7019,7027],"valid"],[[7028,7036],"valid",[],"NV8"],[[7037,7039],"disallowed"],[[7040,7082],"valid"],[[7083,7085],"valid"],[[7086,7097],"valid"],[[7098,7103],"valid"],[[7104,7155],"valid"],[[7156,7163],"disallowed"],[[7164,7167],"valid",[],"NV8"],[[7168,7223],"valid"],[[7224,7226],"disallowed"],[[7227,7231],"valid",[],"NV8"],[[7232,7241],"valid"],[[7242,7244],"disallowed"],[[7245,7293],"valid"],[[7294,7295],"valid",[],"NV8"],[[7296,7359],"disallowed"],[[7360,7367],"valid",[],"NV8"],[[7368,7375],"disallowed"],[[7376,7378],"valid"],[[7379,7379],"valid",[],"NV8"],[[7380,7410],"valid"],[[7411,7414],"valid"],[[7415,7415],"disallowed"],[[7416,7417],"valid"],[[7418,7423],"disallowed"],[[7424,7467],"valid"],[[7468,7468],"mapped",[97]],[[7469,7469],"mapped",[230]],[[7470,7470],"mapped",[98]],[[7471,7471],"valid"],[[7472,7472],"mapped",[100]],[[7473,7473],"mapped",[101]],[[7474,7474],"mapped",[477]],[[7475,7475],"mapped",[103]],[[7476,7476],"mapped",[104]],[[7477,7477],"mapped",[105]],[[7478,7478],"mapped",[106]],[[7479,7479],"mapped",[107]],[[7480,7480],"mapped",[108]],[[7481,7481],"mapped",[109]],[[7482,7482],"mapped",[110]],[[7483,7483],"valid"],[[7484,7484],"mapped",[111]],[[7485,7485],"mapped",[547]],[[7486,7486],"mapped",[112]],[[7487,7487],"mapped",[114]],[[7488,7488],"mapped",[116]],[[7489,7489],"mapped",[117]],[[7490,7490],"mapped",[119]],[[7491,7491],"mapped",[97]],[[7492,7492],"mapped",[592]],[[7493,7493],"mapped",[593]],[[7494,7494],"mapped",[7426]],[[7495,7495],"mapped",[98]],[[7496,7496],"mapped",[100]],[[7497,7497],"mapped",[101]],[[7498,7498],"mapped",[601]],[[7499,7499],"mapped",[603]],[[7500,7500],"mapped",[604]],[[7501,7501],"mapped",[103]],[[7502,7502],"valid"],[[7503,7503],"mapped",[107]],[[7504,7504],"mapped",[109]],[[7505,7505],"mapped",[331]],[[7506,7506],"mapped",[111]],[[7507,7507],"mapped",[596]],[[7508,7508],"mapped",[7446]],[[7509,7509],"mapped",[7447]],[[7510,7510],"mapped",[112]],[[7511,7511],"mapped",[116]],[[7512,7512],"mapped",[117]],[[7513,7513],"mapped",[7453]],[[7514,7514],"mapped",[623]],[[7515,7515],"mapped",[118]],[[7516,7516],"mapped",[7461]],[[7517,7517],"mapped",[946]],[[7518,7518],"mapped",[947]],[[7519,7519],"mapped",[948]],[[7520,7520],"mapped",[966]],[[7521,7521],"mapped",[967]],[[7522,7522],"mapped",[105]],[[7523,7523],"mapped",[114]],[[7524,7524],"mapped",[117]],[[7525,7525],"mapped",[118]],[[7526,7526],"mapped",[946]],[[7527,7527],"mapped",[947]],[[7528,7528],"mapped",[961]],[[7529,7529],"mapped",[966]],[[7530,7530],"mapped",[967]],[[7531,7531],"valid"],[[7532,7543],"valid"],[[7544,7544],"mapped",[1085]],[[7545,7578],"valid"],[[7579,7579],"mapped",[594]],[[7580,7580],"mapped",[99]],[[7581,7581],"mapped",[597]],[[7582,7582],"mapped",[240]],[[7583,7583],"mapped",[604]],[[7584,7584],"mapped",[102]],[[7585,7585],"mapped",[607]],[[7586,7586],"mapped",[609]],[[7587,7587],"mapped",[613]],[[7588,7588],"mapped",[616]],[[7589,7589],"mapped",[617]],[[7590,7590],"mapped",[618]],[[7591,7591],"mapped",[7547]],[[7592,7592],"mapped",[669]],[[7593,7593],"mapped",[621]],[[7594,7594],"mapped",[7557]],[[7595,7595],"mapped",[671]],[[7596,7596],"mapped",[625]],[[7597,7597],"mapped",[624]],[[7598,7598],"mapped",[626]],[[7599,7599],"mapped",[627]],[[7600,7600],"mapped",[628]],[[7601,7601],"mapped",[629]],[[7602,7602],"mapped",[632]],[[7603,7603],"mapped",[642]],[[7604,7604],"mapped",[643]],[[7605,7605],"mapped",[427]],[[7606,7606],"mapped",[649]],[[7607,7607],"mapped",[650]],[[7608,7608],"mapped",[7452]],[[7609,7609],"mapped",[651]],[[7610,7610],"mapped",[652]],[[7611,7611],"mapped",[122]],[[7612,7612],"mapped",[656]],[[7613,7613],"mapped",[657]],[[7614,7614],"mapped",[658]],[[7615,7615],"mapped",[952]],[[7616,7619],"valid"],[[7620,7626],"valid"],[[7627,7654],"valid"],[[7655,7669],"valid"],[[7670,7675],"disallowed"],[[7676,7676],"valid"],[[7677,7677],"valid"],[[7678,7679],"valid"],[[7680,7680],"mapped",[7681]],[[7681,7681],"valid"],[[7682,7682],"mapped",[7683]],[[7683,7683],"valid"],[[7684,7684],"mapped",[7685]],[[7685,7685],"valid"],[[7686,7686],"mapped",[7687]],[[7687,7687],"valid"],[[7688,7688],"mapped",[7689]],[[7689,7689],"valid"],[[7690,7690],"mapped",[7691]],[[7691,7691],"valid"],[[7692,7692],"mapped",[7693]],[[7693,7693],"valid"],[[7694,7694],"mapped",[7695]],[[7695,7695],"valid"],[[7696,7696],"mapped",[7697]],[[7697,7697],"valid"],[[7698,7698],"mapped",[7699]],[[7699,7699],"valid"],[[7700,7700],"mapped",[7701]],[[7701,7701],"valid"],[[7702,7702],"mapped",[7703]],[[7703,7703],"valid"],[[7704,7704],"mapped",[7705]],[[7705,7705],"valid"],[[7706,7706],"mapped",[7707]],[[7707,7707],"valid"],[[7708,7708],"mapped",[7709]],[[7709,7709],"valid"],[[7710,7710],"mapped",[7711]],[[7711,7711],"valid"],[[7712,7712],"mapped",[7713]],[[7713,7713],"valid"],[[7714,7714],"mapped",[7715]],[[7715,7715],"valid"],[[7716,7716],"mapped",[7717]],[[7717,7717],"valid"],[[7718,7718],"mapped",[7719]],[[7719,7719],"valid"],[[7720,7720],"mapped",[7721]],[[7721,7721],"valid"],[[7722,7722],"mapped",[7723]],[[7723,7723],"valid"],[[7724,7724],"mapped",[7725]],[[7725,7725],"valid"],[[7726,7726],"mapped",[7727]],[[7727,7727],"valid"],[[7728,7728],"mapped",[7729]],[[7729,7729],"valid"],[[7730,7730],"mapped",[7731]],[[7731,7731],"valid"],[[7732,7732],"mapped",[7733]],[[7733,7733],"valid"],[[7734,7734],"mapped",[7735]],[[7735,7735],"valid"],[[7736,7736],"mapped",[7737]],[[7737,7737],"valid"],[[7738,7738],"mapped",[7739]],[[7739,7739],"valid"],[[7740,7740],"mapped",[7741]],[[7741,7741],"valid"],[[7742,7742],"mapped",[7743]],[[7743,7743],"valid"],[[7744,7744],"mapped",[7745]],[[7745,7745],"valid"],[[7746,7746],"mapped",[7747]],[[7747,7747],"valid"],[[7748,7748],"mapped",[7749]],[[7749,7749],"valid"],[[7750,7750],"mapped",[7751]],[[7751,7751],"valid"],[[7752,7752],"mapped",[7753]],[[7753,7753],"valid"],[[7754,7754],"mapped",[7755]],[[7755,7755],"valid"],[[7756,7756],"mapped",[7757]],[[7757,7757],"valid"],[[7758,7758],"mapped",[7759]],[[7759,7759],"valid"],[[7760,7760],"mapped",[7761]],[[7761,7761],"valid"],[[7762,7762],"mapped",[7763]],[[7763,7763],"valid"],[[7764,7764],"mapped",[7765]],[[7765,7765],"valid"],[[7766,7766],"mapped",[7767]],[[7767,7767],"valid"],[[7768,7768],"mapped",[7769]],[[7769,7769],"valid"],[[7770,7770],"mapped",[7771]],[[7771,7771],"valid"],[[7772,7772],"mapped",[7773]],[[7773,7773],"valid"],[[7774,7774],"mapped",[7775]],[[7775,7775],"valid"],[[7776,7776],"mapped",[7777]],[[7777,7777],"valid"],[[7778,7778],"mapped",[7779]],[[7779,7779],"valid"],[[7780,7780],"mapped",[7781]],[[7781,7781],"valid"],[[7782,7782],"mapped",[7783]],[[7783,7783],"valid"],[[7784,7784],"mapped",[7785]],[[7785,7785],"valid"],[[7786,7786],"mapped",[7787]],[[7787,7787],"valid"],[[7788,7788],"mapped",[7789]],[[7789,7789],"valid"],[[7790,7790],"mapped",[7791]],[[7791,7791],"valid"],[[7792,7792],"mapped",[7793]],[[7793,7793],"valid"],[[7794,7794],"mapped",[7795]],[[7795,7795],"valid"],[[7796,7796],"mapped",[7797]],[[7797,7797],"valid"],[[7798,7798],"mapped",[7799]],[[7799,7799],"valid"],[[7800,7800],"mapped",[7801]],[[7801,7801],"valid"],[[7802,7802],"mapped",[7803]],[[7803,7803],"valid"],[[7804,7804],"mapped",[7805]],[[7805,7805],"valid"],[[7806,7806],"mapped",[7807]],[[7807,7807],"valid"],[[7808,7808],"mapped",[7809]],[[7809,7809],"valid"],[[7810,7810],"mapped",[7811]],[[7811,7811],"valid"],[[7812,7812],"mapped",[7813]],[[7813,7813],"valid"],[[7814,7814],"mapped",[7815]],[[7815,7815],"valid"],[[7816,7816],"mapped",[7817]],[[7817,7817],"valid"],[[7818,7818],"mapped",[7819]],[[7819,7819],"valid"],[[7820,7820],"mapped",[7821]],[[7821,7821],"valid"],[[7822,7822],"mapped",[7823]],[[7823,7823],"valid"],[[7824,7824],"mapped",[7825]],[[7825,7825],"valid"],[[7826,7826],"mapped",[7827]],[[7827,7827],"valid"],[[7828,7828],"mapped",[7829]],[[7829,7833],"valid"],[[7834,7834],"mapped",[97,702]],[[7835,7835],"mapped",[7777]],[[7836,7837],"valid"],[[7838,7838],"mapped",[115,115]],[[7839,7839],"valid"],[[7840,7840],"mapped",[7841]],[[7841,7841],"valid"],[[7842,7842],"mapped",[7843]],[[7843,7843],"valid"],[[7844,7844],"mapped",[7845]],[[7845,7845],"valid"],[[7846,7846],"mapped",[7847]],[[7847,7847],"valid"],[[7848,7848],"mapped",[7849]],[[7849,7849],"valid"],[[7850,7850],"mapped",[7851]],[[7851,7851],"valid"],[[7852,7852],"mapped",[7853]],[[7853,7853],"valid"],[[7854,7854],"mapped",[7855]],[[7855,7855],"valid"],[[7856,7856],"mapped",[7857]],[[7857,7857],"valid"],[[7858,7858],"mapped",[7859]],[[7859,7859],"valid"],[[7860,7860],"mapped",[7861]],[[7861,7861],"valid"],[[7862,7862],"mapped",[7863]],[[7863,7863],"valid"],[[7864,7864],"mapped",[7865]],[[7865,7865],"valid"],[[7866,7866],"mapped",[7867]],[[7867,7867],"valid"],[[7868,7868],"mapped",[7869]],[[7869,7869],"valid"],[[7870,7870],"mapped",[7871]],[[7871,7871],"valid"],[[7872,7872],"mapped",[7873]],[[7873,7873],"valid"],[[7874,7874],"mapped",[7875]],[[7875,7875],"valid"],[[7876,7876],"mapped",[7877]],[[7877,7877],"valid"],[[7878,7878],"mapped",[7879]],[[7879,7879],"valid"],[[7880,7880],"mapped",[7881]],[[7881,7881],"valid"],[[7882,7882],"mapped",[7883]],[[7883,7883],"valid"],[[7884,7884],"mapped",[7885]],[[7885,7885],"valid"],[[7886,7886],"mapped",[7887]],[[7887,7887],"valid"],[[7888,7888],"mapped",[7889]],[[7889,7889],"valid"],[[7890,7890],"mapped",[7891]],[[7891,7891],"valid"],[[7892,7892],"mapped",[7893]],[[7893,7893],"valid"],[[7894,7894],"mapped",[7895]],[[7895,7895],"valid"],[[7896,7896],"mapped",[7897]],[[7897,7897],"valid"],[[7898,7898],"mapped",[7899]],[[7899,7899],"valid"],[[7900,7900],"mapped",[7901]],[[7901,7901],"valid"],[[7902,7902],"mapped",[7903]],[[7903,7903],"valid"],[[7904,7904],"mapped",[7905]],[[7905,7905],"valid"],[[7906,7906],"mapped",[7907]],[[7907,7907],"valid"],[[7908,7908],"mapped",[7909]],[[7909,7909],"valid"],[[7910,7910],"mapped",[7911]],[[7911,7911],"valid"],[[7912,7912],"mapped",[7913]],[[7913,7913],"valid"],[[7914,7914],"mapped",[7915]],[[7915,7915],"valid"],[[7916,7916],"mapped",[7917]],[[7917,7917],"valid"],[[7918,7918],"mapped",[7919]],[[7919,7919],"valid"],[[7920,7920],"mapped",[7921]],[[7921,7921],"valid"],[[7922,7922],"mapped",[7923]],[[7923,7923],"valid"],[[7924,7924],"mapped",[7925]],[[7925,7925],"valid"],[[7926,7926],"mapped",[7927]],[[7927,7927],"valid"],[[7928,7928],"mapped",[7929]],[[7929,7929],"valid"],[[7930,7930],"mapped",[7931]],[[7931,7931],"valid"],[[7932,7932],"mapped",[7933]],[[7933,7933],"valid"],[[7934,7934],"mapped",[7935]],[[7935,7935],"valid"],[[7936,7943],"valid"],[[7944,7944],"mapped",[7936]],[[7945,7945],"mapped",[7937]],[[7946,7946],"mapped",[7938]],[[7947,7947],"mapped",[7939]],[[7948,7948],"mapped",[7940]],[[7949,7949],"mapped",[7941]],[[7950,7950],"mapped",[7942]],[[7951,7951],"mapped",[7943]],[[7952,7957],"valid"],[[7958,7959],"disallowed"],[[7960,7960],"mapped",[7952]],[[7961,7961],"mapped",[7953]],[[7962,7962],"mapped",[7954]],[[7963,7963],"mapped",[7955]],[[7964,7964],"mapped",[7956]],[[7965,7965],"mapped",[7957]],[[7966,7967],"disallowed"],[[7968,7975],"valid"],[[7976,7976],"mapped",[7968]],[[7977,7977],"mapped",[7969]],[[7978,7978],"mapped",[7970]],[[7979,7979],"mapped",[7971]],[[7980,7980],"mapped",[7972]],[[7981,7981],"mapped",[7973]],[[7982,7982],"mapped",[7974]],[[7983,7983],"mapped",[7975]],[[7984,7991],"valid"],[[7992,7992],"mapped",[7984]],[[7993,7993],"mapped",[7985]],[[7994,7994],"mapped",[7986]],[[7995,7995],"mapped",[7987]],[[7996,7996],"mapped",[7988]],[[7997,7997],"mapped",[7989]],[[7998,7998],"mapped",[7990]],[[7999,7999],"mapped",[7991]],[[8000,8005],"valid"],[[8006,8007],"disallowed"],[[8008,8008],"mapped",[8000]],[[8009,8009],"mapped",[8001]],[[8010,8010],"mapped",[8002]],[[8011,8011],"mapped",[8003]],[[8012,8012],"mapped",[8004]],[[8013,8013],"mapped",[8005]],[[8014,8015],"disallowed"],[[8016,8023],"valid"],[[8024,8024],"disallowed"],[[8025,8025],"mapped",[8017]],[[8026,8026],"disallowed"],[[8027,8027],"mapped",[8019]],[[8028,8028],"disallowed"],[[8029,8029],"mapped",[8021]],[[8030,8030],"disallowed"],[[8031,8031],"mapped",[8023]],[[8032,8039],"valid"],[[8040,8040],"mapped",[8032]],[[8041,8041],"mapped",[8033]],[[8042,8042],"mapped",[8034]],[[8043,8043],"mapped",[8035]],[[8044,8044],"mapped",[8036]],[[8045,8045],"mapped",[8037]],[[8046,8046],"mapped",[8038]],[[8047,8047],"mapped",[8039]],[[8048,8048],"valid"],[[8049,8049],"mapped",[940]],[[8050,8050],"valid"],[[8051,8051],"mapped",[941]],[[8052,8052],"valid"],[[8053,8053],"mapped",[942]],[[8054,8054],"valid"],[[8055,8055],"mapped",[943]],[[8056,8056],"valid"],[[8057,8057],"mapped",[972]],[[8058,8058],"valid"],[[8059,8059],"mapped",[973]],[[8060,8060],"valid"],[[8061,8061],"mapped",[974]],[[8062,8063],"disallowed"],[[8064,8064],"mapped",[7936,953]],[[8065,8065],"mapped",[7937,953]],[[8066,8066],"mapped",[7938,953]],[[8067,8067],"mapped",[7939,953]],[[8068,8068],"mapped",[7940,953]],[[8069,8069],"mapped",[7941,953]],[[8070,8070],"mapped",[7942,953]],[[8071,8071],"mapped",[7943,953]],[[8072,8072],"mapped",[7936,953]],[[8073,8073],"mapped",[7937,953]],[[8074,8074],"mapped",[7938,953]],[[8075,8075],"mapped",[7939,953]],[[8076,8076],"mapped",[7940,953]],[[8077,8077],"mapped",[7941,953]],[[8078,8078],"mapped",[7942,953]],[[8079,8079],"mapped",[7943,953]],[[8080,8080],"mapped",[7968,953]],[[8081,8081],"mapped",[7969,953]],[[8082,8082],"mapped",[7970,953]],[[8083,8083],"mapped",[7971,953]],[[8084,8084],"mapped",[7972,953]],[[8085,8085],"mapped",[7973,953]],[[8086,8086],"mapped",[7974,953]],[[8087,8087],"mapped",[7975,953]],[[8088,8088],"mapped",[7968,953]],[[8089,8089],"mapped",[7969,953]],[[8090,8090],"mapped",[7970,953]],[[8091,8091],"mapped",[7971,953]],[[8092,8092],"mapped",[7972,953]],[[8093,8093],"mapped",[7973,953]],[[8094,8094],"mapped",[7974,953]],[[8095,8095],"mapped",[7975,953]],[[8096,8096],"mapped",[8032,953]],[[8097,8097],"mapped",[8033,953]],[[8098,8098],"mapped",[8034,953]],[[8099,8099],"mapped",[8035,953]],[[8100,8100],"mapped",[8036,953]],[[8101,8101],"mapped",[8037,953]],[[8102,8102],"mapped",[8038,953]],[[8103,8103],"mapped",[8039,953]],[[8104,8104],"mapped",[8032,953]],[[8105,8105],"mapped",[8033,953]],[[8106,8106],"mapped",[8034,953]],[[8107,8107],"mapped",[8035,953]],[[8108,8108],"mapped",[8036,953]],[[8109,8109],"mapped",[8037,953]],[[8110,8110],"mapped",[8038,953]],[[8111,8111],"mapped",[8039,953]],[[8112,8113],"valid"],[[8114,8114],"mapped",[8048,953]],[[8115,8115],"mapped",[945,953]],[[8116,8116],"mapped",[940,953]],[[8117,8117],"disallowed"],[[8118,8118],"valid"],[[8119,8119],"mapped",[8118,953]],[[8120,8120],"mapped",[8112]],[[8121,8121],"mapped",[8113]],[[8122,8122],"mapped",[8048]],[[8123,8123],"mapped",[940]],[[8124,8124],"mapped",[945,953]],[[8125,8125],"disallowed_STD3_mapped",[32,787]],[[8126,8126],"mapped",[953]],[[8127,8127],"disallowed_STD3_mapped",[32,787]],[[8128,8128],"disallowed_STD3_mapped",[32,834]],[[8129,8129],"disallowed_STD3_mapped",[32,776,834]],[[8130,8130],"mapped",[8052,953]],[[8131,8131],"mapped",[951,953]],[[8132,8132],"mapped",[942,953]],[[8133,8133],"disallowed"],[[8134,8134],"valid"],[[8135,8135],"mapped",[8134,953]],[[8136,8136],"mapped",[8050]],[[8137,8137],"mapped",[941]],[[8138,8138],"mapped",[8052]],[[8139,8139],"mapped",[942]],[[8140,8140],"mapped",[951,953]],[[8141,8141],"disallowed_STD3_mapped",[32,787,768]],[[8142,8142],"disallowed_STD3_mapped",[32,787,769]],[[8143,8143],"disallowed_STD3_mapped",[32,787,834]],[[8144,8146],"valid"],[[8147,8147],"mapped",[912]],[[8148,8149],"disallowed"],[[8150,8151],"valid"],[[8152,8152],"mapped",[8144]],[[8153,8153],"mapped",[8145]],[[8154,8154],"mapped",[8054]],[[8155,8155],"mapped",[943]],[[8156,8156],"disallowed"],[[8157,8157],"disallowed_STD3_mapped",[32,788,768]],[[8158,8158],"disallowed_STD3_mapped",[32,788,769]],[[8159,8159],"disallowed_STD3_mapped",[32,788,834]],[[8160,8162],"valid"],[[8163,8163],"mapped",[944]],[[8164,8167],"valid"],[[8168,8168],"mapped",[8160]],[[8169,8169],"mapped",[8161]],[[8170,8170],"mapped",[8058]],[[8171,8171],"mapped",[973]],[[8172,8172],"mapped",[8165]],[[8173,8173],"disallowed_STD3_mapped",[32,776,768]],[[8174,8174],"disallowed_STD3_mapped",[32,776,769]],[[8175,8175],"disallowed_STD3_mapped",[96]],[[8176,8177],"disallowed"],[[8178,8178],"mapped",[8060,953]],[[8179,8179],"mapped",[969,953]],[[8180,8180],"mapped",[974,953]],[[8181,8181],"disallowed"],[[8182,8182],"valid"],[[8183,8183],"mapped",[8182,953]],[[8184,8184],"mapped",[8056]],[[8185,8185],"mapped",[972]],[[8186,8186],"mapped",[8060]],[[8187,8187],"mapped",[974]],[[8188,8188],"mapped",[969,953]],[[8189,8189],"disallowed_STD3_mapped",[32,769]],[[8190,8190],"disallowed_STD3_mapped",[32,788]],[[8191,8191],"disallowed"],[[8192,8202],"disallowed_STD3_mapped",[32]],[[8203,8203],"ignored"],[[8204,8205],"deviation",[]],[[8206,8207],"disallowed"],[[8208,8208],"valid",[],"NV8"],[[8209,8209],"mapped",[8208]],[[8210,8214],"valid",[],"NV8"],[[8215,8215],"disallowed_STD3_mapped",[32,819]],[[8216,8227],"valid",[],"NV8"],[[8228,8230],"disallowed"],[[8231,8231],"valid",[],"NV8"],[[8232,8238],"disallowed"],[[8239,8239],"disallowed_STD3_mapped",[32]],[[8240,8242],"valid",[],"NV8"],[[8243,8243],"mapped",[8242,8242]],[[8244,8244],"mapped",[8242,8242,8242]],[[8245,8245],"valid",[],"NV8"],[[8246,8246],"mapped",[8245,8245]],[[8247,8247],"mapped",[8245,8245,8245]],[[8248,8251],"valid",[],"NV8"],[[8252,8252],"disallowed_STD3_mapped",[33,33]],[[8253,8253],"valid",[],"NV8"],[[8254,8254],"disallowed_STD3_mapped",[32,773]],[[8255,8262],"valid",[],"NV8"],[[8263,8263],"disallowed_STD3_mapped",[63,63]],[[8264,8264],"disallowed_STD3_mapped",[63,33]],[[8265,8265],"disallowed_STD3_mapped",[33,63]],[[8266,8269],"valid",[],"NV8"],[[8270,8274],"valid",[],"NV8"],[[8275,8276],"valid",[],"NV8"],[[8277,8278],"valid",[],"NV8"],[[8279,8279],"mapped",[8242,8242,8242,8242]],[[8280,8286],"valid",[],"NV8"],[[8287,8287],"disallowed_STD3_mapped",[32]],[[8288,8288],"ignored"],[[8289,8291],"disallowed"],[[8292,8292],"ignored"],[[8293,8293],"disallowed"],[[8294,8297],"disallowed"],[[8298,8303],"disallowed"],[[8304,8304],"mapped",[48]],[[8305,8305],"mapped",[105]],[[8306,8307],"disallowed"],[[8308,8308],"mapped",[52]],[[8309,8309],"mapped",[53]],[[8310,8310],"mapped",[54]],[[8311,8311],"mapped",[55]],[[8312,8312],"mapped",[56]],[[8313,8313],"mapped",[57]],[[8314,8314],"disallowed_STD3_mapped",[43]],[[8315,8315],"mapped",[8722]],[[8316,8316],"disallowed_STD3_mapped",[61]],[[8317,8317],"disallowed_STD3_mapped",[40]],[[8318,8318],"disallowed_STD3_mapped",[41]],[[8319,8319],"mapped",[110]],[[8320,8320],"mapped",[48]],[[8321,8321],"mapped",[49]],[[8322,8322],"mapped",[50]],[[8323,8323],"mapped",[51]],[[8324,8324],"mapped",[52]],[[8325,8325],"mapped",[53]],[[8326,8326],"mapped",[54]],[[8327,8327],"mapped",[55]],[[8328,8328],"mapped",[56]],[[8329,8329],"mapped",[57]],[[8330,8330],"disallowed_STD3_mapped",[43]],[[8331,8331],"mapped",[8722]],[[8332,8332],"disallowed_STD3_mapped",[61]],[[8333,8333],"disallowed_STD3_mapped",[40]],[[8334,8334],"disallowed_STD3_mapped",[41]],[[8335,8335],"disallowed"],[[8336,8336],"mapped",[97]],[[8337,8337],"mapped",[101]],[[8338,8338],"mapped",[111]],[[8339,8339],"mapped",[120]],[[8340,8340],"mapped",[601]],[[8341,8341],"mapped",[104]],[[8342,8342],"mapped",[107]],[[8343,8343],"mapped",[108]],[[8344,8344],"mapped",[109]],[[8345,8345],"mapped",[110]],[[8346,8346],"mapped",[112]],[[8347,8347],"mapped",[115]],[[8348,8348],"mapped",[116]],[[8349,8351],"disallowed"],[[8352,8359],"valid",[],"NV8"],[[8360,8360],"mapped",[114,115]],[[8361,8362],"valid",[],"NV8"],[[8363,8363],"valid",[],"NV8"],[[8364,8364],"valid",[],"NV8"],[[8365,8367],"valid",[],"NV8"],[[8368,8369],"valid",[],"NV8"],[[8370,8373],"valid",[],"NV8"],[[8374,8376],"valid",[],"NV8"],[[8377,8377],"valid",[],"NV8"],[[8378,8378],"valid",[],"NV8"],[[8379,8381],"valid",[],"NV8"],[[8382,8382],"valid",[],"NV8"],[[8383,8399],"disallowed"],[[8400,8417],"valid",[],"NV8"],[[8418,8419],"valid",[],"NV8"],[[8420,8426],"valid",[],"NV8"],[[8427,8427],"valid",[],"NV8"],[[8428,8431],"valid",[],"NV8"],[[8432,8432],"valid",[],"NV8"],[[8433,8447],"disallowed"],[[8448,8448],"disallowed_STD3_mapped",[97,47,99]],[[8449,8449],"disallowed_STD3_mapped",[97,47,115]],[[8450,8450],"mapped",[99]],[[8451,8451],"mapped",[176,99]],[[8452,8452],"valid",[],"NV8"],[[8453,8453],"disallowed_STD3_mapped",[99,47,111]],[[8454,8454],"disallowed_STD3_mapped",[99,47,117]],[[8455,8455],"mapped",[603]],[[8456,8456],"valid",[],"NV8"],[[8457,8457],"mapped",[176,102]],[[8458,8458],"mapped",[103]],[[8459,8462],"mapped",[104]],[[8463,8463],"mapped",[295]],[[8464,8465],"mapped",[105]],[[8466,8467],"mapped",[108]],[[8468,8468],"valid",[],"NV8"],[[8469,8469],"mapped",[110]],[[8470,8470],"mapped",[110,111]],[[8471,8472],"valid",[],"NV8"],[[8473,8473],"mapped",[112]],[[8474,8474],"mapped",[113]],[[8475,8477],"mapped",[114]],[[8478,8479],"valid",[],"NV8"],[[8480,8480],"mapped",[115,109]],[[8481,8481],"mapped",[116,101,108]],[[8482,8482],"mapped",[116,109]],[[8483,8483],"valid",[],"NV8"],[[8484,8484],"mapped",[122]],[[8485,8485],"valid",[],"NV8"],[[8486,8486],"mapped",[969]],[[8487,8487],"valid",[],"NV8"],[[8488,8488],"mapped",[122]],[[8489,8489],"valid",[],"NV8"],[[8490,8490],"mapped",[107]],[[8491,8491],"mapped",[229]],[[8492,8492],"mapped",[98]],[[8493,8493],"mapped",[99]],[[8494,8494],"valid",[],"NV8"],[[8495,8496],"mapped",[101]],[[8497,8497],"mapped",[102]],[[8498,8498],"disallowed"],[[8499,8499],"mapped",[109]],[[8500,8500],"mapped",[111]],[[8501,8501],"mapped",[1488]],[[8502,8502],"mapped",[1489]],[[8503,8503],"mapped",[1490]],[[8504,8504],"mapped",[1491]],[[8505,8505],"mapped",[105]],[[8506,8506],"valid",[],"NV8"],[[8507,8507],"mapped",[102,97,120]],[[8508,8508],"mapped",[960]],[[8509,8510],"mapped",[947]],[[8511,8511],"mapped",[960]],[[8512,8512],"mapped",[8721]],[[8513,8516],"valid",[],"NV8"],[[8517,8518],"mapped",[100]],[[8519,8519],"mapped",[101]],[[8520,8520],"mapped",[105]],[[8521,8521],"mapped",[106]],[[8522,8523],"valid",[],"NV8"],[[8524,8524],"valid",[],"NV8"],[[8525,8525],"valid",[],"NV8"],[[8526,8526],"valid"],[[8527,8527],"valid",[],"NV8"],[[8528,8528],"mapped",[49,8260,55]],[[8529,8529],"mapped",[49,8260,57]],[[8530,8530],"mapped",[49,8260,49,48]],[[8531,8531],"mapped",[49,8260,51]],[[8532,8532],"mapped",[50,8260,51]],[[8533,8533],"mapped",[49,8260,53]],[[8534,8534],"mapped",[50,8260,53]],[[8535,8535],"mapped",[51,8260,53]],[[8536,8536],"mapped",[52,8260,53]],[[8537,8537],"mapped",[49,8260,54]],[[8538,8538],"mapped",[53,8260,54]],[[8539,8539],"mapped",[49,8260,56]],[[8540,8540],"mapped",[51,8260,56]],[[8541,8541],"mapped",[53,8260,56]],[[8542,8542],"mapped",[55,8260,56]],[[8543,8543],"mapped",[49,8260]],[[8544,8544],"mapped",[105]],[[8545,8545],"mapped",[105,105]],[[8546,8546],"mapped",[105,105,105]],[[8547,8547],"mapped",[105,118]],[[8548,8548],"mapped",[118]],[[8549,8549],"mapped",[118,105]],[[8550,8550],"mapped",[118,105,105]],[[8551,8551],"mapped",[118,105,105,105]],[[8552,8552],"mapped",[105,120]],[[8553,8553],"mapped",[120]],[[8554,8554],"mapped",[120,105]],[[8555,8555],"mapped",[120,105,105]],[[8556,8556],"mapped",[108]],[[8557,8557],"mapped",[99]],[[8558,8558],"mapped",[100]],[[8559,8559],"mapped",[109]],[[8560,8560],"mapped",[105]],[[8561,8561],"mapped",[105,105]],[[8562,8562],"mapped",[105,105,105]],[[8563,8563],"mapped",[105,118]],[[8564,8564],"mapped",[118]],[[8565,8565],"mapped",[118,105]],[[8566,8566],"mapped",[118,105,105]],[[8567,8567],"mapped",[118,105,105,105]],[[8568,8568],"mapped",[105,120]],[[8569,8569],"mapped",[120]],[[8570,8570],"mapped",[120,105]],[[8571,8571],"mapped",[120,105,105]],[[8572,8572],"mapped",[108]],[[8573,8573],"mapped",[99]],[[8574,8574],"mapped",[100]],[[8575,8575],"mapped",[109]],[[8576,8578],"valid",[],"NV8"],[[8579,8579],"disallowed"],[[8580,8580],"valid"],[[8581,8584],"valid",[],"NV8"],[[8585,8585],"mapped",[48,8260,51]],[[8586,8587],"valid",[],"NV8"],[[8588,8591],"disallowed"],[[8592,8682],"valid",[],"NV8"],[[8683,8691],"valid",[],"NV8"],[[8692,8703],"valid",[],"NV8"],[[8704,8747],"valid",[],"NV8"],[[8748,8748],"mapped",[8747,8747]],[[8749,8749],"mapped",[8747,8747,8747]],[[8750,8750],"valid",[],"NV8"],[[8751,8751],"mapped",[8750,8750]],[[8752,8752],"mapped",[8750,8750,8750]],[[8753,8799],"valid",[],"NV8"],[[8800,8800],"disallowed_STD3_valid"],[[8801,8813],"valid",[],"NV8"],[[8814,8815],"disallowed_STD3_valid"],[[8816,8945],"valid",[],"NV8"],[[8946,8959],"valid",[],"NV8"],[[8960,8960],"valid",[],"NV8"],[[8961,8961],"valid",[],"NV8"],[[8962,9000],"valid",[],"NV8"],[[9001,9001],"mapped",[12296]],[[9002,9002],"mapped",[12297]],[[9003,9082],"valid",[],"NV8"],[[9083,9083],"valid",[],"NV8"],[[9084,9084],"valid",[],"NV8"],[[9085,9114],"valid",[],"NV8"],[[9115,9166],"valid",[],"NV8"],[[9167,9168],"valid",[],"NV8"],[[9169,9179],"valid",[],"NV8"],[[9180,9191],"valid",[],"NV8"],[[9192,9192],"valid",[],"NV8"],[[9193,9203],"valid",[],"NV8"],[[9204,9210],"valid",[],"NV8"],[[9211,9215],"disallowed"],[[9216,9252],"valid",[],"NV8"],[[9253,9254],"valid",[],"NV8"],[[9255,9279],"disallowed"],[[9280,9290],"valid",[],"NV8"],[[9291,9311],"disallowed"],[[9312,9312],"mapped",[49]],[[9313,9313],"mapped",[50]],[[9314,9314],"mapped",[51]],[[9315,9315],"mapped",[52]],[[9316,9316],"mapped",[53]],[[9317,9317],"mapped",[54]],[[9318,9318],"mapped",[55]],[[9319,9319],"mapped",[56]],[[9320,9320],"mapped",[57]],[[9321,9321],"mapped",[49,48]],[[9322,9322],"mapped",[49,49]],[[9323,9323],"mapped",[49,50]],[[9324,9324],"mapped",[49,51]],[[9325,9325],"mapped",[49,52]],[[9326,9326],"mapped",[49,53]],[[9327,9327],"mapped",[49,54]],[[9328,9328],"mapped",[49,55]],[[9329,9329],"mapped",[49,56]],[[9330,9330],"mapped",[49,57]],[[9331,9331],"mapped",[50,48]],[[9332,9332],"disallowed_STD3_mapped",[40,49,41]],[[9333,9333],"disallowed_STD3_mapped",[40,50,41]],[[9334,9334],"disallowed_STD3_mapped",[40,51,41]],[[9335,9335],"disallowed_STD3_mapped",[40,52,41]],[[9336,9336],"disallowed_STD3_mapped",[40,53,41]],[[9337,9337],"disallowed_STD3_mapped",[40,54,41]],[[9338,9338],"disallowed_STD3_mapped",[40,55,41]],[[9339,9339],"disallowed_STD3_mapped",[40,56,41]],[[9340,9340],"disallowed_STD3_mapped",[40,57,41]],[[9341,9341],"disallowed_STD3_mapped",[40,49,48,41]],[[9342,9342],"disallowed_STD3_mapped",[40,49,49,41]],[[9343,9343],"disallowed_STD3_mapped",[40,49,50,41]],[[9344,9344],"disallowed_STD3_mapped",[40,49,51,41]],[[9345,9345],"disallowed_STD3_mapped",[40,49,52,41]],[[9346,9346],"disallowed_STD3_mapped",[40,49,53,41]],[[9347,9347],"disallowed_STD3_mapped",[40,49,54,41]],[[9348,9348],"disallowed_STD3_mapped",[40,49,55,41]],[[9349,9349],"disallowed_STD3_mapped",[40,49,56,41]],[[9350,9350],"disallowed_STD3_mapped",[40,49,57,41]],[[9351,9351],"disallowed_STD3_mapped",[40,50,48,41]],[[9352,9371],"disallowed"],[[9372,9372],"disallowed_STD3_mapped",[40,97,41]],[[9373,9373],"disallowed_STD3_mapped",[40,98,41]],[[9374,9374],"disallowed_STD3_mapped",[40,99,41]],[[9375,9375],"disallowed_STD3_mapped",[40,100,41]],[[9376,9376],"disallowed_STD3_mapped",[40,101,41]],[[9377,9377],"disallowed_STD3_mapped",[40,102,41]],[[9378,9378],"disallowed_STD3_mapped",[40,103,41]],[[9379,9379],"disallowed_STD3_mapped",[40,104,41]],[[9380,9380],"disallowed_STD3_mapped",[40,105,41]],[[9381,9381],"disallowed_STD3_mapped",[40,106,41]],[[9382,9382],"disallowed_STD3_mapped",[40,107,41]],[[9383,9383],"disallowed_STD3_mapped",[40,108,41]],[[9384,9384],"disallowed_STD3_mapped",[40,109,41]],[[9385,9385],"disallowed_STD3_mapped",[40,110,41]],[[9386,9386],"disallowed_STD3_mapped",[40,111,41]],[[9387,9387],"disallowed_STD3_mapped",[40,112,41]],[[9388,9388],"disallowed_STD3_mapped",[40,113,41]],[[9389,9389],"disallowed_STD3_mapped",[40,114,41]],[[9390,9390],"disallowed_STD3_mapped",[40,115,41]],[[9391,9391],"disallowed_STD3_mapped",[40,116,41]],[[9392,9392],"disallowed_STD3_mapped",[40,117,41]],[[9393,9393],"disallowed_STD3_mapped",[40,118,41]],[[9394,9394],"disallowed_STD3_mapped",[40,119,41]],[[9395,9395],"disallowed_STD3_mapped",[40,120,41]],[[9396,9396],"disallowed_STD3_mapped",[40,121,41]],[[9397,9397],"disallowed_STD3_mapped",[40,122,41]],[[9398,9398],"mapped",[97]],[[9399,9399],"mapped",[98]],[[9400,9400],"mapped",[99]],[[9401,9401],"mapped",[100]],[[9402,9402],"mapped",[101]],[[9403,9403],"mapped",[102]],[[9404,9404],"mapped",[103]],[[9405,9405],"mapped",[104]],[[9406,9406],"mapped",[105]],[[9407,9407],"mapped",[106]],[[9408,9408],"mapped",[107]],[[9409,9409],"mapped",[108]],[[9410,9410],"mapped",[109]],[[9411,9411],"mapped",[110]],[[9412,9412],"mapped",[111]],[[9413,9413],"mapped",[112]],[[9414,9414],"mapped",[113]],[[9415,9415],"mapped",[114]],[[9416,9416],"mapped",[115]],[[9417,9417],"mapped",[116]],[[9418,9418],"mapped",[117]],[[9419,9419],"mapped",[118]],[[9420,9420],"mapped",[119]],[[9421,9421],"mapped",[120]],[[9422,9422],"mapped",[121]],[[9423,9423],"mapped",[122]],[[9424,9424],"mapped",[97]],[[9425,9425],"mapped",[98]],[[9426,9426],"mapped",[99]],[[9427,9427],"mapped",[100]],[[9428,9428],"mapped",[101]],[[9429,9429],"mapped",[102]],[[9430,9430],"mapped",[103]],[[9431,9431],"mapped",[104]],[[9432,9432],"mapped",[105]],[[9433,9433],"mapped",[106]],[[9434,9434],"mapped",[107]],[[9435,9435],"mapped",[108]],[[9436,9436],"mapped",[109]],[[9437,9437],"mapped",[110]],[[9438,9438],"mapped",[111]],[[9439,9439],"mapped",[112]],[[9440,9440],"mapped",[113]],[[9441,9441],"mapped",[114]],[[9442,9442],"mapped",[115]],[[9443,9443],"mapped",[116]],[[9444,9444],"mapped",[117]],[[9445,9445],"mapped",[118]],[[9446,9446],"mapped",[119]],[[9447,9447],"mapped",[120]],[[9448,9448],"mapped",[121]],[[9449,9449],"mapped",[122]],[[9450,9450],"mapped",[48]],[[9451,9470],"valid",[],"NV8"],[[9471,9471],"valid",[],"NV8"],[[9472,9621],"valid",[],"NV8"],[[9622,9631],"valid",[],"NV8"],[[9632,9711],"valid",[],"NV8"],[[9712,9719],"valid",[],"NV8"],[[9720,9727],"valid",[],"NV8"],[[9728,9747],"valid",[],"NV8"],[[9748,9749],"valid",[],"NV8"],[[9750,9751],"valid",[],"NV8"],[[9752,9752],"valid",[],"NV8"],[[9753,9753],"valid",[],"NV8"],[[9754,9839],"valid",[],"NV8"],[[9840,9841],"valid",[],"NV8"],[[9842,9853],"valid",[],"NV8"],[[9854,9855],"valid",[],"NV8"],[[9856,9865],"valid",[],"NV8"],[[9866,9873],"valid",[],"NV8"],[[9874,9884],"valid",[],"NV8"],[[9885,9885],"valid",[],"NV8"],[[9886,9887],"valid",[],"NV8"],[[9888,9889],"valid",[],"NV8"],[[9890,9905],"valid",[],"NV8"],[[9906,9906],"valid",[],"NV8"],[[9907,9916],"valid",[],"NV8"],[[9917,9919],"valid",[],"NV8"],[[9920,9923],"valid",[],"NV8"],[[9924,9933],"valid",[],"NV8"],[[9934,9934],"valid",[],"NV8"],[[9935,9953],"valid",[],"NV8"],[[9954,9954],"valid",[],"NV8"],[[9955,9955],"valid",[],"NV8"],[[9956,9959],"valid",[],"NV8"],[[9960,9983],"valid",[],"NV8"],[[9984,9984],"valid",[],"NV8"],[[9985,9988],"valid",[],"NV8"],[[9989,9989],"valid",[],"NV8"],[[9990,9993],"valid",[],"NV8"],[[9994,9995],"valid",[],"NV8"],[[9996,10023],"valid",[],"NV8"],[[10024,10024],"valid",[],"NV8"],[[10025,10059],"valid",[],"NV8"],[[10060,10060],"valid",[],"NV8"],[[10061,10061],"valid",[],"NV8"],[[10062,10062],"valid",[],"NV8"],[[10063,10066],"valid",[],"NV8"],[[10067,10069],"valid",[],"NV8"],[[10070,10070],"valid",[],"NV8"],[[10071,10071],"valid",[],"NV8"],[[10072,10078],"valid",[],"NV8"],[[10079,10080],"valid",[],"NV8"],[[10081,10087],"valid",[],"NV8"],[[10088,10101],"valid",[],"NV8"],[[10102,10132],"valid",[],"NV8"],[[10133,10135],"valid",[],"NV8"],[[10136,10159],"valid",[],"NV8"],[[10160,10160],"valid",[],"NV8"],[[10161,10174],"valid",[],"NV8"],[[10175,10175],"valid",[],"NV8"],[[10176,10182],"valid",[],"NV8"],[[10183,10186],"valid",[],"NV8"],[[10187,10187],"valid",[],"NV8"],[[10188,10188],"valid",[],"NV8"],[[10189,10189],"valid",[],"NV8"],[[10190,10191],"valid",[],"NV8"],[[10192,10219],"valid",[],"NV8"],[[10220,10223],"valid",[],"NV8"],[[10224,10239],"valid",[],"NV8"],[[10240,10495],"valid",[],"NV8"],[[10496,10763],"valid",[],"NV8"],[[10764,10764],"mapped",[8747,8747,8747,8747]],[[10765,10867],"valid",[],"NV8"],[[10868,10868],"disallowed_STD3_mapped",[58,58,61]],[[10869,10869],"disallowed_STD3_mapped",[61,61]],[[10870,10870],"disallowed_STD3_mapped",[61,61,61]],[[10871,10971],"valid",[],"NV8"],[[10972,10972],"mapped",[10973,824]],[[10973,11007],"valid",[],"NV8"],[[11008,11021],"valid",[],"NV8"],[[11022,11027],"valid",[],"NV8"],[[11028,11034],"valid",[],"NV8"],[[11035,11039],"valid",[],"NV8"],[[11040,11043],"valid",[],"NV8"],[[11044,11084],"valid",[],"NV8"],[[11085,11087],"valid",[],"NV8"],[[11088,11092],"valid",[],"NV8"],[[11093,11097],"valid",[],"NV8"],[[11098,11123],"valid",[],"NV8"],[[11124,11125],"disallowed"],[[11126,11157],"valid",[],"NV8"],[[11158,11159],"disallowed"],[[11160,11193],"valid",[],"NV8"],[[11194,11196],"disallowed"],[[11197,11208],"valid",[],"NV8"],[[11209,11209],"disallowed"],[[11210,11217],"valid",[],"NV8"],[[11218,11243],"disallowed"],[[11244,11247],"valid",[],"NV8"],[[11248,11263],"disallowed"],[[11264,11264],"mapped",[11312]],[[11265,11265],"mapped",[11313]],[[11266,11266],"mapped",[11314]],[[11267,11267],"mapped",[11315]],[[11268,11268],"mapped",[11316]],[[11269,11269],"mapped",[11317]],[[11270,11270],"mapped",[11318]],[[11271,11271],"mapped",[11319]],[[11272,11272],"mapped",[11320]],[[11273,11273],"mapped",[11321]],[[11274,11274],"mapped",[11322]],[[11275,11275],"mapped",[11323]],[[11276,11276],"mapped",[11324]],[[11277,11277],"mapped",[11325]],[[11278,11278],"mapped",[11326]],[[11279,11279],"mapped",[11327]],[[11280,11280],"mapped",[11328]],[[11281,11281],"mapped",[11329]],[[11282,11282],"mapped",[11330]],[[11283,11283],"mapped",[11331]],[[11284,11284],"mapped",[11332]],[[11285,11285],"mapped",[11333]],[[11286,11286],"mapped",[11334]],[[11287,11287],"mapped",[11335]],[[11288,11288],"mapped",[11336]],[[11289,11289],"mapped",[11337]],[[11290,11290],"mapped",[11338]],[[11291,11291],"mapped",[11339]],[[11292,11292],"mapped",[11340]],[[11293,11293],"mapped",[11341]],[[11294,11294],"mapped",[11342]],[[11295,11295],"mapped",[11343]],[[11296,11296],"mapped",[11344]],[[11297,11297],"mapped",[11345]],[[11298,11298],"mapped",[11346]],[[11299,11299],"mapped",[11347]],[[11300,11300],"mapped",[11348]],[[11301,11301],"mapped",[11349]],[[11302,11302],"mapped",[11350]],[[11303,11303],"mapped",[11351]],[[11304,11304],"mapped",[11352]],[[11305,11305],"mapped",[11353]],[[11306,11306],"mapped",[11354]],[[11307,11307],"mapped",[11355]],[[11308,11308],"mapped",[11356]],[[11309,11309],"mapped",[11357]],[[11310,11310],"mapped",[11358]],[[11311,11311],"disallowed"],[[11312,11358],"valid"],[[11359,11359],"disallowed"],[[11360,11360],"mapped",[11361]],[[11361,11361],"valid"],[[11362,11362],"mapped",[619]],[[11363,11363],"mapped",[7549]],[[11364,11364],"mapped",[637]],[[11365,11366],"valid"],[[11367,11367],"mapped",[11368]],[[11368,11368],"valid"],[[11369,11369],"mapped",[11370]],[[11370,11370],"valid"],[[11371,11371],"mapped",[11372]],[[11372,11372],"valid"],[[11373,11373],"mapped",[593]],[[11374,11374],"mapped",[625]],[[11375,11375],"mapped",[592]],[[11376,11376],"mapped",[594]],[[11377,11377],"valid"],[[11378,11378],"mapped",[11379]],[[11379,11379],"valid"],[[11380,11380],"valid"],[[11381,11381],"mapped",[11382]],[[11382,11383],"valid"],[[11384,11387],"valid"],[[11388,11388],"mapped",[106]],[[11389,11389],"mapped",[118]],[[11390,11390],"mapped",[575]],[[11391,11391],"mapped",[576]],[[11392,11392],"mapped",[11393]],[[11393,11393],"valid"],[[11394,11394],"mapped",[11395]],[[11395,11395],"valid"],[[11396,11396],"mapped",[11397]],[[11397,11397],"valid"],[[11398,11398],"mapped",[11399]],[[11399,11399],"valid"],[[11400,11400],"mapped",[11401]],[[11401,11401],"valid"],[[11402,11402],"mapped",[11403]],[[11403,11403],"valid"],[[11404,11404],"mapped",[11405]],[[11405,11405],"valid"],[[11406,11406],"mapped",[11407]],[[11407,11407],"valid"],[[11408,11408],"mapped",[11409]],[[11409,11409],"valid"],[[11410,11410],"mapped",[11411]],[[11411,11411],"valid"],[[11412,11412],"mapped",[11413]],[[11413,11413],"valid"],[[11414,11414],"mapped",[11415]],[[11415,11415],"valid"],[[11416,11416],"mapped",[11417]],[[11417,11417],"valid"],[[11418,11418],"mapped",[11419]],[[11419,11419],"valid"],[[11420,11420],"mapped",[11421]],[[11421,11421],"valid"],[[11422,11422],"mapped",[11423]],[[11423,11423],"valid"],[[11424,11424],"mapped",[11425]],[[11425,11425],"valid"],[[11426,11426],"mapped",[11427]],[[11427,11427],"valid"],[[11428,11428],"mapped",[11429]],[[11429,11429],"valid"],[[11430,11430],"mapped",[11431]],[[11431,11431],"valid"],[[11432,11432],"mapped",[11433]],[[11433,11433],"valid"],[[11434,11434],"mapped",[11435]],[[11435,11435],"valid"],[[11436,11436],"mapped",[11437]],[[11437,11437],"valid"],[[11438,11438],"mapped",[11439]],[[11439,11439],"valid"],[[11440,11440],"mapped",[11441]],[[11441,11441],"valid"],[[11442,11442],"mapped",[11443]],[[11443,11443],"valid"],[[11444,11444],"mapped",[11445]],[[11445,11445],"valid"],[[11446,11446],"mapped",[11447]],[[11447,11447],"valid"],[[11448,11448],"mapped",[11449]],[[11449,11449],"valid"],[[11450,11450],"mapped",[11451]],[[11451,11451],"valid"],[[11452,11452],"mapped",[11453]],[[11453,11453],"valid"],[[11454,11454],"mapped",[11455]],[[11455,11455],"valid"],[[11456,11456],"mapped",[11457]],[[11457,11457],"valid"],[[11458,11458],"mapped",[11459]],[[11459,11459],"valid"],[[11460,11460],"mapped",[11461]],[[11461,11461],"valid"],[[11462,11462],"mapped",[11463]],[[11463,11463],"valid"],[[11464,11464],"mapped",[11465]],[[11465,11465],"valid"],[[11466,11466],"mapped",[11467]],[[11467,11467],"valid"],[[11468,11468],"mapped",[11469]],[[11469,11469],"valid"],[[11470,11470],"mapped",[11471]],[[11471,11471],"valid"],[[11472,11472],"mapped",[11473]],[[11473,11473],"valid"],[[11474,11474],"mapped",[11475]],[[11475,11475],"valid"],[[11476,11476],"mapped",[11477]],[[11477,11477],"valid"],[[11478,11478],"mapped",[11479]],[[11479,11479],"valid"],[[11480,11480],"mapped",[11481]],[[11481,11481],"valid"],[[11482,11482],"mapped",[11483]],[[11483,11483],"valid"],[[11484,11484],"mapped",[11485]],[[11485,11485],"valid"],[[11486,11486],"mapped",[11487]],[[11487,11487],"valid"],[[11488,11488],"mapped",[11489]],[[11489,11489],"valid"],[[11490,11490],"mapped",[11491]],[[11491,11492],"valid"],[[11493,11498],"valid",[],"NV8"],[[11499,11499],"mapped",[11500]],[[11500,11500],"valid"],[[11501,11501],"mapped",[11502]],[[11502,11505],"valid"],[[11506,11506],"mapped",[11507]],[[11507,11507],"valid"],[[11508,11512],"disallowed"],[[11513,11519],"valid",[],"NV8"],[[11520,11557],"valid"],[[11558,11558],"disallowed"],[[11559,11559],"valid"],[[11560,11564],"disallowed"],[[11565,11565],"valid"],[[11566,11567],"disallowed"],[[11568,11621],"valid"],[[11622,11623],"valid"],[[11624,11630],"disallowed"],[[11631,11631],"mapped",[11617]],[[11632,11632],"valid",[],"NV8"],[[11633,11646],"disallowed"],[[11647,11647],"valid"],[[11648,11670],"valid"],[[11671,11679],"disallowed"],[[11680,11686],"valid"],[[11687,11687],"disallowed"],[[11688,11694],"valid"],[[11695,11695],"disallowed"],[[11696,11702],"valid"],[[11703,11703],"disallowed"],[[11704,11710],"valid"],[[11711,11711],"disallowed"],[[11712,11718],"valid"],[[11719,11719],"disallowed"],[[11720,11726],"valid"],[[11727,11727],"disallowed"],[[11728,11734],"valid"],[[11735,11735],"disallowed"],[[11736,11742],"valid"],[[11743,11743],"disallowed"],[[11744,11775],"valid"],[[11776,11799],"valid",[],"NV8"],[[11800,11803],"valid",[],"NV8"],[[11804,11805],"valid",[],"NV8"],[[11806,11822],"valid",[],"NV8"],[[11823,11823],"valid"],[[11824,11824],"valid",[],"NV8"],[[11825,11825],"valid",[],"NV8"],[[11826,11835],"valid",[],"NV8"],[[11836,11842],"valid",[],"NV8"],[[11843,11903],"disallowed"],[[11904,11929],"valid",[],"NV8"],[[11930,11930],"disallowed"],[[11931,11934],"valid",[],"NV8"],[[11935,11935],"mapped",[27597]],[[11936,12018],"valid",[],"NV8"],[[12019,12019],"mapped",[40863]],[[12020,12031],"disallowed"],[[12032,12032],"mapped",[19968]],[[12033,12033],"mapped",[20008]],[[12034,12034],"mapped",[20022]],[[12035,12035],"mapped",[20031]],[[12036,12036],"mapped",[20057]],[[12037,12037],"mapped",[20101]],[[12038,12038],"mapped",[20108]],[[12039,12039],"mapped",[20128]],[[12040,12040],"mapped",[20154]],[[12041,12041],"mapped",[20799]],[[12042,12042],"mapped",[20837]],[[12043,12043],"mapped",[20843]],[[12044,12044],"mapped",[20866]],[[12045,12045],"mapped",[20886]],[[12046,12046],"mapped",[20907]],[[12047,12047],"mapped",[20960]],[[12048,12048],"mapped",[20981]],[[12049,12049],"mapped",[20992]],[[12050,12050],"mapped",[21147]],[[12051,12051],"mapped",[21241]],[[12052,12052],"mapped",[21269]],[[12053,12053],"mapped",[21274]],[[12054,12054],"mapped",[21304]],[[12055,12055],"mapped",[21313]],[[12056,12056],"mapped",[21340]],[[12057,12057],"mapped",[21353]],[[12058,12058],"mapped",[21378]],[[12059,12059],"mapped",[21430]],[[12060,12060],"mapped",[21448]],[[12061,12061],"mapped",[21475]],[[12062,12062],"mapped",[22231]],[[12063,12063],"mapped",[22303]],[[12064,12064],"mapped",[22763]],[[12065,12065],"mapped",[22786]],[[12066,12066],"mapped",[22794]],[[12067,12067],"mapped",[22805]],[[12068,12068],"mapped",[22823]],[[12069,12069],"mapped",[22899]],[[12070,12070],"mapped",[23376]],[[12071,12071],"mapped",[23424]],[[12072,12072],"mapped",[23544]],[[12073,12073],"mapped",[23567]],[[12074,12074],"mapped",[23586]],[[12075,12075],"mapped",[23608]],[[12076,12076],"mapped",[23662]],[[12077,12077],"mapped",[23665]],[[12078,12078],"mapped",[24027]],[[12079,12079],"mapped",[24037]],[[12080,12080],"mapped",[24049]],[[12081,12081],"mapped",[24062]],[[12082,12082],"mapped",[24178]],[[12083,12083],"mapped",[24186]],[[12084,12084],"mapped",[24191]],[[12085,12085],"mapped",[24308]],[[12086,12086],"mapped",[24318]],[[12087,12087],"mapped",[24331]],[[12088,12088],"mapped",[24339]],[[12089,12089],"mapped",[24400]],[[12090,12090],"mapped",[24417]],[[12091,12091],"mapped",[24435]],[[12092,12092],"mapped",[24515]],[[12093,12093],"mapped",[25096]],[[12094,12094],"mapped",[25142]],[[12095,12095],"mapped",[25163]],[[12096,12096],"mapped",[25903]],[[12097,12097],"mapped",[25908]],[[12098,12098],"mapped",[25991]],[[12099,12099],"mapped",[26007]],[[12100,12100],"mapped",[26020]],[[12101,12101],"mapped",[26041]],[[12102,12102],"mapped",[26080]],[[12103,12103],"mapped",[26085]],[[12104,12104],"mapped",[26352]],[[12105,12105],"mapped",[26376]],[[12106,12106],"mapped",[26408]],[[12107,12107],"mapped",[27424]],[[12108,12108],"mapped",[27490]],[[12109,12109],"mapped",[27513]],[[12110,12110],"mapped",[27571]],[[12111,12111],"mapped",[27595]],[[12112,12112],"mapped",[27604]],[[12113,12113],"mapped",[27611]],[[12114,12114],"mapped",[27663]],[[12115,12115],"mapped",[27668]],[[12116,12116],"mapped",[27700]],[[12117,12117],"mapped",[28779]],[[12118,12118],"mapped",[29226]],[[12119,12119],"mapped",[29238]],[[12120,12120],"mapped",[29243]],[[12121,12121],"mapped",[29247]],[[12122,12122],"mapped",[29255]],[[12123,12123],"mapped",[29273]],[[12124,12124],"mapped",[29275]],[[12125,12125],"mapped",[29356]],[[12126,12126],"mapped",[29572]],[[12127,12127],"mapped",[29577]],[[12128,12128],"mapped",[29916]],[[12129,12129],"mapped",[29926]],[[12130,12130],"mapped",[29976]],[[12131,12131],"mapped",[29983]],[[12132,12132],"mapped",[29992]],[[12133,12133],"mapped",[30000]],[[12134,12134],"mapped",[30091]],[[12135,12135],"mapped",[30098]],[[12136,12136],"mapped",[30326]],[[12137,12137],"mapped",[30333]],[[12138,12138],"mapped",[30382]],[[12139,12139],"mapped",[30399]],[[12140,12140],"mapped",[30446]],[[12141,12141],"mapped",[30683]],[[12142,12142],"mapped",[30690]],[[12143,12143],"mapped",[30707]],[[12144,12144],"mapped",[31034]],[[12145,12145],"mapped",[31160]],[[12146,12146],"mapped",[31166]],[[12147,12147],"mapped",[31348]],[[12148,12148],"mapped",[31435]],[[12149,12149],"mapped",[31481]],[[12150,12150],"mapped",[31859]],[[12151,12151],"mapped",[31992]],[[12152,12152],"mapped",[32566]],[[12153,12153],"mapped",[32593]],[[12154,12154],"mapped",[32650]],[[12155,12155],"mapped",[32701]],[[12156,12156],"mapped",[32769]],[[12157,12157],"mapped",[32780]],[[12158,12158],"mapped",[32786]],[[12159,12159],"mapped",[32819]],[[12160,12160],"mapped",[32895]],[[12161,12161],"mapped",[32905]],[[12162,12162],"mapped",[33251]],[[12163,12163],"mapped",[33258]],[[12164,12164],"mapped",[33267]],[[12165,12165],"mapped",[33276]],[[12166,12166],"mapped",[33292]],[[12167,12167],"mapped",[33307]],[[12168,12168],"mapped",[33311]],[[12169,12169],"mapped",[33390]],[[12170,12170],"mapped",[33394]],[[12171,12171],"mapped",[33400]],[[12172,12172],"mapped",[34381]],[[12173,12173],"mapped",[34411]],[[12174,12174],"mapped",[34880]],[[12175,12175],"mapped",[34892]],[[12176,12176],"mapped",[34915]],[[12177,12177],"mapped",[35198]],[[12178,12178],"mapped",[35211]],[[12179,12179],"mapped",[35282]],[[12180,12180],"mapped",[35328]],[[12181,12181],"mapped",[35895]],[[12182,12182],"mapped",[35910]],[[12183,12183],"mapped",[35925]],[[12184,12184],"mapped",[35960]],[[12185,12185],"mapped",[35997]],[[12186,12186],"mapped",[36196]],[[12187,12187],"mapped",[36208]],[[12188,12188],"mapped",[36275]],[[12189,12189],"mapped",[36523]],[[12190,12190],"mapped",[36554]],[[12191,12191],"mapped",[36763]],[[12192,12192],"mapped",[36784]],[[12193,12193],"mapped",[36789]],[[12194,12194],"mapped",[37009]],[[12195,12195],"mapped",[37193]],[[12196,12196],"mapped",[37318]],[[12197,12197],"mapped",[37324]],[[12198,12198],"mapped",[37329]],[[12199,12199],"mapped",[38263]],[[12200,12200],"mapped",[38272]],[[12201,12201],"mapped",[38428]],[[12202,12202],"mapped",[38582]],[[12203,12203],"mapped",[38585]],[[12204,12204],"mapped",[38632]],[[12205,12205],"mapped",[38737]],[[12206,12206],"mapped",[38750]],[[12207,12207],"mapped",[38754]],[[12208,12208],"mapped",[38761]],[[12209,12209],"mapped",[38859]],[[12210,12210],"mapped",[38893]],[[12211,12211],"mapped",[38899]],[[12212,12212],"mapped",[38913]],[[12213,12213],"mapped",[39080]],[[12214,12214],"mapped",[39131]],[[12215,12215],"mapped",[39135]],[[12216,12216],"mapped",[39318]],[[12217,12217],"mapped",[39321]],[[12218,12218],"mapped",[39340]],[[12219,12219],"mapped",[39592]],[[12220,12220],"mapped",[39640]],[[12221,12221],"mapped",[39647]],[[12222,12222],"mapped",[39717]],[[12223,12223],"mapped",[39727]],[[12224,12224],"mapped",[39730]],[[12225,12225],"mapped",[39740]],[[12226,12226],"mapped",[39770]],[[12227,12227],"mapped",[40165]],[[12228,12228],"mapped",[40565]],[[12229,12229],"mapped",[40575]],[[12230,12230],"mapped",[40613]],[[12231,12231],"mapped",[40635]],[[12232,12232],"mapped",[40643]],[[12233,12233],"mapped",[40653]],[[12234,12234],"mapped",[40657]],[[12235,12235],"mapped",[40697]],[[12236,12236],"mapped",[40701]],[[12237,12237],"mapped",[40718]],[[12238,12238],"mapped",[40723]],[[12239,12239],"mapped",[40736]],[[12240,12240],"mapped",[40763]],[[12241,12241],"mapped",[40778]],[[12242,12242],"mapped",[40786]],[[12243,12243],"mapped",[40845]],[[12244,12244],"mapped",[40860]],[[12245,12245],"mapped",[40864]],[[12246,12271],"disallowed"],[[12272,12283],"disallowed"],[[12284,12287],"disallowed"],[[12288,12288],"disallowed_STD3_mapped",[32]],[[12289,12289],"valid",[],"NV8"],[[12290,12290],"mapped",[46]],[[12291,12292],"valid",[],"NV8"],[[12293,12295],"valid"],[[12296,12329],"valid",[],"NV8"],[[12330,12333],"valid"],[[12334,12341],"valid",[],"NV8"],[[12342,12342],"mapped",[12306]],[[12343,12343],"valid",[],"NV8"],[[12344,12344],"mapped",[21313]],[[12345,12345],"mapped",[21316]],[[12346,12346],"mapped",[21317]],[[12347,12347],"valid",[],"NV8"],[[12348,12348],"valid"],[[12349,12349],"valid",[],"NV8"],[[12350,12350],"valid",[],"NV8"],[[12351,12351],"valid",[],"NV8"],[[12352,12352],"disallowed"],[[12353,12436],"valid"],[[12437,12438],"valid"],[[12439,12440],"disallowed"],[[12441,12442],"valid"],[[12443,12443],"disallowed_STD3_mapped",[32,12441]],[[12444,12444],"disallowed_STD3_mapped",[32,12442]],[[12445,12446],"valid"],[[12447,12447],"mapped",[12424,12426]],[[12448,12448],"valid",[],"NV8"],[[12449,12542],"valid"],[[12543,12543],"mapped",[12467,12488]],[[12544,12548],"disallowed"],[[12549,12588],"valid"],[[12589,12589],"valid"],[[12590,12592],"disallowed"],[[12593,12593],"mapped",[4352]],[[12594,12594],"mapped",[4353]],[[12595,12595],"mapped",[4522]],[[12596,12596],"mapped",[4354]],[[12597,12597],"mapped",[4524]],[[12598,12598],"mapped",[4525]],[[12599,12599],"mapped",[4355]],[[12600,12600],"mapped",[4356]],[[12601,12601],"mapped",[4357]],[[12602,12602],"mapped",[4528]],[[12603,12603],"mapped",[4529]],[[12604,12604],"mapped",[4530]],[[12605,12605],"mapped",[4531]],[[12606,12606],"mapped",[4532]],[[12607,12607],"mapped",[4533]],[[12608,12608],"mapped",[4378]],[[12609,12609],"mapped",[4358]],[[12610,12610],"mapped",[4359]],[[12611,12611],"mapped",[4360]],[[12612,12612],"mapped",[4385]],[[12613,12613],"mapped",[4361]],[[12614,12614],"mapped",[4362]],[[12615,12615],"mapped",[4363]],[[12616,12616],"mapped",[4364]],[[12617,12617],"mapped",[4365]],[[12618,12618],"mapped",[4366]],[[12619,12619],"mapped",[4367]],[[12620,12620],"mapped",[4368]],[[12621,12621],"mapped",[4369]],[[12622,12622],"mapped",[4370]],[[12623,12623],"mapped",[4449]],[[12624,12624],"mapped",[4450]],[[12625,12625],"mapped",[4451]],[[12626,12626],"mapped",[4452]],[[12627,12627],"mapped",[4453]],[[12628,12628],"mapped",[4454]],[[12629,12629],"mapped",[4455]],[[12630,12630],"mapped",[4456]],[[12631,12631],"mapped",[4457]],[[12632,12632],"mapped",[4458]],[[12633,12633],"mapped",[4459]],[[12634,12634],"mapped",[4460]],[[12635,12635],"mapped",[4461]],[[12636,12636],"mapped",[4462]],[[12637,12637],"mapped",[4463]],[[12638,12638],"mapped",[4464]],[[12639,12639],"mapped",[4465]],[[12640,12640],"mapped",[4466]],[[12641,12641],"mapped",[4467]],[[12642,12642],"mapped",[4468]],[[12643,12643],"mapped",[4469]],[[12644,12644],"disallowed"],[[12645,12645],"mapped",[4372]],[[12646,12646],"mapped",[4373]],[[12647,12647],"mapped",[4551]],[[12648,12648],"mapped",[4552]],[[12649,12649],"mapped",[4556]],[[12650,12650],"mapped",[4558]],[[12651,12651],"mapped",[4563]],[[12652,12652],"mapped",[4567]],[[12653,12653],"mapped",[4569]],[[12654,12654],"mapped",[4380]],[[12655,12655],"mapped",[4573]],[[12656,12656],"mapped",[4575]],[[12657,12657],"mapped",[4381]],[[12658,12658],"mapped",[4382]],[[12659,12659],"mapped",[4384]],[[12660,12660],"mapped",[4386]],[[12661,12661],"mapped",[4387]],[[12662,12662],"mapped",[4391]],[[12663,12663],"mapped",[4393]],[[12664,12664],"mapped",[4395]],[[12665,12665],"mapped",[4396]],[[12666,12666],"mapped",[4397]],[[12667,12667],"mapped",[4398]],[[12668,12668],"mapped",[4399]],[[12669,12669],"mapped",[4402]],[[12670,12670],"mapped",[4406]],[[12671,12671],"mapped",[4416]],[[12672,12672],"mapped",[4423]],[[12673,12673],"mapped",[4428]],[[12674,12674],"mapped",[4593]],[[12675,12675],"mapped",[4594]],[[12676,12676],"mapped",[4439]],[[12677,12677],"mapped",[4440]],[[12678,12678],"mapped",[4441]],[[12679,12679],"mapped",[4484]],[[12680,12680],"mapped",[4485]],[[12681,12681],"mapped",[4488]],[[12682,12682],"mapped",[4497]],[[12683,12683],"mapped",[4498]],[[12684,12684],"mapped",[4500]],[[12685,12685],"mapped",[4510]],[[12686,12686],"mapped",[4513]],[[12687,12687],"disallowed"],[[12688,12689],"valid",[],"NV8"],[[12690,12690],"mapped",[19968]],[[12691,12691],"mapped",[20108]],[[12692,12692],"mapped",[19977]],[[12693,12693],"mapped",[22235]],[[12694,12694],"mapped",[19978]],[[12695,12695],"mapped",[20013]],[[12696,12696],"mapped",[19979]],[[12697,12697],"mapped",[30002]],[[12698,12698],"mapped",[20057]],[[12699,12699],"mapped",[19993]],[[12700,12700],"mapped",[19969]],[[12701,12701],"mapped",[22825]],[[12702,12702],"mapped",[22320]],[[12703,12703],"mapped",[20154]],[[12704,12727],"valid"],[[12728,12730],"valid"],[[12731,12735],"disallowed"],[[12736,12751],"valid",[],"NV8"],[[12752,12771],"valid",[],"NV8"],[[12772,12783],"disallowed"],[[12784,12799],"valid"],[[12800,12800],"disallowed_STD3_mapped",[40,4352,41]],[[12801,12801],"disallowed_STD3_mapped",[40,4354,41]],[[12802,12802],"disallowed_STD3_mapped",[40,4355,41]],[[12803,12803],"disallowed_STD3_mapped",[40,4357,41]],[[12804,12804],"disallowed_STD3_mapped",[40,4358,41]],[[12805,12805],"disallowed_STD3_mapped",[40,4359,41]],[[12806,12806],"disallowed_STD3_mapped",[40,4361,41]],[[12807,12807],"disallowed_STD3_mapped",[40,4363,41]],[[12808,12808],"disallowed_STD3_mapped",[40,4364,41]],[[12809,12809],"disallowed_STD3_mapped",[40,4366,41]],[[12810,12810],"disallowed_STD3_mapped",[40,4367,41]],[[12811,12811],"disallowed_STD3_mapped",[40,4368,41]],[[12812,12812],"disallowed_STD3_mapped",[40,4369,41]],[[12813,12813],"disallowed_STD3_mapped",[40,4370,41]],[[12814,12814],"disallowed_STD3_mapped",[40,44032,41]],[[12815,12815],"disallowed_STD3_mapped",[40,45208,41]],[[12816,12816],"disallowed_STD3_mapped",[40,45796,41]],[[12817,12817],"disallowed_STD3_mapped",[40,46972,41]],[[12818,12818],"disallowed_STD3_mapped",[40,47560,41]],[[12819,12819],"disallowed_STD3_mapped",[40,48148,41]],[[12820,12820],"disallowed_STD3_mapped",[40,49324,41]],[[12821,12821],"disallowed_STD3_mapped",[40,50500,41]],[[12822,12822],"disallowed_STD3_mapped",[40,51088,41]],[[12823,12823],"disallowed_STD3_mapped",[40,52264,41]],[[12824,12824],"disallowed_STD3_mapped",[40,52852,41]],[[12825,12825],"disallowed_STD3_mapped",[40,53440,41]],[[12826,12826],"disallowed_STD3_mapped",[40,54028,41]],[[12827,12827],"disallowed_STD3_mapped",[40,54616,41]],[[12828,12828],"disallowed_STD3_mapped",[40,51452,41]],[[12829,12829],"disallowed_STD3_mapped",[40,50724,51204,41]],[[12830,12830],"disallowed_STD3_mapped",[40,50724,54980,41]],[[12831,12831],"disallowed"],[[12832,12832],"disallowed_STD3_mapped",[40,19968,41]],[[12833,12833],"disallowed_STD3_mapped",[40,20108,41]],[[12834,12834],"disallowed_STD3_mapped",[40,19977,41]],[[12835,12835],"disallowed_STD3_mapped",[40,22235,41]],[[12836,12836],"disallowed_STD3_mapped",[40,20116,41]],[[12837,12837],"disallowed_STD3_mapped",[40,20845,41]],[[12838,12838],"disallowed_STD3_mapped",[40,19971,41]],[[12839,12839],"disallowed_STD3_mapped",[40,20843,41]],[[12840,12840],"disallowed_STD3_mapped",[40,20061,41]],[[12841,12841],"disallowed_STD3_mapped",[40,21313,41]],[[12842,12842],"disallowed_STD3_mapped",[40,26376,41]],[[12843,12843],"disallowed_STD3_mapped",[40,28779,41]],[[12844,12844],"disallowed_STD3_mapped",[40,27700,41]],[[12845,12845],"disallowed_STD3_mapped",[40,26408,41]],[[12846,12846],"disallowed_STD3_mapped",[40,37329,41]],[[12847,12847],"disallowed_STD3_mapped",[40,22303,41]],[[12848,12848],"disallowed_STD3_mapped",[40,26085,41]],[[12849,12849],"disallowed_STD3_mapped",[40,26666,41]],[[12850,12850],"disallowed_STD3_mapped",[40,26377,41]],[[12851,12851],"disallowed_STD3_mapped",[40,31038,41]],[[12852,12852],"disallowed_STD3_mapped",[40,21517,41]],[[12853,12853],"disallowed_STD3_mapped",[40,29305,41]],[[12854,12854],"disallowed_STD3_mapped",[40,36001,41]],[[12855,12855],"disallowed_STD3_mapped",[40,31069,41]],[[12856,12856],"disallowed_STD3_mapped",[40,21172,41]],[[12857,12857],"disallowed_STD3_mapped",[40,20195,41]],[[12858,12858],"disallowed_STD3_mapped",[40,21628,41]],[[12859,12859],"disallowed_STD3_mapped",[40,23398,41]],[[12860,12860],"disallowed_STD3_mapped",[40,30435,41]],[[12861,12861],"disallowed_STD3_mapped",[40,20225,41]],[[12862,12862],"disallowed_STD3_mapped",[40,36039,41]],[[12863,12863],"disallowed_STD3_mapped",[40,21332,41]],[[12864,12864],"disallowed_STD3_mapped",[40,31085,41]],[[12865,12865],"disallowed_STD3_mapped",[40,20241,41]],[[12866,12866],"disallowed_STD3_mapped",[40,33258,41]],[[12867,12867],"disallowed_STD3_mapped",[40,33267,41]],[[12868,12868],"mapped",[21839]],[[12869,12869],"mapped",[24188]],[[12870,12870],"mapped",[25991]],[[12871,12871],"mapped",[31631]],[[12872,12879],"valid",[],"NV8"],[[12880,12880],"mapped",[112,116,101]],[[12881,12881],"mapped",[50,49]],[[12882,12882],"mapped",[50,50]],[[12883,12883],"mapped",[50,51]],[[12884,12884],"mapped",[50,52]],[[12885,12885],"mapped",[50,53]],[[12886,12886],"mapped",[50,54]],[[12887,12887],"mapped",[50,55]],[[12888,12888],"mapped",[50,56]],[[12889,12889],"mapped",[50,57]],[[12890,12890],"mapped",[51,48]],[[12891,12891],"mapped",[51,49]],[[12892,12892],"mapped",[51,50]],[[12893,12893],"mapped",[51,51]],[[12894,12894],"mapped",[51,52]],[[12895,12895],"mapped",[51,53]],[[12896,12896],"mapped",[4352]],[[12897,12897],"mapped",[4354]],[[12898,12898],"mapped",[4355]],[[12899,12899],"mapped",[4357]],[[12900,12900],"mapped",[4358]],[[12901,12901],"mapped",[4359]],[[12902,12902],"mapped",[4361]],[[12903,12903],"mapped",[4363]],[[12904,12904],"mapped",[4364]],[[12905,12905],"mapped",[4366]],[[12906,12906],"mapped",[4367]],[[12907,12907],"mapped",[4368]],[[12908,12908],"mapped",[4369]],[[12909,12909],"mapped",[4370]],[[12910,12910],"mapped",[44032]],[[12911,12911],"mapped",[45208]],[[12912,12912],"mapped",[45796]],[[12913,12913],"mapped",[46972]],[[12914,12914],"mapped",[47560]],[[12915,12915],"mapped",[48148]],[[12916,12916],"mapped",[49324]],[[12917,12917],"mapped",[50500]],[[12918,12918],"mapped",[51088]],[[12919,12919],"mapped",[52264]],[[12920,12920],"mapped",[52852]],[[12921,12921],"mapped",[53440]],[[12922,12922],"mapped",[54028]],[[12923,12923],"mapped",[54616]],[[12924,12924],"mapped",[52280,44256]],[[12925,12925],"mapped",[51452,51032]],[[12926,12926],"mapped",[50864]],[[12927,12927],"valid",[],"NV8"],[[12928,12928],"mapped",[19968]],[[12929,12929],"mapped",[20108]],[[12930,12930],"mapped",[19977]],[[12931,12931],"mapped",[22235]],[[12932,12932],"mapped",[20116]],[[12933,12933],"mapped",[20845]],[[12934,12934],"mapped",[19971]],[[12935,12935],"mapped",[20843]],[[12936,12936],"mapped",[20061]],[[12937,12937],"mapped",[21313]],[[12938,12938],"mapped",[26376]],[[12939,12939],"mapped",[28779]],[[12940,12940],"mapped",[27700]],[[12941,12941],"mapped",[26408]],[[12942,12942],"mapped",[37329]],[[12943,12943],"mapped",[22303]],[[12944,12944],"mapped",[26085]],[[12945,12945],"mapped",[26666]],[[12946,12946],"mapped",[26377]],[[12947,12947],"mapped",[31038]],[[12948,12948],"mapped",[21517]],[[12949,12949],"mapped",[29305]],[[12950,12950],"mapped",[36001]],[[12951,12951],"mapped",[31069]],[[12952,12952],"mapped",[21172]],[[12953,12953],"mapped",[31192]],[[12954,12954],"mapped",[30007]],[[12955,12955],"mapped",[22899]],[[12956,12956],"mapped",[36969]],[[12957,12957],"mapped",[20778]],[[12958,12958],"mapped",[21360]],[[12959,12959],"mapped",[27880]],[[12960,12960],"mapped",[38917]],[[12961,12961],"mapped",[20241]],[[12962,12962],"mapped",[20889]],[[12963,12963],"mapped",[27491]],[[12964,12964],"mapped",[19978]],[[12965,12965],"mapped",[20013]],[[12966,12966],"mapped",[19979]],[[12967,12967],"mapped",[24038]],[[12968,12968],"mapped",[21491]],[[12969,12969],"mapped",[21307]],[[12970,12970],"mapped",[23447]],[[12971,12971],"mapped",[23398]],[[12972,12972],"mapped",[30435]],[[12973,12973],"mapped",[20225]],[[12974,12974],"mapped",[36039]],[[12975,12975],"mapped",[21332]],[[12976,12976],"mapped",[22812]],[[12977,12977],"mapped",[51,54]],[[12978,12978],"mapped",[51,55]],[[12979,12979],"mapped",[51,56]],[[12980,12980],"mapped",[51,57]],[[12981,12981],"mapped",[52,48]],[[12982,12982],"mapped",[52,49]],[[12983,12983],"mapped",[52,50]],[[12984,12984],"mapped",[52,51]],[[12985,12985],"mapped",[52,52]],[[12986,12986],"mapped",[52,53]],[[12987,12987],"mapped",[52,54]],[[12988,12988],"mapped",[52,55]],[[12989,12989],"mapped",[52,56]],[[12990,12990],"mapped",[52,57]],[[12991,12991],"mapped",[53,48]],[[12992,12992],"mapped",[49,26376]],[[12993,12993],"mapped",[50,26376]],[[12994,12994],"mapped",[51,26376]],[[12995,12995],"mapped",[52,26376]],[[12996,12996],"mapped",[53,26376]],[[12997,12997],"mapped",[54,26376]],[[12998,12998],"mapped",[55,26376]],[[12999,12999],"mapped",[56,26376]],[[13000,13000],"mapped",[57,26376]],[[13001,13001],"mapped",[49,48,26376]],[[13002,13002],"mapped",[49,49,26376]],[[13003,13003],"mapped",[49,50,26376]],[[13004,13004],"mapped",[104,103]],[[13005,13005],"mapped",[101,114,103]],[[13006,13006],"mapped",[101,118]],[[13007,13007],"mapped",[108,116,100]],[[13008,13008],"mapped",[12450]],[[13009,13009],"mapped",[12452]],[[13010,13010],"mapped",[12454]],[[13011,13011],"mapped",[12456]],[[13012,13012],"mapped",[12458]],[[13013,13013],"mapped",[12459]],[[13014,13014],"mapped",[12461]],[[13015,13015],"mapped",[12463]],[[13016,13016],"mapped",[12465]],[[13017,13017],"mapped",[12467]],[[13018,13018],"mapped",[12469]],[[13019,13019],"mapped",[12471]],[[13020,13020],"mapped",[12473]],[[13021,13021],"mapped",[12475]],[[13022,13022],"mapped",[12477]],[[13023,13023],"mapped",[12479]],[[13024,13024],"mapped",[12481]],[[13025,13025],"mapped",[12484]],[[13026,13026],"mapped",[12486]],[[13027,13027],"mapped",[12488]],[[13028,13028],"mapped",[12490]],[[13029,13029],"mapped",[12491]],[[13030,13030],"mapped",[12492]],[[13031,13031],"mapped",[12493]],[[13032,13032],"mapped",[12494]],[[13033,13033],"mapped",[12495]],[[13034,13034],"mapped",[12498]],[[13035,13035],"mapped",[12501]],[[13036,13036],"mapped",[12504]],[[13037,13037],"mapped",[12507]],[[13038,13038],"mapped",[12510]],[[13039,13039],"mapped",[12511]],[[13040,13040],"mapped",[12512]],[[13041,13041],"mapped",[12513]],[[13042,13042],"mapped",[12514]],[[13043,13043],"mapped",[12516]],[[13044,13044],"mapped",[12518]],[[13045,13045],"mapped",[12520]],[[13046,13046],"mapped",[12521]],[[13047,13047],"mapped",[12522]],[[13048,13048],"mapped",[12523]],[[13049,13049],"mapped",[12524]],[[13050,13050],"mapped",[12525]],[[13051,13051],"mapped",[12527]],[[13052,13052],"mapped",[12528]],[[13053,13053],"mapped",[12529]],[[13054,13054],"mapped",[12530]],[[13055,13055],"disallowed"],[[13056,13056],"mapped",[12450,12497,12540,12488]],[[13057,13057],"mapped",[12450,12523,12501,12449]],[[13058,13058],"mapped",[12450,12531,12506,12450]],[[13059,13059],"mapped",[12450,12540,12523]],[[13060,13060],"mapped",[12452,12491,12531,12464]],[[13061,13061],"mapped",[12452,12531,12481]],[[13062,13062],"mapped",[12454,12457,12531]],[[13063,13063],"mapped",[12456,12473,12463,12540,12489]],[[13064,13064],"mapped",[12456,12540,12459,12540]],[[13065,13065],"mapped",[12458,12531,12473]],[[13066,13066],"mapped",[12458,12540,12512]],[[13067,13067],"mapped",[12459,12452,12522]],[[13068,13068],"mapped",[12459,12521,12483,12488]],[[13069,13069],"mapped",[12459,12525,12522,12540]],[[13070,13070],"mapped",[12460,12525,12531]],[[13071,13071],"mapped",[12460,12531,12510]],[[13072,13072],"mapped",[12462,12460]],[[13073,13073],"mapped",[12462,12491,12540]],[[13074,13074],"mapped",[12461,12517,12522,12540]],[[13075,13075],"mapped",[12462,12523,12480,12540]],[[13076,13076],"mapped",[12461,12525]],[[13077,13077],"mapped",[12461,12525,12464,12521,12512]],[[13078,13078],"mapped",[12461,12525,12513,12540,12488,12523]],[[13079,13079],"mapped",[12461,12525,12527,12483,12488]],[[13080,13080],"mapped",[12464,12521,12512]],[[13081,13081],"mapped",[12464,12521,12512,12488,12531]],[[13082,13082],"mapped",[12463,12523,12476,12452,12525]],[[13083,13083],"mapped",[12463,12525,12540,12493]],[[13084,13084],"mapped",[12465,12540,12473]],[[13085,13085],"mapped",[12467,12523,12490]],[[13086,13086],"mapped",[12467,12540,12509]],[[13087,13087],"mapped",[12469,12452,12463,12523]],[[13088,13088],"mapped",[12469,12531,12481,12540,12512]],[[13089,13089],"mapped",[12471,12522,12531,12464]],[[13090,13090],"mapped",[12475,12531,12481]],[[13091,13091],"mapped",[12475,12531,12488]],[[13092,13092],"mapped",[12480,12540,12473]],[[13093,13093],"mapped",[12487,12471]],[[13094,13094],"mapped",[12489,12523]],[[13095,13095],"mapped",[12488,12531]],[[13096,13096],"mapped",[12490,12494]],[[13097,13097],"mapped",[12494,12483,12488]],[[13098,13098],"mapped",[12495,12452,12484]],[[13099,13099],"mapped",[12497,12540,12475,12531,12488]],[[13100,13100],"mapped",[12497,12540,12484]],[[13101,13101],"mapped",[12496,12540,12524,12523]],[[13102,13102],"mapped",[12500,12450,12473,12488,12523]],[[13103,13103],"mapped",[12500,12463,12523]],[[13104,13104],"mapped",[12500,12467]],[[13105,13105],"mapped",[12499,12523]],[[13106,13106],"mapped",[12501,12449,12521,12483,12489]],[[13107,13107],"mapped",[12501,12451,12540,12488]],[[13108,13108],"mapped",[12502,12483,12471,12455,12523]],[[13109,13109],"mapped",[12501,12521,12531]],[[13110,13110],"mapped",[12504,12463,12479,12540,12523]],[[13111,13111],"mapped",[12506,12477]],[[13112,13112],"mapped",[12506,12491,12498]],[[13113,13113],"mapped",[12504,12523,12484]],[[13114,13114],"mapped",[12506,12531,12473]],[[13115,13115],"mapped",[12506,12540,12472]],[[13116,13116],"mapped",[12505,12540,12479]],[[13117,13117],"mapped",[12509,12452,12531,12488]],[[13118,13118],"mapped",[12508,12523,12488]],[[13119,13119],"mapped",[12507,12531]],[[13120,13120],"mapped",[12509,12531,12489]],[[13121,13121],"mapped",[12507,12540,12523]],[[13122,13122],"mapped",[12507,12540,12531]],[[13123,13123],"mapped",[12510,12452,12463,12525]],[[13124,13124],"mapped",[12510,12452,12523]],[[13125,13125],"mapped",[12510,12483,12495]],[[13126,13126],"mapped",[12510,12523,12463]],[[13127,13127],"mapped",[12510,12531,12471,12519,12531]],[[13128,13128],"mapped",[12511,12463,12525,12531]],[[13129,13129],"mapped",[12511,12522]],[[13130,13130],"mapped",[12511,12522,12496,12540,12523]],[[13131,13131],"mapped",[12513,12460]],[[13132,13132],"mapped",[12513,12460,12488,12531]],[[13133,13133],"mapped",[12513,12540,12488,12523]],[[13134,13134],"mapped",[12516,12540,12489]],[[13135,13135],"mapped",[12516,12540,12523]],[[13136,13136],"mapped",[12518,12450,12531]],[[13137,13137],"mapped",[12522,12483,12488,12523]],[[13138,13138],"mapped",[12522,12521]],[[13139,13139],"mapped",[12523,12500,12540]],[[13140,13140],"mapped",[12523,12540,12502,12523]],[[13141,13141],"mapped",[12524,12512]],[[13142,13142],"mapped",[12524,12531,12488,12466,12531]],[[13143,13143],"mapped",[12527,12483,12488]],[[13144,13144],"mapped",[48,28857]],[[13145,13145],"mapped",[49,28857]],[[13146,13146],"mapped",[50,28857]],[[13147,13147],"mapped",[51,28857]],[[13148,13148],"mapped",[52,28857]],[[13149,13149],"mapped",[53,28857]],[[13150,13150],"mapped",[54,28857]],[[13151,13151],"mapped",[55,28857]],[[13152,13152],"mapped",[56,28857]],[[13153,13153],"mapped",[57,28857]],[[13154,13154],"mapped",[49,48,28857]],[[13155,13155],"mapped",[49,49,28857]],[[13156,13156],"mapped",[49,50,28857]],[[13157,13157],"mapped",[49,51,28857]],[[13158,13158],"mapped",[49,52,28857]],[[13159,13159],"mapped",[49,53,28857]],[[13160,13160],"mapped",[49,54,28857]],[[13161,13161],"mapped",[49,55,28857]],[[13162,13162],"mapped",[49,56,28857]],[[13163,13163],"mapped",[49,57,28857]],[[13164,13164],"mapped",[50,48,28857]],[[13165,13165],"mapped",[50,49,28857]],[[13166,13166],"mapped",[50,50,28857]],[[13167,13167],"mapped",[50,51,28857]],[[13168,13168],"mapped",[50,52,28857]],[[13169,13169],"mapped",[104,112,97]],[[13170,13170],"mapped",[100,97]],[[13171,13171],"mapped",[97,117]],[[13172,13172],"mapped",[98,97,114]],[[13173,13173],"mapped",[111,118]],[[13174,13174],"mapped",[112,99]],[[13175,13175],"mapped",[100,109]],[[13176,13176],"mapped",[100,109,50]],[[13177,13177],"mapped",[100,109,51]],[[13178,13178],"mapped",[105,117]],[[13179,13179],"mapped",[24179,25104]],[[13180,13180],"mapped",[26157,21644]],[[13181,13181],"mapped",[22823,27491]],[[13182,13182],"mapped",[26126,27835]],[[13183,13183],"mapped",[26666,24335,20250,31038]],[[13184,13184],"mapped",[112,97]],[[13185,13185],"mapped",[110,97]],[[13186,13186],"mapped",[956,97]],[[13187,13187],"mapped",[109,97]],[[13188,13188],"mapped",[107,97]],[[13189,13189],"mapped",[107,98]],[[13190,13190],"mapped",[109,98]],[[13191,13191],"mapped",[103,98]],[[13192,13192],"mapped",[99,97,108]],[[13193,13193],"mapped",[107,99,97,108]],[[13194,13194],"mapped",[112,102]],[[13195,13195],"mapped",[110,102]],[[13196,13196],"mapped",[956,102]],[[13197,13197],"mapped",[956,103]],[[13198,13198],"mapped",[109,103]],[[13199,13199],"mapped",[107,103]],[[13200,13200],"mapped",[104,122]],[[13201,13201],"mapped",[107,104,122]],[[13202,13202],"mapped",[109,104,122]],[[13203,13203],"mapped",[103,104,122]],[[13204,13204],"mapped",[116,104,122]],[[13205,13205],"mapped",[956,108]],[[13206,13206],"mapped",[109,108]],[[13207,13207],"mapped",[100,108]],[[13208,13208],"mapped",[107,108]],[[13209,13209],"mapped",[102,109]],[[13210,13210],"mapped",[110,109]],[[13211,13211],"mapped",[956,109]],[[13212,13212],"mapped",[109,109]],[[13213,13213],"mapped",[99,109]],[[13214,13214],"mapped",[107,109]],[[13215,13215],"mapped",[109,109,50]],[[13216,13216],"mapped",[99,109,50]],[[13217,13217],"mapped",[109,50]],[[13218,13218],"mapped",[107,109,50]],[[13219,13219],"mapped",[109,109,51]],[[13220,13220],"mapped",[99,109,51]],[[13221,13221],"mapped",[109,51]],[[13222,13222],"mapped",[107,109,51]],[[13223,13223],"mapped",[109,8725,115]],[[13224,13224],"mapped",[109,8725,115,50]],[[13225,13225],"mapped",[112,97]],[[13226,13226],"mapped",[107,112,97]],[[13227,13227],"mapped",[109,112,97]],[[13228,13228],"mapped",[103,112,97]],[[13229,13229],"mapped",[114,97,100]],[[13230,13230],"mapped",[114,97,100,8725,115]],[[13231,13231],"mapped",[114,97,100,8725,115,50]],[[13232,13232],"mapped",[112,115]],[[13233,13233],"mapped",[110,115]],[[13234,13234],"mapped",[956,115]],[[13235,13235],"mapped",[109,115]],[[13236,13236],"mapped",[112,118]],[[13237,13237],"mapped",[110,118]],[[13238,13238],"mapped",[956,118]],[[13239,13239],"mapped",[109,118]],[[13240,13240],"mapped",[107,118]],[[13241,13241],"mapped",[109,118]],[[13242,13242],"mapped",[112,119]],[[13243,13243],"mapped",[110,119]],[[13244,13244],"mapped",[956,119]],[[13245,13245],"mapped",[109,119]],[[13246,13246],"mapped",[107,119]],[[13247,13247],"mapped",[109,119]],[[13248,13248],"mapped",[107,969]],[[13249,13249],"mapped",[109,969]],[[13250,13250],"disallowed"],[[13251,13251],"mapped",[98,113]],[[13252,13252],"mapped",[99,99]],[[13253,13253],"mapped",[99,100]],[[13254,13254],"mapped",[99,8725,107,103]],[[13255,13255],"disallowed"],[[13256,13256],"mapped",[100,98]],[[13257,13257],"mapped",[103,121]],[[13258,13258],"mapped",[104,97]],[[13259,13259],"mapped",[104,112]],[[13260,13260],"mapped",[105,110]],[[13261,13261],"mapped",[107,107]],[[13262,13262],"mapped",[107,109]],[[13263,13263],"mapped",[107,116]],[[13264,13264],"mapped",[108,109]],[[13265,13265],"mapped",[108,110]],[[13266,13266],"mapped",[108,111,103]],[[13267,13267],"mapped",[108,120]],[[13268,13268],"mapped",[109,98]],[[13269,13269],"mapped",[109,105,108]],[[13270,13270],"mapped",[109,111,108]],[[13271,13271],"mapped",[112,104]],[[13272,13272],"disallowed"],[[13273,13273],"mapped",[112,112,109]],[[13274,13274],"mapped",[112,114]],[[13275,13275],"mapped",[115,114]],[[13276,13276],"mapped",[115,118]],[[13277,13277],"mapped",[119,98]],[[13278,13278],"mapped",[118,8725,109]],[[13279,13279],"mapped",[97,8725,109]],[[13280,13280],"mapped",[49,26085]],[[13281,13281],"mapped",[50,26085]],[[13282,13282],"mapped",[51,26085]],[[13283,13283],"mapped",[52,26085]],[[13284,13284],"mapped",[53,26085]],[[13285,13285],"mapped",[54,26085]],[[13286,13286],"mapped",[55,26085]],[[13287,13287],"mapped",[56,26085]],[[13288,13288],"mapped",[57,26085]],[[13289,13289],"mapped",[49,48,26085]],[[13290,13290],"mapped",[49,49,26085]],[[13291,13291],"mapped",[49,50,26085]],[[13292,13292],"mapped",[49,51,26085]],[[13293,13293],"mapped",[49,52,26085]],[[13294,13294],"mapped",[49,53,26085]],[[13295,13295],"mapped",[49,54,26085]],[[13296,13296],"mapped",[49,55,26085]],[[13297,13297],"mapped",[49,56,26085]],[[13298,13298],"mapped",[49,57,26085]],[[13299,13299],"mapped",[50,48,26085]],[[13300,13300],"mapped",[50,49,26085]],[[13301,13301],"mapped",[50,50,26085]],[[13302,13302],"mapped",[50,51,26085]],[[13303,13303],"mapped",[50,52,26085]],[[13304,13304],"mapped",[50,53,26085]],[[13305,13305],"mapped",[50,54,26085]],[[13306,13306],"mapped",[50,55,26085]],[[13307,13307],"mapped",[50,56,26085]],[[13308,13308],"mapped",[50,57,26085]],[[13309,13309],"mapped",[51,48,26085]],[[13310,13310],"mapped",[51,49,26085]],[[13311,13311],"mapped",[103,97,108]],[[13312,19893],"valid"],[[19894,19903],"disallowed"],[[19904,19967],"valid",[],"NV8"],[[19968,40869],"valid"],[[40870,40891],"valid"],[[40892,40899],"valid"],[[40900,40907],"valid"],[[40908,40908],"valid"],[[40909,40917],"valid"],[[40918,40959],"disallowed"],[[40960,42124],"valid"],[[42125,42127],"disallowed"],[[42128,42145],"valid",[],"NV8"],[[42146,42147],"valid",[],"NV8"],[[42148,42163],"valid",[],"NV8"],[[42164,42164],"valid",[],"NV8"],[[42165,42176],"valid",[],"NV8"],[[42177,42177],"valid",[],"NV8"],[[42178,42180],"valid",[],"NV8"],[[42181,42181],"valid",[],"NV8"],[[42182,42182],"valid",[],"NV8"],[[42183,42191],"disallowed"],[[42192,42237],"valid"],[[42238,42239],"valid",[],"NV8"],[[42240,42508],"valid"],[[42509,42511],"valid",[],"NV8"],[[42512,42539],"valid"],[[42540,42559],"disallowed"],[[42560,42560],"mapped",[42561]],[[42561,42561],"valid"],[[42562,42562],"mapped",[42563]],[[42563,42563],"valid"],[[42564,42564],"mapped",[42565]],[[42565,42565],"valid"],[[42566,42566],"mapped",[42567]],[[42567,42567],"valid"],[[42568,42568],"mapped",[42569]],[[42569,42569],"valid"],[[42570,42570],"mapped",[42571]],[[42571,42571],"valid"],[[42572,42572],"mapped",[42573]],[[42573,42573],"valid"],[[42574,42574],"mapped",[42575]],[[42575,42575],"valid"],[[42576,42576],"mapped",[42577]],[[42577,42577],"valid"],[[42578,42578],"mapped",[42579]],[[42579,42579],"valid"],[[42580,42580],"mapped",[42581]],[[42581,42581],"valid"],[[42582,42582],"mapped",[42583]],[[42583,42583],"valid"],[[42584,42584],"mapped",[42585]],[[42585,42585],"valid"],[[42586,42586],"mapped",[42587]],[[42587,42587],"valid"],[[42588,42588],"mapped",[42589]],[[42589,42589],"valid"],[[42590,42590],"mapped",[42591]],[[42591,42591],"valid"],[[42592,42592],"mapped",[42593]],[[42593,42593],"valid"],[[42594,42594],"mapped",[42595]],[[42595,42595],"valid"],[[42596,42596],"mapped",[42597]],[[42597,42597],"valid"],[[42598,42598],"mapped",[42599]],[[42599,42599],"valid"],[[42600,42600],"mapped",[42601]],[[42601,42601],"valid"],[[42602,42602],"mapped",[42603]],[[42603,42603],"valid"],[[42604,42604],"mapped",[42605]],[[42605,42607],"valid"],[[42608,42611],"valid",[],"NV8"],[[42612,42619],"valid"],[[42620,42621],"valid"],[[42622,42622],"valid",[],"NV8"],[[42623,42623],"valid"],[[42624,42624],"mapped",[42625]],[[42625,42625],"valid"],[[42626,42626],"mapped",[42627]],[[42627,42627],"valid"],[[42628,42628],"mapped",[42629]],[[42629,42629],"valid"],[[42630,42630],"mapped",[42631]],[[42631,42631],"valid"],[[42632,42632],"mapped",[42633]],[[42633,42633],"valid"],[[42634,42634],"mapped",[42635]],[[42635,42635],"valid"],[[42636,42636],"mapped",[42637]],[[42637,42637],"valid"],[[42638,42638],"mapped",[42639]],[[42639,42639],"valid"],[[42640,42640],"mapped",[42641]],[[42641,42641],"valid"],[[42642,42642],"mapped",[42643]],[[42643,42643],"valid"],[[42644,42644],"mapped",[42645]],[[42645,42645],"valid"],[[42646,42646],"mapped",[42647]],[[42647,42647],"valid"],[[42648,42648],"mapped",[42649]],[[42649,42649],"valid"],[[42650,42650],"mapped",[42651]],[[42651,42651],"valid"],[[42652,42652],"mapped",[1098]],[[42653,42653],"mapped",[1100]],[[42654,42654],"valid"],[[42655,42655],"valid"],[[42656,42725],"valid"],[[42726,42735],"valid",[],"NV8"],[[42736,42737],"valid"],[[42738,42743],"valid",[],"NV8"],[[42744,42751],"disallowed"],[[42752,42774],"valid",[],"NV8"],[[42775,42778],"valid"],[[42779,42783],"valid"],[[42784,42785],"valid",[],"NV8"],[[42786,42786],"mapped",[42787]],[[42787,42787],"valid"],[[42788,42788],"mapped",[42789]],[[42789,42789],"valid"],[[42790,42790],"mapped",[42791]],[[42791,42791],"valid"],[[42792,42792],"mapped",[42793]],[[42793,42793],"valid"],[[42794,42794],"mapped",[42795]],[[42795,42795],"valid"],[[42796,42796],"mapped",[42797]],[[42797,42797],"valid"],[[42798,42798],"mapped",[42799]],[[42799,42801],"valid"],[[42802,42802],"mapped",[42803]],[[42803,42803],"valid"],[[42804,42804],"mapped",[42805]],[[42805,42805],"valid"],[[42806,42806],"mapped",[42807]],[[42807,42807],"valid"],[[42808,42808],"mapped",[42809]],[[42809,42809],"valid"],[[42810,42810],"mapped",[42811]],[[42811,42811],"valid"],[[42812,42812],"mapped",[42813]],[[42813,42813],"valid"],[[42814,42814],"mapped",[42815]],[[42815,42815],"valid"],[[42816,42816],"mapped",[42817]],[[42817,42817],"valid"],[[42818,42818],"mapped",[42819]],[[42819,42819],"valid"],[[42820,42820],"mapped",[42821]],[[42821,42821],"valid"],[[42822,42822],"mapped",[42823]],[[42823,42823],"valid"],[[42824,42824],"mapped",[42825]],[[42825,42825],"valid"],[[42826,42826],"mapped",[42827]],[[42827,42827],"valid"],[[42828,42828],"mapped",[42829]],[[42829,42829],"valid"],[[42830,42830],"mapped",[42831]],[[42831,42831],"valid"],[[42832,42832],"mapped",[42833]],[[42833,42833],"valid"],[[42834,42834],"mapped",[42835]],[[42835,42835],"valid"],[[42836,42836],"mapped",[42837]],[[42837,42837],"valid"],[[42838,42838],"mapped",[42839]],[[42839,42839],"valid"],[[42840,42840],"mapped",[42841]],[[42841,42841],"valid"],[[42842,42842],"mapped",[42843]],[[42843,42843],"valid"],[[42844,42844],"mapped",[42845]],[[42845,42845],"valid"],[[42846,42846],"mapped",[42847]],[[42847,42847],"valid"],[[42848,42848],"mapped",[42849]],[[42849,42849],"valid"],[[42850,42850],"mapped",[42851]],[[42851,42851],"valid"],[[42852,42852],"mapped",[42853]],[[42853,42853],"valid"],[[42854,42854],"mapped",[42855]],[[42855,42855],"valid"],[[42856,42856],"mapped",[42857]],[[42857,42857],"valid"],[[42858,42858],"mapped",[42859]],[[42859,42859],"valid"],[[42860,42860],"mapped",[42861]],[[42861,42861],"valid"],[[42862,42862],"mapped",[42863]],[[42863,42863],"valid"],[[42864,42864],"mapped",[42863]],[[42865,42872],"valid"],[[42873,42873],"mapped",[42874]],[[42874,42874],"valid"],[[42875,42875],"mapped",[42876]],[[42876,42876],"valid"],[[42877,42877],"mapped",[7545]],[[42878,42878],"mapped",[42879]],[[42879,42879],"valid"],[[42880,42880],"mapped",[42881]],[[42881,42881],"valid"],[[42882,42882],"mapped",[42883]],[[42883,42883],"valid"],[[42884,42884],"mapped",[42885]],[[42885,42885],"valid"],[[42886,42886],"mapped",[42887]],[[42887,42888],"valid"],[[42889,42890],"valid",[],"NV8"],[[42891,42891],"mapped",[42892]],[[42892,42892],"valid"],[[42893,42893],"mapped",[613]],[[42894,42894],"valid"],[[42895,42895],"valid"],[[42896,42896],"mapped",[42897]],[[42897,42897],"valid"],[[42898,42898],"mapped",[42899]],[[42899,42899],"valid"],[[42900,42901],"valid"],[[42902,42902],"mapped",[42903]],[[42903,42903],"valid"],[[42904,42904],"mapped",[42905]],[[42905,42905],"valid"],[[42906,42906],"mapped",[42907]],[[42907,42907],"valid"],[[42908,42908],"mapped",[42909]],[[42909,42909],"valid"],[[42910,42910],"mapped",[42911]],[[42911,42911],"valid"],[[42912,42912],"mapped",[42913]],[[42913,42913],"valid"],[[42914,42914],"mapped",[42915]],[[42915,42915],"valid"],[[42916,42916],"mapped",[42917]],[[42917,42917],"valid"],[[42918,42918],"mapped",[42919]],[[42919,42919],"valid"],[[42920,42920],"mapped",[42921]],[[42921,42921],"valid"],[[42922,42922],"mapped",[614]],[[42923,42923],"mapped",[604]],[[42924,42924],"mapped",[609]],[[42925,42925],"mapped",[620]],[[42926,42927],"disallowed"],[[42928,42928],"mapped",[670]],[[42929,42929],"mapped",[647]],[[42930,42930],"mapped",[669]],[[42931,42931],"mapped",[43859]],[[42932,42932],"mapped",[42933]],[[42933,42933],"valid"],[[42934,42934],"mapped",[42935]],[[42935,42935],"valid"],[[42936,42998],"disallowed"],[[42999,42999],"valid"],[[43000,43000],"mapped",[295]],[[43001,43001],"mapped",[339]],[[43002,43002],"valid"],[[43003,43007],"valid"],[[43008,43047],"valid"],[[43048,43051],"valid",[],"NV8"],[[43052,43055],"disallowed"],[[43056,43065],"valid",[],"NV8"],[[43066,43071],"disallowed"],[[43072,43123],"valid"],[[43124,43127],"valid",[],"NV8"],[[43128,43135],"disallowed"],[[43136,43204],"valid"],[[43205,43213],"disallowed"],[[43214,43215],"valid",[],"NV8"],[[43216,43225],"valid"],[[43226,43231],"disallowed"],[[43232,43255],"valid"],[[43256,43258],"valid",[],"NV8"],[[43259,43259],"valid"],[[43260,43260],"valid",[],"NV8"],[[43261,43261],"valid"],[[43262,43263],"disallowed"],[[43264,43309],"valid"],[[43310,43311],"valid",[],"NV8"],[[43312,43347],"valid"],[[43348,43358],"disallowed"],[[43359,43359],"valid",[],"NV8"],[[43360,43388],"valid",[],"NV8"],[[43389,43391],"disallowed"],[[43392,43456],"valid"],[[43457,43469],"valid",[],"NV8"],[[43470,43470],"disallowed"],[[43471,43481],"valid"],[[43482,43485],"disallowed"],[[43486,43487],"valid",[],"NV8"],[[43488,43518],"valid"],[[43519,43519],"disallowed"],[[43520,43574],"valid"],[[43575,43583],"disallowed"],[[43584,43597],"valid"],[[43598,43599],"disallowed"],[[43600,43609],"valid"],[[43610,43611],"disallowed"],[[43612,43615],"valid",[],"NV8"],[[43616,43638],"valid"],[[43639,43641],"valid",[],"NV8"],[[43642,43643],"valid"],[[43644,43647],"valid"],[[43648,43714],"valid"],[[43715,43738],"disallowed"],[[43739,43741],"valid"],[[43742,43743],"valid",[],"NV8"],[[43744,43759],"valid"],[[43760,43761],"valid",[],"NV8"],[[43762,43766],"valid"],[[43767,43776],"disallowed"],[[43777,43782],"valid"],[[43783,43784],"disallowed"],[[43785,43790],"valid"],[[43791,43792],"disallowed"],[[43793,43798],"valid"],[[43799,43807],"disallowed"],[[43808,43814],"valid"],[[43815,43815],"disallowed"],[[43816,43822],"valid"],[[43823,43823],"disallowed"],[[43824,43866],"valid"],[[43867,43867],"valid",[],"NV8"],[[43868,43868],"mapped",[42791]],[[43869,43869],"mapped",[43831]],[[43870,43870],"mapped",[619]],[[43871,43871],"mapped",[43858]],[[43872,43875],"valid"],[[43876,43877],"valid"],[[43878,43887],"disallowed"],[[43888,43888],"mapped",[5024]],[[43889,43889],"mapped",[5025]],[[43890,43890],"mapped",[5026]],[[43891,43891],"mapped",[5027]],[[43892,43892],"mapped",[5028]],[[43893,43893],"mapped",[5029]],[[43894,43894],"mapped",[5030]],[[43895,43895],"mapped",[5031]],[[43896,43896],"mapped",[5032]],[[43897,43897],"mapped",[5033]],[[43898,43898],"mapped",[5034]],[[43899,43899],"mapped",[5035]],[[43900,43900],"mapped",[5036]],[[43901,43901],"mapped",[5037]],[[43902,43902],"mapped",[5038]],[[43903,43903],"mapped",[5039]],[[43904,43904],"mapped",[5040]],[[43905,43905],"mapped",[5041]],[[43906,43906],"mapped",[5042]],[[43907,43907],"mapped",[5043]],[[43908,43908],"mapped",[5044]],[[43909,43909],"mapped",[5045]],[[43910,43910],"mapped",[5046]],[[43911,43911],"mapped",[5047]],[[43912,43912],"mapped",[5048]],[[43913,43913],"mapped",[5049]],[[43914,43914],"mapped",[5050]],[[43915,43915],"mapped",[5051]],[[43916,43916],"mapped",[5052]],[[43917,43917],"mapped",[5053]],[[43918,43918],"mapped",[5054]],[[43919,43919],"mapped",[5055]],[[43920,43920],"mapped",[5056]],[[43921,43921],"mapped",[5057]],[[43922,43922],"mapped",[5058]],[[43923,43923],"mapped",[5059]],[[43924,43924],"mapped",[5060]],[[43925,43925],"mapped",[5061]],[[43926,43926],"mapped",[5062]],[[43927,43927],"mapped",[5063]],[[43928,43928],"mapped",[5064]],[[43929,43929],"mapped",[5065]],[[43930,43930],"mapped",[5066]],[[43931,43931],"mapped",[5067]],[[43932,43932],"mapped",[5068]],[[43933,43933],"mapped",[5069]],[[43934,43934],"mapped",[5070]],[[43935,43935],"mapped",[5071]],[[43936,43936],"mapped",[5072]],[[43937,43937],"mapped",[5073]],[[43938,43938],"mapped",[5074]],[[43939,43939],"mapped",[5075]],[[43940,43940],"mapped",[5076]],[[43941,43941],"mapped",[5077]],[[43942,43942],"mapped",[5078]],[[43943,43943],"mapped",[5079]],[[43944,43944],"mapped",[5080]],[[43945,43945],"mapped",[5081]],[[43946,43946],"mapped",[5082]],[[43947,43947],"mapped",[5083]],[[43948,43948],"mapped",[5084]],[[43949,43949],"mapped",[5085]],[[43950,43950],"mapped",[5086]],[[43951,43951],"mapped",[5087]],[[43952,43952],"mapped",[5088]],[[43953,43953],"mapped",[5089]],[[43954,43954],"mapped",[5090]],[[43955,43955],"mapped",[5091]],[[43956,43956],"mapped",[5092]],[[43957,43957],"mapped",[5093]],[[43958,43958],"mapped",[5094]],[[43959,43959],"mapped",[5095]],[[43960,43960],"mapped",[5096]],[[43961,43961],"mapped",[5097]],[[43962,43962],"mapped",[5098]],[[43963,43963],"mapped",[5099]],[[43964,43964],"mapped",[5100]],[[43965,43965],"mapped",[5101]],[[43966,43966],"mapped",[5102]],[[43967,43967],"mapped",[5103]],[[43968,44010],"valid"],[[44011,44011],"valid",[],"NV8"],[[44012,44013],"valid"],[[44014,44015],"disallowed"],[[44016,44025],"valid"],[[44026,44031],"disallowed"],[[44032,55203],"valid"],[[55204,55215],"disallowed"],[[55216,55238],"valid",[],"NV8"],[[55239,55242],"disallowed"],[[55243,55291],"valid",[],"NV8"],[[55292,55295],"disallowed"],[[55296,57343],"disallowed"],[[57344,63743],"disallowed"],[[63744,63744],"mapped",[35912]],[[63745,63745],"mapped",[26356]],[[63746,63746],"mapped",[36554]],[[63747,63747],"mapped",[36040]],[[63748,63748],"mapped",[28369]],[[63749,63749],"mapped",[20018]],[[63750,63750],"mapped",[21477]],[[63751,63752],"mapped",[40860]],[[63753,63753],"mapped",[22865]],[[63754,63754],"mapped",[37329]],[[63755,63755],"mapped",[21895]],[[63756,63756],"mapped",[22856]],[[63757,63757],"mapped",[25078]],[[63758,63758],"mapped",[30313]],[[63759,63759],"mapped",[32645]],[[63760,63760],"mapped",[34367]],[[63761,63761],"mapped",[34746]],[[63762,63762],"mapped",[35064]],[[63763,63763],"mapped",[37007]],[[63764,63764],"mapped",[27138]],[[63765,63765],"mapped",[27931]],[[63766,63766],"mapped",[28889]],[[63767,63767],"mapped",[29662]],[[63768,63768],"mapped",[33853]],[[63769,63769],"mapped",[37226]],[[63770,63770],"mapped",[39409]],[[63771,63771],"mapped",[20098]],[[63772,63772],"mapped",[21365]],[[63773,63773],"mapped",[27396]],[[63774,63774],"mapped",[29211]],[[63775,63775],"mapped",[34349]],[[63776,63776],"mapped",[40478]],[[63777,63777],"mapped",[23888]],[[63778,63778],"mapped",[28651]],[[63779,63779],"mapped",[34253]],[[63780,63780],"mapped",[35172]],[[63781,63781],"mapped",[25289]],[[63782,63782],"mapped",[33240]],[[63783,63783],"mapped",[34847]],[[63784,63784],"mapped",[24266]],[[63785,63785],"mapped",[26391]],[[63786,63786],"mapped",[28010]],[[63787,63787],"mapped",[29436]],[[63788,63788],"mapped",[37070]],[[63789,63789],"mapped",[20358]],[[63790,63790],"mapped",[20919]],[[63791,63791],"mapped",[21214]],[[63792,63792],"mapped",[25796]],[[63793,63793],"mapped",[27347]],[[63794,63794],"mapped",[29200]],[[63795,63795],"mapped",[30439]],[[63796,63796],"mapped",[32769]],[[63797,63797],"mapped",[34310]],[[63798,63798],"mapped",[34396]],[[63799,63799],"mapped",[36335]],[[63800,63800],"mapped",[38706]],[[63801,63801],"mapped",[39791]],[[63802,63802],"mapped",[40442]],[[63803,63803],"mapped",[30860]],[[63804,63804],"mapped",[31103]],[[63805,63805],"mapped",[32160]],[[63806,63806],"mapped",[33737]],[[63807,63807],"mapped",[37636]],[[63808,63808],"mapped",[40575]],[[63809,63809],"mapped",[35542]],[[63810,63810],"mapped",[22751]],[[63811,63811],"mapped",[24324]],[[63812,63812],"mapped",[31840]],[[63813,63813],"mapped",[32894]],[[63814,63814],"mapped",[29282]],[[63815,63815],"mapped",[30922]],[[63816,63816],"mapped",[36034]],[[63817,63817],"mapped",[38647]],[[63818,63818],"mapped",[22744]],[[63819,63819],"mapped",[23650]],[[63820,63820],"mapped",[27155]],[[63821,63821],"mapped",[28122]],[[63822,63822],"mapped",[28431]],[[63823,63823],"mapped",[32047]],[[63824,63824],"mapped",[32311]],[[63825,63825],"mapped",[38475]],[[63826,63826],"mapped",[21202]],[[63827,63827],"mapped",[32907]],[[63828,63828],"mapped",[20956]],[[63829,63829],"mapped",[20940]],[[63830,63830],"mapped",[31260]],[[63831,63831],"mapped",[32190]],[[63832,63832],"mapped",[33777]],[[63833,63833],"mapped",[38517]],[[63834,63834],"mapped",[35712]],[[63835,63835],"mapped",[25295]],[[63836,63836],"mapped",[27138]],[[63837,63837],"mapped",[35582]],[[63838,63838],"mapped",[20025]],[[63839,63839],"mapped",[23527]],[[63840,63840],"mapped",[24594]],[[63841,63841],"mapped",[29575]],[[63842,63842],"mapped",[30064]],[[63843,63843],"mapped",[21271]],[[63844,63844],"mapped",[30971]],[[63845,63845],"mapped",[20415]],[[63846,63846],"mapped",[24489]],[[63847,63847],"mapped",[19981]],[[63848,63848],"mapped",[27852]],[[63849,63849],"mapped",[25976]],[[63850,63850],"mapped",[32034]],[[63851,63851],"mapped",[21443]],[[63852,63852],"mapped",[22622]],[[63853,63853],"mapped",[30465]],[[63854,63854],"mapped",[33865]],[[63855,63855],"mapped",[35498]],[[63856,63856],"mapped",[27578]],[[63857,63857],"mapped",[36784]],[[63858,63858],"mapped",[27784]],[[63859,63859],"mapped",[25342]],[[63860,63860],"mapped",[33509]],[[63861,63861],"mapped",[25504]],[[63862,63862],"mapped",[30053]],[[63863,63863],"mapped",[20142]],[[63864,63864],"mapped",[20841]],[[63865,63865],"mapped",[20937]],[[63866,63866],"mapped",[26753]],[[63867,63867],"mapped",[31975]],[[63868,63868],"mapped",[33391]],[[63869,63869],"mapped",[35538]],[[63870,63870],"mapped",[37327]],[[63871,63871],"mapped",[21237]],[[63872,63872],"mapped",[21570]],[[63873,63873],"mapped",[22899]],[[63874,63874],"mapped",[24300]],[[63875,63875],"mapped",[26053]],[[63876,63876],"mapped",[28670]],[[63877,63877],"mapped",[31018]],[[63878,63878],"mapped",[38317]],[[63879,63879],"mapped",[39530]],[[63880,63880],"mapped",[40599]],[[63881,63881],"mapped",[40654]],[[63882,63882],"mapped",[21147]],[[63883,63883],"mapped",[26310]],[[63884,63884],"mapped",[27511]],[[63885,63885],"mapped",[36706]],[[63886,63886],"mapped",[24180]],[[63887,63887],"mapped",[24976]],[[63888,63888],"mapped",[25088]],[[63889,63889],"mapped",[25754]],[[63890,63890],"mapped",[28451]],[[63891,63891],"mapped",[29001]],[[63892,63892],"mapped",[29833]],[[63893,63893],"mapped",[31178]],[[63894,63894],"mapped",[32244]],[[63895,63895],"mapped",[32879]],[[63896,63896],"mapped",[36646]],[[63897,63897],"mapped",[34030]],[[63898,63898],"mapped",[36899]],[[63899,63899],"mapped",[37706]],[[63900,63900],"mapped",[21015]],[[63901,63901],"mapped",[21155]],[[63902,63902],"mapped",[21693]],[[63903,63903],"mapped",[28872]],[[63904,63904],"mapped",[35010]],[[63905,63905],"mapped",[35498]],[[63906,63906],"mapped",[24265]],[[63907,63907],"mapped",[24565]],[[63908,63908],"mapped",[25467]],[[63909,63909],"mapped",[27566]],[[63910,63910],"mapped",[31806]],[[63911,63911],"mapped",[29557]],[[63912,63912],"mapped",[20196]],[[63913,63913],"mapped",[22265]],[[63914,63914],"mapped",[23527]],[[63915,63915],"mapped",[23994]],[[63916,63916],"mapped",[24604]],[[63917,63917],"mapped",[29618]],[[63918,63918],"mapped",[29801]],[[63919,63919],"mapped",[32666]],[[63920,63920],"mapped",[32838]],[[63921,63921],"mapped",[37428]],[[63922,63922],"mapped",[38646]],[[63923,63923],"mapped",[38728]],[[63924,63924],"mapped",[38936]],[[63925,63925],"mapped",[20363]],[[63926,63926],"mapped",[31150]],[[63927,63927],"mapped",[37300]],[[63928,63928],"mapped",[38584]],[[63929,63929],"mapped",[24801]],[[63930,63930],"mapped",[20102]],[[63931,63931],"mapped",[20698]],[[63932,63932],"mapped",[23534]],[[63933,63933],"mapped",[23615]],[[63934,63934],"mapped",[26009]],[[63935,63935],"mapped",[27138]],[[63936,63936],"mapped",[29134]],[[63937,63937],"mapped",[30274]],[[63938,63938],"mapped",[34044]],[[63939,63939],"mapped",[36988]],[[63940,63940],"mapped",[40845]],[[63941,63941],"mapped",[26248]],[[63942,63942],"mapped",[38446]],[[63943,63943],"mapped",[21129]],[[63944,63944],"mapped",[26491]],[[63945,63945],"mapped",[26611]],[[63946,63946],"mapped",[27969]],[[63947,63947],"mapped",[28316]],[[63948,63948],"mapped",[29705]],[[63949,63949],"mapped",[30041]],[[63950,63950],"mapped",[30827]],[[63951,63951],"mapped",[32016]],[[63952,63952],"mapped",[39006]],[[63953,63953],"mapped",[20845]],[[63954,63954],"mapped",[25134]],[[63955,63955],"mapped",[38520]],[[63956,63956],"mapped",[20523]],[[63957,63957],"mapped",[23833]],[[63958,63958],"mapped",[28138]],[[63959,63959],"mapped",[36650]],[[63960,63960],"mapped",[24459]],[[63961,63961],"mapped",[24900]],[[63962,63962],"mapped",[26647]],[[63963,63963],"mapped",[29575]],[[63964,63964],"mapped",[38534]],[[63965,63965],"mapped",[21033]],[[63966,63966],"mapped",[21519]],[[63967,63967],"mapped",[23653]],[[63968,63968],"mapped",[26131]],[[63969,63969],"mapped",[26446]],[[63970,63970],"mapped",[26792]],[[63971,63971],"mapped",[27877]],[[63972,63972],"mapped",[29702]],[[63973,63973],"mapped",[30178]],[[63974,63974],"mapped",[32633]],[[63975,63975],"mapped",[35023]],[[63976,63976],"mapped",[35041]],[[63977,63977],"mapped",[37324]],[[63978,63978],"mapped",[38626]],[[63979,63979],"mapped",[21311]],[[63980,63980],"mapped",[28346]],[[63981,63981],"mapped",[21533]],[[63982,63982],"mapped",[29136]],[[63983,63983],"mapped",[29848]],[[63984,63984],"mapped",[34298]],[[63985,63985],"mapped",[38563]],[[63986,63986],"mapped",[40023]],[[63987,63987],"mapped",[40607]],[[63988,63988],"mapped",[26519]],[[63989,63989],"mapped",[28107]],[[63990,63990],"mapped",[33256]],[[63991,63991],"mapped",[31435]],[[63992,63992],"mapped",[31520]],[[63993,63993],"mapped",[31890]],[[63994,63994],"mapped",[29376]],[[63995,63995],"mapped",[28825]],[[63996,63996],"mapped",[35672]],[[63997,63997],"mapped",[20160]],[[63998,63998],"mapped",[33590]],[[63999,63999],"mapped",[21050]],[[64000,64000],"mapped",[20999]],[[64001,64001],"mapped",[24230]],[[64002,64002],"mapped",[25299]],[[64003,64003],"mapped",[31958]],[[64004,64004],"mapped",[23429]],[[64005,64005],"mapped",[27934]],[[64006,64006],"mapped",[26292]],[[64007,64007],"mapped",[36667]],[[64008,64008],"mapped",[34892]],[[64009,64009],"mapped",[38477]],[[64010,64010],"mapped",[35211]],[[64011,64011],"mapped",[24275]],[[64012,64012],"mapped",[20800]],[[64013,64013],"mapped",[21952]],[[64014,64015],"valid"],[[64016,64016],"mapped",[22618]],[[64017,64017],"valid"],[[64018,64018],"mapped",[26228]],[[64019,64020],"valid"],[[64021,64021],"mapped",[20958]],[[64022,64022],"mapped",[29482]],[[64023,64023],"mapped",[30410]],[[64024,64024],"mapped",[31036]],[[64025,64025],"mapped",[31070]],[[64026,64026],"mapped",[31077]],[[64027,64027],"mapped",[31119]],[[64028,64028],"mapped",[38742]],[[64029,64029],"mapped",[31934]],[[64030,64030],"mapped",[32701]],[[64031,64031],"valid"],[[64032,64032],"mapped",[34322]],[[64033,64033],"valid"],[[64034,64034],"mapped",[35576]],[[64035,64036],"valid"],[[64037,64037],"mapped",[36920]],[[64038,64038],"mapped",[37117]],[[64039,64041],"valid"],[[64042,64042],"mapped",[39151]],[[64043,64043],"mapped",[39164]],[[64044,64044],"mapped",[39208]],[[64045,64045],"mapped",[40372]],[[64046,64046],"mapped",[37086]],[[64047,64047],"mapped",[38583]],[[64048,64048],"mapped",[20398]],[[64049,64049],"mapped",[20711]],[[64050,64050],"mapped",[20813]],[[64051,64051],"mapped",[21193]],[[64052,64052],"mapped",[21220]],[[64053,64053],"mapped",[21329]],[[64054,64054],"mapped",[21917]],[[64055,64055],"mapped",[22022]],[[64056,64056],"mapped",[22120]],[[64057,64057],"mapped",[22592]],[[64058,64058],"mapped",[22696]],[[64059,64059],"mapped",[23652]],[[64060,64060],"mapped",[23662]],[[64061,64061],"mapped",[24724]],[[64062,64062],"mapped",[24936]],[[64063,64063],"mapped",[24974]],[[64064,64064],"mapped",[25074]],[[64065,64065],"mapped",[25935]],[[64066,64066],"mapped",[26082]],[[64067,64067],"mapped",[26257]],[[64068,64068],"mapped",[26757]],[[64069,64069],"mapped",[28023]],[[64070,64070],"mapped",[28186]],[[64071,64071],"mapped",[28450]],[[64072,64072],"mapped",[29038]],[[64073,64073],"mapped",[29227]],[[64074,64074],"mapped",[29730]],[[64075,64075],"mapped",[30865]],[[64076,64076],"mapped",[31038]],[[64077,64077],"mapped",[31049]],[[64078,64078],"mapped",[31048]],[[64079,64079],"mapped",[31056]],[[64080,64080],"mapped",[31062]],[[64081,64081],"mapped",[31069]],[[64082,64082],"mapped",[31117]],[[64083,64083],"mapped",[31118]],[[64084,64084],"mapped",[31296]],[[64085,64085],"mapped",[31361]],[[64086,64086],"mapped",[31680]],[[64087,64087],"mapped",[32244]],[[64088,64088],"mapped",[32265]],[[64089,64089],"mapped",[32321]],[[64090,64090],"mapped",[32626]],[[64091,64091],"mapped",[32773]],[[64092,64092],"mapped",[33261]],[[64093,64094],"mapped",[33401]],[[64095,64095],"mapped",[33879]],[[64096,64096],"mapped",[35088]],[[64097,64097],"mapped",[35222]],[[64098,64098],"mapped",[35585]],[[64099,64099],"mapped",[35641]],[[64100,64100],"mapped",[36051]],[[64101,64101],"mapped",[36104]],[[64102,64102],"mapped",[36790]],[[64103,64103],"mapped",[36920]],[[64104,64104],"mapped",[38627]],[[64105,64105],"mapped",[38911]],[[64106,64106],"mapped",[38971]],[[64107,64107],"mapped",[24693]],[[64108,64108],"mapped",[148206]],[[64109,64109],"mapped",[33304]],[[64110,64111],"disallowed"],[[64112,64112],"mapped",[20006]],[[64113,64113],"mapped",[20917]],[[64114,64114],"mapped",[20840]],[[64115,64115],"mapped",[20352]],[[64116,64116],"mapped",[20805]],[[64117,64117],"mapped",[20864]],[[64118,64118],"mapped",[21191]],[[64119,64119],"mapped",[21242]],[[64120,64120],"mapped",[21917]],[[64121,64121],"mapped",[21845]],[[64122,64122],"mapped",[21913]],[[64123,64123],"mapped",[21986]],[[64124,64124],"mapped",[22618]],[[64125,64125],"mapped",[22707]],[[64126,64126],"mapped",[22852]],[[64127,64127],"mapped",[22868]],[[64128,64128],"mapped",[23138]],[[64129,64129],"mapped",[23336]],[[64130,64130],"mapped",[24274]],[[64131,64131],"mapped",[24281]],[[64132,64132],"mapped",[24425]],[[64133,64133],"mapped",[24493]],[[64134,64134],"mapped",[24792]],[[64135,64135],"mapped",[24910]],[[64136,64136],"mapped",[24840]],[[64137,64137],"mapped",[24974]],[[64138,64138],"mapped",[24928]],[[64139,64139],"mapped",[25074]],[[64140,64140],"mapped",[25140]],[[64141,64141],"mapped",[25540]],[[64142,64142],"mapped",[25628]],[[64143,64143],"mapped",[25682]],[[64144,64144],"mapped",[25942]],[[64145,64145],"mapped",[26228]],[[64146,64146],"mapped",[26391]],[[64147,64147],"mapped",[26395]],[[64148,64148],"mapped",[26454]],[[64149,64149],"mapped",[27513]],[[64150,64150],"mapped",[27578]],[[64151,64151],"mapped",[27969]],[[64152,64152],"mapped",[28379]],[[64153,64153],"mapped",[28363]],[[64154,64154],"mapped",[28450]],[[64155,64155],"mapped",[28702]],[[64156,64156],"mapped",[29038]],[[64157,64157],"mapped",[30631]],[[64158,64158],"mapped",[29237]],[[64159,64159],"mapped",[29359]],[[64160,64160],"mapped",[29482]],[[64161,64161],"mapped",[29809]],[[64162,64162],"mapped",[29958]],[[64163,64163],"mapped",[30011]],[[64164,64164],"mapped",[30237]],[[64165,64165],"mapped",[30239]],[[64166,64166],"mapped",[30410]],[[64167,64167],"mapped",[30427]],[[64168,64168],"mapped",[30452]],[[64169,64169],"mapped",[30538]],[[64170,64170],"mapped",[30528]],[[64171,64171],"mapped",[30924]],[[64172,64172],"mapped",[31409]],[[64173,64173],"mapped",[31680]],[[64174,64174],"mapped",[31867]],[[64175,64175],"mapped",[32091]],[[64176,64176],"mapped",[32244]],[[64177,64177],"mapped",[32574]],[[64178,64178],"mapped",[32773]],[[64179,64179],"mapped",[33618]],[[64180,64180],"mapped",[33775]],[[64181,64181],"mapped",[34681]],[[64182,64182],"mapped",[35137]],[[64183,64183],"mapped",[35206]],[[64184,64184],"mapped",[35222]],[[64185,64185],"mapped",[35519]],[[64186,64186],"mapped",[35576]],[[64187,64187],"mapped",[35531]],[[64188,64188],"mapped",[35585]],[[64189,64189],"mapped",[35582]],[[64190,64190],"mapped",[35565]],[[64191,64191],"mapped",[35641]],[[64192,64192],"mapped",[35722]],[[64193,64193],"mapped",[36104]],[[64194,64194],"mapped",[36664]],[[64195,64195],"mapped",[36978]],[[64196,64196],"mapped",[37273]],[[64197,64197],"mapped",[37494]],[[64198,64198],"mapped",[38524]],[[64199,64199],"mapped",[38627]],[[64200,64200],"mapped",[38742]],[[64201,64201],"mapped",[38875]],[[64202,64202],"mapped",[38911]],[[64203,64203],"mapped",[38923]],[[64204,64204],"mapped",[38971]],[[64205,64205],"mapped",[39698]],[[64206,64206],"mapped",[40860]],[[64207,64207],"mapped",[141386]],[[64208,64208],"mapped",[141380]],[[64209,64209],"mapped",[144341]],[[64210,64210],"mapped",[15261]],[[64211,64211],"mapped",[16408]],[[64212,64212],"mapped",[16441]],[[64213,64213],"mapped",[152137]],[[64214,64214],"mapped",[154832]],[[64215,64215],"mapped",[163539]],[[64216,64216],"mapped",[40771]],[[64217,64217],"mapped",[40846]],[[64218,64255],"disallowed"],[[64256,64256],"mapped",[102,102]],[[64257,64257],"mapped",[102,105]],[[64258,64258],"mapped",[102,108]],[[64259,64259],"mapped",[102,102,105]],[[64260,64260],"mapped",[102,102,108]],[[64261,64262],"mapped",[115,116]],[[64263,64274],"disallowed"],[[64275,64275],"mapped",[1396,1398]],[[64276,64276],"mapped",[1396,1381]],[[64277,64277],"mapped",[1396,1387]],[[64278,64278],"mapped",[1406,1398]],[[64279,64279],"mapped",[1396,1389]],[[64280,64284],"disallowed"],[[64285,64285],"mapped",[1497,1460]],[[64286,64286],"valid"],[[64287,64287],"mapped",[1522,1463]],[[64288,64288],"mapped",[1506]],[[64289,64289],"mapped",[1488]],[[64290,64290],"mapped",[1491]],[[64291,64291],"mapped",[1492]],[[64292,64292],"mapped",[1499]],[[64293,64293],"mapped",[1500]],[[64294,64294],"mapped",[1501]],[[64295,64295],"mapped",[1512]],[[64296,64296],"mapped",[1514]],[[64297,64297],"disallowed_STD3_mapped",[43]],[[64298,64298],"mapped",[1513,1473]],[[64299,64299],"mapped",[1513,1474]],[[64300,64300],"mapped",[1513,1468,1473]],[[64301,64301],"mapped",[1513,1468,1474]],[[64302,64302],"mapped",[1488,1463]],[[64303,64303],"mapped",[1488,1464]],[[64304,64304],"mapped",[1488,1468]],[[64305,64305],"mapped",[1489,1468]],[[64306,64306],"mapped",[1490,1468]],[[64307,64307],"mapped",[1491,1468]],[[64308,64308],"mapped",[1492,1468]],[[64309,64309],"mapped",[1493,1468]],[[64310,64310],"mapped",[1494,1468]],[[64311,64311],"disallowed"],[[64312,64312],"mapped",[1496,1468]],[[64313,64313],"mapped",[1497,1468]],[[64314,64314],"mapped",[1498,1468]],[[64315,64315],"mapped",[1499,1468]],[[64316,64316],"mapped",[1500,1468]],[[64317,64317],"disallowed"],[[64318,64318],"mapped",[1502,1468]],[[64319,64319],"disallowed"],[[64320,64320],"mapped",[1504,1468]],[[64321,64321],"mapped",[1505,1468]],[[64322,64322],"disallowed"],[[64323,64323],"mapped",[1507,1468]],[[64324,64324],"mapped",[1508,1468]],[[64325,64325],"disallowed"],[[64326,64326],"mapped",[1510,1468]],[[64327,64327],"mapped",[1511,1468]],[[64328,64328],"mapped",[1512,1468]],[[64329,64329],"mapped",[1513,1468]],[[64330,64330],"mapped",[1514,1468]],[[64331,64331],"mapped",[1493,1465]],[[64332,64332],"mapped",[1489,1471]],[[64333,64333],"mapped",[1499,1471]],[[64334,64334],"mapped",[1508,1471]],[[64335,64335],"mapped",[1488,1500]],[[64336,64337],"mapped",[1649]],[[64338,64341],"mapped",[1659]],[[64342,64345],"mapped",[1662]],[[64346,64349],"mapped",[1664]],[[64350,64353],"mapped",[1658]],[[64354,64357],"mapped",[1663]],[[64358,64361],"mapped",[1657]],[[64362,64365],"mapped",[1700]],[[64366,64369],"mapped",[1702]],[[64370,64373],"mapped",[1668]],[[64374,64377],"mapped",[1667]],[[64378,64381],"mapped",[1670]],[[64382,64385],"mapped",[1671]],[[64386,64387],"mapped",[1677]],[[64388,64389],"mapped",[1676]],[[64390,64391],"mapped",[1678]],[[64392,64393],"mapped",[1672]],[[64394,64395],"mapped",[1688]],[[64396,64397],"mapped",[1681]],[[64398,64401],"mapped",[1705]],[[64402,64405],"mapped",[1711]],[[64406,64409],"mapped",[1715]],[[64410,64413],"mapped",[1713]],[[64414,64415],"mapped",[1722]],[[64416,64419],"mapped",[1723]],[[64420,64421],"mapped",[1728]],[[64422,64425],"mapped",[1729]],[[64426,64429],"mapped",[1726]],[[64430,64431],"mapped",[1746]],[[64432,64433],"mapped",[1747]],[[64434,64449],"valid",[],"NV8"],[[64450,64466],"disallowed"],[[64467,64470],"mapped",[1709]],[[64471,64472],"mapped",[1735]],[[64473,64474],"mapped",[1734]],[[64475,64476],"mapped",[1736]],[[64477,64477],"mapped",[1735,1652]],[[64478,64479],"mapped",[1739]],[[64480,64481],"mapped",[1733]],[[64482,64483],"mapped",[1737]],[[64484,64487],"mapped",[1744]],[[64488,64489],"mapped",[1609]],[[64490,64491],"mapped",[1574,1575]],[[64492,64493],"mapped",[1574,1749]],[[64494,64495],"mapped",[1574,1608]],[[64496,64497],"mapped",[1574,1735]],[[64498,64499],"mapped",[1574,1734]],[[64500,64501],"mapped",[1574,1736]],[[64502,64504],"mapped",[1574,1744]],[[64505,64507],"mapped",[1574,1609]],[[64508,64511],"mapped",[1740]],[[64512,64512],"mapped",[1574,1580]],[[64513,64513],"mapped",[1574,1581]],[[64514,64514],"mapped",[1574,1605]],[[64515,64515],"mapped",[1574,1609]],[[64516,64516],"mapped",[1574,1610]],[[64517,64517],"mapped",[1576,1580]],[[64518,64518],"mapped",[1576,1581]],[[64519,64519],"mapped",[1576,1582]],[[64520,64520],"mapped",[1576,1605]],[[64521,64521],"mapped",[1576,1609]],[[64522,64522],"mapped",[1576,1610]],[[64523,64523],"mapped",[1578,1580]],[[64524,64524],"mapped",[1578,1581]],[[64525,64525],"mapped",[1578,1582]],[[64526,64526],"mapped",[1578,1605]],[[64527,64527],"mapped",[1578,1609]],[[64528,64528],"mapped",[1578,1610]],[[64529,64529],"mapped",[1579,1580]],[[64530,64530],"mapped",[1579,1605]],[[64531,64531],"mapped",[1579,1609]],[[64532,64532],"mapped",[1579,1610]],[[64533,64533],"mapped",[1580,1581]],[[64534,64534],"mapped",[1580,1605]],[[64535,64535],"mapped",[1581,1580]],[[64536,64536],"mapped",[1581,1605]],[[64537,64537],"mapped",[1582,1580]],[[64538,64538],"mapped",[1582,1581]],[[64539,64539],"mapped",[1582,1605]],[[64540,64540],"mapped",[1587,1580]],[[64541,64541],"mapped",[1587,1581]],[[64542,64542],"mapped",[1587,1582]],[[64543,64543],"mapped",[1587,1605]],[[64544,64544],"mapped",[1589,1581]],[[64545,64545],"mapped",[1589,1605]],[[64546,64546],"mapped",[1590,1580]],[[64547,64547],"mapped",[1590,1581]],[[64548,64548],"mapped",[1590,1582]],[[64549,64549],"mapped",[1590,1605]],[[64550,64550],"mapped",[1591,1581]],[[64551,64551],"mapped",[1591,1605]],[[64552,64552],"mapped",[1592,1605]],[[64553,64553],"mapped",[1593,1580]],[[64554,64554],"mapped",[1593,1605]],[[64555,64555],"mapped",[1594,1580]],[[64556,64556],"mapped",[1594,1605]],[[64557,64557],"mapped",[1601,1580]],[[64558,64558],"mapped",[1601,1581]],[[64559,64559],"mapped",[1601,1582]],[[64560,64560],"mapped",[1601,1605]],[[64561,64561],"mapped",[1601,1609]],[[64562,64562],"mapped",[1601,1610]],[[64563,64563],"mapped",[1602,1581]],[[64564,64564],"mapped",[1602,1605]],[[64565,64565],"mapped",[1602,1609]],[[64566,64566],"mapped",[1602,1610]],[[64567,64567],"mapped",[1603,1575]],[[64568,64568],"mapped",[1603,1580]],[[64569,64569],"mapped",[1603,1581]],[[64570,64570],"mapped",[1603,1582]],[[64571,64571],"mapped",[1603,1604]],[[64572,64572],"mapped",[1603,1605]],[[64573,64573],"mapped",[1603,1609]],[[64574,64574],"mapped",[1603,1610]],[[64575,64575],"mapped",[1604,1580]],[[64576,64576],"mapped",[1604,1581]],[[64577,64577],"mapped",[1604,1582]],[[64578,64578],"mapped",[1604,1605]],[[64579,64579],"mapped",[1604,1609]],[[64580,64580],"mapped",[1604,1610]],[[64581,64581],"mapped",[1605,1580]],[[64582,64582],"mapped",[1605,1581]],[[64583,64583],"mapped",[1605,1582]],[[64584,64584],"mapped",[1605,1605]],[[64585,64585],"mapped",[1605,1609]],[[64586,64586],"mapped",[1605,1610]],[[64587,64587],"mapped",[1606,1580]],[[64588,64588],"mapped",[1606,1581]],[[64589,64589],"mapped",[1606,1582]],[[64590,64590],"mapped",[1606,1605]],[[64591,64591],"mapped",[1606,1609]],[[64592,64592],"mapped",[1606,1610]],[[64593,64593],"mapped",[1607,1580]],[[64594,64594],"mapped",[1607,1605]],[[64595,64595],"mapped",[1607,1609]],[[64596,64596],"mapped",[1607,1610]],[[64597,64597],"mapped",[1610,1580]],[[64598,64598],"mapped",[1610,1581]],[[64599,64599],"mapped",[1610,1582]],[[64600,64600],"mapped",[1610,1605]],[[64601,64601],"mapped",[1610,1609]],[[64602,64602],"mapped",[1610,1610]],[[64603,64603],"mapped",[1584,1648]],[[64604,64604],"mapped",[1585,1648]],[[64605,64605],"mapped",[1609,1648]],[[64606,64606],"disallowed_STD3_mapped",[32,1612,1617]],[[64607,64607],"disallowed_STD3_mapped",[32,1613,1617]],[[64608,64608],"disallowed_STD3_mapped",[32,1614,1617]],[[64609,64609],"disallowed_STD3_mapped",[32,1615,1617]],[[64610,64610],"disallowed_STD3_mapped",[32,1616,1617]],[[64611,64611],"disallowed_STD3_mapped",[32,1617,1648]],[[64612,64612],"mapped",[1574,1585]],[[64613,64613],"mapped",[1574,1586]],[[64614,64614],"mapped",[1574,1605]],[[64615,64615],"mapped",[1574,1606]],[[64616,64616],"mapped",[1574,1609]],[[64617,64617],"mapped",[1574,1610]],[[64618,64618],"mapped",[1576,1585]],[[64619,64619],"mapped",[1576,1586]],[[64620,64620],"mapped",[1576,1605]],[[64621,64621],"mapped",[1576,1606]],[[64622,64622],"mapped",[1576,1609]],[[64623,64623],"mapped",[1576,1610]],[[64624,64624],"mapped",[1578,1585]],[[64625,64625],"mapped",[1578,1586]],[[64626,64626],"mapped",[1578,1605]],[[64627,64627],"mapped",[1578,1606]],[[64628,64628],"mapped",[1578,1609]],[[64629,64629],"mapped",[1578,1610]],[[64630,64630],"mapped",[1579,1585]],[[64631,64631],"mapped",[1579,1586]],[[64632,64632],"mapped",[1579,1605]],[[64633,64633],"mapped",[1579,1606]],[[64634,64634],"mapped",[1579,1609]],[[64635,64635],"mapped",[1579,1610]],[[64636,64636],"mapped",[1601,1609]],[[64637,64637],"mapped",[1601,1610]],[[64638,64638],"mapped",[1602,1609]],[[64639,64639],"mapped",[1602,1610]],[[64640,64640],"mapped",[1603,1575]],[[64641,64641],"mapped",[1603,1604]],[[64642,64642],"mapped",[1603,1605]],[[64643,64643],"mapped",[1603,1609]],[[64644,64644],"mapped",[1603,1610]],[[64645,64645],"mapped",[1604,1605]],[[64646,64646],"mapped",[1604,1609]],[[64647,64647],"mapped",[1604,1610]],[[64648,64648],"mapped",[1605,1575]],[[64649,64649],"mapped",[1605,1605]],[[64650,64650],"mapped",[1606,1585]],[[64651,64651],"mapped",[1606,1586]],[[64652,64652],"mapped",[1606,1605]],[[64653,64653],"mapped",[1606,1606]],[[64654,64654],"mapped",[1606,1609]],[[64655,64655],"mapped",[1606,1610]],[[64656,64656],"mapped",[1609,1648]],[[64657,64657],"mapped",[1610,1585]],[[64658,64658],"mapped",[1610,1586]],[[64659,64659],"mapped",[1610,1605]],[[64660,64660],"mapped",[1610,1606]],[[64661,64661],"mapped",[1610,1609]],[[64662,64662],"mapped",[1610,1610]],[[64663,64663],"mapped",[1574,1580]],[[64664,64664],"mapped",[1574,1581]],[[64665,64665],"mapped",[1574,1582]],[[64666,64666],"mapped",[1574,1605]],[[64667,64667],"mapped",[1574,1607]],[[64668,64668],"mapped",[1576,1580]],[[64669,64669],"mapped",[1576,1581]],[[64670,64670],"mapped",[1576,1582]],[[64671,64671],"mapped",[1576,1605]],[[64672,64672],"mapped",[1576,1607]],[[64673,64673],"mapped",[1578,1580]],[[64674,64674],"mapped",[1578,1581]],[[64675,64675],"mapped",[1578,1582]],[[64676,64676],"mapped",[1578,1605]],[[64677,64677],"mapped",[1578,1607]],[[64678,64678],"mapped",[1579,1605]],[[64679,64679],"mapped",[1580,1581]],[[64680,64680],"mapped",[1580,1605]],[[64681,64681],"mapped",[1581,1580]],[[64682,64682],"mapped",[1581,1605]],[[64683,64683],"mapped",[1582,1580]],[[64684,64684],"mapped",[1582,1605]],[[64685,64685],"mapped",[1587,1580]],[[64686,64686],"mapped",[1587,1581]],[[64687,64687],"mapped",[1587,1582]],[[64688,64688],"mapped",[1587,1605]],[[64689,64689],"mapped",[1589,1581]],[[64690,64690],"mapped",[1589,1582]],[[64691,64691],"mapped",[1589,1605]],[[64692,64692],"mapped",[1590,1580]],[[64693,64693],"mapped",[1590,1581]],[[64694,64694],"mapped",[1590,1582]],[[64695,64695],"mapped",[1590,1605]],[[64696,64696],"mapped",[1591,1581]],[[64697,64697],"mapped",[1592,1605]],[[64698,64698],"mapped",[1593,1580]],[[64699,64699],"mapped",[1593,1605]],[[64700,64700],"mapped",[1594,1580]],[[64701,64701],"mapped",[1594,1605]],[[64702,64702],"mapped",[1601,1580]],[[64703,64703],"mapped",[1601,1581]],[[64704,64704],"mapped",[1601,1582]],[[64705,64705],"mapped",[1601,1605]],[[64706,64706],"mapped",[1602,1581]],[[64707,64707],"mapped",[1602,1605]],[[64708,64708],"mapped",[1603,1580]],[[64709,64709],"mapped",[1603,1581]],[[64710,64710],"mapped",[1603,1582]],[[64711,64711],"mapped",[1603,1604]],[[64712,64712],"mapped",[1603,1605]],[[64713,64713],"mapped",[1604,1580]],[[64714,64714],"mapped",[1604,1581]],[[64715,64715],"mapped",[1604,1582]],[[64716,64716],"mapped",[1604,1605]],[[64717,64717],"mapped",[1604,1607]],[[64718,64718],"mapped",[1605,1580]],[[64719,64719],"mapped",[1605,1581]],[[64720,64720],"mapped",[1605,1582]],[[64721,64721],"mapped",[1605,1605]],[[64722,64722],"mapped",[1606,1580]],[[64723,64723],"mapped",[1606,1581]],[[64724,64724],"mapped",[1606,1582]],[[64725,64725],"mapped",[1606,1605]],[[64726,64726],"mapped",[1606,1607]],[[64727,64727],"mapped",[1607,1580]],[[64728,64728],"mapped",[1607,1605]],[[64729,64729],"mapped",[1607,1648]],[[64730,64730],"mapped",[1610,1580]],[[64731,64731],"mapped",[1610,1581]],[[64732,64732],"mapped",[1610,1582]],[[64733,64733],"mapped",[1610,1605]],[[64734,64734],"mapped",[1610,1607]],[[64735,64735],"mapped",[1574,1605]],[[64736,64736],"mapped",[1574,1607]],[[64737,64737],"mapped",[1576,1605]],[[64738,64738],"mapped",[1576,1607]],[[64739,64739],"mapped",[1578,1605]],[[64740,64740],"mapped",[1578,1607]],[[64741,64741],"mapped",[1579,1605]],[[64742,64742],"mapped",[1579,1607]],[[64743,64743],"mapped",[1587,1605]],[[64744,64744],"mapped",[1587,1607]],[[64745,64745],"mapped",[1588,1605]],[[64746,64746],"mapped",[1588,1607]],[[64747,64747],"mapped",[1603,1604]],[[64748,64748],"mapped",[1603,1605]],[[64749,64749],"mapped",[1604,1605]],[[64750,64750],"mapped",[1606,1605]],[[64751,64751],"mapped",[1606,1607]],[[64752,64752],"mapped",[1610,1605]],[[64753,64753],"mapped",[1610,1607]],[[64754,64754],"mapped",[1600,1614,1617]],[[64755,64755],"mapped",[1600,1615,1617]],[[64756,64756],"mapped",[1600,1616,1617]],[[64757,64757],"mapped",[1591,1609]],[[64758,64758],"mapped",[1591,1610]],[[64759,64759],"mapped",[1593,1609]],[[64760,64760],"mapped",[1593,1610]],[[64761,64761],"mapped",[1594,1609]],[[64762,64762],"mapped",[1594,1610]],[[64763,64763],"mapped",[1587,1609]],[[64764,64764],"mapped",[1587,1610]],[[64765,64765],"mapped",[1588,1609]],[[64766,64766],"mapped",[1588,1610]],[[64767,64767],"mapped",[1581,1609]],[[64768,64768],"mapped",[1581,1610]],[[64769,64769],"mapped",[1580,1609]],[[64770,64770],"mapped",[1580,1610]],[[64771,64771],"mapped",[1582,1609]],[[64772,64772],"mapped",[1582,1610]],[[64773,64773],"mapped",[1589,1609]],[[64774,64774],"mapped",[1589,1610]],[[64775,64775],"mapped",[1590,1609]],[[64776,64776],"mapped",[1590,1610]],[[64777,64777],"mapped",[1588,1580]],[[64778,64778],"mapped",[1588,1581]],[[64779,64779],"mapped",[1588,1582]],[[64780,64780],"mapped",[1588,1605]],[[64781,64781],"mapped",[1588,1585]],[[64782,64782],"mapped",[1587,1585]],[[64783,64783],"mapped",[1589,1585]],[[64784,64784],"mapped",[1590,1585]],[[64785,64785],"mapped",[1591,1609]],[[64786,64786],"mapped",[1591,1610]],[[64787,64787],"mapped",[1593,1609]],[[64788,64788],"mapped",[1593,1610]],[[64789,64789],"mapped",[1594,1609]],[[64790,64790],"mapped",[1594,1610]],[[64791,64791],"mapped",[1587,1609]],[[64792,64792],"mapped",[1587,1610]],[[64793,64793],"mapped",[1588,1609]],[[64794,64794],"mapped",[1588,1610]],[[64795,64795],"mapped",[1581,1609]],[[64796,64796],"mapped",[1581,1610]],[[64797,64797],"mapped",[1580,1609]],[[64798,64798],"mapped",[1580,1610]],[[64799,64799],"mapped",[1582,1609]],[[64800,64800],"mapped",[1582,1610]],[[64801,64801],"mapped",[1589,1609]],[[64802,64802],"mapped",[1589,1610]],[[64803,64803],"mapped",[1590,1609]],[[64804,64804],"mapped",[1590,1610]],[[64805,64805],"mapped",[1588,1580]],[[64806,64806],"mapped",[1588,1581]],[[64807,64807],"mapped",[1588,1582]],[[64808,64808],"mapped",[1588,1605]],[[64809,64809],"mapped",[1588,1585]],[[64810,64810],"mapped",[1587,1585]],[[64811,64811],"mapped",[1589,1585]],[[64812,64812],"mapped",[1590,1585]],[[64813,64813],"mapped",[1588,1580]],[[64814,64814],"mapped",[1588,1581]],[[64815,64815],"mapped",[1588,1582]],[[64816,64816],"mapped",[1588,1605]],[[64817,64817],"mapped",[1587,1607]],[[64818,64818],"mapped",[1588,1607]],[[64819,64819],"mapped",[1591,1605]],[[64820,64820],"mapped",[1587,1580]],[[64821,64821],"mapped",[1587,1581]],[[64822,64822],"mapped",[1587,1582]],[[64823,64823],"mapped",[1588,1580]],[[64824,64824],"mapped",[1588,1581]],[[64825,64825],"mapped",[1588,1582]],[[64826,64826],"mapped",[1591,1605]],[[64827,64827],"mapped",[1592,1605]],[[64828,64829],"mapped",[1575,1611]],[[64830,64831],"valid",[],"NV8"],[[64832,64847],"disallowed"],[[64848,64848],"mapped",[1578,1580,1605]],[[64849,64850],"mapped",[1578,1581,1580]],[[64851,64851],"mapped",[1578,1581,1605]],[[64852,64852],"mapped",[1578,1582,1605]],[[64853,64853],"mapped",[1578,1605,1580]],[[64854,64854],"mapped",[1578,1605,1581]],[[64855,64855],"mapped",[1578,1605,1582]],[[64856,64857],"mapped",[1580,1605,1581]],[[64858,64858],"mapped",[1581,1605,1610]],[[64859,64859],"mapped",[1581,1605,1609]],[[64860,64860],"mapped",[1587,1581,1580]],[[64861,64861],"mapped",[1587,1580,1581]],[[64862,64862],"mapped",[1587,1580,1609]],[[64863,64864],"mapped",[1587,1605,1581]],[[64865,64865],"mapped",[1587,1605,1580]],[[64866,64867],"mapped",[1587,1605,1605]],[[64868,64869],"mapped",[1589,1581,1581]],[[64870,64870],"mapped",[1589,1605,1605]],[[64871,64872],"mapped",[1588,1581,1605]],[[64873,64873],"mapped",[1588,1580,1610]],[[64874,64875],"mapped",[1588,1605,1582]],[[64876,64877],"mapped",[1588,1605,1605]],[[64878,64878],"mapped",[1590,1581,1609]],[[64879,64880],"mapped",[1590,1582,1605]],[[64881,64882],"mapped",[1591,1605,1581]],[[64883,64883],"mapped",[1591,1605,1605]],[[64884,64884],"mapped",[1591,1605,1610]],[[64885,64885],"mapped",[1593,1580,1605]],[[64886,64887],"mapped",[1593,1605,1605]],[[64888,64888],"mapped",[1593,1605,1609]],[[64889,64889],"mapped",[1594,1605,1605]],[[64890,64890],"mapped",[1594,1605,1610]],[[64891,64891],"mapped",[1594,1605,1609]],[[64892,64893],"mapped",[1601,1582,1605]],[[64894,64894],"mapped",[1602,1605,1581]],[[64895,64895],"mapped",[1602,1605,1605]],[[64896,64896],"mapped",[1604,1581,1605]],[[64897,64897],"mapped",[1604,1581,1610]],[[64898,64898],"mapped",[1604,1581,1609]],[[64899,64900],"mapped",[1604,1580,1580]],[[64901,64902],"mapped",[1604,1582,1605]],[[64903,64904],"mapped",[1604,1605,1581]],[[64905,64905],"mapped",[1605,1581,1580]],[[64906,64906],"mapped",[1605,1581,1605]],[[64907,64907],"mapped",[1605,1581,1610]],[[64908,64908],"mapped",[1605,1580,1581]],[[64909,64909],"mapped",[1605,1580,1605]],[[64910,64910],"mapped",[1605,1582,1580]],[[64911,64911],"mapped",[1605,1582,1605]],[[64912,64913],"disallowed"],[[64914,64914],"mapped",[1605,1580,1582]],[[64915,64915],"mapped",[1607,1605,1580]],[[64916,64916],"mapped",[1607,1605,1605]],[[64917,64917],"mapped",[1606,1581,1605]],[[64918,64918],"mapped",[1606,1581,1609]],[[64919,64920],"mapped",[1606,1580,1605]],[[64921,64921],"mapped",[1606,1580,1609]],[[64922,64922],"mapped",[1606,1605,1610]],[[64923,64923],"mapped",[1606,1605,1609]],[[64924,64925],"mapped",[1610,1605,1605]],[[64926,64926],"mapped",[1576,1582,1610]],[[64927,64927],"mapped",[1578,1580,1610]],[[64928,64928],"mapped",[1578,1580,1609]],[[64929,64929],"mapped",[1578,1582,1610]],[[64930,64930],"mapped",[1578,1582,1609]],[[64931,64931],"mapped",[1578,1605,1610]],[[64932,64932],"mapped",[1578,1605,1609]],[[64933,64933],"mapped",[1580,1605,1610]],[[64934,64934],"mapped",[1580,1581,1609]],[[64935,64935],"mapped",[1580,1605,1609]],[[64936,64936],"mapped",[1587,1582,1609]],[[64937,64937],"mapped",[1589,1581,1610]],[[64938,64938],"mapped",[1588,1581,1610]],[[64939,64939],"mapped",[1590,1581,1610]],[[64940,64940],"mapped",[1604,1580,1610]],[[64941,64941],"mapped",[1604,1605,1610]],[[64942,64942],"mapped",[1610,1581,1610]],[[64943,64943],"mapped",[1610,1580,1610]],[[64944,64944],"mapped",[1610,1605,1610]],[[64945,64945],"mapped",[1605,1605,1610]],[[64946,64946],"mapped",[1602,1605,1610]],[[64947,64947],"mapped",[1606,1581,1610]],[[64948,64948],"mapped",[1602,1605,1581]],[[64949,64949],"mapped",[1604,1581,1605]],[[64950,64950],"mapped",[1593,1605,1610]],[[64951,64951],"mapped",[1603,1605,1610]],[[64952,64952],"mapped",[1606,1580,1581]],[[64953,64953],"mapped",[1605,1582,1610]],[[64954,64954],"mapped",[1604,1580,1605]],[[64955,64955],"mapped",[1603,1605,1605]],[[64956,64956],"mapped",[1604,1580,1605]],[[64957,64957],"mapped",[1606,1580,1581]],[[64958,64958],"mapped",[1580,1581,1610]],[[64959,64959],"mapped",[1581,1580,1610]],[[64960,64960],"mapped",[1605,1580,1610]],[[64961,64961],"mapped",[1601,1605,1610]],[[64962,64962],"mapped",[1576,1581,1610]],[[64963,64963],"mapped",[1603,1605,1605]],[[64964,64964],"mapped",[1593,1580,1605]],[[64965,64965],"mapped",[1589,1605,1605]],[[64966,64966],"mapped",[1587,1582,1610]],[[64967,64967],"mapped",[1606,1580,1610]],[[64968,64975],"disallowed"],[[64976,65007],"disallowed"],[[65008,65008],"mapped",[1589,1604,1746]],[[65009,65009],"mapped",[1602,1604,1746]],[[65010,65010],"mapped",[1575,1604,1604,1607]],[[65011,65011],"mapped",[1575,1603,1576,1585]],[[65012,65012],"mapped",[1605,1581,1605,1583]],[[65013,65013],"mapped",[1589,1604,1593,1605]],[[65014,65014],"mapped",[1585,1587,1608,1604]],[[65015,65015],"mapped",[1593,1604,1610,1607]],[[65016,65016],"mapped",[1608,1587,1604,1605]],[[65017,65017],"mapped",[1589,1604,1609]],[[65018,65018],"disallowed_STD3_mapped",[1589,1604,1609,32,1575,1604,1604,1607,32,1593,1604,1610,1607,32,1608,1587,1604,1605]],[[65019,65019],"disallowed_STD3_mapped",[1580,1604,32,1580,1604,1575,1604,1607]],[[65020,65020],"mapped",[1585,1740,1575,1604]],[[65021,65021],"valid",[],"NV8"],[[65022,65023],"disallowed"],[[65024,65039],"ignored"],[[65040,65040],"disallowed_STD3_mapped",[44]],[[65041,65041],"mapped",[12289]],[[65042,65042],"disallowed"],[[65043,65043],"disallowed_STD3_mapped",[58]],[[65044,65044],"disallowed_STD3_mapped",[59]],[[65045,65045],"disallowed_STD3_mapped",[33]],[[65046,65046],"disallowed_STD3_mapped",[63]],[[65047,65047],"mapped",[12310]],[[65048,65048],"mapped",[12311]],[[65049,65049],"disallowed"],[[65050,65055],"disallowed"],[[65056,65059],"valid"],[[65060,65062],"valid"],[[65063,65069],"valid"],[[65070,65071],"valid"],[[65072,65072],"disallowed"],[[65073,65073],"mapped",[8212]],[[65074,65074],"mapped",[8211]],[[65075,65076],"disallowed_STD3_mapped",[95]],[[65077,65077],"disallowed_STD3_mapped",[40]],[[65078,65078],"disallowed_STD3_mapped",[41]],[[65079,65079],"disallowed_STD3_mapped",[123]],[[65080,65080],"disallowed_STD3_mapped",[125]],[[65081,65081],"mapped",[12308]],[[65082,65082],"mapped",[12309]],[[65083,65083],"mapped",[12304]],[[65084,65084],"mapped",[12305]],[[65085,65085],"mapped",[12298]],[[65086,65086],"mapped",[12299]],[[65087,65087],"mapped",[12296]],[[65088,65088],"mapped",[12297]],[[65089,65089],"mapped",[12300]],[[65090,65090],"mapped",[12301]],[[65091,65091],"mapped",[12302]],[[65092,65092],"mapped",[12303]],[[65093,65094],"valid",[],"NV8"],[[65095,65095],"disallowed_STD3_mapped",[91]],[[65096,65096],"disallowed_STD3_mapped",[93]],[[65097,65100],"disallowed_STD3_mapped",[32,773]],[[65101,65103],"disallowed_STD3_mapped",[95]],[[65104,65104],"disallowed_STD3_mapped",[44]],[[65105,65105],"mapped",[12289]],[[65106,65106],"disallowed"],[[65107,65107],"disallowed"],[[65108,65108],"disallowed_STD3_mapped",[59]],[[65109,65109],"disallowed_STD3_mapped",[58]],[[65110,65110],"disallowed_STD3_mapped",[63]],[[65111,65111],"disallowed_STD3_mapped",[33]],[[65112,65112],"mapped",[8212]],[[65113,65113],"disallowed_STD3_mapped",[40]],[[65114,65114],"disallowed_STD3_mapped",[41]],[[65115,65115],"disallowed_STD3_mapped",[123]],[[65116,65116],"disallowed_STD3_mapped",[125]],[[65117,65117],"mapped",[12308]],[[65118,65118],"mapped",[12309]],[[65119,65119],"disallowed_STD3_mapped",[35]],[[65120,65120],"disallowed_STD3_mapped",[38]],[[65121,65121],"disallowed_STD3_mapped",[42]],[[65122,65122],"disallowed_STD3_mapped",[43]],[[65123,65123],"mapped",[45]],[[65124,65124],"disallowed_STD3_mapped",[60]],[[65125,65125],"disallowed_STD3_mapped",[62]],[[65126,65126],"disallowed_STD3_mapped",[61]],[[65127,65127],"disallowed"],[[65128,65128],"disallowed_STD3_mapped",[92]],[[65129,65129],"disallowed_STD3_mapped",[36]],[[65130,65130],"disallowed_STD3_mapped",[37]],[[65131,65131],"disallowed_STD3_mapped",[64]],[[65132,65135],"disallowed"],[[65136,65136],"disallowed_STD3_mapped",[32,1611]],[[65137,65137],"mapped",[1600,1611]],[[65138,65138],"disallowed_STD3_mapped",[32,1612]],[[65139,65139],"valid"],[[65140,65140],"disallowed_STD3_mapped",[32,1613]],[[65141,65141],"disallowed"],[[65142,65142],"disallowed_STD3_mapped",[32,1614]],[[65143,65143],"mapped",[1600,1614]],[[65144,65144],"disallowed_STD3_mapped",[32,1615]],[[65145,65145],"mapped",[1600,1615]],[[65146,65146],"disallowed_STD3_mapped",[32,1616]],[[65147,65147],"mapped",[1600,1616]],[[65148,65148],"disallowed_STD3_mapped",[32,1617]],[[65149,65149],"mapped",[1600,1617]],[[65150,65150],"disallowed_STD3_mapped",[32,1618]],[[65151,65151],"mapped",[1600,1618]],[[65152,65152],"mapped",[1569]],[[65153,65154],"mapped",[1570]],[[65155,65156],"mapped",[1571]],[[65157,65158],"mapped",[1572]],[[65159,65160],"mapped",[1573]],[[65161,65164],"mapped",[1574]],[[65165,65166],"mapped",[1575]],[[65167,65170],"mapped",[1576]],[[65171,65172],"mapped",[1577]],[[65173,65176],"mapped",[1578]],[[65177,65180],"mapped",[1579]],[[65181,65184],"mapped",[1580]],[[65185,65188],"mapped",[1581]],[[65189,65192],"mapped",[1582]],[[65193,65194],"mapped",[1583]],[[65195,65196],"mapped",[1584]],[[65197,65198],"mapped",[1585]],[[65199,65200],"mapped",[1586]],[[65201,65204],"mapped",[1587]],[[65205,65208],"mapped",[1588]],[[65209,65212],"mapped",[1589]],[[65213,65216],"mapped",[1590]],[[65217,65220],"mapped",[1591]],[[65221,65224],"mapped",[1592]],[[65225,65228],"mapped",[1593]],[[65229,65232],"mapped",[1594]],[[65233,65236],"mapped",[1601]],[[65237,65240],"mapped",[1602]],[[65241,65244],"mapped",[1603]],[[65245,65248],"mapped",[1604]],[[65249,65252],"mapped",[1605]],[[65253,65256],"mapped",[1606]],[[65257,65260],"mapped",[1607]],[[65261,65262],"mapped",[1608]],[[65263,65264],"mapped",[1609]],[[65265,65268],"mapped",[1610]],[[65269,65270],"mapped",[1604,1570]],[[65271,65272],"mapped",[1604,1571]],[[65273,65274],"mapped",[1604,1573]],[[65275,65276],"mapped",[1604,1575]],[[65277,65278],"disallowed"],[[65279,65279],"ignored"],[[65280,65280],"disallowed"],[[65281,65281],"disallowed_STD3_mapped",[33]],[[65282,65282],"disallowed_STD3_mapped",[34]],[[65283,65283],"disallowed_STD3_mapped",[35]],[[65284,65284],"disallowed_STD3_mapped",[36]],[[65285,65285],"disallowed_STD3_mapped",[37]],[[65286,65286],"disallowed_STD3_mapped",[38]],[[65287,65287],"disallowed_STD3_mapped",[39]],[[65288,65288],"disallowed_STD3_mapped",[40]],[[65289,65289],"disallowed_STD3_mapped",[41]],[[65290,65290],"disallowed_STD3_mapped",[42]],[[65291,65291],"disallowed_STD3_mapped",[43]],[[65292,65292],"disallowed_STD3_mapped",[44]],[[65293,65293],"mapped",[45]],[[65294,65294],"mapped",[46]],[[65295,65295],"disallowed_STD3_mapped",[47]],[[65296,65296],"mapped",[48]],[[65297,65297],"mapped",[49]],[[65298,65298],"mapped",[50]],[[65299,65299],"mapped",[51]],[[65300,65300],"mapped",[52]],[[65301,65301],"mapped",[53]],[[65302,65302],"mapped",[54]],[[65303,65303],"mapped",[55]],[[65304,65304],"mapped",[56]],[[65305,65305],"mapped",[57]],[[65306,65306],"disallowed_STD3_mapped",[58]],[[65307,65307],"disallowed_STD3_mapped",[59]],[[65308,65308],"disallowed_STD3_mapped",[60]],[[65309,65309],"disallowed_STD3_mapped",[61]],[[65310,65310],"disallowed_STD3_mapped",[62]],[[65311,65311],"disallowed_STD3_mapped",[63]],[[65312,65312],"disallowed_STD3_mapped",[64]],[[65313,65313],"mapped",[97]],[[65314,65314],"mapped",[98]],[[65315,65315],"mapped",[99]],[[65316,65316],"mapped",[100]],[[65317,65317],"mapped",[101]],[[65318,65318],"mapped",[102]],[[65319,65319],"mapped",[103]],[[65320,65320],"mapped",[104]],[[65321,65321],"mapped",[105]],[[65322,65322],"mapped",[106]],[[65323,65323],"mapped",[107]],[[65324,65324],"mapped",[108]],[[65325,65325],"mapped",[109]],[[65326,65326],"mapped",[110]],[[65327,65327],"mapped",[111]],[[65328,65328],"mapped",[112]],[[65329,65329],"mapped",[113]],[[65330,65330],"mapped",[114]],[[65331,65331],"mapped",[115]],[[65332,65332],"mapped",[116]],[[65333,65333],"mapped",[117]],[[65334,65334],"mapped",[118]],[[65335,65335],"mapped",[119]],[[65336,65336],"mapped",[120]],[[65337,65337],"mapped",[121]],[[65338,65338],"mapped",[122]],[[65339,65339],"disallowed_STD3_mapped",[91]],[[65340,65340],"disallowed_STD3_mapped",[92]],[[65341,65341],"disallowed_STD3_mapped",[93]],[[65342,65342],"disallowed_STD3_mapped",[94]],[[65343,65343],"disallowed_STD3_mapped",[95]],[[65344,65344],"disallowed_STD3_mapped",[96]],[[65345,65345],"mapped",[97]],[[65346,65346],"mapped",[98]],[[65347,65347],"mapped",[99]],[[65348,65348],"mapped",[100]],[[65349,65349],"mapped",[101]],[[65350,65350],"mapped",[102]],[[65351,65351],"mapped",[103]],[[65352,65352],"mapped",[104]],[[65353,65353],"mapped",[105]],[[65354,65354],"mapped",[106]],[[65355,65355],"mapped",[107]],[[65356,65356],"mapped",[108]],[[65357,65357],"mapped",[109]],[[65358,65358],"mapped",[110]],[[65359,65359],"mapped",[111]],[[65360,65360],"mapped",[112]],[[65361,65361],"mapped",[113]],[[65362,65362],"mapped",[114]],[[65363,65363],"mapped",[115]],[[65364,65364],"mapped",[116]],[[65365,65365],"mapped",[117]],[[65366,65366],"mapped",[118]],[[65367,65367],"mapped",[119]],[[65368,65368],"mapped",[120]],[[65369,65369],"mapped",[121]],[[65370,65370],"mapped",[122]],[[65371,65371],"disallowed_STD3_mapped",[123]],[[65372,65372],"disallowed_STD3_mapped",[124]],[[65373,65373],"disallowed_STD3_mapped",[125]],[[65374,65374],"disallowed_STD3_mapped",[126]],[[65375,65375],"mapped",[10629]],[[65376,65376],"mapped",[10630]],[[65377,65377],"mapped",[46]],[[65378,65378],"mapped",[12300]],[[65379,65379],"mapped",[12301]],[[65380,65380],"mapped",[12289]],[[65381,65381],"mapped",[12539]],[[65382,65382],"mapped",[12530]],[[65383,65383],"mapped",[12449]],[[65384,65384],"mapped",[12451]],[[65385,65385],"mapped",[12453]],[[65386,65386],"mapped",[12455]],[[65387,65387],"mapped",[12457]],[[65388,65388],"mapped",[12515]],[[65389,65389],"mapped",[12517]],[[65390,65390],"mapped",[12519]],[[65391,65391],"mapped",[12483]],[[65392,65392],"mapped",[12540]],[[65393,65393],"mapped",[12450]],[[65394,65394],"mapped",[12452]],[[65395,65395],"mapped",[12454]],[[65396,65396],"mapped",[12456]],[[65397,65397],"mapped",[12458]],[[65398,65398],"mapped",[12459]],[[65399,65399],"mapped",[12461]],[[65400,65400],"mapped",[12463]],[[65401,65401],"mapped",[12465]],[[65402,65402],"mapped",[12467]],[[65403,65403],"mapped",[12469]],[[65404,65404],"mapped",[12471]],[[65405,65405],"mapped",[12473]],[[65406,65406],"mapped",[12475]],[[65407,65407],"mapped",[12477]],[[65408,65408],"mapped",[12479]],[[65409,65409],"mapped",[12481]],[[65410,65410],"mapped",[12484]],[[65411,65411],"mapped",[12486]],[[65412,65412],"mapped",[12488]],[[65413,65413],"mapped",[12490]],[[65414,65414],"mapped",[12491]],[[65415,65415],"mapped",[12492]],[[65416,65416],"mapped",[12493]],[[65417,65417],"mapped",[12494]],[[65418,65418],"mapped",[12495]],[[65419,65419],"mapped",[12498]],[[65420,65420],"mapped",[12501]],[[65421,65421],"mapped",[12504]],[[65422,65422],"mapped",[12507]],[[65423,65423],"mapped",[12510]],[[65424,65424],"mapped",[12511]],[[65425,65425],"mapped",[12512]],[[65426,65426],"mapped",[12513]],[[65427,65427],"mapped",[12514]],[[65428,65428],"mapped",[12516]],[[65429,65429],"mapped",[12518]],[[65430,65430],"mapped",[12520]],[[65431,65431],"mapped",[12521]],[[65432,65432],"mapped",[12522]],[[65433,65433],"mapped",[12523]],[[65434,65434],"mapped",[12524]],[[65435,65435],"mapped",[12525]],[[65436,65436],"mapped",[12527]],[[65437,65437],"mapped",[12531]],[[65438,65438],"mapped",[12441]],[[65439,65439],"mapped",[12442]],[[65440,65440],"disallowed"],[[65441,65441],"mapped",[4352]],[[65442,65442],"mapped",[4353]],[[65443,65443],"mapped",[4522]],[[65444,65444],"mapped",[4354]],[[65445,65445],"mapped",[4524]],[[65446,65446],"mapped",[4525]],[[65447,65447],"mapped",[4355]],[[65448,65448],"mapped",[4356]],[[65449,65449],"mapped",[4357]],[[65450,65450],"mapped",[4528]],[[65451,65451],"mapped",[4529]],[[65452,65452],"mapped",[4530]],[[65453,65453],"mapped",[4531]],[[65454,65454],"mapped",[4532]],[[65455,65455],"mapped",[4533]],[[65456,65456],"mapped",[4378]],[[65457,65457],"mapped",[4358]],[[65458,65458],"mapped",[4359]],[[65459,65459],"mapped",[4360]],[[65460,65460],"mapped",[4385]],[[65461,65461],"mapped",[4361]],[[65462,65462],"mapped",[4362]],[[65463,65463],"mapped",[4363]],[[65464,65464],"mapped",[4364]],[[65465,65465],"mapped",[4365]],[[65466,65466],"mapped",[4366]],[[65467,65467],"mapped",[4367]],[[65468,65468],"mapped",[4368]],[[65469,65469],"mapped",[4369]],[[65470,65470],"mapped",[4370]],[[65471,65473],"disallowed"],[[65474,65474],"mapped",[4449]],[[65475,65475],"mapped",[4450]],[[65476,65476],"mapped",[4451]],[[65477,65477],"mapped",[4452]],[[65478,65478],"mapped",[4453]],[[65479,65479],"mapped",[4454]],[[65480,65481],"disallowed"],[[65482,65482],"mapped",[4455]],[[65483,65483],"mapped",[4456]],[[65484,65484],"mapped",[4457]],[[65485,65485],"mapped",[4458]],[[65486,65486],"mapped",[4459]],[[65487,65487],"mapped",[4460]],[[65488,65489],"disallowed"],[[65490,65490],"mapped",[4461]],[[65491,65491],"mapped",[4462]],[[65492,65492],"mapped",[4463]],[[65493,65493],"mapped",[4464]],[[65494,65494],"mapped",[4465]],[[65495,65495],"mapped",[4466]],[[65496,65497],"disallowed"],[[65498,65498],"mapped",[4467]],[[65499,65499],"mapped",[4468]],[[65500,65500],"mapped",[4469]],[[65501,65503],"disallowed"],[[65504,65504],"mapped",[162]],[[65505,65505],"mapped",[163]],[[65506,65506],"mapped",[172]],[[65507,65507],"disallowed_STD3_mapped",[32,772]],[[65508,65508],"mapped",[166]],[[65509,65509],"mapped",[165]],[[65510,65510],"mapped",[8361]],[[65511,65511],"disallowed"],[[65512,65512],"mapped",[9474]],[[65513,65513],"mapped",[8592]],[[65514,65514],"mapped",[8593]],[[65515,65515],"mapped",[8594]],[[65516,65516],"mapped",[8595]],[[65517,65517],"mapped",[9632]],[[65518,65518],"mapped",[9675]],[[65519,65528],"disallowed"],[[65529,65531],"disallowed"],[[65532,65532],"disallowed"],[[65533,65533],"disallowed"],[[65534,65535],"disallowed"],[[65536,65547],"valid"],[[65548,65548],"disallowed"],[[65549,65574],"valid"],[[65575,65575],"disallowed"],[[65576,65594],"valid"],[[65595,65595],"disallowed"],[[65596,65597],"valid"],[[65598,65598],"disallowed"],[[65599,65613],"valid"],[[65614,65615],"disallowed"],[[65616,65629],"valid"],[[65630,65663],"disallowed"],[[65664,65786],"valid"],[[65787,65791],"disallowed"],[[65792,65794],"valid",[],"NV8"],[[65795,65798],"disallowed"],[[65799,65843],"valid",[],"NV8"],[[65844,65846],"disallowed"],[[65847,65855],"valid",[],"NV8"],[[65856,65930],"valid",[],"NV8"],[[65931,65932],"valid",[],"NV8"],[[65933,65935],"disallowed"],[[65936,65947],"valid",[],"NV8"],[[65948,65951],"disallowed"],[[65952,65952],"valid",[],"NV8"],[[65953,65999],"disallowed"],[[66000,66044],"valid",[],"NV8"],[[66045,66045],"valid"],[[66046,66175],"disallowed"],[[66176,66204],"valid"],[[66205,66207],"disallowed"],[[66208,66256],"valid"],[[66257,66271],"disallowed"],[[66272,66272],"valid"],[[66273,66299],"valid",[],"NV8"],[[66300,66303],"disallowed"],[[66304,66334],"valid"],[[66335,66335],"valid"],[[66336,66339],"valid",[],"NV8"],[[66340,66351],"disallowed"],[[66352,66368],"valid"],[[66369,66369],"valid",[],"NV8"],[[66370,66377],"valid"],[[66378,66378],"valid",[],"NV8"],[[66379,66383],"disallowed"],[[66384,66426],"valid"],[[66427,66431],"disallowed"],[[66432,66461],"valid"],[[66462,66462],"disallowed"],[[66463,66463],"valid",[],"NV8"],[[66464,66499],"valid"],[[66500,66503],"disallowed"],[[66504,66511],"valid"],[[66512,66517],"valid",[],"NV8"],[[66518,66559],"disallowed"],[[66560,66560],"mapped",[66600]],[[66561,66561],"mapped",[66601]],[[66562,66562],"mapped",[66602]],[[66563,66563],"mapped",[66603]],[[66564,66564],"mapped",[66604]],[[66565,66565],"mapped",[66605]],[[66566,66566],"mapped",[66606]],[[66567,66567],"mapped",[66607]],[[66568,66568],"mapped",[66608]],[[66569,66569],"mapped",[66609]],[[66570,66570],"mapped",[66610]],[[66571,66571],"mapped",[66611]],[[66572,66572],"mapped",[66612]],[[66573,66573],"mapped",[66613]],[[66574,66574],"mapped",[66614]],[[66575,66575],"mapped",[66615]],[[66576,66576],"mapped",[66616]],[[66577,66577],"mapped",[66617]],[[66578,66578],"mapped",[66618]],[[66579,66579],"mapped",[66619]],[[66580,66580],"mapped",[66620]],[[66581,66581],"mapped",[66621]],[[66582,66582],"mapped",[66622]],[[66583,66583],"mapped",[66623]],[[66584,66584],"mapped",[66624]],[[66585,66585],"mapped",[66625]],[[66586,66586],"mapped",[66626]],[[66587,66587],"mapped",[66627]],[[66588,66588],"mapped",[66628]],[[66589,66589],"mapped",[66629]],[[66590,66590],"mapped",[66630]],[[66591,66591],"mapped",[66631]],[[66592,66592],"mapped",[66632]],[[66593,66593],"mapped",[66633]],[[66594,66594],"mapped",[66634]],[[66595,66595],"mapped",[66635]],[[66596,66596],"mapped",[66636]],[[66597,66597],"mapped",[66637]],[[66598,66598],"mapped",[66638]],[[66599,66599],"mapped",[66639]],[[66600,66637],"valid"],[[66638,66717],"valid"],[[66718,66719],"disallowed"],[[66720,66729],"valid"],[[66730,66815],"disallowed"],[[66816,66855],"valid"],[[66856,66863],"disallowed"],[[66864,66915],"valid"],[[66916,66926],"disallowed"],[[66927,66927],"valid",[],"NV8"],[[66928,67071],"disallowed"],[[67072,67382],"valid"],[[67383,67391],"disallowed"],[[67392,67413],"valid"],[[67414,67423],"disallowed"],[[67424,67431],"valid"],[[67432,67583],"disallowed"],[[67584,67589],"valid"],[[67590,67591],"disallowed"],[[67592,67592],"valid"],[[67593,67593],"disallowed"],[[67594,67637],"valid"],[[67638,67638],"disallowed"],[[67639,67640],"valid"],[[67641,67643],"disallowed"],[[67644,67644],"valid"],[[67645,67646],"disallowed"],[[67647,67647],"valid"],[[67648,67669],"valid"],[[67670,67670],"disallowed"],[[67671,67679],"valid",[],"NV8"],[[67680,67702],"valid"],[[67703,67711],"valid",[],"NV8"],[[67712,67742],"valid"],[[67743,67750],"disallowed"],[[67751,67759],"valid",[],"NV8"],[[67760,67807],"disallowed"],[[67808,67826],"valid"],[[67827,67827],"disallowed"],[[67828,67829],"valid"],[[67830,67834],"disallowed"],[[67835,67839],"valid",[],"NV8"],[[67840,67861],"valid"],[[67862,67865],"valid",[],"NV8"],[[67866,67867],"valid",[],"NV8"],[[67868,67870],"disallowed"],[[67871,67871],"valid",[],"NV8"],[[67872,67897],"valid"],[[67898,67902],"disallowed"],[[67903,67903],"valid",[],"NV8"],[[67904,67967],"disallowed"],[[67968,68023],"valid"],[[68024,68027],"disallowed"],[[68028,68029],"valid",[],"NV8"],[[68030,68031],"valid"],[[68032,68047],"valid",[],"NV8"],[[68048,68049],"disallowed"],[[68050,68095],"valid",[],"NV8"],[[68096,68099],"valid"],[[68100,68100],"disallowed"],[[68101,68102],"valid"],[[68103,68107],"disallowed"],[[68108,68115],"valid"],[[68116,68116],"disallowed"],[[68117,68119],"valid"],[[68120,68120],"disallowed"],[[68121,68147],"valid"],[[68148,68151],"disallowed"],[[68152,68154],"valid"],[[68155,68158],"disallowed"],[[68159,68159],"valid"],[[68160,68167],"valid",[],"NV8"],[[68168,68175],"disallowed"],[[68176,68184],"valid",[],"NV8"],[[68185,68191],"disallowed"],[[68192,68220],"valid"],[[68221,68223],"valid",[],"NV8"],[[68224,68252],"valid"],[[68253,68255],"valid",[],"NV8"],[[68256,68287],"disallowed"],[[68288,68295],"valid"],[[68296,68296],"valid",[],"NV8"],[[68297,68326],"valid"],[[68327,68330],"disallowed"],[[68331,68342],"valid",[],"NV8"],[[68343,68351],"disallowed"],[[68352,68405],"valid"],[[68406,68408],"disallowed"],[[68409,68415],"valid",[],"NV8"],[[68416,68437],"valid"],[[68438,68439],"disallowed"],[[68440,68447],"valid",[],"NV8"],[[68448,68466],"valid"],[[68467,68471],"disallowed"],[[68472,68479],"valid",[],"NV8"],[[68480,68497],"valid"],[[68498,68504],"disallowed"],[[68505,68508],"valid",[],"NV8"],[[68509,68520],"disallowed"],[[68521,68527],"valid",[],"NV8"],[[68528,68607],"disallowed"],[[68608,68680],"valid"],[[68681,68735],"disallowed"],[[68736,68736],"mapped",[68800]],[[68737,68737],"mapped",[68801]],[[68738,68738],"mapped",[68802]],[[68739,68739],"mapped",[68803]],[[68740,68740],"mapped",[68804]],[[68741,68741],"mapped",[68805]],[[68742,68742],"mapped",[68806]],[[68743,68743],"mapped",[68807]],[[68744,68744],"mapped",[68808]],[[68745,68745],"mapped",[68809]],[[68746,68746],"mapped",[68810]],[[68747,68747],"mapped",[68811]],[[68748,68748],"mapped",[68812]],[[68749,68749],"mapped",[68813]],[[68750,68750],"mapped",[68814]],[[68751,68751],"mapped",[68815]],[[68752,68752],"mapped",[68816]],[[68753,68753],"mapped",[68817]],[[68754,68754],"mapped",[68818]],[[68755,68755],"mapped",[68819]],[[68756,68756],"mapped",[68820]],[[68757,68757],"mapped",[68821]],[[68758,68758],"mapped",[68822]],[[68759,68759],"mapped",[68823]],[[68760,68760],"mapped",[68824]],[[68761,68761],"mapped",[68825]],[[68762,68762],"mapped",[68826]],[[68763,68763],"mapped",[68827]],[[68764,68764],"mapped",[68828]],[[68765,68765],"mapped",[68829]],[[68766,68766],"mapped",[68830]],[[68767,68767],"mapped",[68831]],[[68768,68768],"mapped",[68832]],[[68769,68769],"mapped",[68833]],[[68770,68770],"mapped",[68834]],[[68771,68771],"mapped",[68835]],[[68772,68772],"mapped",[68836]],[[68773,68773],"mapped",[68837]],[[68774,68774],"mapped",[68838]],[[68775,68775],"mapped",[68839]],[[68776,68776],"mapped",[68840]],[[68777,68777],"mapped",[68841]],[[68778,68778],"mapped",[68842]],[[68779,68779],"mapped",[68843]],[[68780,68780],"mapped",[68844]],[[68781,68781],"mapped",[68845]],[[68782,68782],"mapped",[68846]],[[68783,68783],"mapped",[68847]],[[68784,68784],"mapped",[68848]],[[68785,68785],"mapped",[68849]],[[68786,68786],"mapped",[68850]],[[68787,68799],"disallowed"],[[68800,68850],"valid"],[[68851,68857],"disallowed"],[[68858,68863],"valid",[],"NV8"],[[68864,69215],"disallowed"],[[69216,69246],"valid",[],"NV8"],[[69247,69631],"disallowed"],[[69632,69702],"valid"],[[69703,69709],"valid",[],"NV8"],[[69710,69713],"disallowed"],[[69714,69733],"valid",[],"NV8"],[[69734,69743],"valid"],[[69744,69758],"disallowed"],[[69759,69759],"valid"],[[69760,69818],"valid"],[[69819,69820],"valid",[],"NV8"],[[69821,69821],"disallowed"],[[69822,69825],"valid",[],"NV8"],[[69826,69839],"disallowed"],[[69840,69864],"valid"],[[69865,69871],"disallowed"],[[69872,69881],"valid"],[[69882,69887],"disallowed"],[[69888,69940],"valid"],[[69941,69941],"disallowed"],[[69942,69951],"valid"],[[69952,69955],"valid",[],"NV8"],[[69956,69967],"disallowed"],[[69968,70003],"valid"],[[70004,70005],"valid",[],"NV8"],[[70006,70006],"valid"],[[70007,70015],"disallowed"],[[70016,70084],"valid"],[[70085,70088],"valid",[],"NV8"],[[70089,70089],"valid",[],"NV8"],[[70090,70092],"valid"],[[70093,70093],"valid",[],"NV8"],[[70094,70095],"disallowed"],[[70096,70105],"valid"],[[70106,70106],"valid"],[[70107,70107],"valid",[],"NV8"],[[70108,70108],"valid"],[[70109,70111],"valid",[],"NV8"],[[70112,70112],"disallowed"],[[70113,70132],"valid",[],"NV8"],[[70133,70143],"disallowed"],[[70144,70161],"valid"],[[70162,70162],"disallowed"],[[70163,70199],"valid"],[[70200,70205],"valid",[],"NV8"],[[70206,70271],"disallowed"],[[70272,70278],"valid"],[[70279,70279],"disallowed"],[[70280,70280],"valid"],[[70281,70281],"disallowed"],[[70282,70285],"valid"],[[70286,70286],"disallowed"],[[70287,70301],"valid"],[[70302,70302],"disallowed"],[[70303,70312],"valid"],[[70313,70313],"valid",[],"NV8"],[[70314,70319],"disallowed"],[[70320,70378],"valid"],[[70379,70383],"disallowed"],[[70384,70393],"valid"],[[70394,70399],"disallowed"],[[70400,70400],"valid"],[[70401,70403],"valid"],[[70404,70404],"disallowed"],[[70405,70412],"valid"],[[70413,70414],"disallowed"],[[70415,70416],"valid"],[[70417,70418],"disallowed"],[[70419,70440],"valid"],[[70441,70441],"disallowed"],[[70442,70448],"valid"],[[70449,70449],"disallowed"],[[70450,70451],"valid"],[[70452,70452],"disallowed"],[[70453,70457],"valid"],[[70458,70459],"disallowed"],[[70460,70468],"valid"],[[70469,70470],"disallowed"],[[70471,70472],"valid"],[[70473,70474],"disallowed"],[[70475,70477],"valid"],[[70478,70479],"disallowed"],[[70480,70480],"valid"],[[70481,70486],"disallowed"],[[70487,70487],"valid"],[[70488,70492],"disallowed"],[[70493,70499],"valid"],[[70500,70501],"disallowed"],[[70502,70508],"valid"],[[70509,70511],"disallowed"],[[70512,70516],"valid"],[[70517,70783],"disallowed"],[[70784,70853],"valid"],[[70854,70854],"valid",[],"NV8"],[[70855,70855],"valid"],[[70856,70863],"disallowed"],[[70864,70873],"valid"],[[70874,71039],"disallowed"],[[71040,71093],"valid"],[[71094,71095],"disallowed"],[[71096,71104],"valid"],[[71105,71113],"valid",[],"NV8"],[[71114,71127],"valid",[],"NV8"],[[71128,71133],"valid"],[[71134,71167],"disallowed"],[[71168,71232],"valid"],[[71233,71235],"valid",[],"NV8"],[[71236,71236],"valid"],[[71237,71247],"disallowed"],[[71248,71257],"valid"],[[71258,71295],"disallowed"],[[71296,71351],"valid"],[[71352,71359],"disallowed"],[[71360,71369],"valid"],[[71370,71423],"disallowed"],[[71424,71449],"valid"],[[71450,71452],"disallowed"],[[71453,71467],"valid"],[[71468,71471],"disallowed"],[[71472,71481],"valid"],[[71482,71487],"valid",[],"NV8"],[[71488,71839],"disallowed"],[[71840,71840],"mapped",[71872]],[[71841,71841],"mapped",[71873]],[[71842,71842],"mapped",[71874]],[[71843,71843],"mapped",[71875]],[[71844,71844],"mapped",[71876]],[[71845,71845],"mapped",[71877]],[[71846,71846],"mapped",[71878]],[[71847,71847],"mapped",[71879]],[[71848,71848],"mapped",[71880]],[[71849,71849],"mapped",[71881]],[[71850,71850],"mapped",[71882]],[[71851,71851],"mapped",[71883]],[[71852,71852],"mapped",[71884]],[[71853,71853],"mapped",[71885]],[[71854,71854],"mapped",[71886]],[[71855,71855],"mapped",[71887]],[[71856,71856],"mapped",[71888]],[[71857,71857],"mapped",[71889]],[[71858,71858],"mapped",[71890]],[[71859,71859],"mapped",[71891]],[[71860,71860],"mapped",[71892]],[[71861,71861],"mapped",[71893]],[[71862,71862],"mapped",[71894]],[[71863,71863],"mapped",[71895]],[[71864,71864],"mapped",[71896]],[[71865,71865],"mapped",[71897]],[[71866,71866],"mapped",[71898]],[[71867,71867],"mapped",[71899]],[[71868,71868],"mapped",[71900]],[[71869,71869],"mapped",[71901]],[[71870,71870],"mapped",[71902]],[[71871,71871],"mapped",[71903]],[[71872,71913],"valid"],[[71914,71922],"valid",[],"NV8"],[[71923,71934],"disallowed"],[[71935,71935],"valid"],[[71936,72383],"disallowed"],[[72384,72440],"valid"],[[72441,73727],"disallowed"],[[73728,74606],"valid"],[[74607,74648],"valid"],[[74649,74649],"valid"],[[74650,74751],"disallowed"],[[74752,74850],"valid",[],"NV8"],[[74851,74862],"valid",[],"NV8"],[[74863,74863],"disallowed"],[[74864,74867],"valid",[],"NV8"],[[74868,74868],"valid",[],"NV8"],[[74869,74879],"disallowed"],[[74880,75075],"valid"],[[75076,77823],"disallowed"],[[77824,78894],"valid"],[[78895,82943],"disallowed"],[[82944,83526],"valid"],[[83527,92159],"disallowed"],[[92160,92728],"valid"],[[92729,92735],"disallowed"],[[92736,92766],"valid"],[[92767,92767],"disallowed"],[[92768,92777],"valid"],[[92778,92781],"disallowed"],[[92782,92783],"valid",[],"NV8"],[[92784,92879],"disallowed"],[[92880,92909],"valid"],[[92910,92911],"disallowed"],[[92912,92916],"valid"],[[92917,92917],"valid",[],"NV8"],[[92918,92927],"disallowed"],[[92928,92982],"valid"],[[92983,92991],"valid",[],"NV8"],[[92992,92995],"valid"],[[92996,92997],"valid",[],"NV8"],[[92998,93007],"disallowed"],[[93008,93017],"valid"],[[93018,93018],"disallowed"],[[93019,93025],"valid",[],"NV8"],[[93026,93026],"disallowed"],[[93027,93047],"valid"],[[93048,93052],"disallowed"],[[93053,93071],"valid"],[[93072,93951],"disallowed"],[[93952,94020],"valid"],[[94021,94031],"disallowed"],[[94032,94078],"valid"],[[94079,94094],"disallowed"],[[94095,94111],"valid"],[[94112,110591],"disallowed"],[[110592,110593],"valid"],[[110594,113663],"disallowed"],[[113664,113770],"valid"],[[113771,113775],"disallowed"],[[113776,113788],"valid"],[[113789,113791],"disallowed"],[[113792,113800],"valid"],[[113801,113807],"disallowed"],[[113808,113817],"valid"],[[113818,113819],"disallowed"],[[113820,113820],"valid",[],"NV8"],[[113821,113822],"valid"],[[113823,113823],"valid",[],"NV8"],[[113824,113827],"ignored"],[[113828,118783],"disallowed"],[[118784,119029],"valid",[],"NV8"],[[119030,119039],"disallowed"],[[119040,119078],"valid",[],"NV8"],[[119079,119080],"disallowed"],[[119081,119081],"valid",[],"NV8"],[[119082,119133],"valid",[],"NV8"],[[119134,119134],"mapped",[119127,119141]],[[119135,119135],"mapped",[119128,119141]],[[119136,119136],"mapped",[119128,119141,119150]],[[119137,119137],"mapped",[119128,119141,119151]],[[119138,119138],"mapped",[119128,119141,119152]],[[119139,119139],"mapped",[119128,119141,119153]],[[119140,119140],"mapped",[119128,119141,119154]],[[119141,119154],"valid",[],"NV8"],[[119155,119162],"disallowed"],[[119163,119226],"valid",[],"NV8"],[[119227,119227],"mapped",[119225,119141]],[[119228,119228],"mapped",[119226,119141]],[[119229,119229],"mapped",[119225,119141,119150]],[[119230,119230],"mapped",[119226,119141,119150]],[[119231,119231],"mapped",[119225,119141,119151]],[[119232,119232],"mapped",[119226,119141,119151]],[[119233,119261],"valid",[],"NV8"],[[119262,119272],"valid",[],"NV8"],[[119273,119295],"disallowed"],[[119296,119365],"valid",[],"NV8"],[[119366,119551],"disallowed"],[[119552,119638],"valid",[],"NV8"],[[119639,119647],"disallowed"],[[119648,119665],"valid",[],"NV8"],[[119666,119807],"disallowed"],[[119808,119808],"mapped",[97]],[[119809,119809],"mapped",[98]],[[119810,119810],"mapped",[99]],[[119811,119811],"mapped",[100]],[[119812,119812],"mapped",[101]],[[119813,119813],"mapped",[102]],[[119814,119814],"mapped",[103]],[[119815,119815],"mapped",[104]],[[119816,119816],"mapped",[105]],[[119817,119817],"mapped",[106]],[[119818,119818],"mapped",[107]],[[119819,119819],"mapped",[108]],[[119820,119820],"mapped",[109]],[[119821,119821],"mapped",[110]],[[119822,119822],"mapped",[111]],[[119823,119823],"mapped",[112]],[[119824,119824],"mapped",[113]],[[119825,119825],"mapped",[114]],[[119826,119826],"mapped",[115]],[[119827,119827],"mapped",[116]],[[119828,119828],"mapped",[117]],[[119829,119829],"mapped",[118]],[[119830,119830],"mapped",[119]],[[119831,119831],"mapped",[120]],[[119832,119832],"mapped",[121]],[[119833,119833],"mapped",[122]],[[119834,119834],"mapped",[97]],[[119835,119835],"mapped",[98]],[[119836,119836],"mapped",[99]],[[119837,119837],"mapped",[100]],[[119838,119838],"mapped",[101]],[[119839,119839],"mapped",[102]],[[119840,119840],"mapped",[103]],[[119841,119841],"mapped",[104]],[[119842,119842],"mapped",[105]],[[119843,119843],"mapped",[106]],[[119844,119844],"mapped",[107]],[[119845,119845],"mapped",[108]],[[119846,119846],"mapped",[109]],[[119847,119847],"mapped",[110]],[[119848,119848],"mapped",[111]],[[119849,119849],"mapped",[112]],[[119850,119850],"mapped",[113]],[[119851,119851],"mapped",[114]],[[119852,119852],"mapped",[115]],[[119853,119853],"mapped",[116]],[[119854,119854],"mapped",[117]],[[119855,119855],"mapped",[118]],[[119856,119856],"mapped",[119]],[[119857,119857],"mapped",[120]],[[119858,119858],"mapped",[121]],[[119859,119859],"mapped",[122]],[[119860,119860],"mapped",[97]],[[119861,119861],"mapped",[98]],[[119862,119862],"mapped",[99]],[[119863,119863],"mapped",[100]],[[119864,119864],"mapped",[101]],[[119865,119865],"mapped",[102]],[[119866,119866],"mapped",[103]],[[119867,119867],"mapped",[104]],[[119868,119868],"mapped",[105]],[[119869,119869],"mapped",[106]],[[119870,119870],"mapped",[107]],[[119871,119871],"mapped",[108]],[[119872,119872],"mapped",[109]],[[119873,119873],"mapped",[110]],[[119874,119874],"mapped",[111]],[[119875,119875],"mapped",[112]],[[119876,119876],"mapped",[113]],[[119877,119877],"mapped",[114]],[[119878,119878],"mapped",[115]],[[119879,119879],"mapped",[116]],[[119880,119880],"mapped",[117]],[[119881,119881],"mapped",[118]],[[119882,119882],"mapped",[119]],[[119883,119883],"mapped",[120]],[[119884,119884],"mapped",[121]],[[119885,119885],"mapped",[122]],[[119886,119886],"mapped",[97]],[[119887,119887],"mapped",[98]],[[119888,119888],"mapped",[99]],[[119889,119889],"mapped",[100]],[[119890,119890],"mapped",[101]],[[119891,119891],"mapped",[102]],[[119892,119892],"mapped",[103]],[[119893,119893],"disallowed"],[[119894,119894],"mapped",[105]],[[119895,119895],"mapped",[106]],[[119896,119896],"mapped",[107]],[[119897,119897],"mapped",[108]],[[119898,119898],"mapped",[109]],[[119899,119899],"mapped",[110]],[[119900,119900],"mapped",[111]],[[119901,119901],"mapped",[112]],[[119902,119902],"mapped",[113]],[[119903,119903],"mapped",[114]],[[119904,119904],"mapped",[115]],[[119905,119905],"mapped",[116]],[[119906,119906],"mapped",[117]],[[119907,119907],"mapped",[118]],[[119908,119908],"mapped",[119]],[[119909,119909],"mapped",[120]],[[119910,119910],"mapped",[121]],[[119911,119911],"mapped",[122]],[[119912,119912],"mapped",[97]],[[119913,119913],"mapped",[98]],[[119914,119914],"mapped",[99]],[[119915,119915],"mapped",[100]],[[119916,119916],"mapped",[101]],[[119917,119917],"mapped",[102]],[[119918,119918],"mapped",[103]],[[119919,119919],"mapped",[104]],[[119920,119920],"mapped",[105]],[[119921,119921],"mapped",[106]],[[119922,119922],"mapped",[107]],[[119923,119923],"mapped",[108]],[[119924,119924],"mapped",[109]],[[119925,119925],"mapped",[110]],[[119926,119926],"mapped",[111]],[[119927,119927],"mapped",[112]],[[119928,119928],"mapped",[113]],[[119929,119929],"mapped",[114]],[[119930,119930],"mapped",[115]],[[119931,119931],"mapped",[116]],[[119932,119932],"mapped",[117]],[[119933,119933],"mapped",[118]],[[119934,119934],"mapped",[119]],[[119935,119935],"mapped",[120]],[[119936,119936],"mapped",[121]],[[119937,119937],"mapped",[122]],[[119938,119938],"mapped",[97]],[[119939,119939],"mapped",[98]],[[119940,119940],"mapped",[99]],[[119941,119941],"mapped",[100]],[[119942,119942],"mapped",[101]],[[119943,119943],"mapped",[102]],[[119944,119944],"mapped",[103]],[[119945,119945],"mapped",[104]],[[119946,119946],"mapped",[105]],[[119947,119947],"mapped",[106]],[[119948,119948],"mapped",[107]],[[119949,119949],"mapped",[108]],[[119950,119950],"mapped",[109]],[[119951,119951],"mapped",[110]],[[119952,119952],"mapped",[111]],[[119953,119953],"mapped",[112]],[[119954,119954],"mapped",[113]],[[119955,119955],"mapped",[114]],[[119956,119956],"mapped",[115]],[[119957,119957],"mapped",[116]],[[119958,119958],"mapped",[117]],[[119959,119959],"mapped",[118]],[[119960,119960],"mapped",[119]],[[119961,119961],"mapped",[120]],[[119962,119962],"mapped",[121]],[[119963,119963],"mapped",[122]],[[119964,119964],"mapped",[97]],[[119965,119965],"disallowed"],[[119966,119966],"mapped",[99]],[[119967,119967],"mapped",[100]],[[119968,119969],"disallowed"],[[119970,119970],"mapped",[103]],[[119971,119972],"disallowed"],[[119973,119973],"mapped",[106]],[[119974,119974],"mapped",[107]],[[119975,119976],"disallowed"],[[119977,119977],"mapped",[110]],[[119978,119978],"mapped",[111]],[[119979,119979],"mapped",[112]],[[119980,119980],"mapped",[113]],[[119981,119981],"disallowed"],[[119982,119982],"mapped",[115]],[[119983,119983],"mapped",[116]],[[119984,119984],"mapped",[117]],[[119985,119985],"mapped",[118]],[[119986,119986],"mapped",[119]],[[119987,119987],"mapped",[120]],[[119988,119988],"mapped",[121]],[[119989,119989],"mapped",[122]],[[119990,119990],"mapped",[97]],[[119991,119991],"mapped",[98]],[[119992,119992],"mapped",[99]],[[119993,119993],"mapped",[100]],[[119994,119994],"disallowed"],[[119995,119995],"mapped",[102]],[[119996,119996],"disallowed"],[[119997,119997],"mapped",[104]],[[119998,119998],"mapped",[105]],[[119999,119999],"mapped",[106]],[[120000,120000],"mapped",[107]],[[120001,120001],"mapped",[108]],[[120002,120002],"mapped",[109]],[[120003,120003],"mapped",[110]],[[120004,120004],"disallowed"],[[120005,120005],"mapped",[112]],[[120006,120006],"mapped",[113]],[[120007,120007],"mapped",[114]],[[120008,120008],"mapped",[115]],[[120009,120009],"mapped",[116]],[[120010,120010],"mapped",[117]],[[120011,120011],"mapped",[118]],[[120012,120012],"mapped",[119]],[[120013,120013],"mapped",[120]],[[120014,120014],"mapped",[121]],[[120015,120015],"mapped",[122]],[[120016,120016],"mapped",[97]],[[120017,120017],"mapped",[98]],[[120018,120018],"mapped",[99]],[[120019,120019],"mapped",[100]],[[120020,120020],"mapped",[101]],[[120021,120021],"mapped",[102]],[[120022,120022],"mapped",[103]],[[120023,120023],"mapped",[104]],[[120024,120024],"mapped",[105]],[[120025,120025],"mapped",[106]],[[120026,120026],"mapped",[107]],[[120027,120027],"mapped",[108]],[[120028,120028],"mapped",[109]],[[120029,120029],"mapped",[110]],[[120030,120030],"mapped",[111]],[[120031,120031],"mapped",[112]],[[120032,120032],"mapped",[113]],[[120033,120033],"mapped",[114]],[[120034,120034],"mapped",[115]],[[120035,120035],"mapped",[116]],[[120036,120036],"mapped",[117]],[[120037,120037],"mapped",[118]],[[120038,120038],"mapped",[119]],[[120039,120039],"mapped",[120]],[[120040,120040],"mapped",[121]],[[120041,120041],"mapped",[122]],[[120042,120042],"mapped",[97]],[[120043,120043],"mapped",[98]],[[120044,120044],"mapped",[99]],[[120045,120045],"mapped",[100]],[[120046,120046],"mapped",[101]],[[120047,120047],"mapped",[102]],[[120048,120048],"mapped",[103]],[[120049,120049],"mapped",[104]],[[120050,120050],"mapped",[105]],[[120051,120051],"mapped",[106]],[[120052,120052],"mapped",[107]],[[120053,120053],"mapped",[108]],[[120054,120054],"mapped",[109]],[[120055,120055],"mapped",[110]],[[120056,120056],"mapped",[111]],[[120057,120057],"mapped",[112]],[[120058,120058],"mapped",[113]],[[120059,120059],"mapped",[114]],[[120060,120060],"mapped",[115]],[[120061,120061],"mapped",[116]],[[120062,120062],"mapped",[117]],[[120063,120063],"mapped",[118]],[[120064,120064],"mapped",[119]],[[120065,120065],"mapped",[120]],[[120066,120066],"mapped",[121]],[[120067,120067],"mapped",[122]],[[120068,120068],"mapped",[97]],[[120069,120069],"mapped",[98]],[[120070,120070],"disallowed"],[[120071,120071],"mapped",[100]],[[120072,120072],"mapped",[101]],[[120073,120073],"mapped",[102]],[[120074,120074],"mapped",[103]],[[120075,120076],"disallowed"],[[120077,120077],"mapped",[106]],[[120078,120078],"mapped",[107]],[[120079,120079],"mapped",[108]],[[120080,120080],"mapped",[109]],[[120081,120081],"mapped",[110]],[[120082,120082],"mapped",[111]],[[120083,120083],"mapped",[112]],[[120084,120084],"mapped",[113]],[[120085,120085],"disallowed"],[[120086,120086],"mapped",[115]],[[120087,120087],"mapped",[116]],[[120088,120088],"mapped",[117]],[[120089,120089],"mapped",[118]],[[120090,120090],"mapped",[119]],[[120091,120091],"mapped",[120]],[[120092,120092],"mapped",[121]],[[120093,120093],"disallowed"],[[120094,120094],"mapped",[97]],[[120095,120095],"mapped",[98]],[[120096,120096],"mapped",[99]],[[120097,120097],"mapped",[100]],[[120098,120098],"mapped",[101]],[[120099,120099],"mapped",[102]],[[120100,120100],"mapped",[103]],[[120101,120101],"mapped",[104]],[[120102,120102],"mapped",[105]],[[120103,120103],"mapped",[106]],[[120104,120104],"mapped",[107]],[[120105,120105],"mapped",[108]],[[120106,120106],"mapped",[109]],[[120107,120107],"mapped",[110]],[[120108,120108],"mapped",[111]],[[120109,120109],"mapped",[112]],[[120110,120110],"mapped",[113]],[[120111,120111],"mapped",[114]],[[120112,120112],"mapped",[115]],[[120113,120113],"mapped",[116]],[[120114,120114],"mapped",[117]],[[120115,120115],"mapped",[118]],[[120116,120116],"mapped",[119]],[[120117,120117],"mapped",[120]],[[120118,120118],"mapped",[121]],[[120119,120119],"mapped",[122]],[[120120,120120],"mapped",[97]],[[120121,120121],"mapped",[98]],[[120122,120122],"disallowed"],[[120123,120123],"mapped",[100]],[[120124,120124],"mapped",[101]],[[120125,120125],"mapped",[102]],[[120126,120126],"mapped",[103]],[[120127,120127],"disallowed"],[[120128,120128],"mapped",[105]],[[120129,120129],"mapped",[106]],[[120130,120130],"mapped",[107]],[[120131,120131],"mapped",[108]],[[120132,120132],"mapped",[109]],[[120133,120133],"disallowed"],[[120134,120134],"mapped",[111]],[[120135,120137],"disallowed"],[[120138,120138],"mapped",[115]],[[120139,120139],"mapped",[116]],[[120140,120140],"mapped",[117]],[[120141,120141],"mapped",[118]],[[120142,120142],"mapped",[119]],[[120143,120143],"mapped",[120]],[[120144,120144],"mapped",[121]],[[120145,120145],"disallowed"],[[120146,120146],"mapped",[97]],[[120147,120147],"mapped",[98]],[[120148,120148],"mapped",[99]],[[120149,120149],"mapped",[100]],[[120150,120150],"mapped",[101]],[[120151,120151],"mapped",[102]],[[120152,120152],"mapped",[103]],[[120153,120153],"mapped",[104]],[[120154,120154],"mapped",[105]],[[120155,120155],"mapped",[106]],[[120156,120156],"mapped",[107]],[[120157,120157],"mapped",[108]],[[120158,120158],"mapped",[109]],[[120159,120159],"mapped",[110]],[[120160,120160],"mapped",[111]],[[120161,120161],"mapped",[112]],[[120162,120162],"mapped",[113]],[[120163,120163],"mapped",[114]],[[120164,120164],"mapped",[115]],[[120165,120165],"mapped",[116]],[[120166,120166],"mapped",[117]],[[120167,120167],"mapped",[118]],[[120168,120168],"mapped",[119]],[[120169,120169],"mapped",[120]],[[120170,120170],"mapped",[121]],[[120171,120171],"mapped",[122]],[[120172,120172],"mapped",[97]],[[120173,120173],"mapped",[98]],[[120174,120174],"mapped",[99]],[[120175,120175],"mapped",[100]],[[120176,120176],"mapped",[101]],[[120177,120177],"mapped",[102]],[[120178,120178],"mapped",[103]],[[120179,120179],"mapped",[104]],[[120180,120180],"mapped",[105]],[[120181,120181],"mapped",[106]],[[120182,120182],"mapped",[107]],[[120183,120183],"mapped",[108]],[[120184,120184],"mapped",[109]],[[120185,120185],"mapped",[110]],[[120186,120186],"mapped",[111]],[[120187,120187],"mapped",[112]],[[120188,120188],"mapped",[113]],[[120189,120189],"mapped",[114]],[[120190,120190],"mapped",[115]],[[120191,120191],"mapped",[116]],[[120192,120192],"mapped",[117]],[[120193,120193],"mapped",[118]],[[120194,120194],"mapped",[119]],[[120195,120195],"mapped",[120]],[[120196,120196],"mapped",[121]],[[120197,120197],"mapped",[122]],[[120198,120198],"mapped",[97]],[[120199,120199],"mapped",[98]],[[120200,120200],"mapped",[99]],[[120201,120201],"mapped",[100]],[[120202,120202],"mapped",[101]],[[120203,120203],"mapped",[102]],[[120204,120204],"mapped",[103]],[[120205,120205],"mapped",[104]],[[120206,120206],"mapped",[105]],[[120207,120207],"mapped",[106]],[[120208,120208],"mapped",[107]],[[120209,120209],"mapped",[108]],[[120210,120210],"mapped",[109]],[[120211,120211],"mapped",[110]],[[120212,120212],"mapped",[111]],[[120213,120213],"mapped",[112]],[[120214,120214],"mapped",[113]],[[120215,120215],"mapped",[114]],[[120216,120216],"mapped",[115]],[[120217,120217],"mapped",[116]],[[120218,120218],"mapped",[117]],[[120219,120219],"mapped",[118]],[[120220,120220],"mapped",[119]],[[120221,120221],"mapped",[120]],[[120222,120222],"mapped",[121]],[[120223,120223],"mapped",[122]],[[120224,120224],"mapped",[97]],[[120225,120225],"mapped",[98]],[[120226,120226],"mapped",[99]],[[120227,120227],"mapped",[100]],[[120228,120228],"mapped",[101]],[[120229,120229],"mapped",[102]],[[120230,120230],"mapped",[103]],[[120231,120231],"mapped",[104]],[[120232,120232],"mapped",[105]],[[120233,120233],"mapped",[106]],[[120234,120234],"mapped",[107]],[[120235,120235],"mapped",[108]],[[120236,120236],"mapped",[109]],[[120237,120237],"mapped",[110]],[[120238,120238],"mapped",[111]],[[120239,120239],"mapped",[112]],[[120240,120240],"mapped",[113]],[[120241,120241],"mapped",[114]],[[120242,120242],"mapped",[115]],[[120243,120243],"mapped",[116]],[[120244,120244],"mapped",[117]],[[120245,120245],"mapped",[118]],[[120246,120246],"mapped",[119]],[[120247,120247],"mapped",[120]],[[120248,120248],"mapped",[121]],[[120249,120249],"mapped",[122]],[[120250,120250],"mapped",[97]],[[120251,120251],"mapped",[98]],[[120252,120252],"mapped",[99]],[[120253,120253],"mapped",[100]],[[120254,120254],"mapped",[101]],[[120255,120255],"mapped",[102]],[[120256,120256],"mapped",[103]],[[120257,120257],"mapped",[104]],[[120258,120258],"mapped",[105]],[[120259,120259],"mapped",[106]],[[120260,120260],"mapped",[107]],[[120261,120261],"mapped",[108]],[[120262,120262],"mapped",[109]],[[120263,120263],"mapped",[110]],[[120264,120264],"mapped",[111]],[[120265,120265],"mapped",[112]],[[120266,120266],"mapped",[113]],[[120267,120267],"mapped",[114]],[[120268,120268],"mapped",[115]],[[120269,120269],"mapped",[116]],[[120270,120270],"mapped",[117]],[[120271,120271],"mapped",[118]],[[120272,120272],"mapped",[119]],[[120273,120273],"mapped",[120]],[[120274,120274],"mapped",[121]],[[120275,120275],"mapped",[122]],[[120276,120276],"mapped",[97]],[[120277,120277],"mapped",[98]],[[120278,120278],"mapped",[99]],[[120279,120279],"mapped",[100]],[[120280,120280],"mapped",[101]],[[120281,120281],"mapped",[102]],[[120282,120282],"mapped",[103]],[[120283,120283],"mapped",[104]],[[120284,120284],"mapped",[105]],[[120285,120285],"mapped",[106]],[[120286,120286],"mapped",[107]],[[120287,120287],"mapped",[108]],[[120288,120288],"mapped",[109]],[[120289,120289],"mapped",[110]],[[120290,120290],"mapped",[111]],[[120291,120291],"mapped",[112]],[[120292,120292],"mapped",[113]],[[120293,120293],"mapped",[114]],[[120294,120294],"mapped",[115]],[[120295,120295],"mapped",[116]],[[120296,120296],"mapped",[117]],[[120297,120297],"mapped",[118]],[[120298,120298],"mapped",[119]],[[120299,120299],"mapped",[120]],[[120300,120300],"mapped",[121]],[[120301,120301],"mapped",[122]],[[120302,120302],"mapped",[97]],[[120303,120303],"mapped",[98]],[[120304,120304],"mapped",[99]],[[120305,120305],"mapped",[100]],[[120306,120306],"mapped",[101]],[[120307,120307],"mapped",[102]],[[120308,120308],"mapped",[103]],[[120309,120309],"mapped",[104]],[[120310,120310],"mapped",[105]],[[120311,120311],"mapped",[106]],[[120312,120312],"mapped",[107]],[[120313,120313],"mapped",[108]],[[120314,120314],"mapped",[109]],[[120315,120315],"mapped",[110]],[[120316,120316],"mapped",[111]],[[120317,120317],"mapped",[112]],[[120318,120318],"mapped",[113]],[[120319,120319],"mapped",[114]],[[120320,120320],"mapped",[115]],[[120321,120321],"mapped",[116]],[[120322,120322],"mapped",[117]],[[120323,120323],"mapped",[118]],[[120324,120324],"mapped",[119]],[[120325,120325],"mapped",[120]],[[120326,120326],"mapped",[121]],[[120327,120327],"mapped",[122]],[[120328,120328],"mapped",[97]],[[120329,120329],"mapped",[98]],[[120330,120330],"mapped",[99]],[[120331,120331],"mapped",[100]],[[120332,120332],"mapped",[101]],[[120333,120333],"mapped",[102]],[[120334,120334],"mapped",[103]],[[120335,120335],"mapped",[104]],[[120336,120336],"mapped",[105]],[[120337,120337],"mapped",[106]],[[120338,120338],"mapped",[107]],[[120339,120339],"mapped",[108]],[[120340,120340],"mapped",[109]],[[120341,120341],"mapped",[110]],[[120342,120342],"mapped",[111]],[[120343,120343],"mapped",[112]],[[120344,120344],"mapped",[113]],[[120345,120345],"mapped",[114]],[[120346,120346],"mapped",[115]],[[120347,120347],"mapped",[116]],[[120348,120348],"mapped",[117]],[[120349,120349],"mapped",[118]],[[120350,120350],"mapped",[119]],[[120351,120351],"mapped",[120]],[[120352,120352],"mapped",[121]],[[120353,120353],"mapped",[122]],[[120354,120354],"mapped",[97]],[[120355,120355],"mapped",[98]],[[120356,120356],"mapped",[99]],[[120357,120357],"mapped",[100]],[[120358,120358],"mapped",[101]],[[120359,120359],"mapped",[102]],[[120360,120360],"mapped",[103]],[[120361,120361],"mapped",[104]],[[120362,120362],"mapped",[105]],[[120363,120363],"mapped",[106]],[[120364,120364],"mapped",[107]],[[120365,120365],"mapped",[108]],[[120366,120366],"mapped",[109]],[[120367,120367],"mapped",[110]],[[120368,120368],"mapped",[111]],[[120369,120369],"mapped",[112]],[[120370,120370],"mapped",[113]],[[120371,120371],"mapped",[114]],[[120372,120372],"mapped",[115]],[[120373,120373],"mapped",[116]],[[120374,120374],"mapped",[117]],[[120375,120375],"mapped",[118]],[[120376,120376],"mapped",[119]],[[120377,120377],"mapped",[120]],[[120378,120378],"mapped",[121]],[[120379,120379],"mapped",[122]],[[120380,120380],"mapped",[97]],[[120381,120381],"mapped",[98]],[[120382,120382],"mapped",[99]],[[120383,120383],"mapped",[100]],[[120384,120384],"mapped",[101]],[[120385,120385],"mapped",[102]],[[120386,120386],"mapped",[103]],[[120387,120387],"mapped",[104]],[[120388,120388],"mapped",[105]],[[120389,120389],"mapped",[106]],[[120390,120390],"mapped",[107]],[[120391,120391],"mapped",[108]],[[120392,120392],"mapped",[109]],[[120393,120393],"mapped",[110]],[[120394,120394],"mapped",[111]],[[120395,120395],"mapped",[112]],[[120396,120396],"mapped",[113]],[[120397,120397],"mapped",[114]],[[120398,120398],"mapped",[115]],[[120399,120399],"mapped",[116]],[[120400,120400],"mapped",[117]],[[120401,120401],"mapped",[118]],[[120402,120402],"mapped",[119]],[[120403,120403],"mapped",[120]],[[120404,120404],"mapped",[121]],[[120405,120405],"mapped",[122]],[[120406,120406],"mapped",[97]],[[120407,120407],"mapped",[98]],[[120408,120408],"mapped",[99]],[[120409,120409],"mapped",[100]],[[120410,120410],"mapped",[101]],[[120411,120411],"mapped",[102]],[[120412,120412],"mapped",[103]],[[120413,120413],"mapped",[104]],[[120414,120414],"mapped",[105]],[[120415,120415],"mapped",[106]],[[120416,120416],"mapped",[107]],[[120417,120417],"mapped",[108]],[[120418,120418],"mapped",[109]],[[120419,120419],"mapped",[110]],[[120420,120420],"mapped",[111]],[[120421,120421],"mapped",[112]],[[120422,120422],"mapped",[113]],[[120423,120423],"mapped",[114]],[[120424,120424],"mapped",[115]],[[120425,120425],"mapped",[116]],[[120426,120426],"mapped",[117]],[[120427,120427],"mapped",[118]],[[120428,120428],"mapped",[119]],[[120429,120429],"mapped",[120]],[[120430,120430],"mapped",[121]],[[120431,120431],"mapped",[122]],[[120432,120432],"mapped",[97]],[[120433,120433],"mapped",[98]],[[120434,120434],"mapped",[99]],[[120435,120435],"mapped",[100]],[[120436,120436],"mapped",[101]],[[120437,120437],"mapped",[102]],[[120438,120438],"mapped",[103]],[[120439,120439],"mapped",[104]],[[120440,120440],"mapped",[105]],[[120441,120441],"mapped",[106]],[[120442,120442],"mapped",[107]],[[120443,120443],"mapped",[108]],[[120444,120444],"mapped",[109]],[[120445,120445],"mapped",[110]],[[120446,120446],"mapped",[111]],[[120447,120447],"mapped",[112]],[[120448,120448],"mapped",[113]],[[120449,120449],"mapped",[114]],[[120450,120450],"mapped",[115]],[[120451,120451],"mapped",[116]],[[120452,120452],"mapped",[117]],[[120453,120453],"mapped",[118]],[[120454,120454],"mapped",[119]],[[120455,120455],"mapped",[120]],[[120456,120456],"mapped",[121]],[[120457,120457],"mapped",[122]],[[120458,120458],"mapped",[97]],[[120459,120459],"mapped",[98]],[[120460,120460],"mapped",[99]],[[120461,120461],"mapped",[100]],[[120462,120462],"mapped",[101]],[[120463,120463],"mapped",[102]],[[120464,120464],"mapped",[103]],[[120465,120465],"mapped",[104]],[[120466,120466],"mapped",[105]],[[120467,120467],"mapped",[106]],[[120468,120468],"mapped",[107]],[[120469,120469],"mapped",[108]],[[120470,120470],"mapped",[109]],[[120471,120471],"mapped",[110]],[[120472,120472],"mapped",[111]],[[120473,120473],"mapped",[112]],[[120474,120474],"mapped",[113]],[[120475,120475],"mapped",[114]],[[120476,120476],"mapped",[115]],[[120477,120477],"mapped",[116]],[[120478,120478],"mapped",[117]],[[120479,120479],"mapped",[118]],[[120480,120480],"mapped",[119]],[[120481,120481],"mapped",[120]],[[120482,120482],"mapped",[121]],[[120483,120483],"mapped",[122]],[[120484,120484],"mapped",[305]],[[120485,120485],"mapped",[567]],[[120486,120487],"disallowed"],[[120488,120488],"mapped",[945]],[[120489,120489],"mapped",[946]],[[120490,120490],"mapped",[947]],[[120491,120491],"mapped",[948]],[[120492,120492],"mapped",[949]],[[120493,120493],"mapped",[950]],[[120494,120494],"mapped",[951]],[[120495,120495],"mapped",[952]],[[120496,120496],"mapped",[953]],[[120497,120497],"mapped",[954]],[[120498,120498],"mapped",[955]],[[120499,120499],"mapped",[956]],[[120500,120500],"mapped",[957]],[[120501,120501],"mapped",[958]],[[120502,120502],"mapped",[959]],[[120503,120503],"mapped",[960]],[[120504,120504],"mapped",[961]],[[120505,120505],"mapped",[952]],[[120506,120506],"mapped",[963]],[[120507,120507],"mapped",[964]],[[120508,120508],"mapped",[965]],[[120509,120509],"mapped",[966]],[[120510,120510],"mapped",[967]],[[120511,120511],"mapped",[968]],[[120512,120512],"mapped",[969]],[[120513,120513],"mapped",[8711]],[[120514,120514],"mapped",[945]],[[120515,120515],"mapped",[946]],[[120516,120516],"mapped",[947]],[[120517,120517],"mapped",[948]],[[120518,120518],"mapped",[949]],[[120519,120519],"mapped",[950]],[[120520,120520],"mapped",[951]],[[120521,120521],"mapped",[952]],[[120522,120522],"mapped",[953]],[[120523,120523],"mapped",[954]],[[120524,120524],"mapped",[955]],[[120525,120525],"mapped",[956]],[[120526,120526],"mapped",[957]],[[120527,120527],"mapped",[958]],[[120528,120528],"mapped",[959]],[[120529,120529],"mapped",[960]],[[120530,120530],"mapped",[961]],[[120531,120532],"mapped",[963]],[[120533,120533],"mapped",[964]],[[120534,120534],"mapped",[965]],[[120535,120535],"mapped",[966]],[[120536,120536],"mapped",[967]],[[120537,120537],"mapped",[968]],[[120538,120538],"mapped",[969]],[[120539,120539],"mapped",[8706]],[[120540,120540],"mapped",[949]],[[120541,120541],"mapped",[952]],[[120542,120542],"mapped",[954]],[[120543,120543],"mapped",[966]],[[120544,120544],"mapped",[961]],[[120545,120545],"mapped",[960]],[[120546,120546],"mapped",[945]],[[120547,120547],"mapped",[946]],[[120548,120548],"mapped",[947]],[[120549,120549],"mapped",[948]],[[120550,120550],"mapped",[949]],[[120551,120551],"mapped",[950]],[[120552,120552],"mapped",[951]],[[120553,120553],"mapped",[952]],[[120554,120554],"mapped",[953]],[[120555,120555],"mapped",[954]],[[120556,120556],"mapped",[955]],[[120557,120557],"mapped",[956]],[[120558,120558],"mapped",[957]],[[120559,120559],"mapped",[958]],[[120560,120560],"mapped",[959]],[[120561,120561],"mapped",[960]],[[120562,120562],"mapped",[961]],[[120563,120563],"mapped",[952]],[[120564,120564],"mapped",[963]],[[120565,120565],"mapped",[964]],[[120566,120566],"mapped",[965]],[[120567,120567],"mapped",[966]],[[120568,120568],"mapped",[967]],[[120569,120569],"mapped",[968]],[[120570,120570],"mapped",[969]],[[120571,120571],"mapped",[8711]],[[120572,120572],"mapped",[945]],[[120573,120573],"mapped",[946]],[[120574,120574],"mapped",[947]],[[120575,120575],"mapped",[948]],[[120576,120576],"mapped",[949]],[[120577,120577],"mapped",[950]],[[120578,120578],"mapped",[951]],[[120579,120579],"mapped",[952]],[[120580,120580],"mapped",[953]],[[120581,120581],"mapped",[954]],[[120582,120582],"mapped",[955]],[[120583,120583],"mapped",[956]],[[120584,120584],"mapped",[957]],[[120585,120585],"mapped",[958]],[[120586,120586],"mapped",[959]],[[120587,120587],"mapped",[960]],[[120588,120588],"mapped",[961]],[[120589,120590],"mapped",[963]],[[120591,120591],"mapped",[964]],[[120592,120592],"mapped",[965]],[[120593,120593],"mapped",[966]],[[120594,120594],"mapped",[967]],[[120595,120595],"mapped",[968]],[[120596,120596],"mapped",[969]],[[120597,120597],"mapped",[8706]],[[120598,120598],"mapped",[949]],[[120599,120599],"mapped",[952]],[[120600,120600],"mapped",[954]],[[120601,120601],"mapped",[966]],[[120602,120602],"mapped",[961]],[[120603,120603],"mapped",[960]],[[120604,120604],"mapped",[945]],[[120605,120605],"mapped",[946]],[[120606,120606],"mapped",[947]],[[120607,120607],"mapped",[948]],[[120608,120608],"mapped",[949]],[[120609,120609],"mapped",[950]],[[120610,120610],"mapped",[951]],[[120611,120611],"mapped",[952]],[[120612,120612],"mapped",[953]],[[120613,120613],"mapped",[954]],[[120614,120614],"mapped",[955]],[[120615,120615],"mapped",[956]],[[120616,120616],"mapped",[957]],[[120617,120617],"mapped",[958]],[[120618,120618],"mapped",[959]],[[120619,120619],"mapped",[960]],[[120620,120620],"mapped",[961]],[[120621,120621],"mapped",[952]],[[120622,120622],"mapped",[963]],[[120623,120623],"mapped",[964]],[[120624,120624],"mapped",[965]],[[120625,120625],"mapped",[966]],[[120626,120626],"mapped",[967]],[[120627,120627],"mapped",[968]],[[120628,120628],"mapped",[969]],[[120629,120629],"mapped",[8711]],[[120630,120630],"mapped",[945]],[[120631,120631],"mapped",[946]],[[120632,120632],"mapped",[947]],[[120633,120633],"mapped",[948]],[[120634,120634],"mapped",[949]],[[120635,120635],"mapped",[950]],[[120636,120636],"mapped",[951]],[[120637,120637],"mapped",[952]],[[120638,120638],"mapped",[953]],[[120639,120639],"mapped",[954]],[[120640,120640],"mapped",[955]],[[120641,120641],"mapped",[956]],[[120642,120642],"mapped",[957]],[[120643,120643],"mapped",[958]],[[120644,120644],"mapped",[959]],[[120645,120645],"mapped",[960]],[[120646,120646],"mapped",[961]],[[120647,120648],"mapped",[963]],[[120649,120649],"mapped",[964]],[[120650,120650],"mapped",[965]],[[120651,120651],"mapped",[966]],[[120652,120652],"mapped",[967]],[[120653,120653],"mapped",[968]],[[120654,120654],"mapped",[969]],[[120655,120655],"mapped",[8706]],[[120656,120656],"mapped",[949]],[[120657,120657],"mapped",[952]],[[120658,120658],"mapped",[954]],[[120659,120659],"mapped",[966]],[[120660,120660],"mapped",[961]],[[120661,120661],"mapped",[960]],[[120662,120662],"mapped",[945]],[[120663,120663],"mapped",[946]],[[120664,120664],"mapped",[947]],[[120665,120665],"mapped",[948]],[[120666,120666],"mapped",[949]],[[120667,120667],"mapped",[950]],[[120668,120668],"mapped",[951]],[[120669,120669],"mapped",[952]],[[120670,120670],"mapped",[953]],[[120671,120671],"mapped",[954]],[[120672,120672],"mapped",[955]],[[120673,120673],"mapped",[956]],[[120674,120674],"mapped",[957]],[[120675,120675],"mapped",[958]],[[120676,120676],"mapped",[959]],[[120677,120677],"mapped",[960]],[[120678,120678],"mapped",[961]],[[120679,120679],"mapped",[952]],[[120680,120680],"mapped",[963]],[[120681,120681],"mapped",[964]],[[120682,120682],"mapped",[965]],[[120683,120683],"mapped",[966]],[[120684,120684],"mapped",[967]],[[120685,120685],"mapped",[968]],[[120686,120686],"mapped",[969]],[[120687,120687],"mapped",[8711]],[[120688,120688],"mapped",[945]],[[120689,120689],"mapped",[946]],[[120690,120690],"mapped",[947]],[[120691,120691],"mapped",[948]],[[120692,120692],"mapped",[949]],[[120693,120693],"mapped",[950]],[[120694,120694],"mapped",[951]],[[120695,120695],"mapped",[952]],[[120696,120696],"mapped",[953]],[[120697,120697],"mapped",[954]],[[120698,120698],"mapped",[955]],[[120699,120699],"mapped",[956]],[[120700,120700],"mapped",[957]],[[120701,120701],"mapped",[958]],[[120702,120702],"mapped",[959]],[[120703,120703],"mapped",[960]],[[120704,120704],"mapped",[961]],[[120705,120706],"mapped",[963]],[[120707,120707],"mapped",[964]],[[120708,120708],"mapped",[965]],[[120709,120709],"mapped",[966]],[[120710,120710],"mapped",[967]],[[120711,120711],"mapped",[968]],[[120712,120712],"mapped",[969]],[[120713,120713],"mapped",[8706]],[[120714,120714],"mapped",[949]],[[120715,120715],"mapped",[952]],[[120716,120716],"mapped",[954]],[[120717,120717],"mapped",[966]],[[120718,120718],"mapped",[961]],[[120719,120719],"mapped",[960]],[[120720,120720],"mapped",[945]],[[120721,120721],"mapped",[946]],[[120722,120722],"mapped",[947]],[[120723,120723],"mapped",[948]],[[120724,120724],"mapped",[949]],[[120725,120725],"mapped",[950]],[[120726,120726],"mapped",[951]],[[120727,120727],"mapped",[952]],[[120728,120728],"mapped",[953]],[[120729,120729],"mapped",[954]],[[120730,120730],"mapped",[955]],[[120731,120731],"mapped",[956]],[[120732,120732],"mapped",[957]],[[120733,120733],"mapped",[958]],[[120734,120734],"mapped",[959]],[[120735,120735],"mapped",[960]],[[120736,120736],"mapped",[961]],[[120737,120737],"mapped",[952]],[[120738,120738],"mapped",[963]],[[120739,120739],"mapped",[964]],[[120740,120740],"mapped",[965]],[[120741,120741],"mapped",[966]],[[120742,120742],"mapped",[967]],[[120743,120743],"mapped",[968]],[[120744,120744],"mapped",[969]],[[120745,120745],"mapped",[8711]],[[120746,120746],"mapped",[945]],[[120747,120747],"mapped",[946]],[[120748,120748],"mapped",[947]],[[120749,120749],"mapped",[948]],[[120750,120750],"mapped",[949]],[[120751,120751],"mapped",[950]],[[120752,120752],"mapped",[951]],[[120753,120753],"mapped",[952]],[[120754,120754],"mapped",[953]],[[120755,120755],"mapped",[954]],[[120756,120756],"mapped",[955]],[[120757,120757],"mapped",[956]],[[120758,120758],"mapped",[957]],[[120759,120759],"mapped",[958]],[[120760,120760],"mapped",[959]],[[120761,120761],"mapped",[960]],[[120762,120762],"mapped",[961]],[[120763,120764],"mapped",[963]],[[120765,120765],"mapped",[964]],[[120766,120766],"mapped",[965]],[[120767,120767],"mapped",[966]],[[120768,120768],"mapped",[967]],[[120769,120769],"mapped",[968]],[[120770,120770],"mapped",[969]],[[120771,120771],"mapped",[8706]],[[120772,120772],"mapped",[949]],[[120773,120773],"mapped",[952]],[[120774,120774],"mapped",[954]],[[120775,120775],"mapped",[966]],[[120776,120776],"mapped",[961]],[[120777,120777],"mapped",[960]],[[120778,120779],"mapped",[989]],[[120780,120781],"disallowed"],[[120782,120782],"mapped",[48]],[[120783,120783],"mapped",[49]],[[120784,120784],"mapped",[50]],[[120785,120785],"mapped",[51]],[[120786,120786],"mapped",[52]],[[120787,120787],"mapped",[53]],[[120788,120788],"mapped",[54]],[[120789,120789],"mapped",[55]],[[120790,120790],"mapped",[56]],[[120791,120791],"mapped",[57]],[[120792,120792],"mapped",[48]],[[120793,120793],"mapped",[49]],[[120794,120794],"mapped",[50]],[[120795,120795],"mapped",[51]],[[120796,120796],"mapped",[52]],[[120797,120797],"mapped",[53]],[[120798,120798],"mapped",[54]],[[120799,120799],"mapped",[55]],[[120800,120800],"mapped",[56]],[[120801,120801],"mapped",[57]],[[120802,120802],"mapped",[48]],[[120803,120803],"mapped",[49]],[[120804,120804],"mapped",[50]],[[120805,120805],"mapped",[51]],[[120806,120806],"mapped",[52]],[[120807,120807],"mapped",[53]],[[120808,120808],"mapped",[54]],[[120809,120809],"mapped",[55]],[[120810,120810],"mapped",[56]],[[120811,120811],"mapped",[57]],[[120812,120812],"mapped",[48]],[[120813,120813],"mapped",[49]],[[120814,120814],"mapped",[50]],[[120815,120815],"mapped",[51]],[[120816,120816],"mapped",[52]],[[120817,120817],"mapped",[53]],[[120818,120818],"mapped",[54]],[[120819,120819],"mapped",[55]],[[120820,120820],"mapped",[56]],[[120821,120821],"mapped",[57]],[[120822,120822],"mapped",[48]],[[120823,120823],"mapped",[49]],[[120824,120824],"mapped",[50]],[[120825,120825],"mapped",[51]],[[120826,120826],"mapped",[52]],[[120827,120827],"mapped",[53]],[[120828,120828],"mapped",[54]],[[120829,120829],"mapped",[55]],[[120830,120830],"mapped",[56]],[[120831,120831],"mapped",[57]],[[120832,121343],"valid",[],"NV8"],[[121344,121398],"valid"],[[121399,121402],"valid",[],"NV8"],[[121403,121452],"valid"],[[121453,121460],"valid",[],"NV8"],[[121461,121461],"valid"],[[121462,121475],"valid",[],"NV8"],[[121476,121476],"valid"],[[121477,121483],"valid",[],"NV8"],[[121484,121498],"disallowed"],[[121499,121503],"valid"],[[121504,121504],"disallowed"],[[121505,121519],"valid"],[[121520,124927],"disallowed"],[[124928,125124],"valid"],[[125125,125126],"disallowed"],[[125127,125135],"valid",[],"NV8"],[[125136,125142],"valid"],[[125143,126463],"disallowed"],[[126464,126464],"mapped",[1575]],[[126465,126465],"mapped",[1576]],[[126466,126466],"mapped",[1580]],[[126467,126467],"mapped",[1583]],[[126468,126468],"disallowed"],[[126469,126469],"mapped",[1608]],[[126470,126470],"mapped",[1586]],[[126471,126471],"mapped",[1581]],[[126472,126472],"mapped",[1591]],[[126473,126473],"mapped",[1610]],[[126474,126474],"mapped",[1603]],[[126475,126475],"mapped",[1604]],[[126476,126476],"mapped",[1605]],[[126477,126477],"mapped",[1606]],[[126478,126478],"mapped",[1587]],[[126479,126479],"mapped",[1593]],[[126480,126480],"mapped",[1601]],[[126481,126481],"mapped",[1589]],[[126482,126482],"mapped",[1602]],[[126483,126483],"mapped",[1585]],[[126484,126484],"mapped",[1588]],[[126485,126485],"mapped",[1578]],[[126486,126486],"mapped",[1579]],[[126487,126487],"mapped",[1582]],[[126488,126488],"mapped",[1584]],[[126489,126489],"mapped",[1590]],[[126490,126490],"mapped",[1592]],[[126491,126491],"mapped",[1594]],[[126492,126492],"mapped",[1646]],[[126493,126493],"mapped",[1722]],[[126494,126494],"mapped",[1697]],[[126495,126495],"mapped",[1647]],[[126496,126496],"disallowed"],[[126497,126497],"mapped",[1576]],[[126498,126498],"mapped",[1580]],[[126499,126499],"disallowed"],[[126500,126500],"mapped",[1607]],[[126501,126502],"disallowed"],[[126503,126503],"mapped",[1581]],[[126504,126504],"disallowed"],[[126505,126505],"mapped",[1610]],[[126506,126506],"mapped",[1603]],[[126507,126507],"mapped",[1604]],[[126508,126508],"mapped",[1605]],[[126509,126509],"mapped",[1606]],[[126510,126510],"mapped",[1587]],[[126511,126511],"mapped",[1593]],[[126512,126512],"mapped",[1601]],[[126513,126513],"mapped",[1589]],[[126514,126514],"mapped",[1602]],[[126515,126515],"disallowed"],[[126516,126516],"mapped",[1588]],[[126517,126517],"mapped",[1578]],[[126518,126518],"mapped",[1579]],[[126519,126519],"mapped",[1582]],[[126520,126520],"disallowed"],[[126521,126521],"mapped",[1590]],[[126522,126522],"disallowed"],[[126523,126523],"mapped",[1594]],[[126524,126529],"disallowed"],[[126530,126530],"mapped",[1580]],[[126531,126534],"disallowed"],[[126535,126535],"mapped",[1581]],[[126536,126536],"disallowed"],[[126537,126537],"mapped",[1610]],[[126538,126538],"disallowed"],[[126539,126539],"mapped",[1604]],[[126540,126540],"disallowed"],[[126541,126541],"mapped",[1606]],[[126542,126542],"mapped",[1587]],[[126543,126543],"mapped",[1593]],[[126544,126544],"disallowed"],[[126545,126545],"mapped",[1589]],[[126546,126546],"mapped",[1602]],[[126547,126547],"disallowed"],[[126548,126548],"mapped",[1588]],[[126549,126550],"disallowed"],[[126551,126551],"mapped",[1582]],[[126552,126552],"disallowed"],[[126553,126553],"mapped",[1590]],[[126554,126554],"disallowed"],[[126555,126555],"mapped",[1594]],[[126556,126556],"disallowed"],[[126557,126557],"mapped",[1722]],[[126558,126558],"disallowed"],[[126559,126559],"mapped",[1647]],[[126560,126560],"disallowed"],[[126561,126561],"mapped",[1576]],[[126562,126562],"mapped",[1580]],[[126563,126563],"disallowed"],[[126564,126564],"mapped",[1607]],[[126565,126566],"disallowed"],[[126567,126567],"mapped",[1581]],[[126568,126568],"mapped",[1591]],[[126569,126569],"mapped",[1610]],[[126570,126570],"mapped",[1603]],[[126571,126571],"disallowed"],[[126572,126572],"mapped",[1605]],[[126573,126573],"mapped",[1606]],[[126574,126574],"mapped",[1587]],[[126575,126575],"mapped",[1593]],[[126576,126576],"mapped",[1601]],[[126577,126577],"mapped",[1589]],[[126578,126578],"mapped",[1602]],[[126579,126579],"disallowed"],[[126580,126580],"mapped",[1588]],[[126581,126581],"mapped",[1578]],[[126582,126582],"mapped",[1579]],[[126583,126583],"mapped",[1582]],[[126584,126584],"disallowed"],[[126585,126585],"mapped",[1590]],[[126586,126586],"mapped",[1592]],[[126587,126587],"mapped",[1594]],[[126588,126588],"mapped",[1646]],[[126589,126589],"disallowed"],[[126590,126590],"mapped",[1697]],[[126591,126591],"disallowed"],[[126592,126592],"mapped",[1575]],[[126593,126593],"mapped",[1576]],[[126594,126594],"mapped",[1580]],[[126595,126595],"mapped",[1583]],[[126596,126596],"mapped",[1607]],[[126597,126597],"mapped",[1608]],[[126598,126598],"mapped",[1586]],[[126599,126599],"mapped",[1581]],[[126600,126600],"mapped",[1591]],[[126601,126601],"mapped",[1610]],[[126602,126602],"disallowed"],[[126603,126603],"mapped",[1604]],[[126604,126604],"mapped",[1605]],[[126605,126605],"mapped",[1606]],[[126606,126606],"mapped",[1587]],[[126607,126607],"mapped",[1593]],[[126608,126608],"mapped",[1601]],[[126609,126609],"mapped",[1589]],[[126610,126610],"mapped",[1602]],[[126611,126611],"mapped",[1585]],[[126612,126612],"mapped",[1588]],[[126613,126613],"mapped",[1578]],[[126614,126614],"mapped",[1579]],[[126615,126615],"mapped",[1582]],[[126616,126616],"mapped",[1584]],[[126617,126617],"mapped",[1590]],[[126618,126618],"mapped",[1592]],[[126619,126619],"mapped",[1594]],[[126620,126624],"disallowed"],[[126625,126625],"mapped",[1576]],[[126626,126626],"mapped",[1580]],[[126627,126627],"mapped",[1583]],[[126628,126628],"disallowed"],[[126629,126629],"mapped",[1608]],[[126630,126630],"mapped",[1586]],[[126631,126631],"mapped",[1581]],[[126632,126632],"mapped",[1591]],[[126633,126633],"mapped",[1610]],[[126634,126634],"disallowed"],[[126635,126635],"mapped",[1604]],[[126636,126636],"mapped",[1605]],[[126637,126637],"mapped",[1606]],[[126638,126638],"mapped",[1587]],[[126639,126639],"mapped",[1593]],[[126640,126640],"mapped",[1601]],[[126641,126641],"mapped",[1589]],[[126642,126642],"mapped",[1602]],[[126643,126643],"mapped",[1585]],[[126644,126644],"mapped",[1588]],[[126645,126645],"mapped",[1578]],[[126646,126646],"mapped",[1579]],[[126647,126647],"mapped",[1582]],[[126648,126648],"mapped",[1584]],[[126649,126649],"mapped",[1590]],[[126650,126650],"mapped",[1592]],[[126651,126651],"mapped",[1594]],[[126652,126703],"disallowed"],[[126704,126705],"valid",[],"NV8"],[[126706,126975],"disallowed"],[[126976,127019],"valid",[],"NV8"],[[127020,127023],"disallowed"],[[127024,127123],"valid",[],"NV8"],[[127124,127135],"disallowed"],[[127136,127150],"valid",[],"NV8"],[[127151,127152],"disallowed"],[[127153,127166],"valid",[],"NV8"],[[127167,127167],"valid",[],"NV8"],[[127168,127168],"disallowed"],[[127169,127183],"valid",[],"NV8"],[[127184,127184],"disallowed"],[[127185,127199],"valid",[],"NV8"],[[127200,127221],"valid",[],"NV8"],[[127222,127231],"disallowed"],[[127232,127232],"disallowed"],[[127233,127233],"disallowed_STD3_mapped",[48,44]],[[127234,127234],"disallowed_STD3_mapped",[49,44]],[[127235,127235],"disallowed_STD3_mapped",[50,44]],[[127236,127236],"disallowed_STD3_mapped",[51,44]],[[127237,127237],"disallowed_STD3_mapped",[52,44]],[[127238,127238],"disallowed_STD3_mapped",[53,44]],[[127239,127239],"disallowed_STD3_mapped",[54,44]],[[127240,127240],"disallowed_STD3_mapped",[55,44]],[[127241,127241],"disallowed_STD3_mapped",[56,44]],[[127242,127242],"disallowed_STD3_mapped",[57,44]],[[127243,127244],"valid",[],"NV8"],[[127245,127247],"disallowed"],[[127248,127248],"disallowed_STD3_mapped",[40,97,41]],[[127249,127249],"disallowed_STD3_mapped",[40,98,41]],[[127250,127250],"disallowed_STD3_mapped",[40,99,41]],[[127251,127251],"disallowed_STD3_mapped",[40,100,41]],[[127252,127252],"disallowed_STD3_mapped",[40,101,41]],[[127253,127253],"disallowed_STD3_mapped",[40,102,41]],[[127254,127254],"disallowed_STD3_mapped",[40,103,41]],[[127255,127255],"disallowed_STD3_mapped",[40,104,41]],[[127256,127256],"disallowed_STD3_mapped",[40,105,41]],[[127257,127257],"disallowed_STD3_mapped",[40,106,41]],[[127258,127258],"disallowed_STD3_mapped",[40,107,41]],[[127259,127259],"disallowed_STD3_mapped",[40,108,41]],[[127260,127260],"disallowed_STD3_mapped",[40,109,41]],[[127261,127261],"disallowed_STD3_mapped",[40,110,41]],[[127262,127262],"disallowed_STD3_mapped",[40,111,41]],[[127263,127263],"disallowed_STD3_mapped",[40,112,41]],[[127264,127264],"disallowed_STD3_mapped",[40,113,41]],[[127265,127265],"disallowed_STD3_mapped",[40,114,41]],[[127266,127266],"disallowed_STD3_mapped",[40,115,41]],[[127267,127267],"disallowed_STD3_mapped",[40,116,41]],[[127268,127268],"disallowed_STD3_mapped",[40,117,41]],[[127269,127269],"disallowed_STD3_mapped",[40,118,41]],[[127270,127270],"disallowed_STD3_mapped",[40,119,41]],[[127271,127271],"disallowed_STD3_mapped",[40,120,41]],[[127272,127272],"disallowed_STD3_mapped",[40,121,41]],[[127273,127273],"disallowed_STD3_mapped",[40,122,41]],[[127274,127274],"mapped",[12308,115,12309]],[[127275,127275],"mapped",[99]],[[127276,127276],"mapped",[114]],[[127277,127277],"mapped",[99,100]],[[127278,127278],"mapped",[119,122]],[[127279,127279],"disallowed"],[[127280,127280],"mapped",[97]],[[127281,127281],"mapped",[98]],[[127282,127282],"mapped",[99]],[[127283,127283],"mapped",[100]],[[127284,127284],"mapped",[101]],[[127285,127285],"mapped",[102]],[[127286,127286],"mapped",[103]],[[127287,127287],"mapped",[104]],[[127288,127288],"mapped",[105]],[[127289,127289],"mapped",[106]],[[127290,127290],"mapped",[107]],[[127291,127291],"mapped",[108]],[[127292,127292],"mapped",[109]],[[127293,127293],"mapped",[110]],[[127294,127294],"mapped",[111]],[[127295,127295],"mapped",[112]],[[127296,127296],"mapped",[113]],[[127297,127297],"mapped",[114]],[[127298,127298],"mapped",[115]],[[127299,127299],"mapped",[116]],[[127300,127300],"mapped",[117]],[[127301,127301],"mapped",[118]],[[127302,127302],"mapped",[119]],[[127303,127303],"mapped",[120]],[[127304,127304],"mapped",[121]],[[127305,127305],"mapped",[122]],[[127306,127306],"mapped",[104,118]],[[127307,127307],"mapped",[109,118]],[[127308,127308],"mapped",[115,100]],[[127309,127309],"mapped",[115,115]],[[127310,127310],"mapped",[112,112,118]],[[127311,127311],"mapped",[119,99]],[[127312,127318],"valid",[],"NV8"],[[127319,127319],"valid",[],"NV8"],[[127320,127326],"valid",[],"NV8"],[[127327,127327],"valid",[],"NV8"],[[127328,127337],"valid",[],"NV8"],[[127338,127338],"mapped",[109,99]],[[127339,127339],"mapped",[109,100]],[[127340,127343],"disallowed"],[[127344,127352],"valid",[],"NV8"],[[127353,127353],"valid",[],"NV8"],[[127354,127354],"valid",[],"NV8"],[[127355,127356],"valid",[],"NV8"],[[127357,127358],"valid",[],"NV8"],[[127359,127359],"valid",[],"NV8"],[[127360,127369],"valid",[],"NV8"],[[127370,127373],"valid",[],"NV8"],[[127374,127375],"valid",[],"NV8"],[[127376,127376],"mapped",[100,106]],[[127377,127386],"valid",[],"NV8"],[[127387,127461],"disallowed"],[[127462,127487],"valid",[],"NV8"],[[127488,127488],"mapped",[12411,12363]],[[127489,127489],"mapped",[12467,12467]],[[127490,127490],"mapped",[12469]],[[127491,127503],"disallowed"],[[127504,127504],"mapped",[25163]],[[127505,127505],"mapped",[23383]],[[127506,127506],"mapped",[21452]],[[127507,127507],"mapped",[12487]],[[127508,127508],"mapped",[20108]],[[127509,127509],"mapped",[22810]],[[127510,127510],"mapped",[35299]],[[127511,127511],"mapped",[22825]],[[127512,127512],"mapped",[20132]],[[127513,127513],"mapped",[26144]],[[127514,127514],"mapped",[28961]],[[127515,127515],"mapped",[26009]],[[127516,127516],"mapped",[21069]],[[127517,127517],"mapped",[24460]],[[127518,127518],"mapped",[20877]],[[127519,127519],"mapped",[26032]],[[127520,127520],"mapped",[21021]],[[127521,127521],"mapped",[32066]],[[127522,127522],"mapped",[29983]],[[127523,127523],"mapped",[36009]],[[127524,127524],"mapped",[22768]],[[127525,127525],"mapped",[21561]],[[127526,127526],"mapped",[28436]],[[127527,127527],"mapped",[25237]],[[127528,127528],"mapped",[25429]],[[127529,127529],"mapped",[19968]],[[127530,127530],"mapped",[19977]],[[127531,127531],"mapped",[36938]],[[127532,127532],"mapped",[24038]],[[127533,127533],"mapped",[20013]],[[127534,127534],"mapped",[21491]],[[127535,127535],"mapped",[25351]],[[127536,127536],"mapped",[36208]],[[127537,127537],"mapped",[25171]],[[127538,127538],"mapped",[31105]],[[127539,127539],"mapped",[31354]],[[127540,127540],"mapped",[21512]],[[127541,127541],"mapped",[28288]],[[127542,127542],"mapped",[26377]],[[127543,127543],"mapped",[26376]],[[127544,127544],"mapped",[30003]],[[127545,127545],"mapped",[21106]],[[127546,127546],"mapped",[21942]],[[127547,127551],"disallowed"],[[127552,127552],"mapped",[12308,26412,12309]],[[127553,127553],"mapped",[12308,19977,12309]],[[127554,127554],"mapped",[12308,20108,12309]],[[127555,127555],"mapped",[12308,23433,12309]],[[127556,127556],"mapped",[12308,28857,12309]],[[127557,127557],"mapped",[12308,25171,12309]],[[127558,127558],"mapped",[12308,30423,12309]],[[127559,127559],"mapped",[12308,21213,12309]],[[127560,127560],"mapped",[12308,25943,12309]],[[127561,127567],"disallowed"],[[127568,127568],"mapped",[24471]],[[127569,127569],"mapped",[21487]],[[127570,127743],"disallowed"],[[127744,127776],"valid",[],"NV8"],[[127777,127788],"valid",[],"NV8"],[[127789,127791],"valid",[],"NV8"],[[127792,127797],"valid",[],"NV8"],[[127798,127798],"valid",[],"NV8"],[[127799,127868],"valid",[],"NV8"],[[127869,127869],"valid",[],"NV8"],[[127870,127871],"valid",[],"NV8"],[[127872,127891],"valid",[],"NV8"],[[127892,127903],"valid",[],"NV8"],[[127904,127940],"valid",[],"NV8"],[[127941,127941],"valid",[],"NV8"],[[127942,127946],"valid",[],"NV8"],[[127947,127950],"valid",[],"NV8"],[[127951,127955],"valid",[],"NV8"],[[127956,127967],"valid",[],"NV8"],[[127968,127984],"valid",[],"NV8"],[[127985,127991],"valid",[],"NV8"],[[127992,127999],"valid",[],"NV8"],[[128000,128062],"valid",[],"NV8"],[[128063,128063],"valid",[],"NV8"],[[128064,128064],"valid",[],"NV8"],[[128065,128065],"valid",[],"NV8"],[[128066,128247],"valid",[],"NV8"],[[128248,128248],"valid",[],"NV8"],[[128249,128252],"valid",[],"NV8"],[[128253,128254],"valid",[],"NV8"],[[128255,128255],"valid",[],"NV8"],[[128256,128317],"valid",[],"NV8"],[[128318,128319],"valid",[],"NV8"],[[128320,128323],"valid",[],"NV8"],[[128324,128330],"valid",[],"NV8"],[[128331,128335],"valid",[],"NV8"],[[128336,128359],"valid",[],"NV8"],[[128360,128377],"valid",[],"NV8"],[[128378,128378],"disallowed"],[[128379,128419],"valid",[],"NV8"],[[128420,128420],"disallowed"],[[128421,128506],"valid",[],"NV8"],[[128507,128511],"valid",[],"NV8"],[[128512,128512],"valid",[],"NV8"],[[128513,128528],"valid",[],"NV8"],[[128529,128529],"valid",[],"NV8"],[[128530,128532],"valid",[],"NV8"],[[128533,128533],"valid",[],"NV8"],[[128534,128534],"valid",[],"NV8"],[[128535,128535],"valid",[],"NV8"],[[128536,128536],"valid",[],"NV8"],[[128537,128537],"valid",[],"NV8"],[[128538,128538],"valid",[],"NV8"],[[128539,128539],"valid",[],"NV8"],[[128540,128542],"valid",[],"NV8"],[[128543,128543],"valid",[],"NV8"],[[128544,128549],"valid",[],"NV8"],[[128550,128551],"valid",[],"NV8"],[[128552,128555],"valid",[],"NV8"],[[128556,128556],"valid",[],"NV8"],[[128557,128557],"valid",[],"NV8"],[[128558,128559],"valid",[],"NV8"],[[128560,128563],"valid",[],"NV8"],[[128564,128564],"valid",[],"NV8"],[[128565,128576],"valid",[],"NV8"],[[128577,128578],"valid",[],"NV8"],[[128579,128580],"valid",[],"NV8"],[[128581,128591],"valid",[],"NV8"],[[128592,128639],"valid",[],"NV8"],[[128640,128709],"valid",[],"NV8"],[[128710,128719],"valid",[],"NV8"],[[128720,128720],"valid",[],"NV8"],[[128721,128735],"disallowed"],[[128736,128748],"valid",[],"NV8"],[[128749,128751],"disallowed"],[[128752,128755],"valid",[],"NV8"],[[128756,128767],"disallowed"],[[128768,128883],"valid",[],"NV8"],[[128884,128895],"disallowed"],[[128896,128980],"valid",[],"NV8"],[[128981,129023],"disallowed"],[[129024,129035],"valid",[],"NV8"],[[129036,129039],"disallowed"],[[129040,129095],"valid",[],"NV8"],[[129096,129103],"disallowed"],[[129104,129113],"valid",[],"NV8"],[[129114,129119],"disallowed"],[[129120,129159],"valid",[],"NV8"],[[129160,129167],"disallowed"],[[129168,129197],"valid",[],"NV8"],[[129198,129295],"disallowed"],[[129296,129304],"valid",[],"NV8"],[[129305,129407],"disallowed"],[[129408,129412],"valid",[],"NV8"],[[129413,129471],"disallowed"],[[129472,129472],"valid",[],"NV8"],[[129473,131069],"disallowed"],[[131070,131071],"disallowed"],[[131072,173782],"valid"],[[173783,173823],"disallowed"],[[173824,177972],"valid"],[[177973,177983],"disallowed"],[[177984,178205],"valid"],[[178206,178207],"disallowed"],[[178208,183969],"valid"],[[183970,194559],"disallowed"],[[194560,194560],"mapped",[20029]],[[194561,194561],"mapped",[20024]],[[194562,194562],"mapped",[20033]],[[194563,194563],"mapped",[131362]],[[194564,194564],"mapped",[20320]],[[194565,194565],"mapped",[20398]],[[194566,194566],"mapped",[20411]],[[194567,194567],"mapped",[20482]],[[194568,194568],"mapped",[20602]],[[194569,194569],"mapped",[20633]],[[194570,194570],"mapped",[20711]],[[194571,194571],"mapped",[20687]],[[194572,194572],"mapped",[13470]],[[194573,194573],"mapped",[132666]],[[194574,194574],"mapped",[20813]],[[194575,194575],"mapped",[20820]],[[194576,194576],"mapped",[20836]],[[194577,194577],"mapped",[20855]],[[194578,194578],"mapped",[132380]],[[194579,194579],"mapped",[13497]],[[194580,194580],"mapped",[20839]],[[194581,194581],"mapped",[20877]],[[194582,194582],"mapped",[132427]],[[194583,194583],"mapped",[20887]],[[194584,194584],"mapped",[20900]],[[194585,194585],"mapped",[20172]],[[194586,194586],"mapped",[20908]],[[194587,194587],"mapped",[20917]],[[194588,194588],"mapped",[168415]],[[194589,194589],"mapped",[20981]],[[194590,194590],"mapped",[20995]],[[194591,194591],"mapped",[13535]],[[194592,194592],"mapped",[21051]],[[194593,194593],"mapped",[21062]],[[194594,194594],"mapped",[21106]],[[194595,194595],"mapped",[21111]],[[194596,194596],"mapped",[13589]],[[194597,194597],"mapped",[21191]],[[194598,194598],"mapped",[21193]],[[194599,194599],"mapped",[21220]],[[194600,194600],"mapped",[21242]],[[194601,194601],"mapped",[21253]],[[194602,194602],"mapped",[21254]],[[194603,194603],"mapped",[21271]],[[194604,194604],"mapped",[21321]],[[194605,194605],"mapped",[21329]],[[194606,194606],"mapped",[21338]],[[194607,194607],"mapped",[21363]],[[194608,194608],"mapped",[21373]],[[194609,194611],"mapped",[21375]],[[194612,194612],"mapped",[133676]],[[194613,194613],"mapped",[28784]],[[194614,194614],"mapped",[21450]],[[194615,194615],"mapped",[21471]],[[194616,194616],"mapped",[133987]],[[194617,194617],"mapped",[21483]],[[194618,194618],"mapped",[21489]],[[194619,194619],"mapped",[21510]],[[194620,194620],"mapped",[21662]],[[194621,194621],"mapped",[21560]],[[194622,194622],"mapped",[21576]],[[194623,194623],"mapped",[21608]],[[194624,194624],"mapped",[21666]],[[194625,194625],"mapped",[21750]],[[194626,194626],"mapped",[21776]],[[194627,194627],"mapped",[21843]],[[194628,194628],"mapped",[21859]],[[194629,194630],"mapped",[21892]],[[194631,194631],"mapped",[21913]],[[194632,194632],"mapped",[21931]],[[194633,194633],"mapped",[21939]],[[194634,194634],"mapped",[21954]],[[194635,194635],"mapped",[22294]],[[194636,194636],"mapped",[22022]],[[194637,194637],"mapped",[22295]],[[194638,194638],"mapped",[22097]],[[194639,194639],"mapped",[22132]],[[194640,194640],"mapped",[20999]],[[194641,194641],"mapped",[22766]],[[194642,194642],"mapped",[22478]],[[194643,194643],"mapped",[22516]],[[194644,194644],"mapped",[22541]],[[194645,194645],"mapped",[22411]],[[194646,194646],"mapped",[22578]],[[194647,194647],"mapped",[22577]],[[194648,194648],"mapped",[22700]],[[194649,194649],"mapped",[136420]],[[194650,194650],"mapped",[22770]],[[194651,194651],"mapped",[22775]],[[194652,194652],"mapped",[22790]],[[194653,194653],"mapped",[22810]],[[194654,194654],"mapped",[22818]],[[194655,194655],"mapped",[22882]],[[194656,194656],"mapped",[136872]],[[194657,194657],"mapped",[136938]],[[194658,194658],"mapped",[23020]],[[194659,194659],"mapped",[23067]],[[194660,194660],"mapped",[23079]],[[194661,194661],"mapped",[23000]],[[194662,194662],"mapped",[23142]],[[194663,194663],"mapped",[14062]],[[194664,194664],"disallowed"],[[194665,194665],"mapped",[23304]],[[194666,194667],"mapped",[23358]],[[194668,194668],"mapped",[137672]],[[194669,194669],"mapped",[23491]],[[194670,194670],"mapped",[23512]],[[194671,194671],"mapped",[23527]],[[194672,194672],"mapped",[23539]],[[194673,194673],"mapped",[138008]],[[194674,194674],"mapped",[23551]],[[194675,194675],"mapped",[23558]],[[194676,194676],"disallowed"],[[194677,194677],"mapped",[23586]],[[194678,194678],"mapped",[14209]],[[194679,194679],"mapped",[23648]],[[194680,194680],"mapped",[23662]],[[194681,194681],"mapped",[23744]],[[194682,194682],"mapped",[23693]],[[194683,194683],"mapped",[138724]],[[194684,194684],"mapped",[23875]],[[194685,194685],"mapped",[138726]],[[194686,194686],"mapped",[23918]],[[194687,194687],"mapped",[23915]],[[194688,194688],"mapped",[23932]],[[194689,194689],"mapped",[24033]],[[194690,194690],"mapped",[24034]],[[194691,194691],"mapped",[14383]],[[194692,194692],"mapped",[24061]],[[194693,194693],"mapped",[24104]],[[194694,194694],"mapped",[24125]],[[194695,194695],"mapped",[24169]],[[194696,194696],"mapped",[14434]],[[194697,194697],"mapped",[139651]],[[194698,194698],"mapped",[14460]],[[194699,194699],"mapped",[24240]],[[194700,194700],"mapped",[24243]],[[194701,194701],"mapped",[24246]],[[194702,194702],"mapped",[24266]],[[194703,194703],"mapped",[172946]],[[194704,194704],"mapped",[24318]],[[194705,194706],"mapped",[140081]],[[194707,194707],"mapped",[33281]],[[194708,194709],"mapped",[24354]],[[194710,194710],"mapped",[14535]],[[194711,194711],"mapped",[144056]],[[194712,194712],"mapped",[156122]],[[194713,194713],"mapped",[24418]],[[194714,194714],"mapped",[24427]],[[194715,194715],"mapped",[14563]],[[194716,194716],"mapped",[24474]],[[194717,194717],"mapped",[24525]],[[194718,194718],"mapped",[24535]],[[194719,194719],"mapped",[24569]],[[194720,194720],"mapped",[24705]],[[194721,194721],"mapped",[14650]],[[194722,194722],"mapped",[14620]],[[194723,194723],"mapped",[24724]],[[194724,194724],"mapped",[141012]],[[194725,194725],"mapped",[24775]],[[194726,194726],"mapped",[24904]],[[194727,194727],"mapped",[24908]],[[194728,194728],"mapped",[24910]],[[194729,194729],"mapped",[24908]],[[194730,194730],"mapped",[24954]],[[194731,194731],"mapped",[24974]],[[194732,194732],"mapped",[25010]],[[194733,194733],"mapped",[24996]],[[194734,194734],"mapped",[25007]],[[194735,194735],"mapped",[25054]],[[194736,194736],"mapped",[25074]],[[194737,194737],"mapped",[25078]],[[194738,194738],"mapped",[25104]],[[194739,194739],"mapped",[25115]],[[194740,194740],"mapped",[25181]],[[194741,194741],"mapped",[25265]],[[194742,194742],"mapped",[25300]],[[194743,194743],"mapped",[25424]],[[194744,194744],"mapped",[142092]],[[194745,194745],"mapped",[25405]],[[194746,194746],"mapped",[25340]],[[194747,194747],"mapped",[25448]],[[194748,194748],"mapped",[25475]],[[194749,194749],"mapped",[25572]],[[194750,194750],"mapped",[142321]],[[194751,194751],"mapped",[25634]],[[194752,194752],"mapped",[25541]],[[194753,194753],"mapped",[25513]],[[194754,194754],"mapped",[14894]],[[194755,194755],"mapped",[25705]],[[194756,194756],"mapped",[25726]],[[194757,194757],"mapped",[25757]],[[194758,194758],"mapped",[25719]],[[194759,194759],"mapped",[14956]],[[194760,194760],"mapped",[25935]],[[194761,194761],"mapped",[25964]],[[194762,194762],"mapped",[143370]],[[194763,194763],"mapped",[26083]],[[194764,194764],"mapped",[26360]],[[194765,194765],"mapped",[26185]],[[194766,194766],"mapped",[15129]],[[194767,194767],"mapped",[26257]],[[194768,194768],"mapped",[15112]],[[194769,194769],"mapped",[15076]],[[194770,194770],"mapped",[20882]],[[194771,194771],"mapped",[20885]],[[194772,194772],"mapped",[26368]],[[194773,194773],"mapped",[26268]],[[194774,194774],"mapped",[32941]],[[194775,194775],"mapped",[17369]],[[194776,194776],"mapped",[26391]],[[194777,194777],"mapped",[26395]],[[194778,194778],"mapped",[26401]],[[194779,194779],"mapped",[26462]],[[194780,194780],"mapped",[26451]],[[194781,194781],"mapped",[144323]],[[194782,194782],"mapped",[15177]],[[194783,194783],"mapped",[26618]],[[194784,194784],"mapped",[26501]],[[194785,194785],"mapped",[26706]],[[194786,194786],"mapped",[26757]],[[194787,194787],"mapped",[144493]],[[194788,194788],"mapped",[26766]],[[194789,194789],"mapped",[26655]],[[194790,194790],"mapped",[26900]],[[194791,194791],"mapped",[15261]],[[194792,194792],"mapped",[26946]],[[194793,194793],"mapped",[27043]],[[194794,194794],"mapped",[27114]],[[194795,194795],"mapped",[27304]],[[194796,194796],"mapped",[145059]],[[194797,194797],"mapped",[27355]],[[194798,194798],"mapped",[15384]],[[194799,194799],"mapped",[27425]],[[194800,194800],"mapped",[145575]],[[194801,194801],"mapped",[27476]],[[194802,194802],"mapped",[15438]],[[194803,194803],"mapped",[27506]],[[194804,194804],"mapped",[27551]],[[194805,194805],"mapped",[27578]],[[194806,194806],"mapped",[27579]],[[194807,194807],"mapped",[146061]],[[194808,194808],"mapped",[138507]],[[194809,194809],"mapped",[146170]],[[194810,194810],"mapped",[27726]],[[194811,194811],"mapped",[146620]],[[194812,194812],"mapped",[27839]],[[194813,194813],"mapped",[27853]],[[194814,194814],"mapped",[27751]],[[194815,194815],"mapped",[27926]],[[194816,194816],"mapped",[27966]],[[194817,194817],"mapped",[28023]],[[194818,194818],"mapped",[27969]],[[194819,194819],"mapped",[28009]],[[194820,194820],"mapped",[28024]],[[194821,194821],"mapped",[28037]],[[194822,194822],"mapped",[146718]],[[194823,194823],"mapped",[27956]],[[194824,194824],"mapped",[28207]],[[194825,194825],"mapped",[28270]],[[194826,194826],"mapped",[15667]],[[194827,194827],"mapped",[28363]],[[194828,194828],"mapped",[28359]],[[194829,194829],"mapped",[147153]],[[194830,194830],"mapped",[28153]],[[194831,194831],"mapped",[28526]],[[194832,194832],"mapped",[147294]],[[194833,194833],"mapped",[147342]],[[194834,194834],"mapped",[28614]],[[194835,194835],"mapped",[28729]],[[194836,194836],"mapped",[28702]],[[194837,194837],"mapped",[28699]],[[194838,194838],"mapped",[15766]],[[194839,194839],"mapped",[28746]],[[194840,194840],"mapped",[28797]],[[194841,194841],"mapped",[28791]],[[194842,194842],"mapped",[28845]],[[194843,194843],"mapped",[132389]],[[194844,194844],"mapped",[28997]],[[194845,194845],"mapped",[148067]],[[194846,194846],"mapped",[29084]],[[194847,194847],"disallowed"],[[194848,194848],"mapped",[29224]],[[194849,194849],"mapped",[29237]],[[194850,194850],"mapped",[29264]],[[194851,194851],"mapped",[149000]],[[194852,194852],"mapped",[29312]],[[194853,194853],"mapped",[29333]],[[194854,194854],"mapped",[149301]],[[194855,194855],"mapped",[149524]],[[194856,194856],"mapped",[29562]],[[194857,194857],"mapped",[29579]],[[194858,194858],"mapped",[16044]],[[194859,194859],"mapped",[29605]],[[194860,194861],"mapped",[16056]],[[194862,194862],"mapped",[29767]],[[194863,194863],"mapped",[29788]],[[194864,194864],"mapped",[29809]],[[194865,194865],"mapped",[29829]],[[194866,194866],"mapped",[29898]],[[194867,194867],"mapped",[16155]],[[194868,194868],"mapped",[29988]],[[194869,194869],"mapped",[150582]],[[194870,194870],"mapped",[30014]],[[194871,194871],"mapped",[150674]],[[194872,194872],"mapped",[30064]],[[194873,194873],"mapped",[139679]],[[194874,194874],"mapped",[30224]],[[194875,194875],"mapped",[151457]],[[194876,194876],"mapped",[151480]],[[194877,194877],"mapped",[151620]],[[194878,194878],"mapped",[16380]],[[194879,194879],"mapped",[16392]],[[194880,194880],"mapped",[30452]],[[194881,194881],"mapped",[151795]],[[194882,194882],"mapped",[151794]],[[194883,194883],"mapped",[151833]],[[194884,194884],"mapped",[151859]],[[194885,194885],"mapped",[30494]],[[194886,194887],"mapped",[30495]],[[194888,194888],"mapped",[30538]],[[194889,194889],"mapped",[16441]],[[194890,194890],"mapped",[30603]],[[194891,194891],"mapped",[16454]],[[194892,194892],"mapped",[16534]],[[194893,194893],"mapped",[152605]],[[194894,194894],"mapped",[30798]],[[194895,194895],"mapped",[30860]],[[194896,194896],"mapped",[30924]],[[194897,194897],"mapped",[16611]],[[194898,194898],"mapped",[153126]],[[194899,194899],"mapped",[31062]],[[194900,194900],"mapped",[153242]],[[194901,194901],"mapped",[153285]],[[194902,194902],"mapped",[31119]],[[194903,194903],"mapped",[31211]],[[194904,194904],"mapped",[16687]],[[194905,194905],"mapped",[31296]],[[194906,194906],"mapped",[31306]],[[194907,194907],"mapped",[31311]],[[194908,194908],"mapped",[153980]],[[194909,194910],"mapped",[154279]],[[194911,194911],"disallowed"],[[194912,194912],"mapped",[16898]],[[194913,194913],"mapped",[154539]],[[194914,194914],"mapped",[31686]],[[194915,194915],"mapped",[31689]],[[194916,194916],"mapped",[16935]],[[194917,194917],"mapped",[154752]],[[194918,194918],"mapped",[31954]],[[194919,194919],"mapped",[17056]],[[194920,194920],"mapped",[31976]],[[194921,194921],"mapped",[31971]],[[194922,194922],"mapped",[32000]],[[194923,194923],"mapped",[155526]],[[194924,194924],"mapped",[32099]],[[194925,194925],"mapped",[17153]],[[194926,194926],"mapped",[32199]],[[194927,194927],"mapped",[32258]],[[194928,194928],"mapped",[32325]],[[194929,194929],"mapped",[17204]],[[194930,194930],"mapped",[156200]],[[194931,194931],"mapped",[156231]],[[194932,194932],"mapped",[17241]],[[194933,194933],"mapped",[156377]],[[194934,194934],"mapped",[32634]],[[194935,194935],"mapped",[156478]],[[194936,194936],"mapped",[32661]],[[194937,194937],"mapped",[32762]],[[194938,194938],"mapped",[32773]],[[194939,194939],"mapped",[156890]],[[194940,194940],"mapped",[156963]],[[194941,194941],"mapped",[32864]],[[194942,194942],"mapped",[157096]],[[194943,194943],"mapped",[32880]],[[194944,194944],"mapped",[144223]],[[194945,194945],"mapped",[17365]],[[194946,194946],"mapped",[32946]],[[194947,194947],"mapped",[33027]],[[194948,194948],"mapped",[17419]],[[194949,194949],"mapped",[33086]],[[194950,194950],"mapped",[23221]],[[194951,194951],"mapped",[157607]],[[194952,194952],"mapped",[157621]],[[194953,194953],"mapped",[144275]],[[194954,194954],"mapped",[144284]],[[194955,194955],"mapped",[33281]],[[194956,194956],"mapped",[33284]],[[194957,194957],"mapped",[36766]],[[194958,194958],"mapped",[17515]],[[194959,194959],"mapped",[33425]],[[194960,194960],"mapped",[33419]],[[194961,194961],"mapped",[33437]],[[194962,194962],"mapped",[21171]],[[194963,194963],"mapped",[33457]],[[194964,194964],"mapped",[33459]],[[194965,194965],"mapped",[33469]],[[194966,194966],"mapped",[33510]],[[194967,194967],"mapped",[158524]],[[194968,194968],"mapped",[33509]],[[194969,194969],"mapped",[33565]],[[194970,194970],"mapped",[33635]],[[194971,194971],"mapped",[33709]],[[194972,194972],"mapped",[33571]],[[194973,194973],"mapped",[33725]],[[194974,194974],"mapped",[33767]],[[194975,194975],"mapped",[33879]],[[194976,194976],"mapped",[33619]],[[194977,194977],"mapped",[33738]],[[194978,194978],"mapped",[33740]],[[194979,194979],"mapped",[33756]],[[194980,194980],"mapped",[158774]],[[194981,194981],"mapped",[159083]],[[194982,194982],"mapped",[158933]],[[194983,194983],"mapped",[17707]],[[194984,194984],"mapped",[34033]],[[194985,194985],"mapped",[34035]],[[194986,194986],"mapped",[34070]],[[194987,194987],"mapped",[160714]],[[194988,194988],"mapped",[34148]],[[194989,194989],"mapped",[159532]],[[194990,194990],"mapped",[17757]],[[194991,194991],"mapped",[17761]],[[194992,194992],"mapped",[159665]],[[194993,194993],"mapped",[159954]],[[194994,194994],"mapped",[17771]],[[194995,194995],"mapped",[34384]],[[194996,194996],"mapped",[34396]],[[194997,194997],"mapped",[34407]],[[194998,194998],"mapped",[34409]],[[194999,194999],"mapped",[34473]],[[195000,195000],"mapped",[34440]],[[195001,195001],"mapped",[34574]],[[195002,195002],"mapped",[34530]],[[195003,195003],"mapped",[34681]],[[195004,195004],"mapped",[34600]],[[195005,195005],"mapped",[34667]],[[195006,195006],"mapped",[34694]],[[195007,195007],"disallowed"],[[195008,195008],"mapped",[34785]],[[195009,195009],"mapped",[34817]],[[195010,195010],"mapped",[17913]],[[195011,195011],"mapped",[34912]],[[195012,195012],"mapped",[34915]],[[195013,195013],"mapped",[161383]],[[195014,195014],"mapped",[35031]],[[195015,195015],"mapped",[35038]],[[195016,195016],"mapped",[17973]],[[195017,195017],"mapped",[35066]],[[195018,195018],"mapped",[13499]],[[195019,195019],"mapped",[161966]],[[195020,195020],"mapped",[162150]],[[195021,195021],"mapped",[18110]],[[195022,195022],"mapped",[18119]],[[195023,195023],"mapped",[35488]],[[195024,195024],"mapped",[35565]],[[195025,195025],"mapped",[35722]],[[195026,195026],"mapped",[35925]],[[195027,195027],"mapped",[162984]],[[195028,195028],"mapped",[36011]],[[195029,195029],"mapped",[36033]],[[195030,195030],"mapped",[36123]],[[195031,195031],"mapped",[36215]],[[195032,195032],"mapped",[163631]],[[195033,195033],"mapped",[133124]],[[195034,195034],"mapped",[36299]],[[195035,195035],"mapped",[36284]],[[195036,195036],"mapped",[36336]],[[195037,195037],"mapped",[133342]],[[195038,195038],"mapped",[36564]],[[195039,195039],"mapped",[36664]],[[195040,195040],"mapped",[165330]],[[195041,195041],"mapped",[165357]],[[195042,195042],"mapped",[37012]],[[195043,195043],"mapped",[37105]],[[195044,195044],"mapped",[37137]],[[195045,195045],"mapped",[165678]],[[195046,195046],"mapped",[37147]],[[195047,195047],"mapped",[37432]],[[195048,195048],"mapped",[37591]],[[195049,195049],"mapped",[37592]],[[195050,195050],"mapped",[37500]],[[195051,195051],"mapped",[37881]],[[195052,195052],"mapped",[37909]],[[195053,195053],"mapped",[166906]],[[195054,195054],"mapped",[38283]],[[195055,195055],"mapped",[18837]],[[195056,195056],"mapped",[38327]],[[195057,195057],"mapped",[167287]],[[195058,195058],"mapped",[18918]],[[195059,195059],"mapped",[38595]],[[195060,195060],"mapped",[23986]],[[195061,195061],"mapped",[38691]],[[195062,195062],"mapped",[168261]],[[195063,195063],"mapped",[168474]],[[195064,195064],"mapped",[19054]],[[195065,195065],"mapped",[19062]],[[195066,195066],"mapped",[38880]],[[195067,195067],"mapped",[168970]],[[195068,195068],"mapped",[19122]],[[195069,195069],"mapped",[169110]],[[195070,195071],"mapped",[38923]],[[195072,195072],"mapped",[38953]],[[195073,195073],"mapped",[169398]],[[195074,195074],"mapped",[39138]],[[195075,195075],"mapped",[19251]],[[195076,195076],"mapped",[39209]],[[195077,195077],"mapped",[39335]],[[195078,195078],"mapped",[39362]],[[195079,195079],"mapped",[39422]],[[195080,195080],"mapped",[19406]],[[195081,195081],"mapped",[170800]],[[195082,195082],"mapped",[39698]],[[195083,195083],"mapped",[40000]],[[195084,195084],"mapped",[40189]],[[195085,195085],"mapped",[19662]],[[195086,195086],"mapped",[19693]],[[195087,195087],"mapped",[40295]],[[195088,195088],"mapped",[172238]],[[195089,195089],"mapped",[19704]],[[195090,195090],"mapped",[172293]],[[195091,195091],"mapped",[172558]],[[195092,195092],"mapped",[172689]],[[195093,195093],"mapped",[40635]],[[195094,195094],"mapped",[19798]],[[195095,195095],"mapped",[40697]],[[195096,195096],"mapped",[40702]],[[195097,195097],"mapped",[40709]],[[195098,195098],"mapped",[40719]],[[195099,195099],"mapped",[40726]],[[195100,195100],"mapped",[40763]],[[195101,195101],"mapped",[173568]],[[195102,196605],"disallowed"],[[196606,196607],"disallowed"],[[196608,262141],"disallowed"],[[262142,262143],"disallowed"],[[262144,327677],"disallowed"],[[327678,327679],"disallowed"],[[327680,393213],"disallowed"],[[393214,393215],"disallowed"],[[393216,458749],"disallowed"],[[458750,458751],"disallowed"],[[458752,524285],"disallowed"],[[524286,524287],"disallowed"],[[524288,589821],"disallowed"],[[589822,589823],"disallowed"],[[589824,655357],"disallowed"],[[655358,655359],"disallowed"],[[655360,720893],"disallowed"],[[720894,720895],"disallowed"],[[720896,786429],"disallowed"],[[786430,786431],"disallowed"],[[786432,851965],"disallowed"],[[851966,851967],"disallowed"],[[851968,917501],"disallowed"],[[917502,917503],"disallowed"],[[917504,917504],"disallowed"],[[917505,917505],"disallowed"],[[917506,917535],"disallowed"],[[917536,917631],"disallowed"],[[917632,917759],"disallowed"],[[917760,917999],"ignored"],[[918000,983037],"disallowed"],[[983038,983039],"disallowed"],[[983040,1048573],"disallowed"],[[1048574,1048575],"disallowed"],[[1048576,1114109],"disallowed"],[[1114110,1114111],"disallowed"]]');
  }
 }, __webpack_module_cache__ = {}, installedChunks;
 function __webpack_require__(moduleId) {
  var cachedModule = __webpack_module_cache__[moduleId];
  if (void 0 !== cachedModule) return cachedModule.exports;
  var module = __webpack_module_cache__[moduleId] = {
   id: moduleId,
   loaded: !1,
   exports: {}
  };
  return __webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__), 
  module.loaded = !0, module.exports;
 }
 __webpack_require__.m = __webpack_modules__, __webpack_require__.d = (exports, definition) => {
  for (var key in definition) __webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key) && Object.defineProperty(exports, key, {
   enumerable: !0,
   get: definition[key]
  });
 }, __webpack_require__.f = {}, __webpack_require__.e = chunkId => Promise.all(Object.keys(__webpack_require__.f).reduce(((promises, key) => (__webpack_require__.f[key](chunkId, promises), 
 promises)), [])), __webpack_require__.u = chunkId => chunkId + ".extension.js", 
 __webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop), 
 __webpack_require__.r = exports => {
  "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(exports, Symbol.toStringTag, {
   value: "Module"
  }), Object.defineProperty(exports, "__esModule", {
   value: !0
  });
 }, __webpack_require__.nmd = module => (module.paths = [], module.children || (module.children = []), 
 module), installedChunks = {
  792: 1
 }, __webpack_require__.f.require = (chunkId, promises) => {
  installedChunks[chunkId] || (chunk => {
   var moreModules = chunk.modules, chunkIds = chunk.ids, runtime = chunk.runtime;
   for (var moduleId in moreModules) __webpack_require__.o(moreModules, moduleId) && (__webpack_require__.m[moduleId] = moreModules[moduleId]);
   runtime && runtime(__webpack_require__);
   for (var i = 0; i < chunkIds.length; i++) installedChunks[chunkIds[i]] = 1;
  })(require("./" + __webpack_require__.u(chunkId)));
 };
 var __webpack_exports__ = {};
 (() => {
  "use strict";
  var exports = __webpack_exports__;
  Object.defineProperty(exports, "__esModule", {
   value: !0
  }), exports.deactivate = exports.activate = void 0;
  const tslib_1 = __webpack_require__(31635);
  __webpack_require__(38630);
  const dbtPowerUserExtension_1 = __webpack_require__(29597), inversify_config_1 = __webpack_require__(49757);
  exports.activate = function(context) {
   return tslib_1.__awaiter(this, void 0, void 0, (function*() {
    const dbtPowerUserExtension = inversify_config_1.container.get(dbtPowerUserExtension_1.DBTPowerUserExtension);
    context.subscriptions.push(dbtPowerUserExtension), yield dbtPowerUserExtension.activate(context);
   }));
  }, exports.deactivate = function() {};
 })(), module.exports = __webpack_exports__;
})();
//# sourceMappingURL=extension.js.map